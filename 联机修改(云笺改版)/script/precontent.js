+function () {
    const { lib, game, ui, get, ai, _status } = suiSet
    suiSet = Object.assign(suiSet, {
        comboObject(reObject, opts) {
            if (typeof opts !== 'object') return;
            const addObjectKey = (retarget, myTarget) => {
                for (const i in myTarget) {
                    if (retarget[i] && typeof myTarget[i] === 'object') {
                        addObjectKey(retarget[i], myTarget[i])
                    } else {
                        retarget[i] = myTarget[i]
                    }
                }
            }
            addObjectKey(reObject, opts)
        },
        node(tag, selection, parentNode, event, func) {
            const node = document.createElement(tag)
            for (const n in selection) {
                node[n] = selection[n]
            }
            if (parentNode) {
                parentNode.appendChild(node)
            }
            if (event) {
                if (typeof func === 'string') {
                    func = suiSet.selectFun[func]
                } else {
                    node.addEventListener(event, func)
                }
            }
            return node
        },
        exeCute: {
            forObject(object, func) {
                for (const c in object) {
                    func(c, object)
                }
            }
        },
        getSkillByName(names, map) {
            if (names.length === 0) return;
            map.pushList = {}
            const anothSkill = names.map(p => {
                const [, , , skills] = lib.character[p]
                const name = skills.randomGet()
                map.pushList[name] = p
                return name
            });
            return anothSkill
        },
        initList(func = () => { }, unforbidai) {
            let letItBand = c => {
                if (lib.config.forbidai.includes(c)) return true
                if (lib.config.banned.includes(c)) return true
                // if (lib.characterFilter[c] && !lib.characterFilter[c](get.mode())) return true;
                if (lib.configOL.banned.includes(c) || lib.connectBanned.includes(c)) return true;
            }
            if (unforbidai) {
                letItBand = c => {
                    if (lib.config.banned.includes(c)) return true
                    if (lib.configOL.banned.includes(c) || lib.connectBanned.includes(c)) return true;
                }
            }
            lib.connectBanned.remove('shen_diaochan')
            const libCharacter = {}
            lib.configOL.characterPack.forEach(p => {
                const pack = lib.characterPack[p]
                for (const c in pack) {
                    func(c, p)
                    if (!lib.configOL.banned.includes(c) && !letItBand(c)) {
                        if (lib.character[c]) libCharacter[c] = pack[c];
                    }
                }
            })
            return libCharacter
        },
        getSelect(list) {
            if (typeof list !== 'number') {
                list = list.length
            }
            const mode = get.mode()
            let num = lib.configOL[mode + '_select'] || lib.configOL[`${mode}_Selects`]
            num = !parseInt(num) ? '11' : num
            if (num === 'no1') return 5
            if (num === '11') return Math.floor(list / game.players.length)
            return parseInt(num)
        },
        modeConfig: {},
        createFloatBall() {
            const ball = suiSet.node('div', {
                id: 'sstball', className: 'nomal canmove',
                innerHTML:/*html*/`
                <svg  width="16" height="16" fill="currentColor" class="bi bi-tools" viewBox="0 0 16 16">
                    <path d=""/>
                </svg>
                `
            }, document.body)
            ball.configs = suiSet.node('div', { id: 'animateConfig', className: 'aniConfig close', innerHTML: '' }, document.body)
            ball.addEventListener(lib.config.touchscreen ? 'touchend' : 'mousedown', suiSet.activeFlatBall)
            new suiSet.MoveModel(ball, node => {
                const fn = node.configs.classList.contains('opening') ? 'remove' : 'add'
                node.configs.classList[fn]('opening')
            })
            ball.style.animation = 'left 1s ease 0.1s forwards'
            suiSet.initFloatBall(ball.configs)
            const tool = "M1 0 0 1l2.2 3.081a1 1 0 0 0 .815.419h.07a1 1 0 0 1 .708.293l2.675 2.675-2.617 2.654A3.003 3.003 0 0 0 0 13a3 3 0 1 0 5.878-.851l2.654-2.617.968.968-.305.914a1 1 0 0 0 .242 1.023l3.27 3.27a.997.997 0 0 0 1.414 0l1.586-1.586a.997.997 0 0 0 0-1.414l-3.27-3.27a1 1 0 0 0-1.023-.242L10.5 9.5l-.96-.96 2.68-2.643A3.005 3.005 0 0 0 16 3c0-.269-.035-.53-.102-.777l-2.14 2.141L12 4l-.364-1.757L13.777.102a3 3 0 0 0-3.675 3.68L7.462 6.46 4.793 3.793a1 1 0 0 1-.293-.707v-.071a1 1 0 0 0-.419-.814L1 0Zm9.646 10.646a.5.5 0 0 1 .708 0l2.914 2.915a.5.5 0 0 1-.707.707l-2.915-2.914a.5.5 0 0 1 0-.708ZM3 11l.471.242.529.026.287.445.445.287.026.529L5 13l-.242.471-.026.529-.445.287-.287.445-.529.026L3 15l-.471-.242L2 14.732l-.287-.445L1.268 14l-.026-.529L1 13l.242-.471.026-.529.445-.287.287-.445.529-.026L3 11Z"
            setTimeout((ball, tool) => {
                const path = ball.firstElementChild.firstElementChild
                path.setAttribute('d', tool)
            }, 0, ball, tool);
            suiSet.floatBall = ball
        },
        initFloatBall(configs) {
            // suiSet.floatBall
        },
        canMove(node, func) {
            node.classList.add('canmove')
            node.moveEndFunc = func
        },
        MoveModel: class {
            constructor(node, click) {
                this.click = click
                if (node) {
                    node.classList.add('canmove')
                }
                document.addEventListener(lib.config.touchscreen ? 'touchstart' : 'mousedown', this.moveStart)
                return node
            }
            moveStart = (e) => {
                this.startTime = get.utc()
                const epoiont = e.touches ? e.touches[0] : e
                const DOM = document.elementFromPoint(epoiont.clientX, epoiont.clientY);
                if (DOM.classList.contains('canmove')) {
                    DOM.storage = {
                        animation: DOM.style.animation,
                        transition: DOM.style.transition,
                    }
                    DOM.style.animation = ''
                    DOM.style.transition = 'unset'
                    document.addEventListener(lib.config.touchscreen ? 'touchmove' : 'mousemove', this.moveIng)
                    document.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', this.moveEnd)
                    DOM.classList.replace('canmove', 'moveing')
                    suiSet.moveIngDom = DOM;
                    if (!DOM.transforms) {
                        DOM.transforms = {
                            startX: epoiont.pageX,
                            startY: epoiont.pageY
                        }
                        DOM.nowtransforms = {
                            x: epoiont.pageX - DOM.transforms.startX,
                            y: epoiont.pageY - DOM.transforms.startY
                        }
                    } else {
                        const { x, y } = DOM.nowtransforms
                        DOM.transforms = {
                            startX: epoiont.pageX - x,
                            startY: epoiont.pageY - y
                        }
                    }
                }
            }
            moveIng = e => {
                if (!suiSet.moveIngDom) return;
                const epoiont = e.touches ? e.touches[0] : e
                const dom = suiSet.moveIngDom
                const x = epoiont.clientX - dom.transforms.startX
                const y = epoiont.clientY - dom.transforms.startY
                dom.nowtransforms = { x, y }
                dom.style.transform = `translate3d(${x}px,${y}px,0px)`
                dom.style['will-change'] = 'transform'
            }
            moveEnd = e => {
                if (!suiSet.moveIngDom) return;
                const now = get.utc();
                if (now - this.startTime < 200 && this.click) {
                    this.click(suiSet.moveIngDom)
                } else if (typeof this.moveEndFunc === 'function') {
                    this.modeFunction(this, e)
                }
                document.removeEventListener(lib.config.touchscreen ? 'touchmove' : 'mousemove', this.moveIng)
                document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', this.moveEnd)
                suiSet.moveIngDom.classList.replace('moveing', 'canmove')
                delete suiSet.moveIngDom
            }
        },
        replaceHandcardsnum: 1,
        replaceHandcards(...args) {
            if (suiSet.replaceHandcardsnum > lib.config['extension_联机修改_fun_replaceHandCards']) return;
            const next = game.createEvent('replaceHandcards');
            if (Array.isArray(args[0])) next.players = args[0];
            else next.players = args.filter(a => get.itemtype(a) == 'player')
            next.setContent(_status.connectMode ? 'replaceHandcardsOL' : 'replaceHandcards')
        },
        replaceHandcardEvent() {
            'step 0'
            event.players = event.players.filter(p => {
                return p === game.me || (p.ws && p.isOnline2())//人机就不给刷牌了
            })
            event.players.forEach(p => {
                if (!p.replaceHandcardsnum) {
                    p.replaceHandcardsnum = 0
                    p.send(() => { game.me.replaceHandcardsnum = 0 })
                }
            })
            'step 1'
            const send = (allnum, bool) => {
                const num = allnum - game.me.replaceHandcardsnum
                if (bool) {
                    game.me.chooseCard('h', `你可以选择一些手牌置换<br>（还剩${num}次置换的机会）`, false, [1, Infinity])
                } else {
                    game.me.chooseBool(`是否置换手牌？（还剩${num}次）`).set('ai', () => false)
                }
                game.resume()
            }

            const sendback = (result, player) => {
                if ((result && result.bool === false && event)) {
                    event.players.remove(player)
                }
                if (result && result.bool) {
                    player.send(() => { game.me.replaceHandcardsnum++ })
                    player.replaceHandcardsnum++
                    let hs;
                    if (Array.isArray(result.cards) && result.cards.length > 0) {
                        hs = result.cards
                    } else {
                        hs = player.getCards('h')
                    }
                    game.broadcastAll((player, hs) => {
                        game.addVideo('lose', player, [get.cardsInfo(hs), [], [], []]);
                        hs.forEach(h => h.discard(false))
                    }, player, hs)
                    const playerCards = player.getCards('h')
                    const cards = get.cards(hs.length)
                    player.directgain(cards);
                    if (Array.isArray(result.cards) && result.cards.length > 0) {
                        player._start_cards = cards.addArray(playerCards)
                    } else {
                        player._start_cards = cards
                    }
                }
            }

            event.players.forEach(async p => {
                if (p.isOnline()) {
                    event.withol = true;
                    p.send(send, lib.config['extension_联机修改_fun_replaceHandCards'], lib.config['extension_联机修改_edit_noAllReplace']);
                    p.wait(sendback);
                } else if (p == game.me) {
                    event.withme = true;
                    const num = lib.config['extension_联机修改_fun_replaceHandCards'] - game.me.replaceHandcardsnum
                    if (_status.weChat) {
                        game.addVideo('replaceHandCards', game.me, {
                            bool: lib.config['extension_联机修改_edit_noAllReplace'],
                            num
                        })
                    }
                    if (lib.config['extension_联机修改_edit_noAllReplace']) {
                        game.me.chooseCard('h', `你可以选择一些手牌置换<br>（还剩${num}次置换的机会）`, false, [1, Infinity])
                    } else {
                        game.me.chooseBool(`是否置换手牌？（还剩${num}次）`);
                    }
                    game.me.wait(sendback);
                }
            })
            'step 2'
            if (event.withme) {
                game.me.unwait(result);
            }
            'step 3'
            if (!event.resultOL) {
                game.pause();
            }
            'step 4'
            event.players = event.players.filter(p => p === game.me || (p.ws && p.isOnline2()))
            if (event.players.length > 0 && suiSet.replaceHandcardsnum < lib.config['extension_联机修改_fun_replaceHandCards']) {
                event.goto(1)
                suiSet.replaceHandcardsnum++
                delete event.resultOL
            }
        },
        executeConnect({ player, version, config, banned_info }) {
            const playerFunction = {
                tipExtension(player) {
                    player.send(function (ext) {
                        if (!ui.extnode) {
                            ui.extnode = ui.create.div('.foomext', '扩展列表').css({
                                backgroundColor: 'rgb(224 106 106 / 30%)'
                            })
                            ui.system2.appendChild(ui.extnode)
                        }
                        if (!ui.extnode.setPopped) {
                            ui.extnode.setPopped = true
                            lib.setPopped(ui.extnode, function () {
                                var uiintro = ui.create.dialog('hidden');
                                let str = '房主的扩展:<br>'
                                let caption = uiintro.addText(str);
                                caption.style.margin = '0';
                                let a = ''
                                if (ext.length > 0) {
                                    ext.forEach(e => {
                                        a += e + '<br>'
                                    })
                                } else {
                                    a = '房主未开启其他扩展'
                                }
                                uiintro._place_text = uiintro.add('<div class="text">' + str + a + '</div>');
                                uiintro.add(ui.create.div('.placeholder.slim'));
                                return uiintro;
                            }, 200)
                        }
                    }, lib.config.extensionsCopy)
                    player.send(function (ext) {
                        const extcall = []
                        const extclose = []
                        ext.forEach(l => {
                            if (!lib.config.extensions.includes(l)) { //如果自己的扩展列表里没有这些
                                extcall.push(l)
                            } else if (lib.config[`extension_${l}_enable`] != undefined && !lib.config[`extension_${l}_enable`]) {
                                extclose.push(l)
                            }
                        })
                        if (extcall.length > 0) {
                            let str = '提示：当前缺少房主拥有但你未拥有的扩展：'
                            extcall.forEach(c => {
                                str += c + '、'
                            })
                            str += '\r\n这可能会导致游戏开始没有选将框，还有自己不能出牌等等问题。\r\n右上角可以查看房主的扩展，手机版需要打开设置'
                            alert(str)
                        }
                        if (extclose.length > 0) {
                            let str2 = '提示：有已拥有但是未开启的扩展：'
                            extclose.forEach(c => {
                                str2 += c + '、'
                            })
                            str2 += '\r\n请开启这些扩展'
                            alert(str2)
                        }

                    }, lib.config.extensionsCopy)
                },
                tipNonamePlayer(player) {
                    player.send(function () {
                        if (lib.config.connect_nickname === '无名玩家' || lib.config.connect_nickname === '※无名玩家') {
                            alert('提示：请不要使用“无名玩家”做联机名字\r\n可以打开选项，点击联机按钮修改名字')
                        }
                    })
                },
                tipPlayerVersion(player) {
                    player.send(function (version) {
                        if (lib.version < version) {
                            alert('你的游戏版本是：' + lib.version + '\r\n房主的游戏版本是:' + version + '，\r\n此时房主开局可能会影响你正常游戏！请更新游戏！')
                        }
                    }, lib.version)
                },
                observeChat(player) {
                    if (_status.waitingForPlayer) return
                    if (lib.config['extension_联机修改_main_cdown']) {
                        player.send(ui.create.danmu, '<span style="color:red;">', '提示', '本房允许旁观发言</span>')
                    }
                    player.send(() => {
                        game.send = function () {
                            if (game.observe && !['reinited', 'chat', 'emotion'].includes(arguments[0])) return;
                            if (game.ws) {
                                const args = Array.from(arguments);
                                if (['chat', 'emotion'].includes(arguments[0])) args.push(lib.config.connect_nickname)
                                if (typeof args[0] == 'function') {
                                    args.unshift('exec');
                                }
                                game.ws.send(JSON.stringify(get.stringifiedResult(args)));
                            }
                        }
                        const liaotian = Array.from(ui.system.childNodes[1].childNodes).find(c => c.innerHTML === '聊天')
                        if (!liaotian) ui.create.chat()
                    })
                },
            }
            const exe = suiSet.playerConfig;
            exe.forEach(e => {
                if (lib.config['extension_联机修改_' + e] && typeof playerFunction[e.slice(5)] === 'function') {
                    playerFunction[e.slice(5)](player, version, config, banned_info)
                }
            })
        },
        modeCharacter({ player, version, config, banned_info }) {
            player.send(skills => {
                for (const s in skills) lib.skill[s] = skills[s]
            }, suiSet.globalSkills)
            if (_status.playerCharactersUse) {
                player.send(_status.playerCharactersUse, _status.playerCharacters, _status.style.innerHTML, suiSet.copyCharacter)
            }
            if (!lib.config['extension_极略_enable'] && lib.config['extension_联机修改_edit_sksr']) {
                const char = suiSet.moreCharacters.characters.jilueSkSr
                const func = suiSet.moreCharacters.addFcuntion.jilueSkSr
                suiSet.send.call(player, 'jilueSkSr', func, char, true)
            }
            if (!lib.config['extension_活动武将_enable'] && lib.config['extension_联机修改_edit_morecharacter']) {
                const char = suiSet.moreCharacters.characters.HDWJ
                const func = suiSet.moreCharacters.addFcuntion.HDWJ
                suiSet.send.call(player, 'HDWJ', func, char, true)
            }
            if (!lib.config['extension_Q群DIY武将_enable'] && lib.config['extension_联机修改_edit_DIY']) {
                const char = suiSet.moreCharacters.characters.DIY
                const func = suiSet.moreCharacters.addFcuntion.DIY
                suiSet.send.call(player, 'DIY', func, char, true)
            }
            if (lib.config['extension_联机修改_edit_LM']) {
                const char = suiSet.moreCharacters.characters.LM
                const func = suiSet.moreCharacters.addFcuntion.LM
                suiSet.send.call(player, 'LM', func, char, true)
            }
        },
        toString() {
            const args = Array.from(arguments);
            if (typeof args[0] == "function") {
                args.unshift("exec");
            }
            for (let i = 1; i < args.length; i++) {
                args[i] = get.stringifiedResult(args[i]);
            }
            return JSON.stringify(args)
        },
        send(name, ...args) {
            if (!suiSet.strings[name]) {
                suiSet.strings[name] = suiSet.toString(...args)
            }
            return this.ws.send(suiSet.strings[name])
        },
        strings: {},
        moreCharacters: {//为什么不放到一个新文件？因为方了的话总有人加载慢导致没有加载到文件内容
            characters: {
                HDWJ: {
                    huanle: {
                        name: 'extensionsPack',
                        connect: true,
                        characterSort: {
                            MiNikill: {
                                MiNi_wei: ['Mbaby_simalang', 'Mbaby_hanhaoshihuan', 'Mbaby_chentai', 'Mbaby_zhenghun', 'Mbaby_guanlu', 'Mbaby_guanqiujian', 'Mbaby_wenqin', 'Mbaby_liuye', 'Mbaby_chenlin', 'Mbaby_wangshuang', 'Mbaby_yanrou', 'Mbaby_dc_yanghu', 'Mbaby_ruanyu', 'Mbaby_chengyu', 'Mbaby_jianggan', 'Mbaby_yuejin', 'Mbaby_bianfuren', 'Mbaby_zhugedan', 'Mbaby_caohong', 'Mbaby_guojia', 'Mbaby_sp_caoren', 'Mbaby_yinfuren', 'Mbaby_sp_jiaxu', 'Mbaby_kuailiangkuaiyue', 'Mbaby_jsp_guanyu', 'Mbaby_wangji', 'Mbaby_chenqun', 'Mbaby_xiahoulingnv', 'Mbaby_wenyang', 'Mbaby_sp_pangde', 'Mbaby_caocao', 'Mbaby_caozhang', 'Mbaby_dufuren', 'Mbaby_simayi', 'Mbaby_yangxiu', 'Mbaby_zhangchangpu', 'Mbaby_zhonghui', 'Mbaby_sp_jiangwei', 'Mbaby_caoxiu', 'Mbaby_xunyou', 'Mbaby_lidian', 'Mbaby_zhongyao', 'Mbaby_caozhen', 'Mbaby_guohuanghou', 'Mbaby_xinxianying', 'Mbaby_xiahouyuan', 'Mbaby_xizhicai', 'Mbaby_caorui', 'Mbaby_xunyu', 'Mbaby_dengai', 'Mbaby_caozhi', 'Mbaby_sp_caiwenji', 'Mbaby_caopi', 'Mbaby_caoang', 'Mbaby_guojia', 'Mbaby_zhenji', 'Mbaby_caoren', 'Mbaby_wangyi', 'Mbaby_zhangchunhua', 'Mbaby_xiahoudun', 'Mbaby_xuzhu', 'Mbaby_zhangliao', 'Mbaby_guohuai', 'Mbaby_dianwei', 'Mbaby_zhanghe', 'Mbaby_yujin', 'Mbaby_xuhuang'],
                                MiNi_shu: ['Mbaby_ganfurenmifuren', 'Mbaby_zhaotongzhaoguang', 'Mbaby_wulan', 'Mbaby_leitong', 'Mbaby_zongyu', 'Mbaby_mazhong', 'Mbaby_dengzhi', 'Mbaby_hujinding', 'Mbaby_sp_xiahoushi', 'Mbaby_jiangfei', 'Mbaby_zhangyi', 'Mbaby_guanzhang', 'Mbaby_wolongfengchu', 'Mbaby_wangtao', 'Mbabysp_zhangfei', 'Mbaby_wangyue', 'Mbaby_xf_yiji', 'Mbaby_mizhu', 'Mbaby_mifuren', 'Mbaby_liuyong', 'Mbaby_ganfuren', 'Mbaby_sunqian', 'Mbaby_lvkai', 'Mbaby_zhoucang', 'Mbaby_huangyueying', 'Mbaby_yangwan', 'Mbaby_liuchen', 'Mbaby_liyan', 'Mbaby_chendao', 'Mbaby_yanyan', 'Mbaby_xiahouba', 'Mbaby_huaman', 'Mbaby_sp_zhugeliang', 'Mbaby_zhugeguo', 'Mbaby_jianyong', 'Mbaby_wangping', 'Mbaby_mayunlu', 'Mbaby_guansuo', 'Mbaby_xiahoushi', 'Mbaby_shamoke', 'Mbaby_wuxian', 'Mbaby_zhugezhan', 'Mbaby_qinmi', 'Mbaby_guanyinping', 'Mbaby_guanyu', 'Mbaby_zhugeliang', 'Mbaby_liubei', 'Mbaby_machao', 'Mbaby_zhurong', 'Mbaby_zhangfei', 'Mbaby_zhaoyun', 'Mbaby_huangzhong', 'Mbaby_weiyan', 'Mbaby_liaohua', 'Mbaby_pangtong', 'Mbaby_menghuo', 'Mbaby_jiangwei', 'Mbaby_liushan', 'Mbaby_fazheng', 'Mbaby_madai', 'Mbaby_guanping', 'Mbaby_liufeng', 'Mbaby_wuyi', 'Mbaby_zhangxingcai', 'Mbaby_dongyun', 'Mbaby_sp_sunshangxiang', 'Mbaby_xushu', 'Mbaby_masu'],
                                MiNi_wu: ['Mbaby_chendong', 'Mbaby_kanze', 'Mbaby_panzhangmazhong', 'Mbaby_weiwenzhugezhi', 'Mbaby_zhangwen', 'Mbaby_sunhanhua', 'Mbaby_heqi', 'Mbaby_lvdai', 'Mbaby_jiangqing', 'Mbaby_re_guyong', 'Mbaby_quancong', 'Mbaby_yufan', 'Mbaby_dc_sunru', 'Mbaby_sunxiu', 'Mbaby_zhangfen', 'Mbaby_xuezong', 'Mbaby_dingfeng', 'Mbaby_panjun', 'Mbaby_sundeng', 'Mbaby_luji', 'Mbaby_zhoufang', 'Mbaby_zhangxuan', 'Mbaby_yanjun', 'Mbaby_zhuhuan', 'Mbaby_luyusheng', 'Mbaby_re_jsp_pangtong', 'Mbaby_sunhao', 'Mbabysp_daqiao', 'Mbaby_lukang', 'Mbaby_buzhi', 'Mbaby_xushi', 'Mbaby_zhugeke', 'Mbaby_zhoufei', 'Mbaby_zhangzhang', 'Mbaby_sunliang', 'Mbaby_ol_sunjian', 'Mbaby_zhuzhi', 'Mbaby_bulianshi', 'Mbaby_chengpu', 'Mbaby_daqiao', 'Mbaby_ganning', 'Mbaby_huanggai', 'Mbaby_lusu', 'Mbaby_luxun', 'Mbaby_lvmeng', 'Mbaby_sunce', 'Mbaby_sunluban', 'Mbaby_sunluyu', 'Mbaby_sunquan', 'Mbaby_sunshangxiang', 'Mbaby_taishici', 'Mbaby_wuguotai', 'Mbaby_xiaoqiao', 'Mbaby_xusheng', 'Mbaby_zhoutai', 'Mbaby_zhouyu', 'Mbaby_zhugejin', 'Mbaby_zumao', 'Mbabysp_xiaoqiao'],
                                MiNi_qun: ['Mbaby_caiyong', 'Mbaby_mengjie', 'Mbaby_gaolan', 'Mbaby_yl_luzhi', 'Mbaby_tadun', 'Mbaby_re_hansui', 'Mbaby_dongxie', 'Mbaby_fuwan', 'Mbaby_wutugu', 'Mbaby_huangfusong', 'Mbaby_fanchou', 'Mbaby_guosi', 'Mbaby_yanbaihu', 'Mbaby_dc_huangzu', 'Mbaby_licaiwei', 'Mbaby_ol_dingyuan', 'Mbaby_liubian', 'Mbaby_re_pangdegong', 'Mbaby_zhangning', 'Mbaby_zhanglu', 'Mbaby_wangyun', 'Mbaby_zoushi', 'Mbaby_dc_huangchengyan', 'Mbaby_simahui', 'Mbaby_tw_mateng', 'Mbaby_laiyinger', 'Mbaby_sp_kongrong', 'Mbaby_zhujun', 'Mbaby_gongsunyuan', 'Mbaby_sp_zhangliao', 'Mbaby_sp_ol_zhanghe', 'Mbaby_guotufengji', 'Mbaby_yanfuren', 'Mbaby_tangji', 'Mbaby_caojie', 'Mbaby_liangxing', 'Mbabysp_zhenji', 'Mbaby_caoxing', 'Mbaby_sp_menghuo', 'Mbaby_wangrong', 'Mbaby_hetaihou', 'Mbaby_sp_taishici', 'Mbaby_zhangji', 'Mbaby_dongbai', 'Mbaby_beimihu', 'Mbaby_chunyuqiong', 'Mbaby_zhangqiying', 'Mbaby_fuhuanghou', 'Mbaby_liuxie', 'Mbaby_quyi', 'Mbaby_jsp_huangyueying', 'Mbaby_sp_machao', 'Mbaby_lijue', 'Mbaby_panfeng', 'Mbaby_liuzhang', 'Mbaby_jiaxu', 'Mbaby_zhangbao', 'Mbaby_zhangliang', 'Mbaby_gaoshun', 'Mbaby_caifuren', 'Mbaby_xuyou', 'Mbaby_gongsunzan', 'Mbaby_pangde', 'Mbaby_jushou', 'Mbaby_liru', 'Mbaby_dongzhuo', 'Mbaby_zhangjiao', 'Mbaby_huatuo', 'Mbaby_lvbu', 'Mbaby_diaochan', 'Mbaby_sp_diaochan', 'Mbaby_huaxiong', 'Mbaby_yuji', 'Mbaby_yanwen', 'Mbaby_caiwenji', 'Mbaby_liubiao', 'Mbaby_yuanshao', 'Mbaby_yuanshu', 'Mbaby_chengong', 'Mbaby_zuoci'],
                                MiNi_shen: ['Mbaby_shen_luxun', 'Mbaby_shen_dengai', 'Mbaby_shen_zuoci', 'Mbaby_shen_taishici', 'Mbaby_shen_diaochan', 'Mbaby_shen_daxiaoqiao', 'Mbaby_shen_zhenji', 'Mbaby_shen_guojia', 'Mbaby_shen_huatuo', 'Mbaby_shen_dianwei', 'Mbaby_shen_lvbu', 'Mbaby_shen_zhugeliang', 'Mbaby_shen_lvmeng', 'Mbaby_shen_zhouyu', 'Mbaby_shen_guanyu', 'Mbaby_shen_liubei', 'Mbaby_shen_caocao', 'Mbaby_shen_zhangliao', 'Mbaby_shen_sunquan', 'Mbaby_shen_simayi', 'Mbaby_shen_zhaoyun', 'Mbaby_shen_ganning', 'Mbaby_shen_pangtong'],
                                MiNi_change: ['Mbaby_guanning', 'Mbaby_caoying', 'Mbaby_re_nanhualaoxian', 'Mbaby_re_sunyi', 'Mbaby_zhaoxiang', 'Mbaby_xushao', 'Mbaby_baosanniang', 'Mbaby_quanhuijie'],
                                MiNi_shengzhiyifa: ['Mbaby_jingwei', 'Mbaby_sunwukong', 'Mbaby_dalanmao', 'Mbaby_libai', 'Mbaby_change', 'Mbaby_nvwa', 'Mbaby_tunxingmenglix', 'Mbaby_xiaoshan'],
                                MiNi_sbCharacter: ['Mbaby_sb_zhenji', 'Mbaby_sb_ganning', 'Mbaby_ol_sb_jiangwei', 'Mbaby_sb_huangyueying', 'Mbaby_ol_sb_guanyu', 'Mbaby_sb_sunshangxiang', 'Mbaby_sb_xuhuang', 'Mbaby_sb_zhaoyun', 'Mbaby_sb_liubei', 'Mbaby_sb_caocao', 'Mbaby_sb_huanggai', 'Mbaby_sb_yuanshao', 'Mbaby_sb_yujin', 'Mbaby_sb_machao', 'Mbaby_sb_lvmeng', 'Mbaby_sb_huangzhong'],
                                MiNi_miaoKill: ['Mmiao_caiwenji', 'Mmiao_diaochan', 'Mmiao_caifuren', 'Mmiao_zhangxingcai', 'Mmiao_zhurong', 'Mmiao_huangyueying', 'Mmiao_daqiao', 'Mmiao_wangyi', 'Mmiao_zhangchunhua', 'Mmiao_zhenji', 'Mmiao_sunshangxiang', 'Mmiao_xiaoqiao', 'Mmiao_lvlingqi'],
                                MiNi_nianKill: ['Mnian_zhugeliang', 'Mnian_lvbu', 'Mnian_zhouyu'],
                                MiNi_fightKill: ['Mfight_huangzhong'],
                            },
                        },
                        character: {
                            //魏
                            Mbaby_caopi: ['male', 'wei', 3, ['minixingshang', 'minifangzhu', 'songwei'], ['zhu']],
                            Mbaby_caoang: ['male', 'wei', 4, ['minikangkai']],
                            Mbaby_zhenji: ['female', 'wei', 3, ['minireluoshen', 'reqingguo'], ['die:re_zhenji']],
                            Mbaby_caoren: ['male', 'wei', 4, ['minijushou', 'xinjiewei']],
                            Mbaby_zhangchunhua: ['female', 'wei', 3, ['minijueqing', 'minireshangshi']],
                            Mbaby_xuzhu: ['male', 'wei', 4, ['luoyi', 'minihuchi']],
                            Mbaby_guohuai: ['male', 'wei', 4, ['minijingce']],
                            Mbaby_dianwei: ['male', 'wei', 4, ['miniqiangxi']],
                            Mbaby_zhanghe: ['male', 'wei', 4, ['miniqiaobian']],
                            Mbaby_yujin: ['male', 'wei', 4, ['miniyizhong', 'decadezhenjun']],
                            Mbaby_xuhuang: ['male', 'wei', 4, ['duanliang', 'minijiezi']],
                            Mbaby_xunyu: ['male', 'wei', 3, ['miniquhu', 'minijieming'], ['clan:颍川荀氏']],
                            Mbaby_dengai: ['male', 'wei', 4, ['minituntian', 'zaoxian']],
                            Mbaby_sp_caiwenji: ['female', 'wei', 3, ['minichenqing', 'mozhi'], ['name:蔡|琰']],
                            Mbaby_caozhi: ['male', 'wei', 3, ['miniluoying', 'minijiushi']],
                            Mbaby_caorui: ['male', 'wei', 3, ['huituo', 'minimingjian', 'minixingshuai'], ['zhu']],
                            Mbaby_xizhicai: ['male', 'wei', 3, ['tiandu', 'xianfu', 'minichouce'], ['tempname:xizhicai']],
                            Mbaby_xiahouyuan: ['male', 'wei', 4, ['minishensu', 'minishebian'], ['name:夏侯|渊']],
                            Mbaby_caoying: ['female', 'wei', 4, ['minilingren', 'minifujian']],
                            Mbaby_xinxianying: ['female', 'wei', 3, ['minizhongjian', 'minicaishi']],
                            Mbaby_xiahoudun: ['male', 'wei', 4, ['reganglie', 'miniqingjian'], ['name:夏侯|惇']],
                            Mbaby_guohuanghou: ['female', 'wei', 3, ['minijiaozhao', 'minidanxin']],
                            Mbaby_caozhen: ['male', 'wei', 4, ['minisidi']],
                            Mbaby_zhongyao: ['male', 'wei', 3, ['minihomo', 'minizuoding'], ['clan:颍川钟氏']],
                            Mbaby_lidian: ['male', 'wei', 3, ['minixunxun', 'wangxi']],
                            Mbaby_zhangliao: ['male', 'wei', 4, ['new_retuxi', 'minizhengbing']],
                            Mbaby_xunyou: ['male', 'wei', 3, ['miniqice', 'minizhiyu'], ['clan:颍川荀氏']],
                            Mbaby_caoxiu: ['male', 'wei', 4, ['qianju', 'miniqingxi']],
                            Mbaby_sp_jiangwei: ['male', 'wei', 4, ['minikunfen', 'minifengliang'], ['tempname:sp_jiangwei']],
                            Mbaby_zhonghui: ['male', 'wei', 3, ['miniquanji', 'paiyi'], ['clan:颍川钟氏']],
                            Mbaby_zhangchangpu: ['female', 'wei', 3, ['miniyanjiao', 'xingshen']],
                            Mbaby_yangxiu: ['male', 'wei', 3, ['danlao', 'minijilei']],
                            Mbaby_simayi: ['male', 'wei', 3, ['minifankui', 'miniguicai'], ['name:司马|懿']],
                            Mbaby_dufuren: ['female', 'wei', 3, ['miniyise', 'minishunshi'], ['name:杜|null']],
                            Mbaby_caozhang: ['male', 'wei', 4, ['minijiangchi']],
                            Mbaby_caocao: ['male', 'wei', 4, ['minijianxiong', 'minihujia'], ['zhu']],
                            Mbaby_sp_pangde: ['male', 'wei', 4, ['minijuesi', 'miniyuma']],
                            Mbaby_wenyang: ['male', 'wei', 5, ['xinlvli', 'minichoujue']],
                            Mbaby_xiahoulingnv: ['female', 'wei', 4, ['fuping', 'miniweilie'], ['name:夏侯|令女']],
                            Mbaby_chenqun: ['male', 'wei', 3, ['pindi', 'minifaen']],
                            Mbaby_wangji: ['male', 'wei', 3, ['miniqizhi', 'minijinqu']],
                            Mbaby_jsp_guanyu: ['male', 'wei', 4, ['minispwusheng', 'minidanji'], ['tempname:jsp_guanyu']],
                            Mbaby_kuailiangkuaiyue: ['male', 'wei', 3, ['nzry_jianxiang', 'minishenshi']],
                            Mbaby_sp_jiaxu: ['male', 'wei', 3, ['zhenlue', 'minijianshu', 'miniyongdi']],
                            Mbaby_yinfuren: ['female', 'wei', 3, ['dcyingyu', 'miniyongbi'], ['name:尹|null']],
                            Mbaby_sp_caoren: ['male', 'wei', 4, ['miniweikui', 'minilizhan']],
                            Mbaby_guojia: ['male', 'wei', 3, ['tiandu', 'new_reyiji', 'minishenglun'], ['tempname:re_guojia', 'die:re_guojia']],
                            Mbaby_caohong: ['male', 'wei', 4, ['miniyuanhu', 'minijuezhu']],
                            Mbaby_sb_caocao: ['male', 'wei', 4, ['minisbjianxiong', 'minisbqingzheng', 'sbhujia'], ['zhu']],
                            Mbaby_zhugedan: ['male', 'wei', 4, ['minigongao', 'minijuyi'], ['tempname:zhugedan', 'name:诸葛|诞']],
                            Mbaby_bianfuren: ['female', 'wei', 3, ['fh_fuding', 'miniyuejian'], ['die:bianfuren', 'name:卞|null']],
                            Mbaby_sb_yujin: ['male', 'wei', 4, ['minixiayuan', 'minijieyue']],
                            Mbaby_yuejin: ['male', 'wei', 4, ['minixiaoguo']],
                            Mbaby_jianggan: ["male", "wei", 3, ['miniweicheng', 'minidaoshu']],
                            Mbaby_chengyu: ['male', 'wei', 3, ['minishefu', 'minibenyu']],
                            Mbaby_sb_xuhuang: ['male', 'wei', 4, ['minisbduanliang', 'sbshipo']],
                            Mbaby_ruanyu: ['male', 'wei', 3, ['minixingzuo', 'miaoxian']],
                            Mbaby_dc_yanghu: ['male', 'wei', 3, ['minideshao', 'dcmingfa']],
                            Mbaby_yanrou: ['male', 'wei', 4, ['choutao', 'minixiangshu']],
                            Mbaby_wangshuang: ['male', 'wei', 8, ['minizhuilie']],
                            Mbaby_chenlin: ['male', 'wei', 3, ['bifa', 'minisongci']],
                            Mbaby_liuye: ['male', 'wei', 3, ['minipoyuan', 'dchuace'], ['die:dc_liuye']],
                            Mbaby_wenqin: ['male', 'wei', 4, ['olguangao', 'minihuiqi']],
                            Mbaby_guanqiujian: ['male', 'wei', 4, ['minizhengrong', 'minihongju']],
                            Mbaby_guanlu: ['male', 'wei', 3, ['tuiyan', 'minibusuan', 'minimingjie']],
                            Mbaby_zhenghun: ['male', 'wei', 3, ['miniqiangzhi', 'dcpitian']],
                            Mbaby_chentai: ['male', 'wei', 4, ['minijiuxian', 'dcchenyong']],
                            Mbaby_hanhaoshihuan: ['male', 'wei', 4, ['shenduan', 'miniyonglve']],
                            Mbaby_sb_zhenji: ['female', 'wei', 3, ['minisbluoshen', 'minisbqingguo'], ['die:true']],
                            Mbaby_simalang: ['male', 'wei', 3, ['rejunbing', 'miniquji'], ['name:司马|朗']],
                            //蜀
                            Mbaby_guanyu: ['male', 'shu', 4, ['minirewusheng', 'minituodao', 'jsrgguanjue']],
                            Mbaby_zhugeliang: ['male', 'shu', 3, ['minireguanxing', 'minikongcheng'], ['name:诸葛|亮']],
                            Mbaby_liubei: ['male', 'shu', 4, ['minirerende', 'minijijiang'], ['zhu', 'tempname:re_liubei', 'die:re_liubei']],
                            Mbaby_machao: ['male', 'shu', 4, ['miniyuma', 'minitieji']],
                            Mbaby_zhurong: ['female', 'shu', 4, ['minijuxiang', 'minirelieren', 'changbiao'], ['name:null|null']],
                            Mbaby_zhangfei: ['male', 'shu', 4, ['new_repaoxiao', 'minitishen']],
                            Mbaby_zhaoyun: ['male', 'shu', 4, ['ollongdan', 'miniyajiao']],
                            Mbaby_huangzhong: ['male', 'shu', 4, ['miniliegong']],
                            Mbaby_weiyan: ['male', 'shu', 4, ['minikuanggu', 'miniqimou']],
                            Mbaby_liaohua: ['male', 'shu', 4, ['minidangxian', 'minifuli']],
                            Mbaby_pangtong: ['male', 'shu', 3, ['minirelianhuan', 'mininiepan'], ['tempname:ol_pangtong', 'die:ol_pangtong']],
                            Mbaby_menghuo: ['male', 'shu', 5, ['minirehuoshou', 'minizaiqi']],
                            Mbaby_jiangwei: ['male', 'shu', 4, ['minitiaoxin', 'minizhiji'], ['tempname:ol_jiangwei', 'die:ol_jiangwei']],
                            Mbaby_liushan: ['male', 'shu', 4, ['minirexiangle', 'minirefangquan', 'minireruoyu'], ['zhu', 'tempname:ol_liushan', 'die:ol_liushan']],
                            Mbaby_fazheng: ['male', 'shu', 3, ['minireenyuan', 'minirexuanhuo']],
                            Mbaby_madai: ['male', 'shu', 4, ['mashu', 'miniqianxi']],
                            Mbaby_guanping: ['male', 'shu', 4, ['minilongyin', 'jiezhong']],
                            Mbaby_liufeng: ['male', 'shu', 4, ['minixiansi']],
                            Mbaby_guanyinping: ['female', 'shu', 3, ['xueji', 'minihuxiao', 'miniwuji']],
                            Mbaby_dongyun: ['male', 'shu', 3, ['minibingzheng', 'sheyan']],
                            Mbaby_sp_sunshangxiang: ['female', 'shu', 3, ['miniliangzhu', 'minifanxiang'], ['tempname:sp_sunshangxiang']],
                            Mbaby_xushu: ['male', 'shu', 3, ['xinwuyan', 'minijujian']],
                            Mbaby_masu: ['male', 'shu', 3, ['minisanyao', 'rezhiman']],
                            Mbaby_qinmi: ['male', 'shu', 3, ['jianzheng', 'minizhuandui', 'tianbian']],
                            Mbaby_zhugezhan: ['male', 'shu', 3, ['minizuilun', 'xinfu_fuyin'], ['name:诸葛|瞻']],
                            Mbaby_zhangxingcai: ['female', 'shu', 3, ['shenxian', 'miniqiangwu']],
                            Mbaby_wuxian: ['female', 'shu', 3, ['minifumian', 'minidaiyan'], ['clan:陈留吴氏']],
                            Mbaby_shamoke: ['male', 'shu', 4, ['minijili']],
                            Mbaby_xiahoushi: ['female', 'shu', 3, ['miniqiaoshi', 'miniyanyu'], ['name:夏侯|null']],
                            Mbaby_guansuo: ['male', 'shu', 4, ['minizhengnan', 'minixiefang'], ['tempname:guansuo']],
                            Mbaby_mayunlu: ['female', 'shu', 4, ['minifengpo', 'mashu']],
                            Mbaby_wangping: ['male', 'shu', 4, ['minifeijun', 'minibinglve']],
                            Mbaby_jianyong: ['male', 'shu', 3, ['miniqiaoshui', 'jyzongshi']],
                            Mbaby_zhugeguo: ['female', 'shu', 3, ['miniqirang', 'miniyuhua'], ['name:诸葛|果']],
                            Mbaby_sp_zhugeliang: ['male', 'shu', 3, ['minibazhen', 'minihuoji', 'olkanpo'], ['name:诸葛|亮']],
                            Mbaby_baosanniang: ['female', 'shu', 3, ['decadewuniang', 'minixushen']],
                            Mbaby_huaman: ['female', 'shu', 4, ['manyi', 'mansi', 'minisouying', 'minizhanyuan']],
                            Mbaby_zhaoxiang: ['female', 'shu', 4, ['refanghun', 'minifuhan']],
                            Mbaby_xiahouba: ['male', 'shu', 4, ['minibaobian'], ['tempname:xiahouba', 'name:夏侯|霸']],
                            Mbaby_yanyan: ['male', 'shu', 4, ['minijuzhan']],
                            Mbaby_chendao: ['male', 'shu', 4, ['miniwanglie']],
                            Mbaby_liyan: ['male', 'shu', 4, ['miniduliang', 'fulin']],
                            Mbaby_liuchen: ['male', 'shu', 4, ['minizhanjue', 'miniqinwang'], ['zhu']],
                            Mbaby_yangwan: ['female', 'shu', 3, ['miniyouyan', 'zhuihuan']],
                            Mbaby_huangyueying: ['female', 'shu', 3, ['minirejizhi', 'minireqicai']],
                            Mbaby_zhoucang: ['male', 'shu', 4, ['minizhongyong', 'minidaopu']],
                            Mbaby_lvkai: ['male', 'shu', 3, ['minitunan', 'xinfu_bijing']],
                            Mbaby_sunqian: ['male', 'shu', 3, ['miniqianya', 'shuimeng']],
                            Mbaby_ganfuren: ['female', 'shu', 3, ['minishushen', 'minihuangsi'], ['name:甘|null']],
                            Mbaby_liuyong: ['male', 'shu', 3, ['zhuning', 'minifengxiang']],
                            Mbaby_mizhu: ['male', 'shu', 3, ['miniziyuan', 'minijugu']],
                            Mbaby_mifuren: ['female', 'shu', 3, ['miniguixiu', 'minicunsi'], ['name:糜|null']],
                            Mbaby_wangyue: ['female', 'shu', 3, ['minihuguan', 'minimingluan'], ['tempname:wangyue']],
                            Mbaby_xf_yiji: ['male', 'shu', 3, ['minijijie', 'minijiyuan']],
                            Mbabysp_zhangfei: ['male', 'shu', 4, ['minisppaoxiao', 'minixvhe']],
                            Mbaby_wangtao: ['female', 'shu', 3, ['minihuguan', 'miniyaopei']],
                            Mbaby_wolongfengchu: ['male', 'shu', 4, ['miniyoulong', 'miniluanfeng'], ['name:诸葛|亮-庞|统']],
                            Mbaby_guanzhang: ['male', 'shu', 4, ['minifuhun', 'retongxin'], ['tempname:guanzhang', 'name:关|兴-张|苞']],
                            Mbaby_sb_liubei: ['male', 'shu', 4, ['minisbrende', 'minisbzhangwu', 'minisbjijiang'], ['zhu']],
                            Mbaby_sb_machao: ['male', 'shu', 4, ['miniyuma', 'minisbtieji']],
                            Mbaby_sb_huangzhong: ['male', 'shu', 4, ['minisbliegong']],
                            Mbaby_sb_zhaoyun: ['male', 'shu', 4, ['minisblongdan', 'minisbshilve']],
                            Mbaby_zhangyi: ['male', 'shu', 5, ['rewurong', 'minishizhi']],
                            Mbaby_jiangfei: ['male', 'shu', 3, ['dcshengxi', 'minishoucheng']],
                            Mbaby_sb_sunshangxiang: ['female', 'wu', 3, ['minisbxiaoji', 'minisbjieyin', 'minisbfanxiang'], ['border:shu']],
                            Mbaby_sp_xiahoushi: ['female', 'shu', 3, ['sbqiaoshi', 'minispyanyu'], ['die:sb_xiahoushi', 'name:夏侯|null']],
                            Mbaby_hujinding: ['female', 'shu', '3/6', ['dcdeshi', 'miniwuyuan', 'huaizi'], ['die:dc_hujinding']],
                            Mbaby_dengzhi: ['male', 'shu', 3, ['jianliang', 'miniweimeng'], ['die:re_dengzhi']],
                            Mbaby_mazhong: ['male', 'shu', 4, ['minifuman'], ['die:re_mazhong']],
                            Mbaby_ol_sb_guanyu: ['male', 'shu', 4, ['miniweilin', 'miniduoshou']],
                            Mbaby_zongyu: ['male', 'shu', 3, ['zyqiao', 'minichengshang']],
                            Mbaby_sb_huangyueying: ['female', 'shu', 3, ['miniliuma', 'minisbjizhi', 'minisbqicai']],
                            Mbaby_ol_sb_jiangwei: ['male', 'shu', 4, ['olsbzhuri', 'miniranji']],
                            Mbaby_leitong: ['male', 'shu', 4, ['minikuiji']],
                            Mbaby_wulan: ['male', 'shu', 4, ['minicuorui']],
                            Mbaby_zhaotongzhaoguang: ['male', 'shu', 4, ['yizan_use', 'miniqingren', 'dclongyuan']],
                            Mbaby_ganfurenmifuren: ['female', 'shu', 3, ['dcchanjuan', 'minixunbie']],
                            //吴
                            Mbaby_bulianshi: ['female', 'wu', 3, ['minianxu', 'zhuiyi']],
                            Mbaby_chengpu: ['male', 'wu', 4, ['minilihuo', 'minichunlao']],
                            Mbaby_daqiao: ['female', 'wu', 3, ['miniguose', 'miniwanrong', 'liuli'], ['tempname:re_daqiao', 'die:re_daqiao', 'name:桥|null']],
                            Mbaby_ganning: ['male', 'wu', 4, ['miniqixi', 'minifenwei']],
                            Mbaby_huanggai: ['male', 'wu', 4, ['kurou', 'minizhaxiang']],
                            Mbaby_lusu: ['male', 'wu', 3, ['miniolhaoshi', 'minidimeng'], ['die:ol_lusu']],
                            Mbaby_luxun: ['male', 'wu', 3, ['minireqianxun', 'minilianying']],
                            Mbaby_lvmeng: ['male', 'wu', 4, ['minikeji', 'miniqinxue', 'rebotu'], ['tempname:re_lvmeng', 'die:re_lvmeng']],
                            Mbaby_sunce: ['male', 'wu', 4, ['minijiang', 'minihunzi', 'minizhiba'], ['zhu', 'tempname:sunce']],
                            Mbaby_sunluban: ['female', 'wu', 3, ['minizenhui', 'minijiaojin']],
                            Mbaby_sunluyu: ['female', 'wu', 3, ['minimeibu', 'remumu']],
                            Mbaby_sunquan: ['male', 'wu', 4, ['minirezhiheng', 'minijiuyuan'], ['zhu']],
                            Mbaby_sunshangxiang: ['female', 'wu', 3, ['minijieyin', 'xiaoji']],
                            Mbaby_taishici: ['male', 'wu', 4, ['miniretianyi', 'minihanzhan'], [...['die', 'tempname'].map(i => i + ':re_taishici'), 'name:太史|慈']],
                            Mbaby_wuguotai: ['female', 'wu', 3, ['miniganlu', 'minibuyi']],
                            Mbaby_xiaoqiao: ['female', 'wu', 3, ['minitianxiang', 'olhongyan'], ['name:桥|null']],
                            Mbaby_xusheng: ['male', 'wu', 4, ['minirepojun', 'miniyicheng']],
                            Mbaby_zhoutai: ['male', 'wu', 4, ['minirebuqu', 'fenji', 'miniqingchuang']],
                            Mbaby_zhouyu: ['male', 'wu', 3, ['minireyingzi', 'minirefanjian'], ['die:sb_zhouyu']],
                            Mbaby_zhugejin: ['male', 'wu', 3, ['huanshi', 'minihongyuan', 'mingzhe'], ['name:诸葛|瑾']],
                            Mbaby_zumao: ['male', 'wu', 4, ['miniyinbing', 'minijuedi']],
                            Mbabysp_xiaoqiao: ['female', 'wu', 3, ['minixingwu', 'miniluoyan', 'minihuimou'], ['name:桥|null']],
                            Mbaby_zhuzhi: ['male', 'wu', 4, ['minianguo']],
                            Mbaby_ol_sunjian: ['male', 'wu', 4, ['miniyinghun', 'miniwulie'], ['tempname:ol_sunjian']],
                            Mbaby_sunliang: ['male', 'wu', 3, ['minikuizhu', 'minichezheng', 'minilijun'], ['zhu']],
                            Mbaby_zhangzhang: ['male', 'wu', 3, ['rezhijian', 'miniguzheng']],
                            Mbaby_zhoufei: ['female', 'wu', 3, ['miniliangyin', 'kongsheng'], ['name:周|null']],
                            Mbaby_zhugeke: ['male', 'wu', 3, ['miniaocai', 'miniduwu'], ['name:诸葛|恪']],
                            Mbaby_xushi: ['female', 'wu', 3, ['miniwengua', 'minifuzhu'], ['name:徐|null']],
                            Mbaby_buzhi: ['male', 'wu', 3, ['minihongde', 'minidingpan']],
                            Mbaby_lukang: ['male', 'wu', 4, ['drlt_qianjie', 'minijueyan', 'minihuairou'], ['tempname:lukang']],
                            Mbabysp_daqiao: ['female', 'wu', 3, ['miniyanxiao', 'miniwanrong', 'minianxian'], ['die:re_daqiao', 'name:桥|null']],
                            Mbaby_sunhao: ['male', 'wu', 5, ['minicanshi', 'minichouhai', 'guiming'], ['zhu']],
                            Mbaby_re_jsp_pangtong: ['male', 'wu', 3, ['miniguolun', 'minisongsang', 'xinfu_zhanji']],
                            Mbaby_luyusheng: ['female', 'wu', 3, ['minizhente', 'minizhiwei']],
                            Mbaby_zhuhuan: ['male', 'wu', 4, ['minifenli', 'minipingkou']],
                            Mbaby_yanjun: ['male', 'wu', 3, ['miniguanchao', 'minixunxian']],
                            Mbaby_re_sunyi: ['male', 'wu', 5, ['syjiqiao', 'minisyxiongyi'], ['tempname:re_sunyi']],
                            Mbaby_zhangxuan: ['female', 'wu', 4, ['tongli', 'minishezang']],
                            Mbaby_zhoufang: ['male', 'wu', 3, ['xinfu_duanfa', 'miniyoudi']],
                            Mbaby_luji: ['male', 'wu', 3, ['nzry_huaiju', 'nzry_yili', 'minizhenglun']],
                            Mbaby_sundeng: ['male', 'wu', 4, ['minikuangbi']],
                            Mbaby_panjun: ['male', 'wu', 3, ['miniguanwei', 'minigongqing']],
                            Mbaby_dingfeng: ['male', 'wu', 4, ['miniduanbing', 'minifenxun']],
                            Mbaby_xuezong: ['male', 'wu', 3, ['minifunan', 'minijiexun']],
                            Mbaby_sb_huanggai: ['male', 'wu', 4, ['minisbkurou', 'minisbzhaxiang']],
                            Mbaby_zhangfen: ['male', 'wu', 4, ['miniwanglu', 'minixianzhu', 'minichaixie']],
                            Mbaby_sunxiu: ['male', 'wu', 3, ['miniyanzhu', 'minixingxue', 'minizhaofu'], ['zhu']],
                            Mbaby_dc_sunru: ['female', 'wu', 3, ['minixiecui', 'youxu']],
                            Mbaby_yufan: ['male', 'wu', 3, ['minizongxuan', 'minizhiyan']],
                            Mbaby_quancong: ['male', 'wu', 4, ['miniyaoming']],
                            Mbaby_re_guyong: ['male', 'wu', 3, ['minishenxing', 'rebingyi']],
                            Mbaby_sb_lvmeng: ['male', 'wu', 4, ['minikeji', 'minisbduojing']],
                            Mbaby_quanhuijie: ['female', 'wu', 3, ['dchuishu', 'dcyishu', 'miniligong']],
                            Mbaby_jiangqing: ['male', 'wu', 4, ['minijianyi', 'minishangyi']],
                            Mbaby_lvdai: ['male', 'wu', 4, ['miniqinguo']],
                            Mbaby_heqi: ['male', 'wu', 4, ['miniqizhou', 'minishanxi'], ['tempname:heqi']],
                            Mbaby_sunhanhua: ['female', 'wu', 3, ['minihuiling', 'minichongxu'], ['die:dc_sunhanhua']],
                            Mbaby_zhangwen: ['male', 'wu', 3, ['minisongshu', 'minisibian'], ['die:zhangwen']],
                            Mbaby_weiwenzhugezhi: ['male', 'wu', 4, ['minifuhai'], ['die:weiwenzhugezhi', 'name:卫|温-诸葛|直']],
                            Mbaby_panzhangmazhong: ['male', 'wu', 4, ['miniduodao', 'minianjian'], ['die:re_panzhangmazhong', 'name:潘|璋-马|忠']],
                            Mbaby_kanze: ['male', 'wu', 4, ['xiashu', 'minikuanshi'], ['die:kanze']],
                            Mbaby_sb_ganning: ['male', 'wu', 4, ['sbqixi', 'minisbfenwei']],
                            Mbaby_chendong: ['male', 'wu', 4, ['miniduanxie', 'minifenming']],
                            //群
                            Mbaby_gaoshun: ['male', 'qun', 4, ['minixianzhen', 'minijinjiu']],
                            Mbaby_caifuren: ['female', 'qun', 3, ['minireqieting', 'minirexianzhou'], ['name:蔡|null']],
                            Mbaby_lijue: ['male', 'qun', '5/6', ['xinfu_langxi', 'xinfu_yisuan']],
                            Mbaby_zuoci: ['male', 'qun', 3, ['minishendao', 'minixinsheng'], ['die:true']],
                            Mbaby_xuyou: ['male', 'qun', 3, ['minichenglve', 'nzry_shicai', 'nzry_cunmu']],
                            Mbaby_gongsunzan: ['male', 'qun', 4, ['miniqiaomeng', 'miniyicong'], ['name:公孙|瓒']],
                            Mbaby_pangde: ['male', 'qun', 4, ['mashu', 'minijianchu']],
                            Mbaby_jushou: ['male', 'qun', 3, ['jianying', 'minishibei']],
                            Mbaby_liru: ['male', 'qun', 3, ['xinjuece', 'minimieji', 'xinfencheng']],
                            Mbaby_dongzhuo: ['male', 'qun', 8, ['minirejiuchi', 'miniroulin', 'minirebenghuai', 'olbaonue'], ['zhu', 'tempname:ol_dongzhuo', 'die:ol_dongzhuo']],
                            Mbaby_zhangjiao: ['male', 'qun', 3, ['minileiji', 'xinguidao', 'minihuangtian'], ['zhu', 'tempname:sp_zhangjiao', 'die:sp_zhangjiao']],
                            Mbaby_huatuo: ['male', 'qun', 3, ['minijijiu', 'minireqingnang']],
                            Mbaby_lvbu: ['male', 'qun', 5, ['miniwushuang', 'miniwuchang']],
                            Mbaby_sp_diaochan: ['female', 'qun', 3, ['minilihun', 'minibiyue']],
                            Mbaby_huaxiong: ['male', 'qun', 6, ['miniyaowu', 'miniyangwei'], ['tempname:sb_huaxiong', 'die:sb_huaxiong']],
                            Mbaby_yuji: ['male', 'qun', 4, ['miniguhuo']],
                            Mbaby_zhangliang: ['male', 'qun', 4, ['minijijun', 'minifangtong']],
                            Mbaby_zhangbao: ['male', 'qun', 4, ['minizhoufu', 'miniyingbing']],
                            Mbaby_yanwen: ['male', 'qun', 4, ['minishuangxiong']],
                            Mbaby_liubiao: ['male', 'qun', 3, ['rezishou', 'rezongshi']],
                            Mbaby_yuanshao: ['male', 'qun', 4, ['miniluanji', 'minixueyi'], ['zhu']],
                            Mbaby_yuanshu: ['male', 'qun', 4, ['miniyongsi', 'minireweidi']],
                            Mbaby_chengong: ['male', 'qun', 3, ['miniremingce', 'minizhichi']],
                            Mbaby_jiaxu: ['male', 'qun', 3, ['minirewansha', 'reluanwu', 'reweimu'], ['tempname:re_jiaxu', 'die:re_jiaxu']],
                            Mbaby_liuzhang: ['male', 'qun', 4, ['miniyinlang', 'minixiusheng', 'minihuaibi'], ['zhu']],
                            Mbaby_panfeng: ['male', 'qun', 4, ['minikuangfu']],
                            Mbaby_sp_machao: ['male', 'qun', 4, ['minizhuiji', 'minishichou']],
                            Mbaby_diaochan: ['female', 'qun', 3, ['minirelijian', 'minirebiyue']],
                            Mbaby_jsp_huangyueying: ['female', 'qun', 3, ['minijiqiao', 'minilinglong']],
                            Mbaby_quyi: ['male', 'qun', 4, ['minifuqi', 'minijiaozi']],
                            Mbaby_liuxie: ['male', 'qun', 3, ['minitianming', 'minimizhao']],
                            Mbaby_caiwenji: ['female', 'qun', 3, ['minibeige', 'duanchang'], ['name:蔡|琰']],
                            Mbaby_fuhuanghou: ['female', 'qun', 3, ['minizhuikong', 'miniqiuyuan']],
                            Mbaby_zhangqiying: ['female', 'qun', 3, ['xinfu_falu', 'minidianhua', 'minizhenyi']],
                            Mbaby_chunyuqiong: ['male', 'qun', 4, ['minicangchu', 'miniliangying', 'minishishou']],
                            Mbaby_beimihu: ['female', 'qun', 4, ['minizongkui', 'miniguju', 'bmcanshi']],
                            Mbaby_dongbai: ['female', 'qun', 3, ['minilianzhu', 'minixiahui']],
                            Mbaby_zhangji: ['male', 'qun', 4, ['minilveming', 'minitunjun']],
                            Mbaby_sp_taishici: ['male', 'qun', 4, ['minijixu'], ['name:太史|慈']],
                            Mbaby_xushao: ['male', 'qun', 4, ['minipingjian']],
                            Mbaby_hetaihou: ['female', 'qun', 3, ['minizhendu', 'miniqiluan']],
                            Mbaby_wangrong: ['female', 'qun', 3, ['miniminsi', 'minijijing', 'zhuide']],
                            Mbaby_sp_menghuo: ['male', 'qun', 4, ['minimanwang']],
                            Mbaby_caoxing: ['male', 'qun', 4, ['miniliushi', 'zhanwan']],
                            Mbabysp_zhenji: ['female', 'qun', 3, ['minijinghong', 'minispluoshen']],
                            Mbaby_liangxing: ['male', 'qun', 4, ['minilulve', 'lxzhuixi']],
                            Mbaby_caojie: ['female', 'qun', 3, ['minishouxi', 'minihuimin']],
                            Mbaby_tangji: ['female', 'qun', 3, ['minikangge', 'minijielie']],
                            Mbaby_libai: ['male', 'qun', 3, ['minishixian']],
                            Mbaby_guotufengji: ['male', 'qun', 3, ['minijigong', 'minishifei']],
                            Mbaby_re_nanhualaoxian: ['male', 'qun', 4, ['minijinghe', 'minigongxiu']],
                            Mbaby_yanfuren: ['female', 'qun', 3, ['minichanni', 'mininifu'], ['name:严|null']],
                            Mbaby_gongsunyuan: ['male', 'qun', 4, ['minihuaiyi'], ['name:公孙|渊']],
                            Mbaby_sp_zhangliao: ['male', 'qun', 4, ['minimubing', 'miniziqu', 'minidiaoling']],
                            Mbaby_sp_ol_zhanghe: ['male', 'qun', 4, ['minizhouxuan']],
                            Mbaby_zhujun: ['male', 'qun', 4, ['minigongjian', 'kuimang', 'minizjjuxiang']],
                            Mbaby_sp_kongrong: ['male', 'qun', 3, ['minilirang', 'minizhengyi']],
                            Mbaby_laiyinger: ['female', 'qun', 3, ['minixiaowu', 'minihuaping']],
                            Mbaby_sb_yuanshao: ['male', 'qun', 4, ['minisbluanji', 'minisbxueyi'], ['zhu']],
                            Mbaby_tw_mateng: ['male', 'qun', 4, ['miniyuma', 'minixiongzheng', 'miniluannian'], ['zhu']],
                            Mbaby_dc_huangchengyan: ['male', 'qun', 3, ['dcjiezhen', 'minizecai', 'dcyinshi']],
                            Mbaby_simahui: ['male', 'qun', 3, ['minijianjie', 'xinfu_chenghao', 'miniyinshi'], ['name:司马|徽']],
                            Mbaby_zoushi: ['female', 'qun', 3, ['minihuoshui', 'miniqingcheng'], ['name:邹|null']],
                            Mbaby_wangyun: ['male', 'qun', 4, ['minilianji', 'minimoucheng'], ['clan:太原王氏']],
                            Mbaby_xiaoshan: ['female', 'qun', 4, ['minishanshan', 'minianshi']],
                            Mbaby_zhanglu: ['male', 'qun', 3, ['miniyishe', 'minibushi', 'minimidao']],
                            Mbaby_zhangning: ['female', 'qun', 3, ['minitianze', 'minidifa']],
                            Mbaby_ol_dingyuan: ['male', 'qun', 4, ['minicixiao', 'xianshuai']],
                            Mbaby_liubian: ['male', 'qun', 3, ['shiyuan', 'minidushi', 'yuwei'], ['zhu']],
                            Mbaby_re_pangdegong: ['male', 'qun', 3, ['miniheqia', 'yinyi']],
                            Mbaby_licaiwei: ['female', 'qun', 3, ['yijiao', 'miniqibie'], ['border:wei']],
                            Mbaby_dc_huangzu: ['male', 'qun', 4, ['dcjinggong', 'minixiaojuan']],
                            Mbaby_yanbaihu: ['male', 'qun', 4, ['minizhidao', 'minybhijili']],
                            Mbaby_guosi: ['male', 'qun', 4, ['minitanbei', 'minisidao']],
                            Mbaby_fanchou: ['male', 'qun', 4, ['minixingluan']],
                            Mbaby_huangfusong: ['male', 'qun', 4, ['xinfenyue', 'minijuxia']],
                            Mbaby_wutugu: ['male', 'qun', 15, ['miniranshang', 'hanyong']],
                            Mbaby_fuwan: ['male', 'qun', 4, ['minimoukui']],
                            Mbaby_dongxie: ['female', 'qun', 4, ['minijiaoxia', 'minihumei']],
                            Mbaby_guanning: ['male', 'qun', '3/7', ['minidunshi']],
                            Mbaby_re_hansui: ['male', 'qun', 4, ['mininiluan', 'spweiwu']],
                            Mbaby_tadun: ['male', 'qun', 4, ['miniluanzhan']],
                            Mbaby_gaolan: ['male', 'qun', 4, ['minixizhen'], ['die:dc_gaolan']],
                            Mbaby_yl_luzhi: ['male', 'qun', 3, ['nzry_mingren', 'minizhenliang']],
                            Mbaby_mengjie: ['male', 'qun', 3, ['dcyinlu', 'miniyouqi']],
                            Mbaby_caiyong: ['male', 'qun', 3, ['minibizhuan', 'minitongbo']],
                            //神
                            Mbaby_shen_zhugeliang: ['male', 'shen', 3, ['qixing', 'minikuangfeng', 'minidawu'], ['shu', 'name:诸葛|亮']],
                            Mbaby_shen_lvbu: ['male', 'shen', 6, ['miniwuqian', 'minishenfen'], ['qun']],
                            Mbaby_shen_lvmeng: ['male', 'shen', 3, ['minishelie', 'minigongxin'], ['wu']],
                            Mbaby_shen_guanyu: ['male', 'shen', 5, ['miniwushen', 'miniwuhun'], ['shu']],
                            Mbaby_shen_zhouyu: ['male', 'shen', 4, ['miniqinyin', 'miniyeyan'], ['wu']],
                            Mbaby_shen_caocao: ['male', 'shen', 3, ['miniguixin', 'feiying'], ['wei']],
                            Mbaby_shen_liubei: ['male', 'shen', 6, ['minilongnu', 'minijieying'], ['shu']],
                            Mbaby_shen_zhangliao: ['male', 'shen', 4, ['miniduorui', 'minizhiti'], ['wei']],
                            Mbaby_shen_sunquan: ['male', 'shen', 4, ['miniquantui', 'minishehu', 'minidingli'], ['wu']],
                            Mbaby_shen_simayi: ['male', 'shen', 3, ['minirenjie', 'minijilve', 'lianpo'], ['wei', 'name:司马|懿']],
                            Mbaby_shen_zhaoyun: ['male', 'shen', 2, ['minijuejing', 'minilonghun'], ['shu']],
                            Mbaby_shen_ganning: ['male', 'shen', '3/6', ['minipoxi', 'drlt_jieying'], ['wu']],
                            Mbaby_shen_dianwei: ['male', 'shen', 5, ['minishenwei', 'minielai', 'minikuangxi'], ['wei', 'die:true']],
                            Mbaby_shen_huatuo: ['male', 'shen', 1, ['minijishi', 'minitaoxian', 'minishenzhen'], ['qun']],
                            Mbaby_shen_guojia: ['male', 'shen', 3, ['reshuishi', 'minigjtianyi', 'minihuishi'], ['wei']],
                            Mbaby_shen_zhenji: ['female', 'shen', 3, ['minishenfu', 'miniqixian', 'minifeifu'], ['wei']],
                            Mbaby_shen_daxiaoqiao: ['female', 'shen', 4, ['minishuangshu', 'minipingting', 'miniyizheng'], ['wu', 'name:桥|null']],
                            Mbaby_shen_diaochan: ['female', 'shen', 3, ['minimeihun', 'minihuoxin'], ['qun', 'die:true']],
                            Mbaby_sunwukong: ['male', 'shen', 4, ['mini72bian', 'miniruyi', 'miniqitian']],
                            Mbaby_dalanmao: ['male', 'shen', 4, ['minizuzhou', 'minimoyu', 'minisanlian']],
                            Mbaby_change: ['female', 'shen', '1/4', ['minidaoyao', 'minibenyue']],
                            Mbaby_shen_taishici: ['male', 'shen', 4, ['minidulie', 'minichongwei', 'minipowei'], ['wu', 'name:太史|慈']],
                            Mbaby_nvwa: ['female', 'shen', '69/159', ['minibutian', 'minilianshi', 'minituantu']],
                            Mbaby_tunxingmenglix: ['female', 'shen', 4, ['minitunxing', 'minimengli']],
                            Mbaby_shen_zuoci: ['male', 'shen', 3, ['minihuanshu', 'minihuanhua', 'minihuanjing'], ['qun']],
                            Mbaby_shen_dengai: ['male', 'shen', 4, ['dctuoyu', 'minixianjin', 'dcqijing'], ['wei']],
                            Mbaby_shen_luxun: ['male', 'shen', 4, ['nzry_junlve', 'minicuike', 'nzry_dinghuo'], ['wu']],
                            Mbaby_shen_pangtong: ['male', 'shen', 4, ['minilunce', 'minilanhai'], ['shu', 'die:true']],
                            Mbaby_jingwei: ['female', 'shen', 4, ['minitianhai', 'minihaiku']],
                            //喵
                            Mmiao_caiwenji: ['female', 'qun', 3, ['minimiaobeige', 'minimiaoduanchang', 'minidoumao'], ['name:蔡|琰']],
                            Mmiao_diaochan: ['female', 'qun', 3, ['minimiaolijian', 'minimiaobiyue', 'minidoumao']],
                            Mmiao_caifuren: ['female', 'qun', 3, ['minimiaoqieting', 'minimiaoxianzhou', 'minidoumao'], ['name:蔡|null']],
                            Mmiao_zhangxingcai: ['female', 'shu', 3, ['minimiaoshenxian', 'minimiaoqiangwu', 'minidoumao']],
                            Mmiao_zhurong: ['female', 'shu', 4, ['minimiaojuxiang', 'minimiaolieren', 'minidoumao']],
                            Mmiao_huangyueying: ['female', 'shu', 3, ['minimiaojizhi', 'minimiaoqicai', 'minidoumao']],
                            Mmiao_daqiao: ['female', 'wu', 3, ['minimiaoguose', 'minimiaoliuli', 'minidoumao'], ['name:桥|null']],
                            Mmiao_wangyi: ['female', 'wei', 4, ['minimiaozhenlie', 'minimiaomiji', 'minidoumao']],
                            Mmiao_zhangchunhua: ['female', 'wei', 3, ['minimiaojueqing', 'minimiaoshangshi', 'minidoumao']],
                            Mmiao_zhenji: ['female', 'wei', 3, ['minimiaoluoshen', 'minimiaoqingguo', 'minidoumao']],
                            Mmiao_sunshangxiang: ['female', 'wu', 3, ['minimiaojieyin', 'minimiaoxiaoji', 'minidoumao']],
                            Mmiao_xiaoqiao: ['female', 'wu', 3, ['minimiaotianxiang', 'minimiaohongyan', 'minidoumao'], ['name:桥|null']],
                            Mmiao_lvlingqi: ['female', 'qun', 4, ['minimiaozhuangrong', 'minimiaoguowu', 'minidoumao']],
                            //念
                            Mnian_zhugeliang: ['male', 'shu', 3, ['mininianxinghan', 'mininianliaoyuan', 'mininianying_zgl'], ['name:诸葛|亮']],
                            Mnian_lvbu: ['male', 'qun', 5, ['mininiantazhen', 'mininiandoupo', 'mininianying_lb']],
                            Mnian_zhouyu: ['male', 'wu', 4, ['mininiansuhui', 'mininianchongzou', 'mininianying_zy']],
                            //战
                            Mfight_huangzhong: ['male', 'shu', 4, ['minifightdingjun', 'minifightlizhan']],
                        },
                        characterIntro: {
                            Mbaby_change: '嫦娥，中国古代神话中的人物，又名恒我、恒娥、姮娥、常娥、素娥，羿之妻，因偷吃了不死药而飞升至月宫。嫦娥的故事最早出现在商朝卦书 《归藏》。而嫦娥奔月的完整故事最早记载于西汉《淮南子·览冥训》。东汉时期，嫦娥与羿的夫妻关系确立，而嫦娥在进入月宫后变成了捣药的蟾蜍。南北朝以后，嫦娥的形象回归为女儿身。汉画像中，嫦娥人头蛇身，头梳高髻，身着宽袖长襦，身后长尾上饰有倒钩状细短羽毛。南北朝以后，嫦娥的形象被描绘成绝世美女。南朝陈后主陈叔宝曾把宠妃张丽华比作嫦娥。唐朝诗人白居易曾用嫦娥夸赞邻家少女不可多得的容貌。',
                            Mbaby_nvwa: '女娲，中国上古神话中的创世女神。又称娲皇、女阴，史记女娲氏，是华夏民族人文先始，是福佑社稷之正神。相传女娲造人，一日中七十化变，以黄泥仿照自己抟土造人，创造人类社会并建立婚姻制度；因世间天塌地陷，于是熔彩石以补苍天，斩鳌足以立四极，留下了女娲补天的神话传说。女娲不但是补天救世的英雄和抟土造人的女神，还是一个创造万物的自然之神，神通广大化生万物，每天至少能创造出七十样东西。她开世造物，因此被称为大地之母，是被民间广泛而又长久崇拜的创世神和始母神。',
                            Mbaby_tunxingmenglix: '据《王子年拾遗记》记载：蜀先主甘后；生而体貌特异，年至十八，玉质柔肌，态媚容冶…河南献玉人高三尺…甘后与玉人洁白齐润，观者殆相乱惑。刘备非常喜爱这尊玉雕，“夕则用后而玩玉人”。白玉美人怀抱一只白玉狸猫，甘夫人常对玉人倾诉渴望为刘备诞下一子的心愿，然而久盼未果。偶有一日，在梦中化身成一只饥肠辘辘、失去理智的白玉狸猫，闯入到幻境当中，吞掉了幻境中的启明星。事后，梦醒的甘夫人发现已怀有身孕，甚是欣喜。而白玉美人怀抱的玉狸猫则留在了幻境中，化身为吞星梦狸守护着幻境里的星星。',
                            Mbaby_jingwei: '精卫，中国古代神话中的一种鸟。上古神话传说里，女娃是炎帝最小的女儿，后溺水而亡，化作精卫鸟；另一说，女娃是上古的一个部落，由于气候变暖，海平面上升，女娃部落遭到灭顶之灾，后化作精卫。据《山海经》记载：精卫婀娜多姿、长发飘逸、背生双翼，花头颅、白嘴壳、红脚爪，样子有点儿像乌鸦。',

                        },
                        characterFilter: {
                        },
                        characterTitle: {
                        },
                        characterSubstitute: {
                            Mbaby_tunxingmenglix: [
                                ['Mbaby_tunxingmengli', [((lib.device || lib.node) ? 'ext:' : 'db:extension-') + '活动武将/image/character/Mbaby_tunxingmengli.jpg']],
                            ],
                        },
                        card: {
                            miniyanxiao_card: {
                                type: 'delay',
                                judge: 0,
                                effect() { },
                                ai: {
                                    basic: {
                                        order: 1,
                                        useful: 1,
                                        value: 8,
                                    },
                                    result: { target: 1 },
                                },
                            },
                            minilingren_basic: {
                                image: 'ext:活动武将/image/card/minilingren_basic.png',
                                fullimage: true,
                            },
                            minilingren_trick: {
                                image: 'ext:活动武将/image/card/minilingren_trick.png',
                                fullimage: true,
                            },
                            minilingren_equip: {
                                image: 'ext:活动武将/image/card/minilingren_equip.png',
                                fullimage: true,
                            },
                            miniruyi_jingubang: {
                                fullimage: true,
                                derivation: 'Mbaby_sunwukong',
                                type: 'equip',
                                subtype: 'equip1',
                                ai: { basic: { equipValue: 114514 + 1919810 } },
                                skills: ['miniruyi_jingubang', 'miniruyi_jingubang2'],
                            },
                            minidagongche: {
                                fullskin: true,
                                cardimage: 'dagongche',
                                derivation: 'Mbaby_zhangfen',
                                type: 'equip',
                                subtype: 'equip1',
                                distance: { attackFrom: -1 },
                                skills: ['minidagongche_skill'],
                                cardPrompt(card) {
                                    if (!card.storage) return '出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。';
                                    var str = '出牌阶段开始时，你可以视为使用一张';
                                    if (card.storage.大攻车选项一) str += '无距离限制且无视防具的';
                                    str += '【杀】';
                                    if (card.storage.大攻车选项二) str += ('（此【杀】的目标上限+' + card.storage.大攻车选项二 + '）');
                                    str += '，且当此【杀】对目标角色造成伤害后，你弃置其';
                                    var num = 1;
                                    if (card.storage.大攻车选项三) num += card.storage.大攻车选项三;
                                    str += get.cnNumber(num);
                                    str += '张牌。当此牌离开你的装备区后，销毁之。';
                                    return str;
                                },
                                destroy: true,
                                ai: { basic: { equipValue: 114514 + 1919810 } },
                            },
                            minijieyue_junling1: {
                                type: 'junling',
                                vanish: true,
                            },
                            minijieyue_junling2: {
                                type: 'junling',
                                vanish: true,
                            },
                            minijieyue_junling3: {
                                type: 'junling',
                                vanish: true,
                            },
                            minijieyue_junling4: {
                                type: 'junling',
                                vanish: true,
                            },
                            mini_zhong: {
                                type: 'trick',
                                notarget: true,
                                wuxieable: true,
                                global: 'miniweilin_zhong',
                                content() {
                                    const evt = event.getParent(2).mini_zhong || event.getParent(3).mini_zhong;
                                    if (!evt) return event.finish();
                                    player.line(evt.player);
                                    player.addExpose(0.2);
                                    evt.cancel();
                                    player.damage(evt.source ? evt.source : 'nosource', evt.nature, evt.num).set('card', evt.card).set('cards', evt.cards);
                                },
                                ai: {
                                    value: [5, 1],
                                    useful: [5, 1],
                                    order: 1,
                                    wuxie(target, card, player, current, state) {
                                        return -state * get.attitude(player, current);
                                    },
                                    result: {
                                        player(player) {
                                            const trigger = get.event().getParent().mini_zhong;
                                            if (trigger?.player) return get.info('twgonghuan').check(trigger, player) ? 1 : 0;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            mini_yi: {
                                type: 'trick',
                                enable: true,
                                filterTarget(card, player, target) {
                                    return target.countCards('he') && target != player;
                                },
                                content() {
                                    target.chooseToGive(player, 'he', true);
                                    const evt = event.getParent();
                                    if (evt?.name === 'useCard' && evt.cards?.someInD('od')) {
                                        target.gain(evt.cards.filterInD('od'), 'gain2');
                                    }
                                },
                                ai: {
                                    order: 4,
                                    value: [5, 1],
                                    result: { target: -1 },
                                },
                            },
                            minipiliche: {
                                fullskin: true,
                                cardimage: 'ly_piliche',
                                derivation: 'Mbaby_liuye',
                                type: 'equip',
                                subtype: 'equip4',
                                distance: { globalFrom: -1 },
                                skills: ['minipiliche'],
                                destroy: true,
                                ai: { basic: { equipValue: 3 } },
                            },
                            mininiantazhen_sha: {
                                fullimage: true,
                                image: 'ext:活动武将/image/card/mininiantazhen_sha.png',
                            },
                            mininiantazhen_horse: {
                                fullimage: true,
                                image: 'ext:活动武将/image/card/mininiantazhen_horse.png',
                            },
                            mininiantazhen_jiu: {
                                fullimage: true,
                                image: 'ext:活动武将/image/card/mininiantazhen_jiu.png',
                            },
                            zhouyu_宫: {
                                fullimage: true,
                                image: 'ext:活动武将/image/default/zhouyu_宫.jpg',
                            },
                            zhouyu_商: {
                                fullimage: true,
                                image: 'ext:活动武将/image/default/zhouyu_商.jpg',
                            },
                            zhouyu_角: {
                                fullimage: true,
                                image: 'ext:活动武将/image/default/zhouyu_角.jpg',
                            },
                            zhouyu_徵: {
                                fullimage: true,
                                image: 'ext:活动武将/image/default/zhouyu_徵.jpg',
                            },
                            zhouyu_羽: {
                                fullimage: true,
                                image: 'ext:活动武将/image/default/zhouyu_羽.jpg',
                            },
                        },
                        skill: {
                            //魏
                            minijingce: {
                                audio: 'jingce',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                content() {
                                    var list = [];
                                    player.getHistory('useCard', function (evt) {
                                        list.add(get.suit(evt.card));
                                    });
                                    player.draw(Math.min(list.length + 1, 3));
                                },
                            },
                            minihuchi: {
                                audio: 'ext:活动武将/audio/skill:true',
                                group: ['minihuchi_miss', 'minihuchi_draw'],
                                trigger: { player: 'phaseJieshuBegin' },
                                frequent: true,
                                prompt: '是否发动【虎痴】，将手牌摸至两张？',
                                filter(event, player) {
                                    return player.countCards('h') < 2;
                                },
                                content() {
                                    player.drawTo(2);
                                },
                                marktext: '痴',
                                intro: { name: '虎痴', name2: '痴', content: 'mark' },
                                subSkill: {
                                    miss: {
                                        shaRelated: true,
                                        audio: 'minihuchi',
                                        trigger: { player: 'shaMiss' },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addMark('minihuchi', 1);
                                        },
                                    },
                                    draw: {
                                        audio: 'minihuchi',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            return player.countMark('minihuchi');
                                        },
                                        usable: 1,
                                        content() {
                                            var num = player.countMark('minihuchi');
                                            player.removeMark('minihuchi', num);
                                            player.draw(num);
                                        },
                                        ai: {
                                            order: 1,
                                            result: { player: 1 },
                                        },
                                    },
                                },
                            },
                            minixingshang: {
                                audio: 'xingshang',
                                audioname2: { Mbaby_caoying: 'lingren_xingshang' },
                                trigger: { global: 'die' },
                                preHidden: true,
                                content() {
                                    if (trigger.player.countCards('he')) player.gain(trigger.player.getCards('he'), trigger.player, 'giveAuto');
                                    player.draw();
                                },
                            },
                            minilingren: {
                                derivation: ['minijianxiong', 'minixingshang'],
                                audio: 'xinfu_lingren',
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (event.getParent().triggeredTargets3.length > 1) return false;
                                    if (!player.isPhaseUsing()) return false;
                                    if (!['basic', 'trick'].includes(get.type(event.card))) return false;
                                    if (get.tag(event.card, 'damage')) return true;
                                    return false;
                                },
                                usable: 1,
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minilingren'), '选择一名目标角色并猜测其手牌构成', function (card, player, target) {
                                        return _status.event.targets.includes(target);
                                    }).set('ai', function (target) {
                                        return 2 - get.attitude(_status.event.player, target);
                                    }).set('targets', trigger.targets);
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minilingren', target);
                                        var list = ['minilingren_basic', 'minilingren_trick', 'minilingren_equip'];
                                        player.chooseButton(['###' + '凌人：猜测' + get.translation(target) + '的手牌组成类型' + '###' + '请选出你认为' + get.translation(target) + '有的手牌类型', [list, 'vcard']], [0, 3]).set('ai', function (button) {
                                            var name = button.link[2];
                                            switch (name) {
                                                case 'minilingren_basic':
                                                    var A = 0.95;
                                                    if (!target.countCards('h', { type: ['basic'] })) A = 0.05;
                                                    if (!target.countCards('h')) A = 0;
                                                    return Math.random() < A ? 1 : -1;
                                                    break;
                                                case 'minilingren_trick':
                                                    var B = 0.9;
                                                    if (!target.countCards('h', { type: ['trick', 'delay'] })) B = 0.1;
                                                    if (!target.countCards('h')) B = 0;
                                                    return Math.random() < B ? 1 : -1;
                                                    break;
                                                case 'minilingren_equip':
                                                    var C = 0.75;
                                                    if (!target.countCards('h', { type: ['equip'] })) C = 0.25;
                                                    if (!target.countCards('h')) C = 0;
                                                    return Math.random() < C ? 1 : -1;
                                                    break;
                                            }
                                        });
                                    }
                                    else {
                                        player.storage.counttrigger.minilingren--;
                                        event.finish();
                                    }
                                    'step 2'
                                    event.num = 0;
                                    var list1 = [], list2 = [];
                                    if (result.links) for (var name of result.links) list1.push(name[2].slice(12));
                                    if (target.countCards('h')) for (var card of target.getCards('h')) if (!list2.includes(get.type2(card))) list2.push(get.type2(card));
                                    for (var type of ['basic', 'trick', 'equip']) if ((list1.includes(type) && list2.includes(type)) || (!list1.includes(type) && !list2.includes(type))) event.num++;
                                    if (!event.isMine() && !event.isOnline()) game.delayx();
                                    'step 3'
                                    player.popup('猜对' + get.cnNumber(event.num) + '项');
                                    game.log(player, '猜对了' + get.cnNumber(event.num) + '项');
                                    if (event.num > 0) {
                                        var map = trigger.customArgs;
                                        var id = target.playerid;
                                        if (!map[id]) map[id] = {};
                                        if (typeof map[id].extraDamage != "number") map[id].extraDamage = 0;
                                        map[id].extraDamage++;
                                    }
                                    if (event.num > 1) player.draw(2);
                                    if (event.num > 2) player.addTempSkills(['minijianxiong', 'minixingshang'], { player: 'phaseBegin' });
                                },
                            },
                            minifujian: {
                                audio: 'xinfu_fujian',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards('h');
                                    });
                                },
                                direct: true,
                                locked: true,
                                content() {
                                    var target = game.filterPlayer(function (target) {
                                        return player != target && target.countCards('h');
                                    }).randomGet();
                                    var cards = target.getCards('h').randomGets(1);
                                    player.logSkill('minifujian', target);
                                    var content = [get.translation(target) + '的一张手牌', cards];
                                    game.log(player, '观看了', target, '的一张手牌');
                                    player.chooseControl('ok').set('dialog', content);
                                },
                            },
                            minijiezi: {
                                audio: 'jiezi',
                                trigger: { global: ['phaseDrawSkipped', 'phaseDrawCancelled'] },
                                filter(event, player) {
                                    return event.player != player && player.countMark('minijiezi_silent') < 2;
                                },
                                forced: true,
                                logTarget: 'player',
                                content() {
                                    player.addTempSkill('minijiezi_silent', 'roundStart');
                                    player.addMark('minijiezi_silent', 1, false);
                                    player.draw(2);
                                },
                                subSkill: { silent: { onremove: true, charlotte: true } },
                            },
                            miniyizhong: {
                                audio: 'yizhong',
                                trigger: { target: 'shaBefore' },
                                filter(event, player) {
                                    if (!player.hasEmptySlot(2)) return false;
                                    return event.card.name == 'sha' && get.suit(event.card) == 'club';
                                },
                                forced: true,
                                content() {
                                    trigger.cancel();
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (player == target && get.subtype(card) == 'equip2') {
                                                if (get.equipValue(card) <= 5.5) return 0;
                                            }
                                            if (!target.hasEmptySlot(2)) return;
                                            if (card.name == 'sha' && get.suit(card) == 'club') return 'zerotarget';
                                        },
                                    },
                                },
                            },
                            miniqiangxi: {
                                group: 'miniqiangxi_qiangxi',
                                audio: 'qiangxi',
                                trigger: { global: 'damageBegin2' },
                                filter(event, player) {
                                    return event.player != player && player.countCards('he', { type: 'equip' }) > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard('he', get.prompt('miniqiangxi', trigger.player), '弃置一张装备牌并令此伤害+1', function (card) {
                                        return get.type(card) == 'equip';
                                    }).set('goon', get.damageEffect(trigger.player, player, player) > 0).set('ai', function (card) {
                                        if (_status.event.goon) return 12 - get.value(card);
                                        return 0;
                                    }).logSkill = ['miniqiangxi', trigger.player];
                                    'step 1'
                                    if (result.bool) trigger.num++;
                                },
                                ai: { expose: 0.25 },
                                subSkill: {
                                    qiangxi: {
                                        audio: 'qiangxi',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            return game.hasPlayer(function (target) {
                                                return player.inRange(target) && !target.hasSkill('miniqiangxi_off');
                                            });
                                        },
                                        filterTarget(card, player, target) {
                                            if (player == target) return false;
                                            if (target.hasSkill('miniqiangxi_off')) return false;
                                            return player.inRange(target);
                                        },
                                        prompt: '失去1点体力并摸一张牌，对一名其他角色造成1点伤害',
                                        content() {
                                            'step 0'
                                            player.loseHp();
                                            player.draw();
                                            'step 1'
                                            target.addTempSkill('miniqiangxi_off');
                                            target.damage();
                                        },
                                        ai: {
                                            order: 8.5,
                                            result: {
                                                target(player, target) {
                                                    //主公内奸矜持，其他身份当疯狗
                                                    var bool = (lib.translate[player.identity] == '主' || lib.translate[player.identity] == '内' || (get.mode() == 'identity' && player.hasSkill('olzaowang2') && lib.translate[player.identity] != 'nei'));
                                                    if (bool && target.hp - player.hp > 1) return 0;
                                                    if (!bool && player.hp < 2 && !player.countCards('hs', { name: ['tao', 'jiu'] })) return 0;
                                                    return -1;
                                                },
                                            },
                                        },
                                    },
                                    off: { charlotte: true },
                                },
                            },
                            miniluoshen: {
                                audio: 'reluoshen',
                                audioname2: {
                                    Mmiao_zhenji: 'minimiaoluoshen',
                                    wechat_zhenji: 'luoshen',
                                },
                                trigger: { player: 'phaseZhunbeiBegin' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    var next = player.judge(function (card) {
                                        if (get.color(card) == 'black') return 1;
                                        return -1;
                                    });
                                    next.set('callback', function () {
                                        if (get.position(card, true) == 'o') {
                                            let next = player.gain(card, 'gain2');
                                            if (event.getParent(2).name == 'minireluoshen') next.gaintag = ['minireluoshen'];
                                        }
                                    });
                                    'step 1'
                                    if (result.judge > 0) player.chooseBool('是否再次发动【洛神】？').set('frequentSkill', event.name);
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) event.goto(0);
                                },
                            },
                            minireluoshen: {
                                inherit: 'miniluoshen',
                                trigger: {
                                    player: ['phaseZhunbeiBegin', 'loseAfter'],
                                    global: ['loseAsyncAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    if (event.name == 'phaseZhunbei') return true;
                                    return player.getRoundHistory('lose', evt => {
                                        if (!evt.cards.some(card => get.color(card) == 'red')) return false;
                                        return evt.gaintag_map && Object.keys(evt.gaintag_map).some(i => evt.gaintag_map[i].includes('minireluoshen'));
                                    }).indexOf(event) == 0;
                                },
                            },
                            miniqiaobian: {
                                audio: 'qiaobian',
                                trigger: { player: ['phaseJudgeBefore', 'phaseDrawBefore', 'phaseUseBefore', 'phaseDiscardBefore', 'phaseJieshuBegin'] },
                                filter(event, player) {
                                    if (event.name == 'phaseJieshu') return player.getHistory('skipped').length >= 3;
                                    return player.countCards('h') > 0;
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    if (trigger.name == 'phaseJieshu') {
                                        player.logSkill('miniqiaobian');
                                        player.draw(2);
                                        event.finish();
                                        return;
                                    }
                                    var check, str = '弃置一张手牌并跳过';
                                    str += ['判定', '摸牌', '出牌', '弃牌'][lib.skill.miniqiaobian.trigger.player.indexOf(event.triggername)];
                                    str += '阶段';
                                    if (trigger.name == 'phaseDraw') str += '，然后可以获得至多两名角色各一张手牌';
                                    if (trigger.name == 'phaseUse') str += '，然后可以移动场上的一张牌';
                                    switch (trigger.name) {
                                        case 'phaseJudge':
                                            var list = player.getHistory('skipped'), num = list.length + 1;
                                            if (player.countCards('j')) check = true;
                                            if (num >= 3) check = false;
                                            else {
                                                if (player.countCards('h') > 1) {
                                                    if (!list.includes('phaseDraw')) {
                                                        var check1 = function () {
                                                            var i, num = 0, num2 = 0, players = game.filterPlayer();
                                                            for (i = 0; i < players.length; i++) {
                                                                if (player != players[i] && players[i].countCards('h')) {
                                                                    var att = get.attitude(player, players[i]);
                                                                    if (att <= 0) num++;
                                                                    if (att < 0) num2++;
                                                                }
                                                            }
                                                            return num >= 2 && num2 > 0;
                                                        };
                                                        if (check1()) num++;
                                                    }
                                                    if (!list.includes('phaseUse')) {
                                                        var check;
                                                        if (!player.canMoveCard(true)) check = false;
                                                        else {
                                                            check = game.hasPlayer(function (current) {
                                                                return get.attitude(player, current) > 0 && current.countCards('j');
                                                            });
                                                            if (!check) {
                                                                if (player.countCards('h') > player.hp + 1) check = false;
                                                                else if (player.countCards('h', { name: ['wuzhong'] })) check = false;
                                                                else check = true;
                                                            }
                                                        }
                                                        if (check) num++;
                                                    }
                                                    if (num == 2 && !list.includes('phaseDiscard')) num++;
                                                    if (num == 3) check = true;
                                                }
                                            }
                                            break;
                                        case 'phaseDraw':
                                            var i, num = 0, num2 = 0, players = game.filterPlayer();
                                            for (i = 0; i < players.length; i++) {
                                                if (player != players[i] && players[i].countCards('h')) {
                                                    var att = get.attitude(player, players[i]);
                                                    if (att <= 0) {
                                                        num++;
                                                    }
                                                    if (att < 0) {
                                                        num2++;
                                                    }
                                                }
                                            }
                                            check = (num >= 2 && num2 > 0);
                                            break;
                                        case 'phaseUse':
                                            if (!player.canMoveCard(true)) {
                                                check = false;
                                            }
                                            else {
                                                check = game.hasPlayer(function (current) {
                                                    return get.attitude(player, current) > 0 && current.countCards('j');
                                                });
                                                if (!check) {
                                                    if (player.countCards('h') > player.hp + 1) {
                                                        check = false;
                                                    }
                                                    else if (player.countCards('h', { name: ['wuzhong'] })) {
                                                        check = false;
                                                    }
                                                    else {
                                                        check = true;
                                                    }
                                                }
                                            }
                                            break;
                                        case 'phaseDiscard':
                                            check = (player.needsToDiscard() || player.getHistory('skipped').length == 2);
                                            break;
                                    }
                                    player.chooseToDiscard(get.prompt('miniqiaobian'), str, lib.filter.cardDiscardable).set('ai', card => {
                                        if (!_status.event.check) return -1;
                                        return 7 - get.value(card);
                                    }).set('check', check).set('logSkill', 'miniqiaobian').setHiddenSkill('miniqiaobian');
                                    'step 1'
                                    if (result.bool) {
                                        trigger.cancel();
                                        game.log(player, '跳过了', '#y' + ['判定', '摸牌', '出牌', '弃牌'][lib.skill.miniqiaobian.trigger.player.indexOf(event.triggername)] + '阶段');
                                        if (trigger.name == 'phaseUse') {
                                            if (player.canMoveCard()) player.moveCard();
                                            event.finish();
                                        }
                                        else if (trigger.name == 'phaseDraw') {
                                            player.chooseTarget([1, 2], '获得至多两名角色各一张手牌', function (card, player, target) {
                                                return target != player && target.countCards('h');
                                            }).set('ai', function (target) {
                                                return 1 - get.attitude(_status.event.player, target);
                                            });
                                        }
                                        else event.finish();
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        result.targets.sortBySeat();
                                        player.line(result.targets, 'green');
                                        event.targets = result.targets;
                                        if (!event.targets.length) event.finish();
                                    }
                                    else event.finish();
                                    'step 3'
                                    player.gainMultiple(event.targets);
                                    'step 4'
                                    game.delay();
                                },
                                ai: { threaten: 3 },
                            },
                            minifangzhu: {
                                audio: 'fangzhu',
                                trigger: { player: 'damageEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minifangzhu'), '令一名其他角色将武将牌翻面并摸一张牌', lib.filter.notMe).ai = function (target) {
                                        if (target.hasSkillTag('noturn')) return 0;
                                        var player = _status.event.player, att = get.attitude(player, target);
                                        if (att < 0 && target.isTurnedOver()) return 0;
                                        if (att > 2 && target.isTurnedOver()) return att * 10;
                                        return -att;
                                    }
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minifangzhu', result.targets[0]);
                                        result.targets[0].turnOver();
                                        result.targets[0].draw();
                                    }
                                    else event.finish();
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, 'damage')) {
                                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                if (target.hp <= 1) return;
                                                if (!target.hasFriend()) return;
                                                var hastarget = false;
                                                var turnfriend = false;
                                                var players = game.filterPlayer();
                                                for (var i = 0; i < players.length; i++) {
                                                    if (get.attitude(target, players[i]) < 0 && !players[i].isTurnedOver()) {
                                                        hastarget = true;
                                                    }
                                                    if (get.attitude(target, players[i]) > 0 && players[i].isTurnedOver()) {
                                                        hastarget = true;
                                                        turnfriend = true;
                                                    }
                                                }
                                                if (get.attitude(player, target) > 0 && !hastarget) return;
                                                if (turnfriend || target.hp == target.maxHp) return [0.5, 1];
                                                if (target.hp > 1) return [1, 0.5];
                                            }
                                        }
                                    }
                                },
                            },
                            minikangkai: {
                                audio: 'kaikang',
                                trigger: { global: 'useCardToTargeted' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && get.distance(player, event.target) <= 1;
                                },
                                usable: 2,
                                forced: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    if (trigger.target != player) {
                                        player.chooseCard('he', '慷忾：是否交给' + get.translation(trigger.target) + '一张牌？').set('ai', function (card) {
                                            if (get.position(card) == 'e') return -1;
                                            if (card.name == 'shan' && get.attitude(player, trigger.target) > 0) return 1;
                                            if (get.type(card) == 'equip' && get.attitude(player, trigger.target) > 0) return 0.5;
                                            if (card.name == 'du' && get.attitude(player, trigger.target) < 0) return 5;
                                            return 0;
                                        });
                                    }
                                    else event.finish();
                                    'step 1'
                                    if (result.bool) {
                                        trigger.target.gain(result.cards, player, 'give');
                                        game.delayx();
                                        event.card = result.cards[0];
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (trigger.target.getCards('h').includes(card) && get.type(card) == 'equip') trigger.target.chooseUseTarget(card);
                                },
                            },
                            minishangshi: {
                                audio: 'shangshi',
                                audioname2: { Mmiao_zhangchunhua: 'minimiaoshangshi' },
                                trigger: {
                                    player: ['loseAfter', 'changeHp', 'gainMaxHpAfter', 'loseMaxHpAfter', 'enterGame'],
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'phaseBefore'],
                                },
                                filter(event, player) {
                                    return player.countCards('h') < Math.max(player.getDamagedHp(), 1) && (event.name != 'phase' || game.phaseNumber == 0);
                                },
                                prompt2(event, player) {
                                    return '将手牌摸至' + get.cnNumber(Math.max(player.getDamagedHp(), 1)) + '张';
                                },
                                frequent: true,
                                content() {
                                    player.draw(Math.max(player.getDamagedHp(), 1) - player.countCards('h'));
                                },
                                ai: {
                                    noh: true,
                                    skillTagFilter(player, tag) {
                                        if (tag == 'noh' && Math.max(player.getDamagedHp(), 1) < player.countCards('h')) return false;
                                    },
                                },
                            },
                            minijueqing: {
                                audio: 'jueqing',
                                trigger: { source: 'damageBefore' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseBool(get.prompt('minijueqing'), '失去1点体力，令即将对其造成的伤害增加1点').set('choice', player.hp > 1 && trigger.player.hp > 1 && get.attitude(player, trigger.player) < 0);
                                    'step 1'
                                    if (result.bool) {
                                        event.logged = true;
                                        player.logSkill('minijueqing');
                                        player.loseHp();
                                        trigger.num++;
                                    }
                                    'step 2'
                                    player.chooseBool(get.prompt('minijueqing'), '防止此伤害，改为令' + get.translation(trigger.player) + '失去' + trigger.num + '点体力');
                                    'step 3'
                                    if (result.bool) {
                                        if (!event.logged) player.logSkill('minijueqing');
                                        trigger.cancel();
                                        trigger.player.loseHp(trigger.num);
                                    }
                                },
                            },
                            minireshangshi: {
                                inherit: 'minishangshi',
                                group: 'minireshangshi_zhiheng',
                                subSkill: {
                                    zhiheng: {
                                        audio: 'shangshi',
                                        trigger: { player: 'logSkill' },
                                        filter(event, player) {
                                            return event.skill == 'minireshangshi' && player.countDiscardableCards(player, 'h');
                                        },
                                        direct: true,
                                        usable: 1,
                                        async content(event, trigger, player) {
                                            const { result: { bool, cards } } = await player.chooseCard(get.prompt('minireshangshi'), [1, Infinity], (card, player) => {
                                                return lib.filter.cardDiscardable(card, player);
                                            }).set('prompt2', '弃置任意张手牌，若你以此法弃置了所有手牌，则你于下个回合的摸牌阶段额外摸一张牌').set('ai', lib.skill.rezhiheng.check);
                                            if (!bool) {
                                                player.storage.counttrigger.minireshangshi_zhiheng--;
                                                return;
                                            }
                                            player.logSkill('minireshangshi_zhiheng');
                                            const cardx = player.getCards('h');
                                            await player.discard(cards);
                                            if (!cards.some(card => !cardx.includes(card)) && !cardx.some(card => !cards.includes(card))) {
                                                player.addTempSkill('minireshangshi_effect', { player: 'phaseAfter' });
                                                player.addMark('minireshangshi_effect', 1, false);
                                            }
                                        },
                                    },
                                    effect: {
                                        inherit: 'dcduliang2',
                                        content() {
                                            trigger.num += player.countMark('minireshangshi_effect');
                                        },
                                    },
                                },
                            },
                            minijushou: {
                                audio: 'xinjushou',
                                trigger: { player: 'phaseJieshuBegin' },
                                content() {
                                    'step 0'
                                    player.turnOver();
                                    player.draw(4);
                                    'step 1'
                                    player.chooseToUse(function (card) {
                                        if (!lib.filter.cardEnabled(card, _status.event.player, _status.event)) return false;
                                        return get.type(card) == 'equip';
                                    }, '据守：是否使用一张装备牌？');
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (card.name == 'guiyoujie') return [0, 1];
                                        },
                                    },
                                },
                            },
                            minichenqing: {
                                audio: 'chenqing',
                                trigger: { global: 'dying' },
                                filter(event, player) {
                                    return event.player.hp <= 0 && !player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'minichenqing';
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minichenqing'), function (card, player, target) {
                                        return target != _status.event.getTrigger().player;
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        var trigger = _status.event.getTrigger();
                                        if (get.attitude(player, trigger.player) > 0) {
                                            var att1 = get.attitude(target, player);
                                            var att2 = get.attitude(target, trigger.player);
                                            var att3 = get.attitude(player, target);
                                            if (att3 < 0) return 0;
                                            return att1 / 2 + att2 + att3;
                                        }
                                        else return 0;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minichenqing', target);
                                        target.draw(5);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var target = event.target;
                                    var tosave = trigger.player;
                                    var att = get.attitude(target, tosave);
                                    var hastao = target.countCards('h', 'tao');
                                    target.chooseToDiscard(4, true, 'he').set('ai', function (card) {
                                        var hastao = _status.event.hastao;
                                        var att = _status.event.att;
                                        if (!hastao && att > 0) {
                                            var suit = get.suit(card);
                                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                                if (get.suit(ui.selected.cards[i]) == suit) {
                                                    return -4 - get.value(card);
                                                }
                                            }
                                        }
                                        if (att < 0 && ui.selected.cards.length == 3) {
                                            var suit = get.suit(card);
                                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                                if (get.suit(ui.selected.cards[i]) == suit) {
                                                    return -get.value(card);
                                                }
                                            }
                                            return -10 - get.value(card);
                                        }
                                        return -get.value(card);
                                    }).set('hastao', hastao).set('att', att);
                                    'step 3'
                                    if (result.cards && result.cards.length == 4) {
                                        var suits = [];
                                        for (var i = 0; i < result.cards.length; i++) suits.add(get.suit(result.cards[i]));
                                        if (suits.length == 4 && game.checkMod({ name: 'tao', isCard: true }, player, trigger.player, 'unchanged', 'cardSavable', player)) target.useCard({ name: 'tao', isCard: true }, trigger.player);
                                    }
                                },
                                ai: { expose: 0.2 },
                            },
                            minituntian: {
                                audio: 'tuntian',
                                subSkill: {
                                    tuntian: {
                                        audio: 'tuntian',
                                        inherit: 'tuntian',
                                    },
                                },
                                group: ['minituntian_tuntian', 'tuntian_dist'],
                                trigger: { player: 'phaseJieshuBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard('he', get.prompt('minituntian'), '弃置一张牌并进行〖屯田〗判定').set('ai', function (card) {
                                        var player = _status.event.player;
                                        return 7 - get.value(card, player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minituntian');
                                        var next = game.createEvent('minituntian');
                                        next.player = player;
                                        next.setContent(lib.skill.tuntian.content);
                                    }
                                },
                            },
                            minijiushi: {
                                audio: 'jiushi1',
                                group: ['minijiushi1', 'minijiushi2', 'minijiushi3', 'minijiushi_gain'],
                                subfrequent: ['gain'],
                                subSkill: {
                                    gain: {
                                        audio: 'jiushi1',
                                        trigger: { player: 'turnOverAfter' },
                                        frequent: true,
                                        prompt: '是否发动【酒诗】，获得牌堆中的一张锦囊牌？',
                                        content() {
                                            var card = get.cardPile2(function (card) {
                                                return get.type2(card) == 'trick';
                                            });
                                            if (card) player.gain(card, 'gain2', 'log');
                                        },
                                    },
                                },
                            },
                            minijiushi1: {
                                hiddenCard(player, name) {
                                    if (name == 'jiu') return !player.isTurnedOver();
                                    return false;
                                },
                                audio: 'jiushi1',
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    if (player.classList.contains('turnedover')) return false;
                                    return event.filterCard({ name: 'jiu', isCard: true }, player, event);
                                },
                                content() {
                                    if (_status.event.getParent(2).type == 'dying') {
                                        event.dying = player;
                                        event.type = 'dying';
                                    }
                                    player.turnOver();
                                    player.useCard({ name: 'jiu', isCard: true }, player);
                                },
                                ai: {
                                    order: 5,
                                    result: {
                                        player(player) {
                                            if (_status.event.parent.name == 'phaseUse') {
                                                if (player.countCards('h', 'jiu') > 0) return 0;
                                                if (player.getEquip('zhuge') && player.countCards('h', 'sha') > 1) return 0;
                                                if (!player.countCards('h', 'sha')) return 0;
                                                var targets = [];
                                                var target;
                                                var players = game.filterPlayer();
                                                for (var i = 0; i < players.length; i++) {
                                                    if (get.attitude(player, players[i]) < 0) {
                                                        if (player.canUse('sha', players[i], true, true)) {
                                                            targets.push(players[i]);
                                                        }
                                                    }
                                                }
                                                if (targets.length) {
                                                    target = targets[0];
                                                }
                                                else {
                                                    return 0;
                                                }
                                                var num = get.effect(target, { name: 'sha' }, player, player);
                                                for (var i = 1; i < targets.length; i++) {
                                                    var num2 = get.effect(targets[i], { name: 'sha' }, player, player);
                                                    if (num2 > num) {
                                                        target = targets[i];
                                                        num = num2;
                                                    }
                                                }
                                                if (num <= 0) return 0;
                                                var e2 = target.getEquips(2);
                                                if (e2.length) {
                                                    if (e2.some(i => i.name == 'tengjia')) {
                                                        if (!player.countCards('h', { name: 'sha', nature: 'fire' }) && !player.getEquip('zhuque')) return 0;
                                                    }
                                                    if (e2.some(i => i.name == 'renwang')) {
                                                        if (!player.countCards('h', { name: 'sha', color: 'red' })) return 0;
                                                    }
                                                    if (e2.some(i => i.name == 'baiyin')) return 0;
                                                }
                                                if (player.getEquip('guanshi') && player.countCards('he') > 2) return 1;
                                                return target.countCards('h') > 3 ? 0 : 1;
                                            }
                                            if (player == _status.event.dying || player.isTurnedOver()) return 3;
                                        }
                                    },
                                    effect: {
                                        target(card, player, target) {
                                            if (card.name == 'guiyoujie') return [0, 0.5];
                                            if (target.isTurnedOver()) {
                                                if (get.tag(card, 'damage')) {
                                                    if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                    if (target.hp == 1) return;
                                                    return [1, target.countCards('h') / 2];
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            minijiushi2: {
                                trigger: { player: 'damageBegin3' },
                                silent: true,
                                firstDo: true,
                                filter(event, player) {
                                    return player.classList.contains('turnedover');
                                },
                                content() {
                                    trigger.minijiushi = true;
                                },
                            },
                            minijiushi3: {
                                audio: 'jiushi1',
                                trigger: { player: 'damageEnd' },
                                check(event, player) {
                                    return player.isTurnedOver();
                                },
                                filter(event, player) {
                                    return event.minijiushi;
                                },
                                prompt: '是否发动【酒诗】，将武将牌翻面？',
                                content() {
                                    delete trigger.minijiushi;
                                    player.turnOver();
                                },
                            },
                            miniluoying: {
                                mod: {
                                    ignoredHandcard(card, player) {
                                        if (get.suit(card) == 'club') return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && get.suit(card) == 'club') return false;
                                    },
                                },
                                audio: 'luoying_discard',
                                group: ['miniluoying_discard', 'miniluoying_judge'],
                                subfrequent: ['judge'],
                                subSkill: {
                                    discard: {
                                        trigger: { global: 'loseAfter' },
                                        filter(event, player) {
                                            if (event.type != 'discard') return false;
                                            if (event.player == player) return false;
                                            for (var i = 0; i < event.cards2.length; i++) {
                                                if (get.suit(event.cards2[i], event.player) == 'club' && get.position(event.cards2[i], true) == 'd') return true;
                                            }
                                            return false;
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            if (trigger.delay == false) game.delay();
                                            'step 1'
                                            var cards = [];
                                            for (var i = 0; i < trigger.cards2.length; i++) {
                                                if (get.suit(trigger.cards2[i], trigger.player) == 'club' && get.position(trigger.cards2[i], true) == 'd') {
                                                    cards.push(trigger.cards2[i]);
                                                }
                                            }
                                            if (cards.length) {
                                                player.chooseButton(['落英：选择要获得的牌', cards], [1, cards.length]).set('ai', function (button) {
                                                    return get.value(button.link, _status.event.player, 'raw');
                                                });
                                            }
                                            else event.finish();
                                            'step 2'
                                            if (result.bool) {
                                                player.logSkill('miniluoying');
                                                player.gain(result.links, 'gain2');
                                            }
                                        },
                                    },
                                    judge: {
                                        trigger: { global: 'cardsDiscardAfter' },
                                        filter(event, player) {
                                            var evt = event.getParent().relatedEvent;
                                            if (!evt || evt.name != 'judge') return;
                                            if (evt.player == player) return false;
                                            if (get.position(event.cards[0], true) != 'd') return false;
                                            return (get.suit(event.cards[0]) == 'club');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseButton(['落英：选择要获得的牌', trigger.cards], [1, trigger.cards.length]).set('ai', function (button) {
                                                return get.value(button.link, _status.event.player, 'raw');
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('miniluoying');
                                                player.gain(result.links, 'gain2');
                                            }
                                        },
                                    },
                                },
                            },
                            miniquhu: {
                                enable: 'phaseUse',
                                audio: 'quhu',
                                filter(event, player) {
                                    return (!player.hasSkill('miniquhu0') && player.countCards('he') > 1) || !player.hasSkill('miniquhu1');
                                },
                                usable: 1,//纪念传奇各限一次荀彧
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [
                                            '弃置两张牌，对一名其他角色造成1点伤害',
                                            '对自己造成1点伤害，然后摸一张牌',
                                        ];
                                        var choiceList = ui.create.dialog('驱虎：请选择一项', 'forcebutton', 'hidden');
                                        for (var i = 0; i < list.length; i++) {
                                            var str = '<div class="popup text" style="width:calc(100% - 10px);display:inline-block">';
                                            var bool = lib.skill.miniquhu.chooseButton.filter({ link: i }, player);
                                            if (!bool) str += '<div style="opacity:0.5">';
                                            str += list[i];
                                            if (!bool) str += '</div>';
                                            str += '</div>';
                                            var next = choiceList.add(str);
                                            next.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.button);
                                            next.firstChild.link = i;
                                            //for(var j in lib.element.button){
                                            //next[j]=lib.element.button[j];
                                            //}
                                            Object.setPrototypeOf(next, lib.element.Button.prototype);
                                            choiceList.buttons.add(next.firstChild);
                                        }
                                        return choiceList;
                                    },
                                    filter(button, player) {
                                        return !player.hasSkill('miniquhu' + button.link);
                                    },
                                    check(button) {
                                        var player = _status.event.player;
                                        if (game.hasPlayer([
                                            function (target) {
                                                return get.damageEffect(target, player, player) > 0;
                                            },
                                            function (target) {
                                                if (!target.hasSkill('jieming') && !target.hasSkill('minijieming')) return 0;
                                                return target.hp > 2 && game.hasPlayer(function (current) {
                                                    return get.attitude(current, player) > 0 && current.countCards('h') < current.maxHp - 1;
                                                });
                                            },
                                        ][button.link])) return 1 + button.link;
                                        return 0;
                                    },
                                    backup(links) {
                                        return {
                                            audio: 'quhu',
                                            filterTarget: [
                                                function (card, player, target) {
                                                    return target != player;
                                                },
                                                function (card, player, target) {
                                                    return target == player;
                                                },
                                            ][links[0]],
                                            selectTarget: [1, -1][links[0]],
                                            index: links[0],
                                            filterCard: [
                                                function (card, player) {
                                                    return true;
                                                },
                                                function (card, player) {
                                                    return false;
                                                },
                                            ][links[0]],
                                            selectCard: [2, -1][links[0]],
                                            check(card) {
                                                return 7 - get.value(card);
                                            },
                                            position: 'he',
                                            content() {
                                                player.addTempSkill('miniquhu' + lib.skill[event.name].index, 'phaseUseAfter')
                                                target.damage('nocard');
                                                if (target == player) player.draw();
                                            },
                                            ai: {
                                                order: 7,
                                                result: {
                                                    target(player, target) {
                                                        return get.damageEffect(target, player, player) * get.sgn(get.attitude(player, target));
                                                    },
                                                },
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        if (links[0] == 0) return '弃置两张牌，对一名其他角色造成1点伤害';
                                        return '对自己造成1点伤害，然后摸一张牌';
                                    },
                                },
                                ai: {
                                    order: 7,
                                    result: { player: 1 },
                                },
                                subSkill: { backup: {} },
                            },
                            miniquhu0: {},
                            miniquhu1: {},
                            minijieming: {
                                audio: 'jieming',
                                trigger: { player: 'damageEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    player.chooseTarget(get.prompt2('minijieming')).set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (target.countCards('h') >= Math.min(target.maxHp, 4)) return -1;
                                        if (target.hasSkillTag('nogain')) att /= 6;
                                        if (att > 0) return Math.min(4, target.maxHp) - target.countCards('h');
                                        return -1;
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minijieming', target);
                                        target.drawTo(Math.min(4, target.maxHp));
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (event.count > 0 && player.hasSkill('minijieming')) event.goto(1);
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'damage') && target.hp > 1) {
                                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                var max = 0;
                                                var players = game.filterPlayer();
                                                for (var i = 0; i < players.length; i++) {
                                                    if (get.attitude(target, players[i]) > 0) {
                                                        max = Math.max(Math.min(4, players[i].hp) - players[i].countCards('h'), max);
                                                    }
                                                }
                                                switch (max) {
                                                    case 0: return 2;
                                                    case 1: return 1.5;
                                                    case 2: return [1, 2];
                                                    default: return [0, max];
                                                }
                                            }
                                            if ((card.name == 'tao' || card.name == 'caoyao') &&
                                                target.hp > 1 && target.countCards('h') <= target.hp) return [0, 0];
                                        },
                                    },
                                },
                            },
                            minimingjian: {
                                audio: 'mingjian',
                                enable: 'phaseUse',
                                usable: 1,
                                filterTarget: lib.filter.notMe,
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterCard: true,
                                selectCard: [1, Infinity],
                                check: () => 1,
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    target.gain(cards, player, 'giveAuto');
                                    target.addTempSkill('mingjian2', { player: 'phaseAfter' });
                                    target.storage.mingjian2++;
                                    target.updateMarks('mingjian2');
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            if (target.hasSkillTag('nogain')) return 0;
                                            if (player.countCards('h') == player.countCards('h', 'du')) return -1;
                                            if (target.hasJudge('lebu')) return 0;
                                            if (get.attitude(player, target) > 3) {
                                                var basis = get.threaten(target);
                                                if (player == get.zhu(player) && player.hp <= 2 && player.countCards('h', 'shan') && !game.hasPlayer(function (current) {
                                                    return get.attitude(current, player) > 3 && current.countCards('h', 'tao') > 0;
                                                })) return 0;
                                                if (target.countCards('h') + player.countCards('h') > target.hp + 2) return basis * 0.8;
                                                return basis;
                                            }
                                            return 0;
                                        },
                                    },
                                },
                            },
                            minixingshuai: {
                                unique: true,
                                audio: 'xingshuai',
                                trigger: { player: 'dying' },
                                zhuSkill: true,
                                filter(event, player) {
                                    if (player.hp > 0) return false;
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.group == 'wei';
                                    });
                                },
                                mark: true,
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'thunder',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minixingshuai');
                                    var targets = game.filterPlayer();
                                    targets.remove(player);
                                    event.targets = targets;
                                    event.damages = [];
                                    'step 1'
                                    if (event.targets.length) {
                                        var current = event.targets.shift();
                                        if (current.group == 'wei') {
                                            current.chooseBool('是否令' + get.translation(player) + '回复1点体力？').set('ai', function () {
                                                return get.attitude(_status.event.player, _status.event.target) > 2;
                                            }).set('target', player);
                                            event.current = current;
                                        }
                                        else event.redo();
                                    }
                                    else event.goto(3);
                                    'step 2'
                                    if (result.bool) {
                                        event.damages.push(event.current);
                                        event.current.line(player, 'green');
                                        game.log(event.current, '令', player, '回复1点体力');
                                        player.recover();
                                    }
                                    if (event.targets.length) event.goto(1);
                                    'step 3'
                                    if (event.damages.length) {
                                        var next = game.createEvent('minixingshuai_next');
                                        event.next.remove(next);
                                        trigger.after.push(next);
                                        next.targets = event.damages;
                                        next.setContent(function () {
                                            for (var target of targets) {
                                                target.damage();
                                                target.draw();
                                            }
                                        });
                                    }
                                },
                            },
                            minichouce: {
                                audio: 'chouce',
                                trigger: { player: 'damageEnd' },
                                content() {
                                    'step 0'
                                    event.num = trigger.num;
                                    'step 1'
                                    player.judge();
                                    'step 2'
                                    event.color = result.color;
                                    if (event.color == 'black') {
                                        player.chooseTarget('获得一名角色区域内的一张牌', function (card, player, target) {
                                            return target.countCards('hej');
                                        }).set('ai', function (target) {
                                            var player = _status.event.player;
                                            var att = get.attitude(player, target);
                                            if (att < 0) att = -Math.sqrt(-att);
                                            else att = Math.sqrt(att);
                                            return att * lib.card.shunshou.ai.result.target(player, target);
                                        });
                                    }
                                    else {
                                        var next = player.chooseTarget('令一名角色摸一张牌');
                                        if (player.storage.xianfu2 && player.storage.xianfu2.length) {
                                            next.set('prompt2', '（若目标为' + get.translation(player.storage.xianfu2) + '则改为摸两张牌）');
                                        }
                                        next.set('ai', function (target) {
                                            var player = _status.event.player;
                                            var att = get.attitude(player, target) / Math.sqrt(1 + target.countCards('h'));
                                            if (target.hasSkillTag('nogain')) att /= 10;
                                            if (player.storage.xianfu2 && player.storage.xianfu2.includes(target)) return att * 2;
                                            return att;
                                        })
                                    }
                                    'step 3'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'green');
                                        if (event.color == 'black') player.gainPlayerCard(target, 'hej', true);
                                        else {
                                            if (player.storage.xianfu2 && player.storage.xianfu2.includes(target)) {
                                                if (!target.storage.xianfu_mark) target.storage.xianfu_mark = [];
                                                target.storage.xianfu_mark.add(player);
                                                target.storage.xianfu_mark.sortBySeat();
                                                target.markSkill('xianfu_mark');
                                                target.draw(2);
                                            }
                                            else target.draw();
                                        }
                                    }
                                    'step 4'
                                    if (--event.num > 0) player.chooseBool(get.prompt2('minichouce'));
                                    else event.finish();
                                    'step 5'
                                    if (result.bool) {
                                        player.logSkill('minichouce');
                                        event.goto(1);
                                    }
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, 'damage')) {
                                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                if (!target.hasFriend()) return;
                                                if (target.hp >= 4) return [1, get.tag(card, 'damage') * 1.5];
                                                if (target.hp == 3) return [1, get.tag(card, 'damage') * 1];
                                                if (target.hp == 2) return [1, get.tag(card, 'damage') * 0.5];
                                            }
                                        },
                                    },
                                },
                            },
                            minishensu: {
                                audio: 'shensu1',
                                audioname: ['xiahouba'],
                                trigger: { player: ['phaseJudgeBefore', 'phaseUseBefore', 'phaseDiscardBefore'] },
                                direct: true,
                                content() {
                                    'step 0'
                                    var check;
                                    switch (trigger.name) {
                                        case 'phaseJudge': check = player.countCards('h') > 2; break;
                                        case 'phaseUse': check = player.needsToDiscard(); break;
                                        case 'phaseDiscard': check = player.needsToDiscard() || player.isTurnedOver() || (['shensu', 'minishensu'].some(skill => player.hasSkill(skill)) && player.canMoveCard(true, true)); break;
                                    }
                                    var str = ['判定阶段和摸牌', '出牌', '弃牌'][lib.skill.minishensu.trigger.player.indexOf(event.triggername)];
                                    player.chooseTarget(get.prompt('minishensu'), '跳过' + str + '阶段' + (trigger.name == 'phaseDiscard' ? '并翻面' : '') + '，视为对一名其他角色使用一张雷【杀】', function (card, player, target) {
                                        if (player == target) return false;
                                        return player.canUse({ name: 'sha', nature: 'thunder', isCard: true }, target, false);
                                    }).set('check', check).set('ai', function (target) {
                                        if (!_status.event.check) return 0;
                                        return get.effect(target, { name: 'sha', nature: 'thunder', isCard: true }, _status.event.player);
                                    }).setHiddenSkill('minishensu');
                                    'step 1'
                                    if (result.bool) {
                                        trigger.cancel();
                                        if (trigger.name == 'phaseJudge') player.skip('phaseDraw');
                                        player.logSkill('minishensu', result.targets);
                                        if (trigger.name == 'phaseDiscard') player.turnOver();
                                        player.useCard({ name: 'sha', nature: 'thunder', isCard: true }, result.targets[0], false).audio = false;
                                    }
                                },
                            },
                            minishebian: {
                                audio: 'shebian',
                                trigger: { player: 'turnOverEnd' },
                                check(event, player) {
                                    return player.canMoveCard(true, true);
                                },
                                filter(event, player) {
                                    return player.canMoveCard(null, true);
                                },
                                content() {
                                    'step 0'
                                    player.moveCard().nojudge = true;
                                    'step 1'
                                    player.recover();
                                },
                            },
                            minizhongjian: {
                                enable: 'phaseUse',
                                audio: 'zhongjian',
                                usable: 2,
                                filter(event, player) {
                                    if (player.getStat().skill.minizhongjian && !player.hasSkill('recaishi2')) return false;
                                    return game.hasPlayer(function (current) {
                                        return lib.skill.minizhongjian.filterTarget(null, player, current);
                                    });
                                },
                                filterTarget(card, player, target) {
                                    if (!player.storage.rezhongjian2) return true;
                                    return !player.storage.rezhongjian2[0].includes(target) && !player.storage.rezhongjian2[1].includes(target);
                                },
                                content() {
                                    'step 0'
                                    player.chooseControl().set('prompt', '忠鉴：为' + get.translation(target) + '选择获得一项效果').set('choiceList', [
                                        '令其于下回合开始前首次造成伤害后弃置两张牌',
                                        '令其于下回合开始前首次受到伤害后摸两张牌',
                                    ]).set('ai', function () {
                                        return get.attitude(_status.event.player, _status.event.getParent().target) > 0 ? 1 : 0;
                                    });
                                    'step 1'
                                    player.addSkill('rezhongjian2');
                                    //var str=['造成伤害弃牌','受到伤害摸牌'][result.index];
                                    //player.popup(str,['fire','wood'][result.index]);
                                    //game.log(player,'选择了','#y'+str);
                                    player.storage.rezhongjian2[result.index].push(target);
                                    //player.markSkill('rezhongjian2');
                                },
                                ai: {
                                    order: 10,
                                    expose: 0,
                                    result: {
                                        player(player, target) {
                                            if (get.attitude(player, target) == 0) return false;
                                            var sgn = get.sgn((get.realAttitude || get.attitude)(player, target));
                                            if (game.countPlayer(function (current) {
                                                return get.sgn((get.realAttitude || get.attitude)(player, current)) == sgn;
                                            }) <= game.countPlayer(function (current) {
                                                return get.sgn((get.realAttitude || get.attitude)(player, current)) != sgn;
                                            })) return 1;
                                            return 0.9;
                                        },
                                    },
                                },
                            },
                            minicaishi: {
                                audio: 'caishi',
                                trigger: { player: 'phaseDrawEnd' },
                                direct: true,
                                isSame(event) {
                                    var cards = [];
                                    event.player.getHistory('gain', function (evt) {
                                        if (evt.getParent().name == 'draw' && evt.getParent('phaseDraw') == event) cards.addArray(evt.cards);
                                    });
                                    if (!cards.length) return 'nogain';
                                    var list = [];
                                    for (var i = 0; i < cards.length; i++) {
                                        list.add(get.suit(cards[i]));
                                    }
                                    if (list.length == 1) return true;
                                    if (list.length == cards.length) return false;
                                    return 'nogain';
                                },
                                filter(event, player) {
                                    var isSame = lib.skill.minicaishi.isSame(event);
                                    if (isSame == 'nogain') return false;
                                    return (isSame && !player.hasSkill('recaishi2')) || player.isDamaged();
                                },
                                content() {
                                    'step 0'
                                    if (lib.skill.minicaishi.isSame(trigger)) {
                                        if (!player.hasSkill('recaishi2')) {
                                            player.logSkill('minicaishi');
                                            player.addTempSkill('recaishi2');
                                            lib.skill.recaishi2.charlotte = true;
                                            game.log(player, '修改了技能', '#g【忠鉴】');
                                            event.finish();
                                            return;
                                        }
                                    }
                                    else if (player.isDamaged()) player.chooseToDiscard(get.prompt('minicaishi'), '弃置一张牌并回复1点体力').set('ai', function (card) {
                                        return 7 - get.value(card);
                                    }).logSkill = 'minicaishi';
                                    else event.finish();
                                    'step 1'
                                    if (result.bool) player.recover();
                                },
                            },
                            minijiaozhao: {
                                derivation: ['minijiaozhao_1', 'minijiaozhao_2'],
                                audio: 'jiaozhao',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    if (!player.hasCard(card => lib.skill.minijiaozhao.filterCard(card, player), 'h')) return false;
                                    var num = player.getStat('skill').minijiaozhao;
                                    return !num || num < player.countMark('minidanxin') + 1;
                                },
                                filterCard(card, player) {
                                    return !player.storage.minijiaozhao2?.[card.cardid];
                                },
                                discard: false,
                                lose: false,
                                delay: false,
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                content() {
                                    'step 0'
                                    player.addTempSkill('minijiaozhao2', 'phaseUseAfter');
                                    player.showCards(cards, get.translation(player) + '发动了【矫诏】');
                                    'step 1'
                                    var list = get.inpileVCardList(info => {
                                        const name = info[2];
                                        if (player.hasMark('minidanxin')) {
                                            const str = ['type', 'name'][player.countMark('minidanxin') - 1];
                                            if (player.storage.minijiaozhao_used?.[str]?.includes([get.type(name), name][player.countMark('minidanxin') - 1])) return false;
                                        }
                                        return get.type(name) === 'basic' || get.type(name) === 'trick';
                                    });
                                    if (!list.length) {
                                        player.popup('杯具');
                                        game.log('但是', player, '已经没有可以声明的牌了！');
                                        event.finish();
                                        return;
                                    }
                                    var str = '###矫诏(' + (player.countMark('minidanxin') + 1) + '级)';
                                    str += '###请选择并声明' + get.translation(cards[0]) + '视为的牌';
                                    if (player.countMark('minidanxin') < 2) str += '，且此牌不能指定你为目标';
                                    player.chooseButton([str, [list, 'vcard']], true).set('ai', function (button) {
                                        var player = _status.event.player;
                                        return player.getUseValue({ name: button.link[2], nature: button.link[3], storage: { minijiaozhao: true } });
                                    });
                                    'step 2'
                                    var card = { name: result.links[0][2], nature: result.links[0][3], storage: { minijiaozhao: true } };
                                    player.storage.minijiaozhao2[cards[0].cardid] = card;
                                    var chosen = card.name, nature = card.nature, tag = 'minijiaozhao2_' + chosen + nature;
                                    player.storage.minijiaozhao2.cardid.add(tag);
                                    player.storage.minijiaozhao_used.type.add(get.type(card));
                                    player.storage.minijiaozhao_used.name.add(chosen);
                                    player.updateMarks('minijiaozhao2');
                                    player.updateMarks('minijiaozhao_used');
                                    if (!lib.skill[tag]) {
                                        game.broadcastAll((tag, nature, chosen) => {
                                            lib.skill[tag] = {};
                                            lib.translate[tag] = "矫诏<br>" + (get.translation(nature) || '') + get.translation(chosen);
                                        }, tag, nature, chosen);
                                    }
                                    player.addGaintag(cards, tag);
                                    player.showCards(game.createCard({
                                        name: chosen,
                                        nature: nature,
                                        suit: cards[0].suit,
                                        number: cards[0].number,
                                    }), get.translation(player) + '声明了' + (get.translation(nature) || '') + '【' + get.translation(chosen) + '】');
                                },
                                ai: {
                                    order: 8,
                                    result: { player: 1 },
                                },
                            },
                            minijiaozhao2: {
                                mod: {
                                    playerEnabled(card, player, target) {
                                        if (target != player || player.countMark('minidanxin') >= 2) return;
                                        if (card.storage?.minijiaozhao2) return false;
                                    },
                                },
                                charlotte: true,
                                init(player, skill) {
                                    if (!player.storage[skill]) player.storage[skill] = { cardid: [] };
                                    if (!player.storage.minijiaozhao_used) player.storage.minijiaozhao_used = { type: [], name: [] };
                                },
                                onremove(player, skill) {
                                    let tags = player.storage[skill].cardid;
                                    delete player.storage[skill];
                                    delete player.storage.minijiaozhao_used;
                                    if (tags?.length) tags.forEach(tag => player.removeGaintag(tag));
                                },
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hasCard(card => lib.skill.minijiaozhao2.filterCard(card, player), 'h');
                                },
                                filterCard(card, player) {
                                    const map = player.storage.minijiaozhao2;
                                    if (!map[card.cardid]) return false;
                                    return player.hasUseTarget(get.autoViewAs(map[card.cardid], [card]), true, true);
                                },
                                filterTarget(cardx, player, target) {
                                    const cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                                    if (!cards.length) return false;
                                    const card = get.autoViewAs(map[cards[0].cardid], cards);
                                    const filterTarget = lib.card[card.name].filterTarget;
                                    return filterTarget && (typeof filterTarget === 'boolean' ? filterTarget : filterTarget.apply(this, arguments));
                                },
                                selectTarget() {
                                    const player = get.player(), cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                                    if (!cards.length) return -1;
                                    const card = get.autoViewAs(map[cards[0].cardid], cards);
                                    let range, select = get.copy(get.info(card).selectTarget);
                                    if (select == undefined) range = [1, 1];
                                    else if (typeof select == 'number') range = [select, select];
                                    else if (get.itemtype(select) == 'select') range = select;
                                    else if (typeof select == 'function') range = select(card, player);
                                    game.checkMod(card, player, range, 'selectTarget', player);
                                    return range;
                                },
                                lose: false,
                                discard: false,
                                delay: false,
                                check(card) {
                                    const player = get.player(), map = player.storage.minijiaozhao2;
                                    return player.getUseValue(get.autoViewAs(map[card.cardid], [card]), true, true);
                                },
                                multiline: true,
                                multitarget: true,
                                prompt: '选择一张“矫诏”牌当作声明的牌使用',
                                content() {
                                    const map = player.storage.minijiaozhao2;
                                    player.useCard(get.autoViewAs(map[cards[0].cardid], cards), targets).set('cards', cards);
                                },
                                ai: {
                                    order: 7.9,
                                    result: {
                                        player(player, target) {
                                            const cards = ui.selected.cards, map = player.storage.minijiaozhao2;
                                            if (cards.length) {
                                                const card = get.autoViewAs(map[cards[0].cardid], cards);
                                                return get.effect(target, card, player, player);
                                            }
                                            return 1;
                                        },
                                    },
                                },
                            },
                            minidanxin: {
                                audio: 'danxin',
                                trigger: { player: 'damageEnd' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    'step 1'
                                    if (player.countMark('minidanxin') < 2) {
                                        player.addMark('minidanxin', 1, false);
                                        player.popup('矫诏');
                                        game.log(player, '升级了技能', '#g【矫诏】');
                                    }
                                },
                            },
                            miniqingjian: {
                                audio: 'qingjian',
                                trigger: { player: 'gainAfter' },
                                filter(event, player) {
                                    if (event.parent.parent.name == 'phaseDraw') return false;
                                    return event.cards?.length > 0
                                },
                                usable: 1,
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        position: 'he',
                                        filterCard: true,
                                        selectCard: [1, Infinity],
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            if (get.attitude(_status.event.player, _status.currentPhase) < 0 && _status.currentPhase.needsToDiscard() && card.name != 'du') return -1;
                                            for (var i = 0; i < ui.selected.cards.length; i++) {
                                                if (get.type(ui.selected.cards[i]) == get.type(card) || (ui.selected.cards[i].name == 'du' && card.name != 'du')) return -1;
                                            };
                                            if (card.name == 'du') return 20;
                                            return (_status.event.player.countCards('h') - _status.event.player.hp);
                                        },
                                        ai2(target) {
                                            if (get.attitude(_status.event.player, _status.currentPhase) < 0) return -1;
                                            var att = get.attitude(_status.event.player, target);
                                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                                if (target.hasSkillTag('nodu')) return 0;
                                                return 1 - att;
                                            }
                                            if (target.countCards('h') > _status.event.player.countCards('h')) return 0;
                                            return att - 4;
                                        },
                                        prompt: get.prompt2('miniqingjian'),
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0], cards = result.cards;
                                        player.logSkill('miniqingjian', target);
                                        target.gain(cards, player, 'giveAuto');
                                        player.draw();
                                    }
                                    else player.storage.counttrigger.miniqingjian--;
                                },
                                ai: { expose: 0.3 },
                            },
                            minisidi: {
                                audio: 'residi',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.countCards('he', function (card) {
                                        if (_status.connectMode) return true;
                                        return get.type(card) != 'basic';
                                    }) > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCard('he', get.prompt('minisidi'), [1, 2], '将至多两张非基本牌置于武将牌上作为“司”', function (card, player) {
                                        return get.type(card) != 'basic';
                                    }).set('ai', function (card) {
                                        if (get.position(card) == 'e') return 5 + player.hp - get.value(card);
                                        return 7 - get.value(card);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minisidi');
                                        player.addToExpansion(result.cards, 'give', player).gaintag.add('minisidi');
                                    }
                                },
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                group: 'minisidi_push',
                                ai: { notemp: true },
                                subSkill: {
                                    push: {
                                        trigger: { global: 'phaseUseBegin' },
                                        direct: true,
                                        filter(event, player) {
                                            return event.player != player && player.getExpansions('minisidi').length > 0;
                                        },
                                        content() {
                                            'step 0'
                                            player.chooseButton([get.prompt('minisidi', trigger.player), player.getExpansions('minisidi')]).set('ai', function (button) {
                                                var player = _status.event.player;
                                                var target = _status.event.getTrigger().player;
                                                if (get.attitude(player, target) > -1) return 0;
                                                var card = button.link;
                                                var color = get.color(button.link, false);
                                                var eff = target.countCards('h', function (card) {
                                                    return get.color(card, target) == color && target.hasValueTarget(card);
                                                });
                                                if (!target.countCards('h', function (card) {
                                                    return get.color(card, target) == color && get.name(card, target) == 'sha' && target.hasValueTarget(card);
                                                })) eff += 1.5;
                                                if (!target.countCards('h', function (card) {
                                                    return get.color(card, target) == color && get.type2(card, target) == 'trick' && target.hasValueTarget(card);
                                                })) eff += 1.5;
                                                return eff - 1;
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                if (!trigger.residi) trigger.residi = [];
                                                trigger.residi.push(player);
                                                var card = result.links[0];
                                                var target = trigger.player;
                                                player.logSkill('minisidi', target);
                                                player.loseToDiscardpile(card);
                                                var color = get.color(card, false);
                                                if (!target.storage.residi2) target.storage.residi2 = [];
                                                target.storage.residi2.add(color);
                                                target.addTempSkill('residi2', 'phaseUseAfter');
                                                target.markSkill('residi2');
                                                player.addTempSkill('residi3', 'phaseUseAfter');
                                            }
                                        },
                                    },
                                },
                            },
                            //homo（难视
                            minihomo: {
                                audio: 'huomo',
                                enable: 'chooseToUse',
                                hiddenCard(player, name) {
                                    return get.type(name) == 'basic' && player.hasCard(function (card) {
                                        return get.color(card) == 'black' && get.type(card) != 'basic';
                                    }, 'he');
                                },
                                filter(event, player) {
                                    for (var i of lib.inpile) {
                                        if (get.type(i) != 'basic') continue;
                                        if (event.filterCard({ name: i }, player, event)) {
                                            return player.hasCard(function (card) {
                                                return get.color(card) == 'black' && get.type(card) != 'basic';
                                            }, 'he');
                                        }
                                    }
                                    return false;
                                },
                                usable: 2,
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        for (var i of lib.inpile) {
                                            if (get.type(i) != 'basic') continue;
                                            if (event.filterCard({ name: i }, player, event)) {
                                                list.push(['基本', '', i]);
                                                if (i == 'sha') for (var j of lib.inpile_nature) list.push(['基本', '', i, j]);
                                            }
                                        }
                                        return ui.create.dialog('活墨', [list, 'vcard'], 'hidden');
                                    },
                                    check(button) {
                                        var player = _status.event.player;
                                        var card = { name: button.link[2], nature: button.link[3] };
                                        if (game.hasPlayer(function (current) {
                                            return player.canUse(card, current) && get.effect(current, card, player, player) > 0;
                                        })) {
                                            switch (button.link[2]) {
                                                case 'tao': return 5;
                                                case 'jiu': return 3.01;
                                                case 'shan': return 3.01;
                                                case 'sha':
                                                    if (button.link[3] == 'fire') return 2.95;
                                                    else if (button.link[3] == 'fire') return 2.92;
                                                    else return 2.9;
                                            }
                                        }
                                        return 0;
                                    },
                                    backup(links, player) {
                                        return {
                                            check(card) {
                                                return 1 / Math.max(0.1, get.value(card));
                                            },
                                            filterCard(card) {
                                                return get.type(card) != 'basic' && get.color(card) == 'black';
                                            },
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                                suit: 'none',
                                                number: null,
                                                isCard: true,
                                            },
                                            position: 'he',
                                            popname: true,
                                            ignoreMod: true,
                                            precontent() {
                                                'step 0'
                                                player.logSkill('minihomo');
                                                var card = event.result.cards[0];
                                                event.card = card;
                                                player.$throw(card, 1000);
                                                game.log(player, '将', card, '置于牌堆顶');
                                                event.result.card = { name: event.result.card.name, nature: event.result.card.nature };
                                                event.result.cards = [];
                                                player.lose(card, ui.cardPile, 'visible', 'insert');
                                                'step 1'
                                                game.delay();
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        return '将一张黑色非基本牌置于牌堆顶并视为使用一张' + get.translation(links[0][3] || '') + get.translation(links[0][2]);
                                    }
                                },
                                ai: {
                                    order() {
                                        var player = _status.event.player;
                                        var event = _status.event;
                                        if (event.filterCard({ name: 'jiu' }, player, event) && get.effect(player, { name: 'jiu' }) > 0) {
                                            return 3.1;
                                        }
                                        return 2.9;
                                    },
                                    respondSha: true,
                                    fireAttack: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (player.hasCard(function (card) {
                                            return get.color(card) == 'black' && get.type(card) != 'basic';
                                        }, 'he')) {
                                            if (tag == 'respondSha' || tag == 'respondShan') {
                                                if (arg != 'use') return false;
                                            }
                                            return true;
                                        }
                                        else return false;
                                    },
                                    result: { player: 1 },
                                },
                            },
                            minizuoding: {
                                audio: 'zuoding',
                                trigger: { global: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (event.getParent().triggeredTargets3.length > 1) return false;
                                    return get.suit(event.card) == 'spade' && _status.currentPhase == event.player && event.targets && event.targets.length && game.countPlayer2(function (current) {
                                        return current.getHistory('damage').length > 0;
                                    }) == 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minizuoding'), '令一名目标角色摸一张牌', function (card, player, target) {
                                        return _status.event.targets.includes(target);
                                    }).set('ai', function (target) {
                                        return get.attitude(_status.event.player, target);
                                    }).set('targets', trigger.targets);
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minizuoding', result.targets);
                                        result.targets[0].draw();
                                        if (result.targets[0] != player) player.addExpose(0.2);
                                    }
                                },
                            },
                            minixunxun: {
                                audio: 'xunxun',
                                inherit: 'xunxun',
                                group: 'minixunxun_biyue',
                                subSkill: {
                                    biyue: {
                                        audio: 'xunxun',
                                        trigger: { player: 'phaseJieshuBegin' },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            var cards = get.bottomCards(2);
                                            if (cards.length) {
                                                player.gain(cards);
                                                player.$draw(cards.length);
                                                game.log(player, '从牌堆底获得了' + get.cnNumber(cards.length) + '张牌');
                                            }
                                        },
                                    },
                                },
                            },
                            minizhengbing: {
                                mod: {
                                    ignoredHandcard(card, player) {
                                        if (card.hasGaintag('minizhengbing')) return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && card.hasGaintag('minizhengbing')) return false;
                                    },
                                },
                                group: 'minizhengbing_mark',
                                audio: 'ext:活动武将/audio/skill:true',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h', function (card) {
                                        return card.hasGaintag('minizhengbing') && player.canRecast(card);
                                    });
                                },
                                filterCard(card, player) {
                                    return card.hasGaintag('minizhengbing') && player.canRecast(card);
                                },
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    'step 0'
                                    player.recast(cards);
                                    'step 1'
                                    if (!player.countCards('h', function (card) {
                                        return card.hasGaintag('minizhengbing');
                                    })) player.draw();
                                },
                                ai: {
                                    order: 10,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        trigger: { player: 'gainBegin' },
                                        filter(event, player) {
                                            return lib.translate[event.getParent(3).name] == '突袭';
                                        },
                                        direct: true,
                                        firstDo: true,
                                        content() {
                                            trigger.gaintag.add('minizhengbing');
                                        },
                                    },
                                },
                            },
                            miniqice: {
                                audio: 'qice',
                                inherit: 'qice',
                                filter(event, player) {
                                    const hs = player.getCards('h');
                                    if (!hs.length) return false;
                                    if (hs.every(card => {
                                        const mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                        return mod2 === false;
                                    })) return false;
                                    return lib.inpile.some(name => {
                                        if (get.type(name) != 'trick') return false;
                                        const card = get.autoViewAs({ name }, hs);
                                        return event.filterCard(card, player, event);
                                    });
                                },
                                get chooseButton() {
                                    let chooseButton = {
                                        filter(button, player) {
                                            const event = get.event().getParent();
                                            return player.hasCard(card => event.filterCard(get.autoViewAs({ name: button.link[2] }, [card]), player, event), 'h');
                                        },
                                        backup(links, player) {
                                            return {
                                                audio: 'qice',
                                                filterCard: true,
                                                selectCard: [1, Infinity],
                                                check(card) {
                                                    if (ui.selected.cards.length) return -1;
                                                    return 7 - get.value(card);
                                                },
                                                complexCard: true,
                                                position: 'h',
                                                popname: true,
                                                viewAs: { name: links[0][2] },
                                            }
                                        },
                                        prompt(links, player) {
                                            return '将任意张手牌当作' + get.translation(links[0][2]) + '使用';
                                        },
                                    };
                                    const info = get.info('qice').chooseButton;
                                    for (const i in info) {
                                        if (!chooseButton[i]) chooseButton[i] = info[i];
                                    }
                                    return chooseButton;
                                },
                            },
                            minizhiyu: {
                                audio: 'zhiyu',
                                trigger: { player: 'damageEnd' },
                                preHidden: true,
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.draw(2);
                                    'step 1'
                                    var att = undefined;
                                    if (trigger.source && trigger.source.countCards('h') > player.countCards('h') - 1) att = get.attitude(player, trigger.source);
                                    if (!player.countCards('h')) event.finish();
                                    else player.chooseToDiscard('he', true).set('ai', function (card) {
                                        var list = [0, 0];
                                        for (var i of player.getCards('h')) {
                                            list[get.color(card) == 'red' ? 0 : 1]++;
                                        }
                                        if (typeof att == 'number') {
                                            if (att < 0) {
                                                if (get.color(card) == 'red' && list[0] == 1) return 10 - get.value(card);
                                                if (get.color(card) == 'black' && list[1] == 1) return 10 - get.value(card);
                                            }
                                        }
                                        return -get.value(card);
                                    });
                                    'step 2'
                                    if (player.countCards('h')) player.showHandcards();
                                    if (!trigger.source) event.finish();
                                    'step 3'
                                    var stop = false;
                                    var cards = player.getCards('h');
                                    if (cards.length) {
                                        var color = get.color(cards[0], player);
                                        for (var i = 1; i < cards.length; i++) {
                                            if (get.color(cards[i], player) != color) {
                                                stop = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (trigger.source.countCards('h') <= player.countCards('h')) stop = true;
                                    if (stop) event.finish();
                                    else player.chooseBool('智愚：是否令' + get.translation(trigger.source) + '将手牌数弃置至' + get.cnNumber(player.countCards('h')) + '张')
                                    'step 4'
                                    if (result.bool) {
                                        player.line(trigger.source);
                                        trigger.source.chooseToDiscard(trigger.source.countCards('h') - player.countCards('h'), true);
                                    }
                                },
                                ai: {
                                    maixie_defend: true,
                                    threaten: 0.7,
                                },
                            },
                            miniqingxi: {
                                audio: 'qingxi',
                                inherit: 'reqingxi',
                            },
                            _miniqingxi_draw: {
                                charlotte: true,
                                trigger: { global: 'judgeAfter' },
                                filter(event, player) {
                                    return event.result.color == 'black' && event.getParent().name == 'miniqingxi' && event.getParent().player == player;
                                },
                                lastDo: true,
                                direct: true,
                                content() {
                                    player.draw(2);
                                },
                            },
                            minikunfen: {
                                audio: 'kunfen',
                                audioname2: { Mbaby_ol_sb_jiangwei: 'kunfen_ol_sb_jiangwei' },
                                trigger: { player: 'phaseJieshuBegin' },
                                check(event, player) {
                                    if (player.hp > 3) return true;
                                    if (player.hp == 3 && player.countCards('h') < 3) return true;
                                    if (player.hp == 2 && player.countCards('h') == 0) return true;
                                    return false;
                                },
                                content() {
                                    'step 0'
                                    player.loseHp();
                                    'step 1'
                                    player.draw(2);
                                    'step 2'
                                    player.chooseUseTarget('huogong', false);
                                },
                            },
                            minifengliang: {
                                unique: true,
                                derivation: 'minitiaoxin',
                                audio: 'fengliang',
                                trigger: { player: 'dying' },
                                juexingji: true,
                                forced: true,
                                skillAnimation: true,
                                animationColor: 'thunder',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minifengliang');
                                    'step 1'
                                    player.loseMaxHp();
                                    'step 2'
                                    if (player.hp < 3) player.recover(3 - player.hp);
                                    'step 3'
                                    player.addSkills('minitiaoxin');
                                },
                            },
                            //钟会
                            miniquanji: {
                                group: 'miniquanji_phase',
                                audio: 'quanji',
                                trigger: { player: 'damageEnd' },
                                filter(event, player) {
                                    return event.num > 0;
                                },
                                frequent: true,
                                prompt2: '摸两张牌',
                                content() {
                                    'step 0'
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    player.draw(2);
                                    'step 2'
                                    if (event.count > 0 && player.hasSkill('miniquanji')) player.chooseBool(get.prompt('miniquanji'), '摸两张牌').set('frequentSkill', 'miniquanji');
                                    else event.finish();
                                    'step 3'
                                    if (result.bool) {
                                        player.logSkill('miniquanji');
                                        event.goto(1);
                                    }
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions('quanji');
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + Math.min(5, player.getExpansions('quanji').length);
                                    },
                                },
                                subSkill: {
                                    phase: {
                                        audio: 'quanji',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            return player.countCards('h');
                                        },
                                        prompt: '将任意张手牌置于武将牌上',
                                        selectCard: [1, Infinity],
                                        filterCard: true,
                                        delay: 0,
                                        discard: false,
                                        lose: false,
                                        delay: false,
                                        check(card) {
                                            var player = _status.event.player, num = player.needsToDiscard();
                                            if (!player.getExpansions('quanji').length || num - ui.selected.cards.length - Math.min(5, player.getExpansions('quanji').length + ui.selected.cards.length) > 0) return 5 - get.value(card);
                                            return -1;
                                        },
                                        content() {
                                            player.addToExpansion(cards, player, 'give').gaintag.add('quanji');
                                        },
                                        ai: {
                                            order: 5,
                                            result: { player: 1 },
                                        },
                                    },
                                },
                            },
                            //杨修
                            minijilei: {
                                audio: 'jilei',
                                inherit: 'jilei',
                                content() {
                                    'step 0'
                                    player.chooseControl('basic', 'trick', 'equip', 'cancel2', function () {
                                        var source = _status.event.source;
                                        if (get.attitude(_status.event.player, source) > 0) return 'cancel2';
                                        var list = ['basic', 'trick', 'equip'].filter(function (name) {
                                            return (!source.storage.jilei2 || !source.storage.jilei2.includes(name));
                                        });
                                        if (!list.length) return 'cancel2';
                                        if (list.includes('trick') && source.countCards('h', function (card) {
                                            return get.type(card, source) == 'trick' && source.hasValueTarget(card);
                                        }) > 1) return 'trick';
                                        return list[0];
                                    }).set('prompt', get.prompt2('minijilei', trigger.source)).set('source', trigger.source);
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minijilei', trigger.source);
                                        player.popup(get.translation(result.control) + '牌');
                                        var card = get.cardPile2(function (card) {
                                            return get.type2(card) == result.control;
                                        });
                                        if (card) player.gain(card, 'gain2');
                                        trigger.source.addTempSkill('jilei2', { player: 'phaseBegin' });
                                        trigger.source.storage.jilei2.add(result.control);
                                        trigger.source.updateMarks('jilei2');
                                    }
                                },
                            },
                            //张昌蒲
                            miniyanjiao: {
                                audio: 'yanjiao',
                                enable: 'phaseUse',
                                filterTarget: true,
                                usable: 1,
                                content() {
                                    'step 0'
                                    var num = 3;
                                    if (player.storage.xingshen) {
                                        num += player.storage.xingshen;
                                        player.storage.xingshen = 0;
                                        player.unmarkSkill('xingshen');
                                    }
                                    if (player.storage.olxingshen) {
                                        num += player.storage.olxingshen;
                                        player.storage.olxingshen = 0;
                                        player.unmarkSkill('olxingshen');
                                    }
                                    event.cards = get.cards(num);
                                    game.cardsGotoOrdering(event.cards);
                                    target.showCards(event.cards, get.translation(player) + '发动了【严教】');
                                    'step 1'
                                    var num = 0;
                                    for (var i of cards) num += get.number(i, false);
                                    num = Math.max(1, Math.floor(num / 2));
                                    var str = '选择获得任意张总点数不大于' + num + '的牌';
                                    if (target != player) str += '，然后' + get.translation(player) + '获得剩余的牌';
                                    target.chooseButton([str, cards], [1, cards.length], true).set('filterButton', function (button) {
                                        var summer = 0, num = _status.event.num;
                                        for (var i = 0; i < ui.selected.buttons.length; i++) summer += get.number(ui.selected.buttons[i].link, false);
                                        return summer + get.number(button.link, false) <= num;
                                    }).set('num', num);
                                    'step 2'
                                    if (result.bool) {
                                        cards.removeArray(result.links);
                                        target.gain(result.links, 'gain2');
                                    }
                                    'step 3'
                                    if (cards.length) {
                                        if (target != player) player.gain(cards, 'gain2');
                                        else {
                                            player.$throw(cards, 1000);
                                            game.cardsDiscard(cards);
                                            game.log(cards, '被置入了弃牌堆');
                                        }
                                    }
                                    else event.finish();
                                    'step 4'
                                    game.delayx();
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        target(player, target) {
                                            return target == player ? 1 : 2;
                                        },
                                    },
                                },
                            },
                            minifankui: {
                                audio: 'fankui',
                                trigger: { player: 'damageEnd' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    player.judge();
                                    'step 2'
                                    if (!game.hasPlayer(function (current) {
                                        return current.countGainableCards(player, 'he');
                                    })) {
                                        event.goto(4);
                                        return;
                                    }
                                    if (result.suit != 'heart' && (!trigger.source || !trigger.source.countCards('he'))) {
                                        event.goto(4);
                                        return;
                                    }
                                    if (result.suit != 'heart') event._result = { bool: true, targets: [trigger.source] };
                                    else player.chooseTarget('请选择【反馈】的目标', '获得一名角色的一张牌', true, function (card, player, target) {
                                        return target.countGainableCards(player, 'he');
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                    });
                                    'step 3'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        player.gainPlayerCard(target, 'he', true);
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (event.count > 0 && player.hasSkill('minifankui')) player.chooseBool(get.prompt2('minifankui')).set('frequentSkill', 'minifankui');
                                    else event.finish();
                                    'step 5'
                                    if (result.bool) {
                                        player.logSkill('minifankui');
                                        event.goto(1);
                                    }
                                },
                                ai: {
                                    maixie_defend: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.countCards('he') > 1 && get.tag(card, 'damage')) {
                                                if (player.hasSkillTag('jueqing', false, target)) return [1, -1.5];
                                                if (get.attitude(target, player) < 0) return [1, 1];
                                            }
                                        },
                                    },
                                },
                            },
                            miniguicai: {
                                audio: 'guicai',
                                trigger: { global: 'judge' },
                                filter(event, player) {
                                    return player.countCards('hes');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCard(get.translation(trigger.player) + '的' + (trigger.judgestr || '') + '判定为' +
                                        get.translation(trigger.player.judging[0]) + '，' + get.prompt('miniguicai'), 'hes', function (card) {
                                            var player = _status.event.player;
                                            var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                            if (mod2 != 'unchanged') return mod2;
                                            var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                                            if (mod != 'unchanged') return mod;
                                            return true;
                                        }).set('ai', function (card) {
                                            var trigger = _status.event.getTrigger();
                                            var player = _status.event.player;
                                            var judging = _status.event.judging;
                                            var result = trigger.judge(card) - trigger.judge(judging);
                                            var attitude = get.attitude(player, trigger.player);
                                            if (attitude == 0) {
                                                if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                                if (get.suit(card, player) == 'club') return 8;
                                                return 0;
                                            }
                                            if (attitude > 0) {
                                                if (result == 0) {
                                                    if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                                    if (get.suit(card, player) == 'club') return 8;
                                                    return 0;
                                                }
                                                return result - get.value(card) / 2;
                                            }
                                            else {
                                                if (result == 0) {
                                                    if (player.isDamaged() && get.suit(card) == 'heart') return 10;
                                                    if (get.suit(card) == 'club') return 8;
                                                    return 0;
                                                }
                                                return -result - get.value(card) / 2;
                                            }
                                        }).set('judging', trigger.player.judging[0]);
                                    'step 1'
                                    if (result.bool) {
                                        player.respond(result.cards, 'miniguicai', 'highlight', 'noOrdering');
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        if (trigger.player.judging[0].clone) {
                                            trigger.player.judging[0].clone.classList.remove('thrownhighlight');
                                            game.broadcast(function (card) {
                                                if (card.clone) {
                                                    card.clone.classList.remove('thrownhighlight');
                                                }
                                            }, trigger.player.judging[0]);
                                            game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                                        }
                                        game.cardsDiscard(trigger.player.judging[0]);
                                        trigger.player.judging[0] = result.cards[0];
                                        trigger.orderingCards.addArray(result.cards);
                                        game.log(trigger.player, '的判定牌改为', result.cards[0]);
                                        game.delay(2);
                                        event.card = result.cards[0];
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (get.suit(card, player) == 'heart') player.recover();
                                    if (get.suit(card, player) == 'club') player.draw(2);
                                },
                                ai: {
                                    rejudge: true,
                                    tag: { rejudge: 1 },
                                },
                            },
                            //杜夫人
                            miniyise: {
                                audio: 'yise',
                                trigger: { global: 'gainAfter', player: 'loseAsyncAfter' },
                                filter(event, player) {
                                    if (event.name == 'loseAsync') {
                                        if (event.type != 'gain') return false;
                                    }
                                    var cards = event.getl(player).cards2;
                                    return game.hasPlayer(function (current) {
                                        if (current == player) return false;
                                        var cardsx = event.getg(current);
                                        for (var i of cardsx) {
                                            if (cards.includes(i)) return true;
                                        }
                                        return false;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var cards = trigger.getl(player).cards2;
                                    event.cards = cards;
                                    event.targets = game.filterPlayer(function (current) {
                                        if (current == player) return false;
                                        var cardsx = trigger.getg(current);
                                        for (var i of cardsx) {
                                            if (cards.includes(i)) return true;
                                        }
                                        return false;
                                    }).sortBySeat();
                                    'step 1'
                                    var target = targets.shift();
                                    var cardsx = trigger.getg(target);
                                    var next = game.createEvent('miniyise_insert');
                                    next.player = player;
                                    next.target = target;
                                    next.cards = cardsx;
                                    next.setContent(lib.skill.miniyise.contentx);
                                    if (targets.length > 0) event.redo();
                                },
                                contentx() {
                                    'step 0'
                                    event.logged = false;
                                    for (var i of cards) {
                                        event[get.color(i, player)] = true;
                                        if (event.red && event.black) break;
                                    }
                                    if (event.red) {
                                        var list = ['摸牌'], choiceList = [
                                            '令自己摸一张牌',
                                            '令' + get.translation(target) + '回复1点体力'
                                        ];
                                        if (target.isDamaged()) list.push('回复体力');
                                        else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                                        list.push('cancel2');
                                        player.chooseControl(list).set('prompt', get.prompt('miniyise', target)).set('ai', function () {
                                            if (list.includes('回复体力') && get.recoverEffect(_status.event.getParent().target, _status.event.player, _status.event.player) > 0) return '回复体力';
                                            return '摸牌';
                                        }).set('choiceList', choiceList);
                                    }
                                    'step 1'
                                    if (event.red && result.control != 'cancel2') {
                                        event.logged = true;
                                        player.logSkill('miniyise', target);
                                        if (result.control == '摸牌') player.draw();
                                        else target.recover();
                                    }
                                    if (!event.black) event.finish();
                                    'step 2'
                                    player.chooseBool(get.prompt('miniyise', target), '令' + get.translation(target) + '下次受到【杀】造成的伤害+1').set('choice', get.attitude(player, target) < 0);
                                    'step 3'
                                    if (result.bool) {
                                        if (!event.logged) player.logSkill('miniyise', target);
                                        else player.line(target);
                                        target.addMark('yise_damage', 1, false);
                                        target.addSkill('yise_damage');
                                    }
                                },
                            },
                            minishunshi: {
                                audio: 'shunshi',
                                trigger: { player: ['damageEnd', 'phaseZhunbeiBegin'] },
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        prompt: get.prompt2('minishunshi'),
                                        filterTarget: lib.filter.notMe,
                                        filterCard: true,
                                        position: 'he',
                                        ai1(card) {
                                            var player = _status.event.player;
                                            if (player.hasSkill('miniyise')) {
                                                if (get.color(card, player) == 'red' && game.hasPlayer(function (current) {
                                                    return current != player && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                                                })) return 10 - get.value(card);
                                                if (get.color(card, player) == 'black') return 4 - get.value(card);
                                            }
                                            return 8 - get.value(card);
                                        },
                                        ai2(target) {
                                            var player = _status.event.player, card = ui.selected.cards[0];
                                            var att = get.attitude(player, target);
                                            if (player.hasSkill('miniyise')) {
                                                if (get.color(card) == 'red' && target.isDamaged()) return 2 * get.recoverEffect(target, player, player) + get.sgn(att);
                                                if (get.color(card) == 'black') return -att;
                                            }
                                            if (get.value(card, target) < 0) return -att;
                                            if (get.value(card, target) < 1) return 0.01 * -att;
                                            return Math.max(1, get.value(card, target) - get.value(card, player)) * att;
                                        },
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minishunshi', target);
                                        player.give(result.cards, target);
                                        for (var phase of ['phaseDraw', 'phaseUse', 'phaseDiscard']) {
                                            player.addTempSkill('minishunshi_' + phase, { player: phase + 'After' });
                                            player.addMark('minishunshi_' + phase, 1, false);
                                        }
                                    }
                                },
                                subSkill: {
                                    phaseDraw: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: '摸',
                                        intro: { content: '下个摸牌阶段多摸#张牌' },
                                        trigger: { player: 'phaseDrawBegin2' },
                                        filter(event, player) {
                                            return !event.numFixed;
                                        },
                                        direct: true,
                                        content() {
                                            trigger.num += player.countMark('minishunshi_phaseDraw');
                                        },
                                    },
                                    phaseUse: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: '出',
                                        intro: { content: '下个出牌阶段使用【杀】的次数上限+#，且使用【杀】无视防具' },
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (player.isPhaseUsing() && card.name == 'sha') return num + player.countMark('minishunshi_phaseUse');
                                            },
                                        },
                                        ai: {
                                            unequip: true,
                                            skillTagFilter(player, tag, arg) {
                                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.isPhaseUsing()) return false;
                                            },
                                        },
                                    },
                                    phaseDiscard: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: '弃',
                                        intro: { content: '下个弃牌阶段手牌上限+#' },
                                        mod: {
                                            maxHandcard(player, num) {
                                                if (player.hasSkill('minishunshi_phaseDiscard2')) return num + player.countMark('minishunshi_phaseDiscard');
                                            },
                                        },
                                        trigger: { player: 'phaseDiscardBefore' },
                                        direct: true,
                                        content() {
                                            player.addTempSkill('minishunshi_phaseDiscard2', { player: 'phaseDiscardAfter' });
                                        },
                                    },
                                    phaseDiscard2: { charlotte: true },
                                },
                            },
                            minijiangchi: {
                                audio: 'jiangchi',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var list = [
                                        '摸一张牌，直到你的下个回合开始，受到伤害后摸一张牌',
                                        '摸三张牌，本回合内不能使用或打出【杀】且手牌上限+2',
                                        '本回合可以多使用一张【杀】且无距离限制',
                                    ];
                                    player.chooseControl('cancel2').set('prompt', get.prompt('xinjiangchi')).set('choiceList', list).set('ai', function () {
                                        var player = _status.event.player;
                                        var num = player.countCards('hs', function (card) {
                                            return get.name(card) == 'sha' && player.hasValueTarget(card, false);
                                        });
                                        if (num == 0) return 1;
                                        if (num > 1) return 2;
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minijiangchi');
                                        switch (result.index) {
                                            case 0: {
                                                player.draw();
                                                player.addTempSkill('minijiangchi_draw', { player: 'phaseBegin' });
                                                break;
                                            }
                                            case 1: {
                                                player.draw(3);
                                                player.addTempSkill('xinjiangchi_less');
                                                player.addTempSkill('minijiangchi_hand');
                                                break;
                                            }
                                            case 2: {
                                                player.addTempSkill('xinjiangchi_more');
                                                break;
                                            }
                                        }
                                    }
                                },
                                subSkill: {
                                    draw: {
                                        charlotte: true,
                                        audio: 'jiangchi',
                                        trigger: { player: 'damageEnd' },
                                        forced: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    hand: {
                                        charlotte: true,
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num + 2;
                                            },
                                        },
                                    },
                                },
                            },
                            //曹操
                            minijianxiong: {
                                audio: 'jianxiong',
                                audioname2: { Mbaby_caoying: 'lingren_jianxiong' },
                                trigger: { player: 'damageEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    player.chooseControl('摸两张牌', '拿牌摸牌', 'cancel2').set('prompt', get.prompt2('minijianxiong')).set('ai', function () {
                                        var trigger = _status.event.getTrigger();
                                        if (get.itemtype(trigger.cards) != 'cards' || trigger.cards.filterInD().length < 1 || (trigger.cards.filterInD().length == 1 && trigger.cards.filterInD()[0].name == 'sha')) return '摸两张牌';
                                        return '拿牌摸牌';
                                    });
                                    'step 2'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minijianxiong');
                                        if (result.control == '拿牌摸牌') {
                                            if (trigger.cards.filterInD().length) player.gain(trigger.cards.filterInD(), 'gain2');
                                            player.draw();
                                        }
                                        else player.draw(2);
                                        if (event.count > 0 && player.hasSkill('minijianxiong')) event.goto(1);
                                    }
                                    else event.finish();
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.hasSkillTag('jueqing', false, target)) return [1, -1];
                                            if (get.tag(card, 'damage') && player != target) return [1, 0.6];
                                        },
                                    },
                                },
                            },
                            minihujia: {
                                unique: true,
                                audio: 'hujia',
                                trigger: { player: ['chooseToRespondBefore', 'chooseToUseBefore'] },
                                filter(event, player) {
                                    if (event.responded) return false;
                                    if (player.storage.minihujiaing) return false;
                                    if (!event.filterCard({ name: 'shan' }, player, event)) return false;
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.group == 'wei';
                                    });
                                },
                                check(event, player) {
                                    return get.damageEffect(player, event.player, player) < 0;
                                },
                                zhuSkill: true,
                                content() {
                                    'step 0'
                                    if (!event.current) event.current = player.next;
                                    if (event.current == player) event.finish();
                                    else if (event.current.group == 'wei') {
                                        if ((event.current == game.me && !_status.auto) || (
                                            get.attitude(event.current, player) > 2) ||
                                            event.current.isOnline()) {
                                            player.storage.minihujiaing = true;
                                            var next = event.current.chooseToRespond('是否替' + get.translation(player) + '打出一张闪？', { name: 'shan' });
                                            next.set('ai', function () {
                                                var event = _status.event;
                                                return (get.attitude(event.player, event.source) - 2);
                                            });
                                            next.set('skillwarn', '替' + get.translation(player) + '打出一张闪');
                                            next.autochoose = lib.filter.autoRespondShan;
                                            next.set('source', player);
                                        }
                                    }
                                    'step 1'
                                    player.storage.minihujiaing = false;
                                    if (result.bool) {
                                        event.target = event.current;
                                        trigger.result = { bool: true, card: { name: 'shan', isCard: true } };
                                        trigger.responded = true;
                                        trigger.animate = false;
                                        if (typeof event.current.ai.shown == 'number' && event.current.ai.shown < 0.95) {
                                            event.current.ai.shown += 0.3;
                                            if (event.current.ai.shown > 0.95) event.current.ai.shown = 0.95;
                                        }
                                    }
                                    else {
                                        event.current = event.current.next;
                                        event.goto(0);
                                    }
                                    'step 2'
                                    target.chooseBool('是否令' + get.translation(player) + '摸一张牌？');
                                    'step 3'
                                    if (result.bool) {
                                        target.line(player);
                                        player.draw();
                                    }
                                },
                                ai: {
                                    respondShan: true,
                                    skillTagFilter(player) {
                                        if (player.storage.minihujiaing) return false;
                                        return game.hasPlayer(function (current) {
                                            return current != player && current.group == 'wei';
                                        });
                                    },
                                },
                            },
                            //庞德
                            minijuesi: {
                                audio: 'juesi',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h', { name: 'sha' });
                                },
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('he') > 0 && player.inRange(target);
                                },
                                filterCard: { name: 'sha' },
                                content() {
                                    'step 0'
                                    target.chooseToDiscard('he', true);
                                    'step 1'
                                    if (result.bool) {
                                        if (target.hp >= player.hp && result.cards[0].name != 'sha') player.draw(2);
                                        if (result.cards[0].name == 'sha' && player.canUse({ name: 'juedou', isCard: true }, target, false)) player.useCard({ name: 'juedou', isCard: true }, target, false);
                                    }
                                },
                                ai: {
                                    order: 2,
                                    result: {
                                        target(player, target) {
                                            if (get.effect(target, { name: 'juedou' }, player, player) <= 0) {
                                                return 0;
                                            }
                                            if (target.hp < player.hp) {
                                                if (player.countCards('h') > player.hp) return -0.1;
                                                return 0;
                                            }
                                            var hs1 = target.getCards('h', 'sha');
                                            var hs2 = player.getCards('h', 'sha');
                                            if (hs1.length > hs2.length) {
                                                return 0;
                                            }
                                            var hsx = target.getCards('h');
                                            if (hsx.length > 2 && hs2.length <= 1 && hsx[0].number < 6) {
                                                return 0;
                                            }
                                            if (hsx.length > 3 && hs2.length <= 1) {
                                                return 0;
                                            }
                                            if (hs1.length > hs2.length - 1 && hs1.length > 0 && (hs2.length <= 1 || hs1[0].number > hs2[0].number)) {
                                                return 0;
                                            }
                                            return -1;
                                        },
                                    },
                                },
                            },
                            minichoujue: {
                                derivation: ['minibeishui', 'miniqingjiao'],
                                unique: true,
                                audio: 'choujue',
                                trigger: { global: 'phaseAfter' },
                                filter(event, player) {
                                    return Math.abs(player.hp - player.countCards('h')) >= 3;
                                },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: 'water',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minichoujue');
                                    player.storage.choujue = true;
                                    player.loseMaxHp();
                                    'step 1'
                                    player.addSkills('minibeishui');
                                },
                            },
                            minibeishui: {
                                unique: true,
                                audio: 'beishui',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return Math.min(player.hp, player.countCards('h')) <= 2;
                                },
                                forced: true,
                                juexingji: true,
                                skillAnimation: 'epic',
                                animationColor: 'thunder',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minibeishui');
                                    player.storage.beishui = true;
                                    player.loseMaxHp();
                                    'step 1'
                                    player.addSkills('miniqingjiao');
                                },
                            },
                            miniqingjiao: {
                                audio: 'qingjiao',
                                inherit: 'qingjiao',
                                filter(event, player) {
                                    if (!ui.cardPile.hasChildNodes() && !ui.discardPile.hasChildNodes()) return false;
                                    var hs = player.getCards('h');
                                    if (!hs.length) return false;
                                    return hs.every(i => lib.filter.cardDiscardable(i, player, 'miniqingjiao'));
                                },
                                content() {
                                    'step 0';
                                    player.chooseToDiscard(true, 'h', player.countCards('h'));
                                    'step 1';
                                    var evt = trigger.getParent();
                                    if (evt?.getParent && !evt.miniqingjiao) {
                                        evt.miniqingjiao = true;
                                        var next = game.createEvent('miniqingjiao_discard', false, evt.getParent());
                                        next.player = player;
                                        next.setContent(function () {
                                            var hs = player.getCards('h');
                                            if (hs.length) player.discard(hs);
                                        });
                                    }
                                    'step 2';
                                    var list = [];
                                    var typelist = [];
                                    var getType = function (card) {
                                        var sub = get.subtype(card);
                                        if (sub) return sub;
                                        return card.name;
                                    };
                                    for (var i = 0; i < ui.cardPile.childElementCount; i++) {
                                        var node = ui.cardPile.childNodes[i];
                                        var typex = getType(node);
                                        if (!typelist.includes(typex)) {
                                            list.push(node);
                                            typelist.push(typex);
                                            if (list.length >= 8) break;
                                        }
                                    }
                                    if (list.length < 8) {
                                        for (var i = 0; i < ui.discardPile.childElementCount; i++) {
                                            var node = ui.discardPile.childNodes[i];
                                            var typex = getType(node);
                                            if (!typelist.includes(typex)) {
                                                list.push(node);
                                                typelist.push(typex);
                                                if (list.length >= 8) break;
                                            }
                                        }
                                    }
                                    player.gain(list, 'gain2');
                                },
                            },
                            //夏侯令女
                            miniweilie: {
                                audio: 'weilie',
                                inherit: 'weilie',
                                filter(event, player) {
                                    if (player.countMark('miniweilie') > player.getStorage('fuping').length) return false;
                                    return player.countCards('he') && game.hasPlayer(current => current.isDamaged());
                                },
                                content() {
                                    player.addMark('miniweilie', 1, false);
                                    target.recover();
                                    target.draw();
                                },
                            },
                            minifaen: {
                                audio: 'faen',
                                trigger: { global: ['turnOverAfter', 'linkAfter', 'damageBegin4'] },
                                filter(event, player) {
                                    if (event.name == 'damage' && !player.countCards('he')) return false;
                                    return event.name == 'turnOver' || event.player.isLinked();
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var target = trigger.player;
                                    event.target = target;
                                    if (trigger.name == 'damage') {
                                        player.chooseToDiscard(get.prompt('minifaen', target), '弃置一张牌，防止即将对' + get.translation(target) + '造成的伤害', 'he').set('ai', function (card) {
                                            if (!_status.event.check()) return -1;
                                            return 7 - get.value(card);
                                        }).set('check', function () {
                                            if (get.attitude(player, target) <= 0) return false;
                                            if (player.countCards('h', function (card) {
                                                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                                if (mod2 != 'unchanged') return mod2;
                                                var mod = game.checkMod(card, player, target, 'unchanged', 'cardSavable', player);
                                                if (mod != 'unchanged') return mod;
                                                var savable = get.info(card).savable;
                                                if (typeof savable == 'function') savable = savable(card, player, target);
                                                return savable;
                                            }) >= 1 + trigger.num - target.hp) return false;
                                            if (target == player || target == get.zhu(player)) return true;
                                            return !player.hasUnknown();
                                        }).logSkill = ['minifaen', target];
                                    }
                                    else player.chooseBool(get.prompt('minifaen', target), '令' + get.translation(target) + '摸一张牌').set('choice', get.attitude(player, target) > 0);
                                    'step 1'
                                    if (result.bool) {
                                        if (trigger.name != 'damage') {
                                            player.logSkill('minifaen', target);
                                            target.draw();
                                        }
                                        else trigger.cancel();
                                    }
                                },
                                ai: { expose: 0.2 },
                            },
                            //王基
                            miniqizhi: {
                                audio: 'qizhi',
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (!event.targets || !event.isFirstTarget) return false;
                                    if (_status.currentPhase != player) return false;
                                    var type = get.type(event.card, 'trick');
                                    if (type != 'basic' && type != 'trick') return false;
                                    return game.hasPlayer(function (target) {
                                        return !event.targets.includes(target) && target.countCards('he') > 0;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniqizhi'), '弃置一名角色的一张牌，然后若弃置的牌与使用的牌类型相同，你摸一张牌；类型不同，其摸一张牌', function (card, player, target) {
                                        return !_status.event.targets.includes(target) && target.countCards('he') > 0;
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        if (target == player) return 2;
                                        if (get.attitude(player, target) <= 0) {
                                            return 1
                                        }
                                        return 0.5;
                                    }).set('targets', trigger.targets);
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniqizhi', result.targets);
                                        player.discardPlayerCard(result.targets[0], true, 'he');
                                        event.target = result.targets[0];
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool && get.type2(result.cards[0]) == get.type2(trigger.card)) player.draw();
                                    else target.draw();
                                },
                            },
                            minijinqu: {
                                audio: 'jinqu',
                                trigger: { player: 'phaseDiscardBefore' },
                                prompt(event, player) {
                                    var num = player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'miniqizhi';
                                    }).length + 1;
                                    return '进趋：是否摸两张牌并跳过弃牌阶段，然后将手牌弃置至' + get.cnNumber(num) + '张？';
                                },
                                check(event, player) {
                                    var num = player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'miniqizhi';
                                    }).length + 1;
                                    var numx = player.countCards('h') + 2 - num;
                                    return num >= 2 || player.needsToDiscard() >= numx;
                                },
                                content() {
                                    'step 0'
                                    trigger.cancel();
                                    player.draw(2);
                                    'step 1'
                                    var num = player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'miniqizhi';
                                    }).length + 1;
                                    if (player.countCards('h') > num) player.chooseToDiscard(player.countCards('h') - num, true);
                                },
                                ai: { combo: 'miniqizhi' },
                            },
                            //SP甄姬
                            minijinghong: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards('h');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var num = Math.min(game.countPlayer(function (current) {
                                        return current != player && current.countCards('h');
                                    }), game.countPlayer() - 1, 4);
                                    player.chooseTarget(get.prompt2('minijinghong'), [1, num], lib.filter.notMe).set('ai', function (target) {
                                        var player = _status.event.player;
                                        if (!target.countCards('h')) return 0;
                                        return (1 - get.sgn(get.attitude(player, target))) / target.countCards('h');
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        event.targets = targets;
                                        player.logSkill('minijinghong', targets);
                                        player.addTempSkill('minijinghong_effect');
                                    }
                                    else event.finish();
                                    'step 2'
                                    var target = event.targets.shift();
                                    event.target = target;
                                    player.line(target);
                                    if (!target.countCards('h')) event.redo();
                                    'step 3'
                                    var card = target.getCards('h').randomGet();
                                    player.showCards(card, get.translation(player) + '展示的' + get.translation(target) + '的手牌');
                                    if (get.color(card, target) == 'black') player.gain(card, target, 'giveAuto', 'bySelf').gaintag.add('minijinghong');
                                    if (get.color(card, target) == 'red') target.discard(card);
                                    'step 4'
                                    if (event.targets.length) event.goto(2);
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove(player) {
                                            player.removeGaintag('minijinghong');
                                        },
                                        mod: {
                                            ignoredHandcard(card, player) {
                                                if (card.hasGaintag('minijinghong')) return true;
                                            },
                                            cardDiscardable(card, player, name) {
                                                if (name == 'phaseDiscard' && card.hasGaintag('minijinghong')) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minispluoshen: {
                                mod: {
                                    aiValue(player, card, num) {
                                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                                        var cards = player.getCards('hs', function (card) {
                                            return get.name(card) == 'shan' || get.color(card) == 'black';
                                        });
                                        cards.sort(function (a, b) {
                                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                                        });
                                        var geti = function () {
                                            if (cards.includes(card)) {
                                                return cards.indexOf(card);
                                            }
                                            return cards.length;
                                        };
                                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                                    },
                                    aiUseful() {
                                        return lib.skill.minispluoshen.mod.aiValue.apply(this, arguments);
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: ['chooseToRespond', 'chooseToUse'],
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                frequent: true,
                                locked: false,
                                position: 'hes',
                                viewAs: { name: 'shan' },
                                viewAsFilter(player) {
                                    if (!player.countCards('hes', { color: 'black' })) return false;
                                },
                                onuse(links, player) {
                                    player.addTempSkill('minispluoshen_effect');
                                },
                                onrespond(links, player) {
                                    player.addTempSkill('minispluoshen_effect');
                                },
                                prompt: '将一张黑色牌当作【闪】使用或打出',
                                check: () => 1,
                                ai: {
                                    order(item, player) {
                                        if (!player.hasSkill('minispluoshen_used')) return 1145141919810
                                        return 2;
                                    },
                                    respondShan: true,
                                    skillTagFilter(player) {
                                        if (!player.countCards('hes', { color: 'black' })) return false;
                                    },
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                                        },
                                    },
                                },
                                subSkill: {
                                    used: { charlotte: true },
                                    effect: {
                                        charlotte: true,
                                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                                        filter(event, player) {
                                            return event.skill == 'minispluoshen' && !player.hasSkill('minispluoshen_used');
                                        },
                                        prompt2: '进行一次判定并获得判定牌，若结果为黑色，你可以重复此流程',
                                        content() {
                                            'step 0'
                                            player.addTempSkill('minispluoshen_used', 'roundStart');
                                            event.cards = [];
                                            'step 1'
                                            var next = player.judge(function (card) {
                                                var color = get.color(card);
                                                return color == 'black' ? 1 : -1;
                                            });
                                            next.judge2 = function (result) {
                                                return result.bool;
                                            };
                                            next.set('callback', function () {
                                                if (get.position(card, true) == 'o') player.gain(card, 'gain2');
                                            });
                                            'step 2'
                                            if (result.judge > 0) player.chooseBool('是否继续进行【洛神】判定？').set('frequentSkill', 'minispluoshen');
                                            else event.finish();
                                            'step 3'
                                            if (result.bool) event.goto(1);
                                        },
                                    },
                                },
                            },
                            minispwusheng: {
                                group: ['minispwusheng_wusheng', 'minispwusheng_effect'],
                                audio: 'wusheng',
                                audioname: ['jsp_guanyu'],
                                audioname2: {
                                    guanzhang: "wusheng_guanzhang",
                                    guansuo: "wusheng_guansuo",
                                },
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    var card = get.cardPile(function (card) {
                                        return get.color(card) == 'red';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                },
                                subSkill: {
                                    wusheng: {
                                        audio: 'wusheng',
                                        audioname: ['jsp_guanyu'],
                                        audioname2: {
                                            guanzhang: "wusheng_guanzhang",
                                            guansuo: "wusheng_guansuo",
                                        },
                                        enable: ['chooseToRespond', 'chooseToUse'],
                                        filterCard(card, player) {
                                            return get.color(card) == 'red';
                                        },
                                        position: 'hes',
                                        viewAs: { name: 'sha' },
                                        viewAsFilter(player) {
                                            if (!player.countCards('hes', { color: 'red' })) return false;
                                        },
                                        prompt: '武圣：将一张红色牌当作【杀】使用或打出',
                                        check(card) {
                                            var val = get.value(card);
                                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                                            return 5 - val;
                                        },
                                        ai: {
                                            respondSha: true,
                                            skillTagFilter(player) {
                                                if (!player.countCards('hes', { color: 'red' })) return false;
                                            },
                                        },
                                    },
                                    effect: {
                                        mod: {
                                            aiOrder(player, card, num) {
                                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                                            },
                                            targetInRange(card) {
                                                if (get.suit(card) == 'diamond' && card.name == 'sha') return true;
                                            },
                                        },
                                        audio: 'wusheng',
                                        audioname: ['jsp_guanyu'],
                                        audioname2: {
                                            guanzhang: "wusheng_guanzhang",
                                            guansuo: "wusheng_guansuo",
                                        },
                                        inherit: 'jie',
                                        filter(event, player) {
                                            return lib.skill.jie.filter(event) && event.card.isCard;
                                        },
                                    },
                                },
                            },
                            minidanji: {
                                unique: true,
                                derivation: ['miniyuma', 'mininuzhan'],
                                audio: 'danji',
                                trigger: { player: ['useCard', 'respond'], source: 'damageSource' },
                                filter(event, player) {
                                    if (event.name != 'damage') return player.getAllHistory('useCard').length + player.getAllHistory('respond').length >= 5;
                                    var num = 0;
                                    player.getAllHistory('sourceDamage', evt => num += evt.num);
                                    return num >= 6;
                                },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: 'water',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minidanji');
                                    if (player.isDamaged()) player.recover(player.maxHp - player.hp);
                                    'step 1'
                                    player.addSkills(lib.skill.minidanji.derivation);
                                },
                            },
                            mininuzhan: {
                                audio: 'dcnuchen',
                                trigger: { player: 'useCard1', source: 'damageBegin1' },
                                filter(event, player) {
                                    if (!(event.card && event.card.name == 'sha' && event.cards?.length && !event.card.isCard)) return false;
                                    if (event.name == 'useCard') return event.addCount !== false && get.type2(event.cards[0]) != 'trick';
                                    return get.type2(event.cards[0]) == 'trick';
                                },
                                forced: true,
                                content() {
                                    var card = trigger.cards[0];
                                    if (get.type2(card) != 'trick') {
                                        trigger.addCount = false;
                                        if (player.stat[player.stat.length - 1].card.sha > 0) {
                                            player.stat[player.stat.length - 1].card.sha--;
                                        }
                                        game.log(event.card, '不计入次数限制');
                                    }
                                    else trigger.num++;
                                },
                            },
                            //筷子
                            minishenshi: {
                                audio: 'nzry_shenshi_1',
                                group: 'minishenshi_2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he') > 0;
                                },
                                discard: false,
                                line: true,
                                lose: false,
                                delay: false,
                                position: 'he',
                                filterCard: true,
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    return 5 - get.value(card);
                                },
                                usable: 1,
                                prompt: '将一张牌交给一名其他角色，然后对其造成1点伤害，若该角色因此死亡，则你可以令一名角色将手牌摸至四张',
                                content() {
                                    'step 0'
                                    player.give(cards, target);
                                    target.damage('nocard');
                                    'step 1'
                                    if (!target.isIn()) {
                                        player.chooseTarget('审时：令一名角色将手牌摸至四张', function (card, player, target) {
                                            return target.countCards('h') < 4;
                                        }).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.attitude(player, target);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        player.line(result.targets);
                                        result.targets[0].drawTo(4)
                                    };
                                },
                                ai: {
                                    order: 1,
                                    result: { target: -1 },
                                },
                                subSkill: {
                                    '2': {
                                        audio: 'nzry_shenshi_1',
                                        trigger: { player: 'damageEnd' },
                                        filter(event, player) {
                                            return player.countCards('he') > 0 && event.source && event.source != player;
                                        },
                                        logTarget: 'source',
                                        prompt2: '观看该角色的手牌，然后交给其一张牌，其失去此牌后，你将手牌摸至四张',
                                        content() {
                                            'step 0'
                                            player.viewHandcards(trigger.source);
                                            player.chooseCard('he', true, '交给' + get.translation(trigger.source) + '一张牌').set('ai', function (card) {
                                                return 5 - get.value(card);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                var skill = 'minishenshi_' + player.playerid;
                                                if (!lib.skill[skill]) {
                                                    lib.skill[skill] = {};
                                                    lib.translate[skill] = '审时';
                                                }
                                                player.give(result.cards, trigger.source).gaintag.add(skill);
                                                player.addSkill('minishenshi_3');
                                            }
                                        },
                                    },
                                    '3': {
                                        charlotte: true,
                                        audio: 'nzry_shenshi_1',
                                        trigger: { global: ['equipAfter', 'addJudgeAfter', 'loseAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                                        filter(event, player) {
                                            if (player.countCards('h') >= 4) return false;
                                            return game.hasPlayer2(function (current) {
                                                var evt = event.getl(current);
                                                if (evt?.gaintag_map) {
                                                    for (var i in evt.gaintag_map) {
                                                        if (evt.gaintag_map[i].includes('minishenshi_' + player.playerid)) return true;
                                                    }
                                                }
                                                return false;
                                            });
                                        },
                                        forced: true,
                                        content() {
                                            player.drawTo(4);
                                        },
                                    },
                                },
                            },
                            //魏贾诩
                            minijianshu: {
                                audio: 'jianshu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterTarget(card, player, target) {
                                    if (target == player) return false;
                                    if (ui.selected.targets.length) {
                                        return ui.selected.targets[0] != target && !ui.selected.targets[0].hasSkillTag('noCompareSource') && target.countCards('h') && !target.hasSkillTag('noCompareTarget');
                                    }
                                    return true;
                                },
                                usable: 1,
                                targetprompt: ['发起者', '拼点目标'],
                                filterCard: true,
                                discard: false,
                                lose: false,
                                delay: false,
                                check(card) {
                                    if (_status.event.player.hp == 1) return 8 - get.value(card);
                                    return 6 - get.value(card);
                                },
                                selectTarget: 2,
                                multitarget: true,
                                content() {
                                    'step 0'
                                    player.give(cards, targets[0], 'give');
                                    'step 1'
                                    targets[0].chooseToCompare(targets[1]);
                                    'step 2'
                                    player.addTempSkill('dcjianshu_check', 'phaseUseAfter');
                                    if (result.bool) {
                                        var cards = targets[0].getCards('he');
                                        if (cards.length) player.gain(cards.randomGet(), targets[0], 'giveAuto');
                                        targets[1].loseHp();
                                    }
                                    else if (result.tie) {
                                        targets[0].loseHp();
                                        targets[1].loseHp();
                                    }
                                    else {
                                        var cards = targets[1].getCards('he');
                                        if (cards.length) player.gain(cards.randomGet(), targets[1], 'giveAuto');
                                        targets[0].loseHp();
                                    }
                                },
                                subSkill: {
                                    check: {
                                        trigger: { global: 'dieAfter' },
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        filter(event, player) {
                                            return event.getParent(3).name == 'minijianshu';
                                        },
                                        content() {
                                            delete player.getStat('skill').minijianshu;
                                        },
                                    },
                                },
                                ai: {
                                    expose: 0.4,
                                    order: 4,
                                    result: {
                                        target(player, target) {
                                            if (ui.selected.targets.length) return -1;
                                            return -0.5;
                                        },
                                    },
                                },
                            },
                            miniyongdi: {
                                unique: true,
                                audio: 'yongdi',
                                mark: true,
                                limited: true,
                                enable: 'phaseUse',
                                filterTarget: true,
                                animationColor: 'thunder',
                                skillAnimation: 'legend',
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniyongdi');
                                    if (!game.hasPlayer(current => current.maxHp < target.maxHp)) target.gainMaxHp();
                                    'step 1'
                                    if (target.isMinHp()) target.recover();
                                    'step 2'
                                    if (target.isMinHandcard()) target.draw(Math.min(5, target.maxHp));
                                    'step 3'
                                    game.delayx();
                                },
                                ai: {
                                    expose: 0.3,
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            var val = 0;
                                            var bool1 = !game.hasPlayer(current => current.maxHp < target.maxHp), bool2 = target.isMinHp(), bool3 = target.isMinHandcard();
                                            if (bool1) val += 5;
                                            if (bool2) {
                                                if (bool1) target.maxHp++;
                                                val += Math.max(0, get.recoverEffect(target, player, player));
                                                if (bool1) target.maxHp--;
                                            }
                                            if (bool3) {
                                                var num = Math.max(0, Math.min(5, target.maxHp + (bool1 ? 1 : 0)));
                                                val += 5 * num;
                                            }
                                            return val;
                                        },
                                    },
                                },
                            },
                            //尹夫人
                            miniyongbi: {
                                audio: 'dcyongbi',
                                inherit: 'dcyongbi',
                                filter(event, player) {
                                    return player.countCards('h') > 0;
                                },
                                filterTarget: lib.filter.notMe,
                                selectCard: [1, Infinity],
                                complexCard: true,
                                complexSelect: true,
                                check(card) {
                                    var player = _status.event.player;
                                    if (!ui.selected.cards.some(cardx => get.suit(card, player) == get.suit(cardx, player))) return 8 - get.value(card);
                                    return 0;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniyongbi');
                                    if (player.hasSkill('dcyingyu', null, null, false)) player.storage.dcyingyu = true;
                                    player.give(cards, target);
                                    'step 1'
                                    var list = [];
                                    for (var i of cards) {
                                        list.add(get.suit(i, player));
                                        if (list.length >= 3) break;
                                    }
                                    if (list.length >= 2) {
                                        player.addMark('dcyongbi_eff1', 2, false);
                                        player.addSkill('dcyongbi_eff1');
                                        target.addMark('dcyongbi_eff1', 2, false);
                                        target.addSkill('dcyongbi_eff1');
                                    }
                                    if (list.length >= 3) {
                                        player.addMark('dcyongbi_eff2', 1, false);
                                        player.addSkill('dcyongbi_eff2');
                                        target.addMark('dcyongbi_eff2', 1, false);
                                        target.addSkill('dcyongbi_eff2');
                                    }
                                },
                            },
                            //SP曹仁
                            miniweikui: {
                                audio: 'weikui',
                                enable: 'phaseUse',
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('h');
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.loseHp();
                                    player.viewHandcards(target);
                                    'step 1'
                                    if (target.countCards('h', { name: 'shan' })) player.gainPlayerCard(target, 'visible', true, 'h').set('ai', function (button) {
                                        return get.value(button.link, _status.event.target);
                                    });
                                    else {
                                        if (player.canUse({ name: 'sha', isCard: true }, target, false)) player.useCard({ name: 'sha', isCard: true }, target, false);
                                        player.storage.weikui2 = target;
                                        player.addTempSkill('weikui2');
                                        event.finish();
                                    }
                                    'step 2'
                                    player.recover();
                                },
                                ai: {
                                    order: 8,
                                    result: {
                                        target(player, target) {
                                            if (!target.countCards('h', { name: 'shan' })) {
                                                if (player.hp <= 2) return 0;
                                                if (player.hp == 3) return target.hp <= 2 ? -1 : 0;
                                            }
                                            return -1;
                                        },
                                    },
                                },
                            },
                            minilizhan: {
                                audio: 'lizhan',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(current => current.isDamaged());
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minilizhan'), [1, Infinity], function (card, player, target) {
                                        return target.isDamaged();
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        event.targets = targets;
                                        player.logSkill('minilizhan', targets);
                                        game.asyncDraw(targets);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var num = targets.filter(target => target.countCards('h') == target.getHp()).length;
                                    if (num) player.draw(num);
                                    else game.delayx();
                                },
                                ai: { threaten: 1.5 },
                            },
                            //郭嘉
                            minishenglun: {
                                audio: 'ext:活动武将/audio/skill:true',
                                enable: 'phaseUse',
                                filterTarget: lib.filter.notMe,
                                selectTarget: [1, 2],
                                usable: 1,
                                content() {
                                    'step 0'
                                    var list = [
                                        get.sgn(player.hp - target.hp),
                                        get.sgn(player.countCards('h') - target.countCards('h')),
                                        get.sgn(player.countCards('e', card => get.subtype(card) == 'equip1') - target.countCards('e', card => get.subtype(card) == 'equip1')),
                                        get.sgn(player.countCards('e', card => get.subtype(card) == 'equip2') - target.countCards('e', card => get.subtype(card) == 'equip2')),
                                        get.sgn(player.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))) - target.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card)))),
                                    ], num = 0;
                                    while (num < 5) {
                                        game.log('第' + get.cnNumber(num + 1, true) + '局', list[num] > 0 ? '#g成功' : '#y失败');
                                        player.addMark('minishenglun_' + (list[num] > 0 ? 'win' : 'lose'), 1, false);
                                        num++;
                                    }
                                    'step 1'
                                    if (player.countMark('minishenglun_win') >= 10) {
                                        player.recover();
                                        var next = game.createEvent('minishenglun_result');
                                        next.player = player;
                                        next.setContent(lib.skill.minishenglun.content_yiji);
                                        player.removeMark('minishenglun_win', player.countMark('minishenglun_win'), false);
                                    }
                                    'step 2'
                                    if (player.countMark('minishenglun_lose') >= 10) {
                                        player.chooseTarget('请选择【胜论】的目标', '对一名角色造成1点伤害', true).set('ai', target => get.damageEffect(target, _status.event.player, _status.event.player));
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        target.damage();
                                    }
                                    var next = game.createEvent('minishenglun_result');
                                    next.player = player;
                                    next.setContent(lib.skill.minishenglun.content_yiji);
                                    player.removeMark('minishenglun_lose', player.countMark('minishenglun_lose'), false);
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            var att = get.attitude(player, target);
                                            var num = get.sgn(att);
                                            var ref = get.recoverEffect(player, player, player);
                                            var def = game.filterPlayer().reduce((list, current) => {
                                                list.push(get.damageEffect(current, player, player));
                                                return list;
                                            }, []).sort((a, b) => b - a)[0];
                                            var sum = get.sgn(player.hp - target.hp) + get.sgn(player.countCards('h') - target.countCards('h')) +
                                                get.sgn(player.countCards('e', card => get.subtype(card) == 'equip1') - target.countCards('e', card => get.subtype(card) == 'equip1')) +
                                                get.sgn(player.countCards('e', card => get.subtype(card) == 'equip2') - target.countCards('e', card => get.subtype(card) == 'equip2')) +
                                                get.sgn(player.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))) - target.countCards('e', card => ['equip3', 'equip4'].includes(get.subtype(card))));
                                            if (((ref - def) * sum) > 0) return 2 * num;
                                            return num;
                                        },
                                    },
                                },
                                content_yiji() {
                                    'step 0'
                                    player.logSkill('new_reyiji');
                                    player.draw(2);
                                    if (_status.connectMode) game.broadcastAll(function () { _status.noclearcountdown = true });
                                    event.given_map = {};
                                    event.num = 2;
                                    'step 1'
                                    player.chooseCardTarget({
                                        filterCard(card) {
                                            return get.itemtype(card) == 'card' && !card.hasGaintag('reyiji_tag');
                                        },
                                        filterTarget: lib.filter.notMe,
                                        selectCard: [1, event.num],
                                        prompt: '请选择要分配的卡牌和目标',
                                        ai1(card) {
                                            if (!ui.selected.cards.length) return 1;
                                            return 0;
                                        },
                                        ai2(target) {
                                            var player = _status.event.player, card = ui.selected.cards[0];
                                            var val = target.getUseValue(card);
                                            if (val > 0) return val * get.attitude(player, target) * 2;
                                            return get.value(card, target) * get.attitude(player, target);
                                        },
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var res = result.cards, target = result.targets[0].playerid;
                                        player.addGaintag(res, 'reyiji_tag');
                                        event.num -= res.length
                                        if (!event.given_map[target]) event.given_map[target] = [];
                                        event.given_map[target].addArray(res);
                                        if (event.num > 0) event.goto(1);
                                    }
                                    else if (event.num == 2) {
                                        if (_status.connectMode) game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                                        event.finish();
                                    }
                                    'step 3'
                                    if (_status.connectMode) game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                                    var map = [], cards = [];
                                    for (var i in event.given_map) {
                                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, 'green');
                                        map.push([source, event.given_map[i]]);
                                        cards.addArray(event.given_map[i]);
                                    }
                                    game.loseAsync({
                                        gain_list: map,
                                        player: player,
                                        cards: cards,
                                        giver: player,
                                        animate: 'giveAuto',
                                    }).setContent('gaincardMultiple');
                                },
                                subSkill: {
                                    win: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '胜',
                                        intro: { content: '已胜利#次' },
                                    },
                                    lose: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '败',
                                        intro: { content: '已失败#次' },
                                    },
                                },
                            },
                            //曹洪
                            miniyuanhu: {
                                audio: 'yuanhu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hasCard({ type: 'equip' }, 'he');
                                },
                                filterCard: { type: 'equip' },
                                filterTarget(card, player, target) {
                                    var card = ui.selected.cards[0];
                                    return target.canEquip(card);
                                },
                                usable: 2,
                                discard: false,
                                lose: false,
                                prepare: 'give',
                                position: 'he',
                                check(card) {
                                    if (get.position(card) == 'h') return 9 - get.value(card);
                                    return 7 - get.value(card);
                                },
                                content() {
                                    'step 0'
                                    target.equip(cards[0]);
                                    player.draw();
                                    'step 1'
                                    event.goto(3);
                                    switch (get.subtype(cards[0])) {
                                        case 'equip1':
                                            if (game.hasPlayer(function (current) {
                                                return current != target && get.distance(target, current) == 1 && current.countCards('hej') > 0;
                                            })) {
                                                player.chooseTarget(true, '弃置一名距离' + get.translation(target) + '为1的角色区域内的一张牌', function (card, player, target) {
                                                    var current = _status.event.current;
                                                    return current != target && get.distance(current, target) == 1 && current.countCards('hej') > 0;
                                                }).set('current', target).set('ai', function (target) {
                                                    var player = _status.event.player;
                                                    return get.effect(target, { name: 'guohe_copy' }, player, player);
                                                });
                                                event.goto(2);
                                            }
                                            break;
                                        case 'equip2':
                                            target.draw();
                                            break;
                                        case 'equip3': case 'equip4':
                                            target.recover();
                                            break;
                                    }
                                    'step 2'
                                    var target = result.targets[0];
                                    player.line(target);
                                    player.discardPlayerCard(target, true, 'hej');
                                },
                                group: 'miniyuanhu_biyue',
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player, target) {
                                            if (get.attitude(player, target) == 0) return 0;
                                            if (!ui.selected.cards.length) return;
                                            var eff = get.effect(target, ui.selected.cards[0], player, player), sub = get.subtype(ui.selected.cards[0], false);
                                            if (target == player) eff += 4;
                                            else {
                                                var hp = player.hp, hs = player.countCards('h', (card) => card != ui.selected.cards[0]);
                                                var tp = target.hp, ts = target.countCards('h');
                                                if (sub == 'equip2') ts++;
                                                if (tp < target.maxHp && (sub == 'equip3' || sub == 'equip4')) tp++;
                                                if (tp <= hp || ts <= hs) eff += 2;
                                            }
                                            if (sub == 'equip1') {
                                                var list = game.filterPlayer(function (current) {
                                                    return current != target && get.distance(target, current) == 1 && current.countCards('hej') < 0;
                                                }).map(function (i) {
                                                    return get.effect(i, { name: 'guohe_copy' }, player, player);
                                                }).sort((a, b) => b - a);
                                                if (list.length) eff += list[0];
                                            }
                                            return eff;
                                        },
                                        target(player, target) {
                                            if (!ui.selected.cards.length) return 0;
                                            var sub = get.subtype(ui.selected.cards[0], false);
                                            var eff = get.effect(target, ui.selected.cards[0], player, target);
                                            if (sub == 'equip2') eff += (get.effect(target, { name: 'wuzhong' }, target, target) / 2);
                                            if (target.isDamaged() && (sub == 'equip3' || sub == 'equip4')) eff += get.recoverEffect(target, player, player);
                                            return eff;
                                        },
                                    },
                                },
                                subSkill: {
                                    biyue: {
                                        audio: 'yuanhu',
                                        trigger: { player: 'phaseEnd' },
                                        filter(event, player) {
                                            return !player.getHistory('useSkill', evt => evt.skill == 'miniyuanhu').length;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            var card = get.cardPile2(card => get.type(card) == 'equip');
                                            if (card) player.gain(card, 'gain2');
                                        },
                                    },
                                },
                            },
                            minijuezhu: {
                                unique: true,
                                limited: true,
                                audio: 'twjuezhu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hasEnabledSlot(3) || player.hasEnabledSlot(4);
                                },
                                skillAnimation: true,
                                animationColor: 'water',
                                filterTarget: true,
                                async content(event, trigger, player) {
                                    const target = event.target;
                                    player.awakenSkill('minijuezhu');
                                    let list = [], control;
                                    for (let i = 3; i <= 4; i++) {
                                        if (player.hasEnabledSlot(i)) list.push('equip' + i);
                                    }
                                    if (list.length == 1) control = list[0];
                                    else control = await player.chooseControl(list).set('prompt', '决助：请选择废除一个坐骑栏').forResult('control');
                                    if (control) {
                                        await player.disableEquip(control);
                                        player.addSkill('twjuezhu_restore');
                                        player.markAuto('twjuezhu_restore', [[target, control]]);
                                    }
                                    await target.addSkills('feiying');
                                    await target.disableJudge();
                                },
                                ai: {
                                    order: (item, player) => player.hasUnknown() ? 0 : 10,
                                    result: { target: 1 },
                                },
                                derivation: 'feiying',
                            },
                            //谋曹操
                            minisbjianxiong: {
                                audio: 'sbjianxiong',
                                inherit: 'sbjianxiong',
                                filter(event, player) {
                                    return get.itemtype(event.cards) == 'cards' && event.cards.some(i => get.position(i, true) == 'o') || 2 - player.countMark('sbjianxiong') > 0;
                                },
                                prompt2(event, player) {
                                    var gain = get.itemtype(event.cards) == 'cards' && event.cards.some(i => get.position(i, true) == 'o');
                                    var str = '', draw = 2 - player.countMark('sbjianxiong');
                                    if (gain) str += '获得' + get.translation(event.cards);
                                    if (gain && draw > 0) str += '并';
                                    if (draw > 0) str += '摸' + get.cnNumber(draw) + '张牌';
                                    if (player.countMark('sbjianxiong')) str += '，然后可以弃1枚“治世”标记';
                                    return str;
                                },
                                content() {
                                    'step 0'
                                    if (get.itemtype(trigger.cards) == 'cards' && trigger.cards.some(i => get.position(i, true) == 'o')) player.gain(trigger.cards, 'gain2');
                                    var num = player.countMark('sbjianxiong');
                                    if (2 - num > 0) player.draw(2 - num, 'nodelay');
                                    'step 1'
                                    var controls = [];
                                    if (player.countMark('sbjianxiong') < 2) controls.push('获得标记');
                                    if (player.hasMark('sbjianxiong')) controls.push('失去标记');
                                    player.chooseControl(controls, 'cancel2').set('prompt', '是否获得或失去1枚“治世”标记？').set('ai', () => {
                                        if (_status.event.controls.includes('失去标记')) {
                                            var player = _status.event.player, current = _status.currentPhase;
                                            if (get.distance(current, player, 'absolute') > 3 && player.hp <= 2) return '失去标记';
                                        }
                                        return (_status.event.controls.includes('获得标记') && Math.random() < 0.5) ? '获得标记' : 'cancel2';
                                    });
                                    'step 2'
                                    if (result.control != 'cancel2') player[result.control == '失去标记' ? 'removeMark' : 'addMark']('sbjianxiong', 1);
                                },
                            },
                            minisbqingzheng: {
                                audio: 'sbqingzheng',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return lib.suit.filter(suitx => player.countCards('h', { suit: suitx })).length >= (3 - player.countMark('sbjianxiong'));
                                },
                                usable: 1,
                                chooseButton: {
                                    dialog(event, player) {
                                        return ui.create.dialog(
                                            '###清正###<div class="text center">弃置' + get.cnNumber(3 - player.countMark('sbjianxiong')) + '种花色的所有手牌并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记。</div>',
                                            [lib.suit.map(i => ['', '', 'lukai_' + i]), 'vcard'], 'hidden');
                                    },
                                    select: () => 3 - _status.event.player.countMark('sbjianxiong'),
                                    /*
                                    filter:function(button){
                                    var player=_status.event.player;
                                    return player.countCards('h',card=>get.suit(card,player)==button.link[2].slice(6));
                                    },
                                    */
                                    check(button) {
                                        var player = _status.event.player;
                                        return player.countMark('sbjianxiong') * 15 - player.getCards('h', { suit: button.link[2].slice(6) }).map(i => get.value(i)).reduce((p, c) => p + c, 0);
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: 'sbqingzheng',
                                            suits: links.map(i => i[2].slice(6)),
                                            filterTarget(card, player, target) {
                                                return target != player && target.countCards('h');
                                            },
                                            filterCard: () => false,
                                            selectCard: -1,
                                            content() {
                                                'step 0'
                                                var suits = lib.skill.minisbqingzheng_backup.suits;
                                                const popup = suits.slice().sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b)).reduce((str, suit) => str + get.translation(suit), '');
                                                player.popup(popup);
                                                game.log(player, '选择了花色', '#g' + popup);
                                                var cards = player.getCards('h', card => suits.includes(get.suit(card, player)));
                                                event.cards = cards;
                                                if (cards.length) player.discard(cards);
                                                'step 1'
                                                var list = [];
                                                var dialog = ['清正：弃置' + get.translation(target) + '一种花色的所有牌'];
                                                for (var suit of lib.suit.concat('none')) {
                                                    if (target.countCards('h', { suit: suit })) {
                                                        dialog.push('<div class="text center">' + get.translation(suit + '2') + '牌</div>');
                                                        dialog.push(target.getCards('h', { suit: suit }));
                                                        list.push(suit);
                                                    }
                                                }
                                                if (list.length) {
                                                    player.chooseControl(list).set('dialog', dialog).set('ai', () => {
                                                        return _status.event.control;
                                                    }).set('control', (() => {
                                                        var getv = (cards) => cards.map(i => get.value(i)).reduce((p, c) => p + c, 0);
                                                        return list.sort((a, b) => getv(target.getCards('h', { suit: b })) - getv(target.getCards('h', { suit: a })))[0];
                                                    })());
                                                }
                                                else {
                                                    event.cards2 = [];
                                                    event.goto(3);
                                                }
                                                'step 2'
                                                var cards2 = target.getCards('h', { suit: result.control });
                                                event.cards2 = cards2;
                                                target.discard(cards2, 'notBySelf').set('discarder', player);
                                                'step 3'
                                                if (event.cards2.length < cards.length) target.damage();
                                                'step 4'
                                                var controls = [];
                                                if (player.countMark('sbjianxiong') < 2) controls.push('获得标记');
                                                if (player.hasMark('sbjianxiong')) controls.push('失去标记');
                                                player.chooseControl(controls, 'cancel2').set('prompt', '是否获得或失去1枚“治世”标记？').set('ai', () => {
                                                    if (_status.event.controls.includes('失去标记')) {
                                                        var player = _status.event.player, current = _status.currentPhase;
                                                        if (get.distance(current, player, 'absolute') > 3 && player.hp <= 2) return '失去标记';
                                                    }
                                                    return (_status.event.controls.includes('获得标记') && Math.random() < 0.5) ? '获得标记' : 'cancel2';
                                                });
                                                'step 5'
                                                if (result.control != 'cancel2') player[result.control == '失去标记' ? 'removeMark' : 'addMark']('sbjianxiong', 1);
                                            },
                                            ai: {
                                                result: {
                                                    target(player, target) {
                                                        var att = get.attitude(player, target);
                                                        return att > 0 ? 0 : (1 - (get.sgn(get.effect(target, { name: 'guohe_copy2' }, player, player)) * Math.sqrt(target.countCards('h'))));
                                                    },
                                                },
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        const popup = links.map(i => i[2].slice(6)).sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b)).reduce((str, suit) => str + get.translation(suit), '');
                                        return '###清正###弃置' + popup + '花色的所有手牌并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记';
                                    },
                                },
                                ai: {
                                    combo: 'minisbjianxiong',
                                    order(item, player) {
                                        var getNum = function (player, target) {
                                            return get.attitude(player, target) > 0 ? 0 : (get.sgn(get.effect(target, { name: 'guohe_copy2' }, player, player)) * Math.sqrt(target.countCards('h')));
                                        };
                                        var targets = game.filterPlayer(current => current != player && current.countCards('h'));
                                        if (!targets.length) return 0;
                                        targets.sort((a, b) => getNum(player, b) - getNum(player, a));
                                        if (getNum(player, targets[0]) <= 0) return 0;
                                        return targets[0].countCards('h') + 3;
                                    },
                                    result: { player: 1 },
                                },
                            },
                            //蛋神
                            minigongao: {
                                audio: 'gongao',
                                inherit: 'regongao',
                                filter(event, player) {
                                    return event.player != player;
                                },
                            },
                            minijuyi: {
                                audio: 'juyi',
                                trigger: {
                                    player: 'phaseZhunbeiBegin',
                                },
                                filter(event, player) {
                                    return player.maxHp > game.countPlayer();
                                },
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'thunder',
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    await player.drawTo(player.maxHp);
                                    await player.addSkills(get.info(event.name).derivation);
                                },
                                derivation: ['minibenghuai', 'reweizhong'],
                            },
                            //卞夫人
                            miniyuejian: {
                                audio: 'yuejian',
                                mod: { maxHandcard: (player, num) => num + player.maxHp },
                                locked: false,
                                enable: 'chooseToUse',
                                hiddenCard(player, name) {
                                    if (get.type(name) == 'basic' && lib.inpile.includes(name) && !player.hasSkill('miniyuejian_used')) return true;
                                },
                                filter(event, player) {
                                    if (event.type == 'wuxie') return false;
                                    if (player.hasSkill('miniyuejian_used')) return false;
                                    for (var i of lib.inpile) {
                                        if (get.type(i) != 'basic') continue;
                                        var card = { name: i, isCard: true };
                                        if (event.filterCard(card, player, event)) return true;
                                        if (i == 'sha') {
                                            for (var j of lib.inpile_nature) {
                                                card.nature = j;
                                                if (event.filterCard(card, player, event)) return true;
                                            }
                                        }
                                    }
                                    return false;
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        for (var i of lib.inpile) {
                                            if (get.type(i) != 'basic') continue;
                                            var card = { name: i, isCard: true };
                                            if (event.filterCard(card, player, event)) list.push(['基本', '', i]);
                                            if (i == 'sha') {
                                                for (var j of lib.inpile_nature) {
                                                    card.nature = j;
                                                    if (event.filterCard(card, player, event)) list.push(['基本', '', i, j]);
                                                }
                                            }
                                        }
                                        return ui.create.dialog('约俭', [list, 'vcard'], 'hidden');
                                    },
                                    check(button) {
                                        if (button.link[2] == 'shan') return 3;
                                        var player = _status.event.player;
                                        if (button.link[2] == 'jiu') {
                                            if (player.getUseValue({ name: 'jiu' }) <= 0) return 0;
                                            if (player.countCards('h', 'sha')) return player.getUseValue({ name: 'jiu' });
                                            return 0;
                                        }
                                        return player.getUseValue({ name: button.link[2], nature: button.link[3], isCard: true });
                                    },
                                    backup(links, player) {
                                        return {
                                            selectCard: -1,
                                            filterCard: () => false,
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                                isCard: true,
                                            },
                                            precontent() {
                                                player.logSkill('miniyuejian');
                                                delete event.result.skill;
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        var name = links[0][2];
                                        var nature = links[0][3];
                                        return '视为使用' + (get.translation(nature) || '') + get.translation(name);
                                    },
                                },
                                ai: {
                                    order(item, player) {
                                        if (player && _status.event.type == 'phase') {
                                            var max = 0, add = false;
                                            var list = lib.inpile.filter(name => get.type(name) == 'basic');
                                            if (list.includes('sha')) add = true;
                                            list = list.map(namex => { return { name: namex, isCard: true } });
                                            if (add) {
                                                lib.inpile_nature.forEach(naturex => list.push({ name: 'sha', nature: naturex, isCard: true }));
                                            }
                                            for (var card of list) {
                                                if (player.getUseValue(card) > 0) {
                                                    var temp = get.order(card);
                                                    if (temp > max) max = temp;
                                                }
                                            }
                                            if (max > 0) max += 0.3;
                                            return max;
                                        }
                                        return 10;
                                    },
                                    respondShan: true,
                                    respondSha: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg == 'respond') return false;
                                        return !player.hasSkill('miniyuejian_used');
                                    },
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                group: 'miniyuejian_count',
                                //联机の痛！！！！！！
                                init(player) {
                                    if (!player.hasSkill('miniyuejian_used') && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').length) player.addTempSkill('miniyuejian_used');
                                },
                                subSkill: {
                                    used: { charlotte: true },
                                    count: {
                                        charlotte: true,
                                        trigger: { player: 'useCard1' },
                                        filter(event, player) {
                                            return !player.hasSkill('miniyuejian_used') && get.type(event.card) == 'basic';
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        content() {
                                            player.addTempSkill('miniyuejian_used');
                                        },
                                    },
                                },
                            },
                            //于禁
                            minixiayuan: {
                                audio: 'sbxiayuan',
                                trigger: { global: 'dying' },
                                filter(event, player) {
                                    return event.player != player && !player.hasSkill('minixiayuan_used') && player.countCards('he');
                                },
                                direct: true,
                                *content(event, map) {
                                    var player = map.player;
                                    var target = map.trigger.player;
                                    var result = yield player.chooseToDiscard(get.prompt2('minixiayuan', target), 'he', [1, 2]).set('ai', card => {
                                        var player = _status.event.player, target = _status.event.target;
                                        if (get.attitude(player, target) <= 0) return 0;
                                        return 7 - get.value(card);
                                    }).set('target', target).set('logSkill', ['minixiayuan', target]);
                                    if (result.bool) {
                                        player.addTempSkill('minixiayuan_used', 'roundStart');
                                        target.recover(result.cards.length);
                                    }
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            minijieyue: {
                                derivation: ['minijieyue_junling1', 'minijieyue_junling2', 'minijieyue_junling3', 'minijieyue_junling4'],
                                getJunLingEffect: (player, target, junling) => {
                                    var att = get.attitude(player, target);
                                    switch (junling) {
                                        case 'minijieyue_junling1':
                                            return game.filterPlayer().map(aim => get.damageEffect(aim, target, player) * (2 - get.sgn(att))).sort((a, b) => b - a)[0];
                                            break;
                                        case 'minijieyue_junling2':
                                            if (att > 0) return 0;
                                            var num = 0;
                                            if (target.countCards('h', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target))) {
                                                player.addSkill('minijieyue_checkh');
                                                num += get.effect(target, { name: 'guohe_copy2' }, player, player);
                                                player.removeSkill('minijieyue_checkh');
                                            }
                                            if (target.countCards('e', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target))) {
                                                player.addSkill('minijieyue_checke');
                                                num += get.effect(target, { name: 'guohe_copy2' }, player, player);
                                                player.removeSkill('minijieyue_checke');
                                            }
                                            return num;
                                            break;
                                        case 'minijieyue_junling3':
                                            if (att > 0) return 0;
                                            return Math.max(0, 3 - target.getHp());
                                            break;
                                        case 'minijieyue_junling4':
                                            if (att > 0) return 0;
                                            return Math.sqrt(target.countCards('h'));
                                            break;
                                    }
                                },
                                audio: 'sbjieyue',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minijieyue'), lib.filter.notMe).set('ai', target => {
                                        var player = _status.event.player;
                                        return function (player, target) {
                                            var max = 0;
                                            for (var i = 1; i <= 4; i++) {
                                                var temp = lib.skill.minijieyue.getJunLingEffect(player, target, 'minijieyue_junling' + i);
                                                if (temp > max) max = temp;
                                            }
                                            return max;
                                        }(player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minijieyue', target);
                                        target.draw();
                                        event.cards = [1, 2, 3, 4]/*.randomGets(2).sort((a,b)=>a-b)*/.map(num => 'minijieyue_junling' + num);
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.chooseButton(['###节钺###请选择' + get.translation(target) + '执行的军令', [cards, 'vcard']], true).set('ai', button => {
                                        var player = _status.event.player, target = _status.event.target;
                                        return lib.skill.minijieyue.getJunLingEffect(player, target, button.link[2]);
                                    }).set('target', target);
                                    'step 3'
                                    if (result.bool) {
                                        var junling = result.links[0][2];
                                        event.junling = junling;
                                        game.log(player, '选择了', '#y' + get.translation(junling));
                                        if (event.junling == 'minijieyue_junling1') {
                                            player.chooseTarget('军令一：请选择' + get.translation(target) + '造成伤害的目标', true).set('ai', aim => {
                                                var player = _status.event.player, target = _status.event.target;
                                                return get.damageEffect(aim, target, player);
                                            }).set('target', target);
                                        }
                                    }
                                    'step 4'
                                    if (event.junling == 'minijieyue_junling1') {
                                        if (result.bool) event.aim = result.targets[0];
                                        else {
                                            event._result = { bool: false };
                                            return;
                                        }
                                    }
                                    var str = [
                                        '对' + get.translation(event.aim) + '造成1点伤害',
                                        '随机弃置一张手牌和装备牌',
                                        '本回合不能回复体力',
                                        '本回合不能使用或打出手牌且所有非锁定技失效',
                                    ][parseInt(event.junling.slice('minijieyue_junling'.length)) - 1];
                                    target.chooseBool('节钺：是否执行' + get.translation(event.junling) + '？', str).set('choice', function () {
                                        switch (event.junling) {
                                            case 'minijieyue_junling1':
                                                return get.damageEffect(event.aim, target, target) >= 0;
                                                break;
                                            case 'minijieyue_junling2':
                                                if (!target.countCards('he')) return true;
                                                var cards1 = target.getCards('h', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target));
                                                var cards2 = target.getCards('e', card => get.value(card) >= 7 && lib.filter.cardDiscardable(card, target));
                                                return cards1.length * 2 < target.countCards('h', card => lib.filter.cardDiscardable(card, target)) && cards2.length * 2 < target.countCards('e', card => lib.filter.cardDiscardable(card, target));
                                                break;
                                            case 'minijieyue_junling3': case 'minijieyue_junling4':
                                                if (target.hp > 3) return true;
                                                return !target.countCards('hes', card => {
                                                    if (target.canSaveCard(card, target)) return true;
                                                    if (event.junling == 'minijieyue_junling4' && (get.name(card) == 'wuxie' || get.name(card) == 'caochuanjiejian')) return true;
                                                    return false;
                                                });
                                                break;
                                            default:
                                                return false;
                                                break;
                                        }
                                    }());
                                    'step 5'
                                    if (result.bool) {
                                        game.log(target, '#g选择执行', '#y' + get.translation(event.junling));
                                        switch (event.junling) {
                                            case 'minijieyue_junling1':
                                                target.line(event.aim);
                                                event.aim.damage(1, target);
                                                break;
                                            case 'minijieyue_junling2':
                                                var cards = [];
                                                var cards1 = target.getCards('h', card => lib.filter.cardDiscardable(card, target));
                                                if (cards1.length) cards.push(cards1.randomGet());
                                                var cards2 = target.getCards('he', card => get.type(card) == 'equip' && !cards.includes(card) && lib.filter.cardDiscardable(card, target));
                                                if (cards2.length) cards.push(cards2.randomGet());
                                                if (cards.length) target.discard(cards);
                                                break;
                                            case 'minijieyue_junling3':
                                                target.addTempSkill('minijieyue_junling3');
                                                break;
                                            case 'minijieyue_junling4':
                                                target.addTempSkill('minijieyue_junling4');
                                                target.addTempSkill('fengyin');
                                                break;
                                        }
                                        player.draw();
                                    }
                                    else {
                                        target.chat('拒绝');
                                        game.log(target, '#y拒绝执行', '#g' + get.translation(event.junling));
                                        player.draw(3);
                                        target.addTempSkill('minijieyue_damage');
                                        target.addMark('minijieyue_damage', 1, false);
                                    }
                                    target.addExpose(0.15);
                                },
                                subSkill: {
                                    checkh: {
                                        charlotte: true,
                                        global: 'minijieyue_check1',
                                    },
                                    checke: {
                                        charlotte: true,
                                        global: 'minijieyue_check2',
                                    },
                                    check1: {
                                        mod: {
                                            canBeDiscarded(card, player, target) {
                                                if (player.hasSkill('minijieyue_checkh') && get.position(card) == 'h') return false;
                                            },
                                        },
                                    },
                                    check2: {
                                        mod: {
                                            canBeDiscarded(card, player, target) {
                                                if (player.hasSkill('minijieyue_checke') && get.position(card) == 'e') return false;
                                            },
                                        },
                                    },
                                    junling3: {
                                        charlotte: true,
                                        mark: true,
                                        intro: '令',
                                        intro: { content: '不能回复体力' },
                                        trigger: { player: 'recoverBefore' },
                                        forced: true,
                                        content() {
                                            trigger.cancel();
                                        },
                                        ai: {
                                            threaten: 10,
                                            effect: {
                                                target(card, player, target) {
                                                    if (get.tag(card, 'recover')) return 'zeroplayertarget';
                                                },
                                            },
                                        },
                                    },
                                    junling4: {
                                        charlotte: true,
                                        mark: true,
                                        intro: '令',
                                        intro: { content: '不能使用或打出手牌' },
                                        trigger: { player: 'recoverBefore' },
                                        mod: {
                                            cardEnabled2(card) {
                                                if (get.position(card) == 'h') return false;
                                            },
                                        },
                                        ai: { threaten: 10 },
                                    },
                                    damage: {
                                        charlotte: true,
                                        onremove: true,
                                        trigger: { player: 'damageBegin3' },
                                        forced: true,
                                        content() {
                                            trigger.num += player.countMark('minijieyue_damage');
                                        },
                                        ai: { threaten: 10 },
                                        intro: { content: '受到的伤害+#' },
                                    },
                                },
                            },
                            //乐进
                            minixiaoguo: {
                                audio: 'xiaoguo',
                                trigger: { global: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return event.player.isIn() && event.player != player && player.countCards('he', card => {
                                        if (_status.connectMode && get.position(card) == 'h') return true;
                                        return lib.filter.cardDiscardable(card, player);
                                    });
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const { result: { bool } } = await player.chooseToDiscard(get.prompt2('minixiaoguo', trigger.player), 'he').set('ai', card => {
                                        return _status.event.eff - get.useful(card);
                                    }).set('logSkill', ['minixiaoguo', trigger.player]).set('eff', (() => {
                                        if (trigger.player.hasSkillTag('noe')) return get.attitude(_status.event.player, trigger.player);
                                        return get.damageEffect(trigger.player, player, _status.event.player);
                                    })());
                                    if (bool) {
                                        if (get.mode() !== 'identity' || player.identity !== 'nei') player.addExpose(0.15);
                                        const { result: { bool } } = await trigger.player.chooseToDiscard('he', '骁果：请选择一项', { type: 'equip' }).set('prompt2', ((source) => {
                                            let target = get.translation(source);
                                            let str = '①弃置一张装备牌，令' + target + '摸一张牌，直到你的下个结束阶段，' + target + '对你造成伤害时摸一张牌。';
                                            str += '<br>②受到' + target + '对你造成的1点伤害，直到你的下个结束阶段，' + target + '对你使用【杀】造成的伤害+1。';
                                            return '<span class="text center">' + str + '</span>';
                                        })(player)).set('ai', card => {
                                            if (_status.event.damage > 0) return 0;
                                            if (_status.event.noe) return 12 - get.value(card);
                                            return 2 * _status.event.damage - get.value(card);
                                        }).set('damage', get.damageEffect(trigger.player, player, trigger.player)).set('noe', trigger.player.hasSkillTag('noe'));
                                        if (bool) {
                                            await player.draw();
                                            player.addSkill('minixiaoguo_buff1');
                                            player.markAuto('minixiaoguo_buff1', [trigger.player]);
                                        }
                                        else {
                                            await trigger.player.damage();
                                            player.addSkill('minixiaoguo_buff2');
                                            player.markAuto('minixiaoguo_buff2', [trigger.player]);
                                        }
                                        player.when({ global: 'phaseJieshuBefore' })
                                            .filter(evt => player.getStorage('minixiaoguo_buff1').concat(player.getStorage('minixiaoguo_buff2')).includes(evt.player))
                                            .then(() => {
                                                const target = trigger.player;
                                                for (const skill of ['minixiaoguo_buff1', 'minixiaoguo_buff2']) {
                                                    if (player.getStorage(skill).includes(target)) {
                                                        player.unmarkAuto(skill, [target]);
                                                        if (!player.getStorage(skill).length) player.removeSkill(skill);
                                                    }
                                                }
                                            });
                                    }
                                },
                                subSkill: {
                                    buff1: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '骁',
                                        intro: { content: '对$造成伤害时摸一张牌' },
                                        trigger: { source: 'damageBegin2' },
                                        filter(event, player) {
                                            return player.getStorage('minixiaoguo_buff1').includes(event.player);
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    buff2: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '果',
                                        intro: { content: '使用【杀】对$造成的伤害+1' },
                                        trigger: { player: 'useCardToTargeted' },
                                        filter(event, player) {
                                            return event.card.name == 'sha' && player.getStorage('minixiaoguo_buff2').includes(event.target);
                                        },
                                        forced: true,
                                        logTarget: 'target',
                                        content() {
                                            var id = trigger.target.playerid;
                                            var map = trigger.getParent().customArgs;
                                            if (!map[id]) map[id] = {};
                                            if (typeof map[id].extraDamage != 'number') map[id].extraDamage = 0;
                                            map[id].extraDamage++;
                                        },
                                    },
                                },
                            },
                            //蒋干
                            miniweicheng: {
                                audio: 'weicheng',
                                inherit: 'weicheng',
                                filter(event, player) {
                                    if (player.getHp() < player.countCards('h')) return false;
                                    if (event.name == 'loseAsync') {
                                        if (event.type != 'gain') return false;
                                        var cards = event.getl(player).hs;
                                        return game.hasPlayer(function (current) {
                                            if (current == player) return false;
                                            var cardsx = event.getg(current);
                                            for (var i of cardsx) {
                                                if (cards.includes(i)) return true;
                                            }
                                            return false;
                                        });
                                    }
                                    if (event.player == player) return false;
                                    var evt = event.getl(player);
                                    return evt?.hs?.length > 0;
                                },
                            },
                            minidaoshu: {
                                audio: 'daoshu',
                                inherit: 'daoshu',
                                filter(event, player) {
                                    return !player.hasSkill('minidaoshu_used');
                                },
                                async content(event, trigger, player) {
                                    const target = event.target;
                                    const { result: { control } } = await player.chooseControl(lib.suit).set('prompt', '请选择一个花色').set('ai', () => lib.suit.randomGet());
                                    const suit = control;
                                    player.popup(suit + 2);
                                    game.log(player, '选择了', event.suit + 2);
                                    const { result: { bool, cards } } = await player.gainPlayerCard(target, true, 'h', 'visibleMove');
                                    if (bool) {
                                        const suit2 = get.suit(cards[0]);
                                        if (suit2 == suit) target.damage();
                                        else {
                                            player.addTempSkill('minidaoshu_used', 'phaseUseEnd');
                                            if (player.countCards('h')) {
                                                const { result: { bool, cards, targets } } = await player.chooseCardTarget({
                                                    prompt: '盗书：将一张手牌交给一名其他角色',
                                                    filterCard: true,
                                                    position: 'h',
                                                    forced: true,
                                                    filterTarget: lib.filter.notMe,
                                                    ai1(card) {
                                                        if (card.name == 'du') return 10;
                                                        var player = _status.event.player;
                                                        if (!game.hasPlayer(current => {
                                                            return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                                        })) return 0;
                                                        return 1 / Math.max(0.1, get.value(card));
                                                    },
                                                    ai2(target) {
                                                        var player = _status.event.player, att = get.attitude(player, target);
                                                        if (ui.selected.cards[0].name == 'du') return -att;
                                                        if (target.hasSkillTag('nogain')) att /= 6;
                                                        return att;
                                                    },
                                                });
                                                if (bool) {
                                                    player.line(targets[0]);
                                                    await targets[0].gain(cards, player, 'giveAuto');
                                                }
                                            }
                                        }
                                    }
                                },
                            },
                            minishefu: {
                                audio: 'shefu',
                                trigger: { player: ['phaseJieshuBegin', 'damageEnd'] },
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const list = get.inpileVCardList(info => {
                                        if (info[2] == 'sha' && info[3]) return false;
                                        return info[0] != 'equip';
                                    });
                                    let dialog = [get.prompt('minishefu'), '<div class="text center">选择一个牌名和一张手牌组成「伏兵」</div>'];
                                    dialog.push('<div class="text center">牌名选择</div>');
                                    dialog.push([list, 'vcard']);
                                    dialog.push('<div class="text center">手牌区</div>');
                                    dialog.push([player.getCards('h'), 'vcard']);
                                    const { result: { bool, links } } = await player.chooseButton(dialog, 2).set('ai', button => {
                                        const player = get.event('player');
                                        if (!get.owner(button.link)) {
                                            switch (button.link[2]) {
                                                case 'sha': return 5 + Math.random();
                                                case 'tao': return 4 + Math.random();
                                                case 'lebu': return 3 + Math.random();
                                                case 'shan': return 4.5 + Math.random();
                                                case 'wuzhong': return 4 + Math.random();
                                                case 'shunshou': return 3 + Math.random();
                                                case 'nanman': return 2 + Math.random();
                                                case 'wanjian': return 2 + Math.random();
                                                default: return Math.random();
                                            }
                                        }
                                        return 7.5 - get.value(button.link);
                                    }).set('filterButton', button => {
                                        const player = get.event('player');
                                        if (!get.owner(button.link) && player.getStorage('minishefu').map(i => i[1]).includes(button.link[2])) return false;
                                        return !ui.selected.buttons.length || get.owner(ui.selected.buttons[0].link) != get.owner(button.link);
                                    });
                                    if (bool) {
                                        player.logSkill('minishefu');
                                        let fjks = links.slice();//伏击狂神[doge]
                                        if (get.owner(fjks[0])) fjks.reverse();
                                        player.addToExpansion([fjks[1]], player, 'give').gaintag.add('minishefu');
                                        player.markAuto('minishefu', [[[get.translation(fjks[0][2]), '', fjks[1].name, fjks[1].nature], fjks[0][2], fjks[1],]]);
                                    }
                                },
                                onremove(player, skill) {
                                    const cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                marktext: '伏',
                                intro: {
                                    name: '伏兵',
                                    content: 'expansion',
                                    markcount: 'expansion',
                                    mark(dialog, content, player) {
                                        if (content?.length) {
                                            if (player.isUnderControl(true)) dialog.addSmall([content.map(i => i[0]), 'vcard']);
                                            else dialog.addAuto(player.getExpansions('minishefu'));
                                        }
                                    },
                                },
                                ai: { threaten: 2 },
                                group: 'minishefu_kanpo',
                                subSkill: {
                                    kanpo: {
                                        audio: 'shefu',
                                        trigger: { global: 'useCard' },
                                        filter(event, player) {
                                            return _status.currentPhase != player && event.player != player && player.getStorage('minishefu').some(i => i[1] == event.card.name);
                                        },
                                        check(event, player) {
                                            return get.info('sbkanpo').subSkill.kanpo.check(event, player);
                                        },
                                        prompt2(event, player) {
                                            return '令' + get.translation(event.card) + '无效' + (event.player == _status.currentPhase ? ('，然后本回合' + get.translation(event.player) + '所有技能失效') : '');
                                        },
                                        logTarget: 'player',
                                        content() {
                                            const removes = player.getStorage('minishefu').filter(i => i[1] == trigger.card.name);
                                            const cards = removes.map(i => i[2]);
                                            player.unmarkAuto('minishefu', removes);
                                            player.loseToDiscardpile(cards);
                                            trigger.targets.length = 0;
                                            trigger.all_excluded = true;
                                            if (trigger.player == _status.currentPhase) trigger.player.addTempSkill('baiban');
                                        },
                                        ai: { expose: 0.3 },
                                    },
                                },
                            },
                            minibenyu: {
                                audio: 'benyu',
                                trigger: { player: 'damageEnd' },
                                filter(event, player) {
                                    const target = event.source;
                                    if (!target || !target.isIn()) return false;
                                    return player.countCards('h') < Math.min(5, target.countCards('h')) || player.countCards('h');
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const target = trigger.source;
                                    const num = Math.min(5, target.countCards('h')) - player.countCards('h');
                                    let choice = [], choiceList = [];
                                    if (num > 0) {
                                        choice.push('摸牌');
                                        choiceList.push('摸' + get.cnNumber(num) + '张牌');
                                    }
                                    if (player.countDiscardableCards(player, 'h')) {
                                        choice.push('弃牌');
                                        choiceList.push('弃置一张手牌，对' + get.translation(target) + '造成1点伤害');
                                    }
                                    const { result: { control } } = await player.chooseControl(choice, 'cancel2')
                                        .set('prompt', get.prompt('benyu', target)).set('choiceList', choiceList)
                                        .set('ai', () => {
                                            const player = get.event('player'), target = get.event('target');
                                            const num = get.event('num'), controls = get.event('controls').filter(i => i != 'cancel2');
                                            const def = get.damageEffect(target, player, player);
                                            if (controls.length == 1) {
                                                if (controls[0] == '摸牌') return '摸牌';
                                                return def > 0 ? '弃牌' : 'cancel2';
                                            }
                                            return get.effect(player, { name: 'draw' }, player, player) * num > def ? '摸牌' : '弃牌';
                                        }).set('num', num).set('target', target);
                                    if (control != 'cancel2') {
                                        if (control == '摸牌') {
                                            player.logSkill('minibenyu', target);
                                            await player.draw(num);
                                        }
                                        else {
                                            await player.chooseToDiscard('h', true).set('logSkill', ['minibenyu', target]);
                                            await target.damage();
                                        }
                                    }
                                },
                            },
                            //徐晃
                            minisbduanliang: {
                                audio: 'sbduanliang',
                                enable: 'phaseUse',
                                usable: 2,
                                logAudio: () => 1,
                                filterTarget: lib.filter.notMe,
                                async content(event, trigger, player) {
                                    const target = event.target;
                                    player.removeGaintag('minisbduanliang_tag');
                                    await player.draw().set('gaintag', ['minisbduanliang_tag']);
                                    const card = player.getCards('he', card => card.hasGaintag('minisbduanliang_tag'))[0];
                                    const { result } = await player.chooseToDuiben(target).set('namelist', [
                                        '固守城池', '突出重围', '围城断粮', '擂鼓进军'
                                    ]).set('ai', button => {
                                        const source = _status.event.getParent().player, target = _status.event.getParent().target;
                                        if (get.effect(target, { name: 'juedou' }, source, source) >= 10 && button.link[2] == 'db_def2' && Math.random() < 0.5) return 10;
                                        return 1 + Math.random();
                                    }).set('sourceSkill', 'sbduanliang');
                                    if (result.bool) {
                                        if (result.player == 'db_def1') {
                                            if (target.hasJudge('bingliang')) await player.gainPlayerCard(target, 'he', true);
                                            else if (card && player.canUse(get.autoViewAs({ name: 'bingliang' }, [card]), target, false)) await player.useCard({ name: 'bingliang' }, target, [card], false);
                                        }
                                        else {
                                            const juedou = { name: 'juedou', isCard: true };
                                            if (player.canUse(juedou, target, false)) await player.useCard(juedou, target, false);
                                        }
                                    }
                                },
                                get ai() {
                                    return get.info('sbduanliang').ai || {};
                                },
                                init() {
                                    if (!_status.miniMouYi) {
                                        _status.miniMouYi = true;
                                        lib.skill.minisbtieji.initMouYi();
                                    }
                                },
                            },
                            //阮瑀
                            minixingzuo: {
                                audio: 'xingzuo',
                                inherit: 'xingzuo',
                                async content(event, trigger, player) {
                                    player.addTempSkill('minixingzuo_effect');
                                    const next = game.cardsGotoOrdering(get.bottomCards(3));
                                    await next;
                                    const result = await (() => {
                                        const cards = next.cards, next2 = player.chooseToMove('兴作：将三张牌置于牌堆底');
                                        const list = [['牌堆底', cards]], hs = player.getCards('h');
                                        if (hs.length) {
                                            list.push(['手牌', hs]);
                                            next2.set('filterMove', (_, to) => typeof to !== 'number');
                                        }
                                        next2.set('list', list);
                                        next2.set('processAI', list => {
                                            const player = get.player(), getv = button => {
                                                if (button.name == 'sha' && allcards.filter(function (card) {
                                                    return card.name == 'sha' && !cards.filter(function () {
                                                        return button == card;
                                                    }).length;
                                                }).length > player.getCardUsable({ name: 'sha' })) return 10;
                                                return -player.getUseValue(button, player);
                                            };
                                            let allcards = list[0][1].slice(0), cards = [];
                                            if (list.length > 1) allcards = allcards.concat(list[1][1]);
                                            let canchoose = allcards.slice(0);
                                            while (cards.length < 3) {
                                                canchoose.sort((a, b) => getv(b) - getv(a));
                                                cards.push(canchoose.shift());
                                            }
                                            return [cards, canchoose];
                                        });
                                        return next2;
                                    })().forResult();
                                    if (result.bool) {
                                        event.forceDie = true;
                                        const hs = player.getCards('h'), cards = result.moved[0];
                                        player.storage.minixingzuo_effect = cards;
                                        const lose = cards.filter(i => hs.includes(i)), gain = next.cards.slice().removeArray(cards.filter(i => !hs.includes(i)));
                                        if (lose.length) await player.lose(lose, ui.cardPile);
                                        if (gain.length) await player.gain(gain, 'draw');
                                        for (const i of cards) {
                                            if (!(('hejsdx').includes(get.position(i, true)))) {
                                                i.fix();
                                                ui.cardPile.appendChild(i);
                                            }
                                        }
                                        game.updateRoundNumber();
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        audio: 'xingzuo',
                                        inherit: 'xingzuo2',
                                        content() {
                                            'step 0'
                                            player.chooseTarget(function (card, player, target) {
                                                return target.countCards('h') > 0;
                                            }, '兴作：是否令一名角色将其手牌与牌堆底的三张牌替换？').set('ai', function (target) {
                                                var player = _status.event.player, att = get.attitude(player, target), hs = target.getCards('h'), num = hs.length;
                                                var getv = function (list, target) {
                                                    var num = 0;
                                                    for (var i of list) num += get.value(i, target);
                                                    return num;
                                                }, val = getv(hs, target) - getv(player.storage.minixingzuo_effect, target);
                                                if (num < 3) return att * Math.sqrt(Math.max(0, -val)) * 1.5;
                                                if (num == 3) return -att * Math.sqrt(Math.max(0, val));
                                                return -att * Math.sqrt(Math.max(0, val));
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                player.logSkill('minixingzuo', target);
                                                var cards = get.bottomCards(3);
                                                game.cardsGotoOrdering(cards);
                                                var hs = target.getCards('h');
                                                target.lose(hs, ui.cardPile);
                                                target.gain(cards, 'draw');
                                            }
                                            else event.finish();
                                            'step 2'
                                            game.updateRoundNumber();
                                        },
                                    },
                                },
                            },
                            //羊祜
                            minideshao: {
                                audio: 'dcdeshao',
                                inherit: 'dcdeshao',
                                filter(event, player) {
                                    return get.color(event.card) == 'black';
                                },
                                check: () => true,
                                async content(event, trigger, player) {
                                    await player.draw();
                                    const target = trigger.player;
                                    if (player.countCards('h') < target.countCards('h') && target.countCards('he') > 0) {
                                        await player.discardPlayerCard(target, 'he');
                                        player.addExpose(0.2);
                                    }
                                },
                            },
                            //阎柔
                            minixiangshu: {
                                audio: 'xiangshu',
                                inherit: 'xiangshu',
                                async content(event, trigger, player) {
                                    const num = Math.min(5, player.getAllHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0));
                                    const result = await player.chooseTarget(get.prompt('minixiangshu'), '令一名已受伤角色回复' + event.num + '点体力并摸' + get.cnNumber(event.num) + '张牌', (card, player, target) => {
                                        return target.isDamaged();
                                    }).set('ai', target => {
                                        const num = get.event().getParent().num, player = get.event().player, att = get.attitude(player, target);
                                        if (att > 0 && num >= Math.min(player.hp, 2)) return att * Math.sqrt(target.getDamagedHp());
                                        return 0;
                                    }).set('num', num).forResult();
                                    if (result.bool) {
                                        const target = result.targets[0];
                                        player.awakenSkill('minixiangshu');
                                        await player.logSkill('minixiangshu', target);
                                        if (player != target) player.addExpose(0.2);
                                        await target.recover(num);
                                        await target.draw(num);
                                    }
                                },
                            },
                            //王双
                            minizhuilie: {
                                audio: 'spzhuilie',
                                inherit: 'spzhuilie',
                                async content(event, trigger, player) {
                                    if (trigger.getParent().addCount !== false) {
                                        trigger.getParent().addCount = false;
                                        const stat = player.getStat();
                                        if (stat?.card?.sha) stat.card.sha--;
                                    }
                                    const next = player.judge(card => {
                                        return ['equip1', 'equip4', 'equip3', 'equip6'].includes(get.subtype(card)) || get.type2(card) == 'trick' ? 6 : -6;
                                    });
                                    next.judge2 = result => result.bool == false;
                                    const { card } = await next.forResult();
                                    if (['equip1', 'equip4', 'equip3', 'equip6'].includes(get.subtype(card))) {
                                        const map = trigger.customArgs;
                                        const id = trigger.target.playerid;
                                        if (!map[id]) map[id] = {};
                                        if (typeof map[id].extraDamage != 'number') map[id].extraDamage = 0;
                                        map[id].extraDamage += trigger.target.hp - 1;
                                    }
                                    else if (get.type2(card) == 'trick') await player.gain(card, 'gain2');
                                    else if (get.type(card) == 'basic') await player.loseHp();
                                },
                            },
                            //陈琳
                            minisongci: {
                                audio: 'songci',
                                inherit: 'songci',
                                filter(event, player) {
                                    return game.hasPlayer(current => {
                                        return !player.getStorage("minisongci").includes(current);
                                    });
                                },
                                filterTarget(card, player, target) {
                                    return !player.getStorage("minisongci").includes(target);
                                },
                                async content(event, trigger, player) {
                                    const target = event.target, goon = target.countCards("h") > target.getHp();
                                    player.markAuto("minisongci", [target]);
                                    if (goon) await target.chooseToDiscard(2, "he", true);
                                    else await target.draw(2);
                                },
                                group: 'minisongci_draw',
                                subSkill: {
                                    draw: {
                                        inherit: 'songci_draw',
                                        locked: false,
                                        filter: () => true,
                                    },
                                },
                            },
                            //刘晔
                            minipoyuan: {
                                audio: 'dcpoyuan',
                                trigger: {
                                    global: 'phaseBefore',
                                    player: ['phaseZhunbeiBegin', 'enterGame'],
                                },
                                filter(event, player) {
                                    if (event.name == 'phase' && game.phaseNumber > 0) return false;
                                    if (player.getEquip('minipiliche')) {
                                        return game.hasPlayer(current => {
                                            return current != player && current.countDiscardableCards(player, 'he') > 0;
                                        });
                                    }
                                    return player.hasEquipableSlot(4);
                                },
                                frequent: true,
                                async cost(event, trigger, player) {
                                    if (player.getEquip('minipiliche')) {
                                        event.result = await player.chooseTarget(get.prompt('minipoyuan'), '弃置一名其他角色的至多两张牌', (card, player, target) => {
                                            return target != player && target.countDiscardableCards(player, 'he') > 0;
                                        }).set('ai', target => {
                                            var player = _status.event.player, cards = target.getDiscardableCards(player, 'he');
                                            var att = get.attitude(player, target);
                                            if (att < 0 && target.hasSkillTag('noe')) att /= 2;
                                            var zheng = [], fu = [];
                                            for (var i of cards) {
                                                var val = get.value(i, target);
                                                if (val > 0) zheng.push(i);
                                                else fu.push(i);
                                            }
                                            zheng.sort((a, b) => get.value(b, target) - get.value(a, target));
                                            fu.sort((a, b) => get.value(b, target) - get.value(a, target));
                                            zheng = zheng.slice(0, 2);
                                            fu = fu.slice(0, 2);
                                            var eff1 = 0, eff2 = 0;
                                            for (var i of zheng) eff1 += get.value(i, target);
                                            for (var i of fu) {
                                                if (get.position(i) == 'e') eff2 += (1 - get.value(i, target));
                                            }
                                            return -att * Math.max(eff1, eff2);
                                        }).forResult();
                                    }
                                    else {
                                        event.result = await player.chooseBool(get.prompt('minipoyuan'), '装备一张【霹雳投石车】').set('frequentSkill', 'minipoyuan').forResult();
                                    }
                                },
                                content() {
                                    if (event.targets?.length) {
                                        const target = event.targets[0];
                                        player.discardPlayerCard(target, true, 'he', [1, 2]);
                                    }
                                    else {
                                        const card = game.createCard('minipiliche', 'diamond', 9);
                                        player.$gain2(card);
                                        game.delayx();
                                        player.equip(card);
                                    }
                                },
                            },
                            minipiliche: {
                                inherit: 'pilitoushiche',
                            },
                            minihuiqi: {
                                audio: 'olhuiqi',
                                inherit: 'olhuiqi',
                                derivation: 'minixieju',
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    if (player.isDamaged()) await player.recover();
                                    await player.addSkills('minixieju');
                                },
                            },
                            minixieju: {
                                audio: 'olxieju',
                                inherit: 'olxieju',
                                filterTarget(card, player, target) {
                                    return get.event().olxieju.includes(target);
                                },
                                async content(event, trigger, player) {
                                    const next = event.target.chooseToUse();
                                    next.set('openskilldialog', '偕举：是否将一张黑色牌当作【杀】使用？');
                                    next.set('norestore', true);
                                    next.set('_backupevent', event.name + '_backup');
                                    next.set('custom', {
                                        add: {},
                                        replace: { window() { } },
                                    });
                                    next.backup(event.name + '_backup');
                                    await next;
                                },
                                subSkill: {
                                    backup: {
                                        filterCard(card) {
                                            return get.itemtype(card) == 'card' && get.color(card) == 'black';
                                        },
                                        position: 'hes',
                                        viewAs: { name: 'sha' },
                                        check(card) {
                                            return 7 - get.value(card);
                                        },
                                    }
                                },
                            },
                            //毌丘俭
                            minizhengrong: {
                                audio: 'drlt_zhenrong',
                                inherit: 'drlt_zhenrong',
                                filter(event, player) {
                                    return event.player !== player && event.player.countCards('he');
                                },
                                onremove(player) {
                                    const cards = player.getExpansions('drlt_zhenrong');
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                            },
                            minihongju: {
                                audio: 'drlt_hongju',
                                inherit: 'drlt_hongju',
                                async content(event, trigger, player) {
                                    'step 0'
                                    player.awakenSkill(event.name);
                                    var cards = player.getExpansions('drlt_zhenrong');
                                    if (cards.length && player.countCards('h')) {
                                        const next = player.chooseToMove('征荣：是否交换“荣”和手牌？');
                                        next.set('list', [
                                            [get.translation(player) + '（你）的“荣”', cards],
                                            ['手牌区', player.getCards('h')],
                                        ]);
                                        next.set('filterMove', (from, to) => typeof to != 'number');
                                        next.set('processAI', list => {
                                            var player = _status.event.player, cards = list[0][1].concat(list[1][1]).sort((a, b) => {
                                                return get.value(a) - get.value(b);
                                            }), cards2 = cards.splice(0, player.getExpansions('drlt_zhenrong').length);
                                            return [cards2, cards];
                                        });
                                        const result = await next.forResult();
                                        if (result.bool) {
                                            var pushs = result.moved[0], gains = result.moved[1];
                                            pushs.removeArray(player.getExpansions('drlt_zhenrong'));
                                            gains.removeArray(player.getCards('h'));
                                            if (pushs.length && pushs.length === gains.length) {
                                                const next2 = player.addToExpansion(pushs, player, 'give');
                                                next2.gaintag.add('drlt_zhenrong');
                                                await next2;
                                                await player.gain(gains, 'gain2');
                                            }
                                        }
                                    }
                                    await player.addSkills('drlt_qingce');
                                },
                            },
                            //管辂
                            minibusuan: {
                                audio: 'busuan',
                                inherit: 'busuan',
                                filterTarget: true,
                                async content(event, trigger, player) {
                                    const { target } = event;
                                    const list = get.inpileVCardList(info => {
                                        return info[0] != 'basic';
                                    });
                                    if (!list.length) return;
                                    const links = await player.chooseButton(["选择至多两种牌", [list, "vcard"]], true, [1, 2]).set("ai", function (button) {
                                        const player = get.player(), target = get.event().getParent().target;
                                        const card = { name: button.link[2], nature: button.link[3] };
                                        if (get.type(card) == 'basic' || !target.hasUseTarget(card)) return false;
                                        return get.attitude(player, target) * (target.getUseValue(card) - 0.1);
                                    }).forResultLinks();
                                    if (links?.length) {
                                        target.addSkill(event.name + '_effect');
                                        target.storage[event.name + '_effect'] = links.slice(0);
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        intro: {
                                            mark(dialog, content, player) {
                                                if (content?.length) dialog.add([content, 'vcard']);
                                            },
                                        },
                                        trigger: { player: 'drawBefore' },
                                        filter(event, player) {
                                            return event.getParent().name == 'phaseDraw';
                                        },
                                        forced: true,
                                        popup: false,
                                        async content(event, trigger, player) {
                                            const list = player.storage[event.name], cards = [];
                                            for (let i = 0; i < Math.min(trigger.num, list.length); i++) {
                                                const card = get.cardPile(cardx => {
                                                    if (cards.includes(cardx)) return false;
                                                    if (cardx.name != list[Math.min(i, list.length - 1)][2]) return false;
                                                    if (get.nature(cardx, false) != list[Math.min(i, list.length - 1)][3]) return false;
                                                    return true;
                                                });
                                                if (card) {
                                                    player.storage[event.name].splice(i--, 1);
                                                    trigger.num--;
                                                    cards.push(card);
                                                }
                                            }
                                            if (cards.length) await player.gain(cards, 'gain2', 'log');
                                            if (!trigger.num) trigger.cancel();
                                            if (!list.length) player.removeSkill(event.name);
                                        },
                                    }
                                }
                            },
                            minimingjie: {
                                audio: 'mingjie',
                                trigger: { player: 'phaseJieshuBegin' },
                                frequent: true,
                                async content(event, trigger, player) {
                                    let cards = [], count = 0;
                                    while (true) {
                                        const { result } = await player.draw();
                                        if (get.itemtype(result) != 'cards') return;
                                        count += result.length;
                                        cards.addArray(result)
                                        if (get.color(result) == 'black' || count > 2) break;
                                        const bool = await player.chooseBool('是否继续发动【命戒】？').set('choice', player.isHealthy() || (lib.skill.mingjie.check() && get.recoverEffect(player, player, player) > 0)).forResultBool();
                                        if (!bool) break;
                                    }
                                    if (cards.every(card => get.color(card) == 'red') && player.isDamaged()) await player.recover();
                                },
                            },
                            //郑浑
                            miniqiangzhi: {
                                audio: 'dcqiangzhi',
                                inherit: 'dcqiangzhi',
                                async content(event, trigger, player) {
                                    let { target } = event, discarded = [], num = 0;
                                    while (num < 3 && get.info(event.name).filterTarget(null, player, target)) {
                                        const result = await player.chooseTarget('强峙：弃置你或' + get.translation(target) + '的一张牌', (card, player, target) => {
                                            if (!target.countDiscardableCards(player, 'he')) return false;
                                            return target === player || target === get.event().getParent().target;
                                        }, '当前进度：' + (num + 1) + '/3', true).set('ai', aim => {
                                            const { player, damage } = get.event(), { target } = get.event().getParent();
                                            if (aim === player) {
                                                if (damage) return 15 - Math.min(...player.getDiscardableCards(player, 'he').map(card => get.value(card)));
                                                if (player.hp >= 3 || get.damageEffect(player, target, player) >= 0 || player.hasSkill('dcpitian') && player.getHandcardLimit() - player.countCards('h') >= 1 && player.hp > 1) return 0;
                                                return 10 - Math.min(...player.getDiscardableCards(player, 'he').map(card => get.value(card)));
                                            }
                                            else {
                                                if (damage) return 0;
                                                return -(get.sgnAttitude(player, target) || 1) * Math.max(...target.getDiscardableCards(player, 'he').map(card => get.value(card)));
                                            }
                                        }).set('damage', (() => {
                                            if (discarded.includes(target)) return false;
                                            return get.damageEffect(target, player, player) > 10 && player.countCards('he', card => {
                                                return lib.filter.canBeDiscarded(card, player, player) && get.value(card) < 5;
                                            }) >= 3;
                                        })()).forResult();
                                        if (result?.bool && result.targets?.length) {
                                            const [discarder] = result.targets;
                                            discarded.add(discarder);
                                            player.line(discarder);
                                            const resultx = await player.discardPlayerCard(discarder, 'he', true).forResult();
                                            if (resultx?.bool && resultx.cards?.length) num += resultx.cards.length;
                                            else break;
                                        }
                                        else break;
                                    }
                                    if (discarded.length === 1 && [player, target].every(i => i.isIn())) {
                                        const damaged = [player, target].removeArray(discarded)[0];
                                        discarded = discarded[0];
                                        discarded.line(damaged);
                                        await damaged.damage(discarded);
                                    }
                                },
                            },
                            //陈泰
                            minijiuxian: {
                                audio: 'dcctjiuxian',
                                inherit: 'dcctjiuxian',
                                selectCard() {
                                    const player = get.player();
                                    return [1, Math.ceil(player.countCards('h') / 2)];
                                },
                            },
                            //韩史
                            miniyonglve: {
                                audio: 'yonglve',
                                trigger: { global: 'phaseJudgeBegin' },
                                filter(event, player) {
                                    return event.player !== player && event.player.countCards('j') > 0;
                                },
                                async cost(event, trigger, player) {
                                    const target = trigger.player;
                                    let list = [
                                        get.prompt2('miniyonglve', target),
                                        '<div class="text center">' + get.translation(target) + '的判定牌</div>',
                                        target.getCards('j'),
                                    ];
                                    if (player.countCards('h')) {
                                        list.addArray([
                                            '<div class="text center">你的手牌</div>',
                                            player.getCards('h'),
                                        ]);
                                    }
                                    if (player.countCards('e')) {
                                        list.addArray([
                                            '<div class="text center">你的装备牌</div>',
                                            player.getCards('he'),
                                        ]);
                                    }
                                    event.result = await player.chooseButton(list).set('filterButton', button => {
                                        return lib.filter.canBeDiscarded(button.link, get.player(), get.owner(button.link));
                                    }).set('ai', button => {
                                        const player = get.player(), trigger = get.event().getTrigger();
                                        let att = get.attitude(player, trigger.player), nh = trigger.player.countCards('h');
                                        let eff = get.effect(trigger.player, { name: 'sha', isCard: true }, player, player);
                                        if (player.inRange(trigger.player) || !player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) eff = 0;
                                        if (get.owner(button.link) === trigger.player) {
                                            const name = button.link.viewAs || button.link.name;
                                            if (att > 0 && eff >= 0) return 10;
                                            if (att >= 0 && eff > 0) return 10;
                                            if (att > 0 && (trigger.player.getHp() >= 3 || trigger.player.hasSkillTag('freeShan', false, {
                                                player: _status.event.player,
                                                card: new lib.element.VCard({ name: 'sha', isCard: true })
                                            }) || trigger.player.countCards('h', 'shan'))) {
                                                if (name == 'lebu' && nh > trigger.player.hp) return 10;
                                                if (name == 'bingliang' && nh < trigger.player.hp) return 10;
                                            }
                                            return 0;
                                        }
                                        else {
                                            if (player.inRange(trigger.player)) return get.info('zhiheng').check(button.link);
                                            else if (player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) return eff;
                                            else return 0;
                                        }
                                    }).forResult();
                                    event.result.cards = event.result?.links;
                                },
                                logTarget: 'player',
                                async content(event, trigger, player) {
                                    const [card] = event.cards;
                                    await get.owner(card).discard(event.cards).set('discarder', player);
                                    if (!player.inRange(trigger.player)) {
                                        if (player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) {
                                            await player.useCard({ name: 'sha', isCard: true }, trigger.player);
                                        }
                                    }
                                    else await player.draw();
                                },
                            },
                            //谋甄姬
                            minisbluoshen: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    if (player.countCards('h', { color: 'red' })) return false;
                                    const evt = event.getl(player);
                                    return evt?.hs?.some(card => get.color(card) == 'red');
                                },
                                frequent: true,
                                async content(event, trigger, player) {
                                    while (true) {
                                        const card = get.cards()[0];
                                        await game.cardsGotoOrdering(card);
                                        await player.showCards(card, get.translation(player) + '发动了【洛神】');
                                        const color = get.color(card);
                                        if (color == 'red') {
                                            await player.gain(card, 'gain2');
                                            break;
                                        }
                                        else if (color == 'black' && player.hasUseTarget(card)) await player.chooseUseTarget(card, false);
                                    }
                                },
                            },
                            minisbqingguo: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                usable: 2,
                                filterCard: { color: 'red' },
                                filterTarget: lib.filter.notMe,
                                discard: false,
                                lose: false,
                                delay: false,
                                check(card) {
                                    return 6.5 - get.value(card);
                                },
                                async content(event, trigger, player) {
                                    const { cards, target } = event;
                                    await player.give(cards, target);
                                    if (!target.countCards('he', { color: 'black' })) return;
                                    await target.chooseToGive(player, 'he', { color: 'black' }, true);
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        target(player, target) {
                                            if (target.hasSkillTag('nogain')) return 0;
                                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                                if (target.hasSkillTag('nodu')) return 0;
                                                return -10;
                                            }
                                            const att = get.attitude(player, target);
                                            if (att > 0) return 1;
                                            if (target.countCards('he', { color: 'black' }) && player.hasSkill('minisbluoshen')) return -1;
                                            return 0;
                                        },
                                    }
                                },
                                group: 'minisbqingguo_effect',
                                subSkill: {
                                    effect: {
                                        audio: 'minisbqingguo',
                                        trigger: { target: 'useCardToTarget' },
                                        filter(event, player) {
                                            const { player: target, card } = event;
                                            if (player == target) return false;
                                            return (get.type(card) == 'trick' || card.name == 'sha') && player.hasCard(card => {
                                                if (_status.connectMode) return true;
                                                return get.color(card) == 'black' && lib.filter.cardDiscardable(card, player);
                                            }, 'he');
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseToDiscard(get.prompt(event.skill), `弃置一张黑色牌令${get.translation(trigger.card)}对你无效`, (card, player) => {
                                                return get.color(card) == 'black';
                                            }, 'chooseonly', 'he').set('ai', card => {
                                                const { goon } = get.event();
                                                if (goon) return 7 - get.value(card);
                                                return 0;
                                            }).set('goon', get.effect(player, trigger.card, trigger.player, player) < 0).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            await player.discard(event.cards);
                                            trigger.excluded.add(player);
                                        },
                                    }
                                }
                            },
                            //司马朗
                            miniquji: {
                                audio: 'quji',
                                inherit: 'quji',
                                filter(event, player) {
                                    return game.hasPlayer(current => current.isDamaged());
                                },
                                filterCard: lib.filter.cardRecastable,
                                selectCard() {
                                    const player = get.player();
                                    return player.getDamagedHp() + 1;
                                },
                                check(card) {
                                    return 6.5 - get.value(card);
                                },
                                multitarget: true,
                                multiline: true,
                                discard: false,
                                lose: false,
                                delay: false,
                                async content(event, trigger, player) {
                                    const { cards, targets } = event;
                                    await player.recast(cards);
                                    for (const target of targets.sortBySeat()) {
                                        if (target.isDamaged()) await target.recover();
                                    }
                                    if (targets.some(target => target.isDamaged())) await game.asyncDraw(targets.filter(target => target.isDamaged()).sortBySeat())
                                },
                            },
                            //蜀
                            //关羽
                            miniwusheng: {
                                group: 'miniwusheng_damage',
                                audio: 'wusheng',
                                audioname2: {
                                    guanzhang: "wusheng_guanzhang",
                                    guansuo: "wusheng_guansuo",
                                },
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    var card = get.cardPile(function (card) {
                                        return card.name == 'sha' && get.color(card) == 'red';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                },
                                subSkill: {
                                    damage: {
                                        mod: {
                                            aiOrder(player, card, num) {
                                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                                            },
                                        },
                                        audio: 'wusheng',
                                        audioname2: {
                                            guanzhang: "wusheng_guanzhang",
                                            guansuo: "wusheng_guansuo",
                                        },
                                        inherit: 'jie',
                                    },
                                },
                            },
                            miniguanxing: {
                                audio: 'guanxing',
                                audioname: ['ol_jiangwei'],
                                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                                filter(event, player) {
                                    return event.name != 'phaseJieshu' || player.hasSkill('miniguanxing_on');
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    var num = game.countPlayer() < 3 ? 3 : 5;
                                    var cards = get.cards(num);
                                    game.cardsGotoOrdering(cards);
                                    var next = player.chooseToMove();
                                    next.set('list', [
                                        ['牌堆顶', cards],
                                        ['牌堆底'],
                                    ]);
                                    next.set('prompt', '观星：点击将牌移动到牌堆顶或牌堆底');
                                    next.processAI = function (list) {
                                        var cards = list[0][1], player = _status.event.player;
                                        var target = (_status.event.getTrigger().name == 'phaseZhunbei') ? player : player.next;
                                        var att = get.sgn(get.attitude(player, target));
                                        var top = [];
                                        var judges = target.getCards('j');
                                        var stopped = false;
                                        if (player != target || !target.hasWuxie()) {
                                            for (var i = 0; i < judges.length; i++) {
                                                var judge = get.judge(judges[i]);
                                                cards.sort(function (a, b) {
                                                    return (judge(b) - judge(a)) * att;
                                                });
                                                if (judge(cards[0]) * att < 0) {
                                                    stopped = true; break;
                                                }
                                                else {
                                                    top.unshift(cards.shift());
                                                }
                                            }
                                        }
                                        var bottom;
                                        if (!stopped) {
                                            cards.sort(function (a, b) {
                                                return (get.value(b, player) - get.value(a, player)) * att;
                                            });
                                            while (cards.length) {
                                                if ((get.value(cards[0], player) <= 5) == (att > 0)) break;
                                                top.unshift(cards.shift());
                                            }
                                        }
                                        bottom = cards;
                                        return [top, bottom];
                                    }
                                    'step 1'
                                    var top = result.moved[0], bottom = result.moved[1];
                                    top.reverse();
                                    game.cardsGotoPile(
                                        top.concat(bottom),
                                        ['top_cards', top],
                                        function (event, card) {
                                            if (event.top_cards.includes(card)) return ui.cardPile.firstChild;
                                            return null;
                                        }
                                    )
                                    if (trigger.name == 'phaseZhunbei' && !top.length) player.addTempSkill('miniguanxing_on');
                                    player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                                    game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                                    'step 2'
                                    game.delayx();
                                },
                                subSkill: { on: { charlotte: true } },
                            },
                            minireguanxing: {
                                audio: 'guanxing',
                                audioname: ['ol_jiangwei'],
                                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                                frequent: true,
                                preHidden: true,
                                *content(event, map) {
                                    const player = map.player;
                                    const num = Math.min(game.countPlayer() <= 2 ? 3 : 5);
                                    const goon = player.getExpansions('minireguanxing').length < num;
                                    let cards = get.cards(num);
                                    let list = [['牌堆顶', cards], ['牌堆底']], str = '观星：点击将牌移动到牌堆顶或牌堆底';
                                    if (goon) {
                                        list.push(['置于武将牌上的“星”']);
                                        str += '，并可以将一张牌称为“星”置于武将牌上';
                                    }
                                    let result = yield player.chooseToMove().set('filterMove', (from, to, moved) => {
                                        if (moved[2] && !moved[2].includes(from.link)) {
                                            if (typeof to == 'number') {
                                                if (to == 2 && moved[2].length) return false;
                                                return true;
                                            }
                                        }
                                        return true;
                                    }).set('processAI', list => {
                                        const cards = list[0][1], player = _status.event.player;
                                        let top = [], bottom;
                                        const judges = player.getCards('j');
                                        let stopped = false;
                                        if (!player.hasWuxie()) {
                                            for (let i = 0; i < judges.length; i++) {
                                                const judge = get.judge(judges[i]);
                                                cards.sort((a, b) => judge(b) - judge(a));
                                                if (judge(cards[0]) < 0) { stopped = true; break; }
                                                else top.unshift(cards.shift());
                                            }
                                        }
                                        if (!stopped) {
                                            cards.sort((a, b) => get.value(b, player) - get.value(a, player));
                                            while (cards.length) {
                                                if (get.value(cards[0], player) <= 5) break;
                                                top.unshift(cards.shift());
                                            }
                                        }
                                        bottom = cards;
                                        if (!_status.event.goon) return [top, bottom];
                                        let cardx = top.slice().concat(bottom).slice(player.hasWuxie() ? 0 : judges.length);
                                        if (!cardx.length) return [top, bottom, []];
                                        let card = cardx.sort((a, b) => get.value(b) / get.useful(b) - get.value(a) / get.useful(b))[0];
                                        top.remove(card);
                                        bottom.remove(card);
                                        return [top, bottom, [card]];
                                    }).set('goon', goon).set('list', list).set('prompt', str);
                                    if (result.bool) {
                                        const top = result.moved[0], bottom = result.moved[1], put = result.moved[2];
                                        top.reverse();
                                        game.cardsGotoPile(
                                            top.concat(bottom),
                                            ['top_cards', top],
                                            (event, card) => {
                                                if (event.top_cards.includes(card)) return ui.cardPile.firstChild;
                                                return null;
                                            }
                                        );
                                        player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                                        game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                                        if (put?.length) player.addToExpansion(put, 'gain2').gaintag.add('minireguanxing');
                                        game.updateRoundNumber();
                                        game.delayx();
                                    }
                                },
                                marktext: '星',
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                group: ['minireguanxing_gain'/*,'minireguanxing_lose'*/],
                                subSkill: {
                                    gain: {
                                        audio: 'guanxing',
                                        audioname: ['ol_jiangwei'],
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            return player.getExpansions('minireguanxing').length;
                                        },
                                        prompt() {
                                            const player = _status.event.player;
                                            let str = '获得武将牌上的所有“星”';
                                            if (player.getExpansions('minireguanxing').length >= Math.min(game.countPlayer() <= 2 ? 3 : 5)) str += '，本回合获得如下效果：若你有空置的装备栏，则你视为装备【诸葛连弩】';
                                            return str;
                                        },
                                        content() {
                                            const cards = player.getExpansions('minireguanxing');
                                            player.gain(cards, 'gain2');
                                            if (cards.length >= Math.min(game.countPlayer() <= 2 ? 3 : 5)) player.addTempSkill('minireguanxing_liannu');
                                        },
                                        ai: {
                                            order: 9,
                                            result: { player: player => player.getExpansions('minireguanxing').length >= Math.min(game.countPlayer() <= 2 ? 3 : 5) || player.hp < 2 ? 1 : 0 },
                                        },
                                    },
                                    liannu: {
                                        charlotte: true,
                                        mark: true,
                                        markimage: 'image/card/zhuge.png',
                                        nobracket: true,
                                        intro: { content: '若你有空置的武器栏，则你视为装备【诸葛连弩】' },
                                        group: 'minireguanxing_zhuge',
                                    },
                                    zhuge: {
                                        inherit: 'zhuge_skill',
                                        audio: 'guanxing',
                                        audioname: ['ol_jiangwei'],
                                        nobracket: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name != 'sha'/*||player.getEquips('zhuge').length||player.hasSkill('zhuge_skill',null,false)*/ || !player.hasEmptySlot(1)) return;
                                                //if(get.is.versus()||get.is.changban()) return num+3;
                                                return Infinity;
                                            },
                                        },
                                    },
                                    lose: {
                                        audio: 'guanxing',
                                        audioname: ['ol_jiangwei'],
                                        trigger: { global: ['phaseBefore', 'dieAfter'], player: 'enterGame' },
                                        filter(event, player) {
                                            const num = Math.min(game.countPlayer() <= 2 ? 3 : 5);
                                            return player.getExpansions('minireguanxing').length > num;
                                        },
                                        forced: true,
                                        locked: false,
                                        *content(event, map) {
                                            const player = map.player, num = player.getExpansions('minireguanxing').length - Math.min(game.countPlayer() <= 2 ? 3 : 5);
                                            let result = yield player.chooseButton(['观星：请移去' + get.cnNumber(num) + '张多余的“星”', player.getExpansions('minireguanxing')], true, num);
                                            if (result.bool) player.loseToDiscardpile(result.links);
                                        },
                                    },
                                },
                            },
                            minikongcheng: {
                                mod: {
                                    targetEnabled(card, player, target, now) {
                                        if (target.countCards('h') == 0) {
                                            if (card.name == 'sha' || card.name == 'juedou' || card.name == 'shunshou') return false;
                                        }
                                    },
                                },
                                audio: 'kongcheng1',
                                trigger: { player: 'loseEnd' },
                                forced: true,
                                firstDo: true,
                                filter(event, player) {
                                    if (player.countCards('h')) return false;
                                    return event.cards.some(card => card.original == 'h');
                                },
                                content() { },
                                ai: {
                                    noh: true,
                                    skillTagFilter(player, tag) {
                                        return player.countCards('h') == 1;
                                    },
                                },
                            },
                            //刘备
                            minirende: {
                                audio: 'rende',
                                trigger: { player: 'phaseUseEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minirende'), [1, 2]).set('ai', function (target) {
                                        return Math.sqrt(5 - Math.min(4, target.countCards('h'))) * get.attitude(_status.event.player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('minirende', targets);
                                        if (targets.length == 1) {
                                            targets[0].draw();
                                            event.finish();
                                        }
                                        else game.asyncDraw(targets);
                                    }
                                    else event.finish();
                                    'step 2'
                                    game.delayx();
                                },
                            },
                            minirerende: {
                                audio: 'rerende',
                                enable: 'phaseUse',
                                filterCard: true,
                                selectCard: [1, Infinity],
                                discard: false,
                                lose: false,
                                delay: false,
                                filterTarget(card, player, target) {
                                    return player != target && !player.getStorage('minirerende2').includes(target);
                                },
                                check(card) {
                                    if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') return 0;
                                    if (!ui.selected.cards.length && card.name == 'du') return 20;
                                    var player = get.owner(card);
                                    if (ui.selected.cards.length >= Math.max(2, player.countCards('h') - player.hp)) return 0;
                                    if (player.hp == player.maxHp || player.storage.minirerende < 0 || player.countCards('h') <= 1) {
                                        var players = game.filterPlayer();
                                        for (var i = 0; i < players.length; i++) {
                                            if (players[i].hasSkill('haoshi') &&
                                                !players[i].isTurnedOver() &&
                                                !players[i].hasJudge('lebu') &&
                                                get.attitude(player, players[i]) >= 3 &&
                                                get.attitude(players[i], player) >= 3) {
                                                return 11 - get.value(card);
                                            }
                                        }
                                        if (player.countCards('h') > player.hp) return 10 - get.value(card);
                                        if (player.countCards('h') > 2) return 6 - get.value(card);
                                        return -1;
                                    }
                                    return 10 - get.value(card);
                                },
                                content() {
                                    'step 0'
                                    var evt = _status.event.getParent('phaseUse');
                                    if (evt?.name == 'phaseUse' && !evt.minirerende) {
                                        var next = game.createEvent('minirerende_clear');
                                        _status.event.next.remove(next);
                                        evt.after.push(next);
                                        evt.minirerende = true;
                                        next.player = player;
                                        next.setContent(function () {
                                            player.storage.minirerende = 0;
                                            delete player.storage.minirerende2;
                                        });
                                    }
                                    player.markAuto('minirerende2', [target]);
                                    player.give(cards, target);
                                    player.addTempSkill('minirerende_sha', { player: 'phaseBegin' });
                                    player.markAuto('minirerende_sha', [target]);
                                    if (typeof player.storage.minirerende != 'number') player.storage.minirerende = 0;
                                    if (player.storage.minirerende >= 0) {
                                        player.storage.minirerende += cards.length;
                                        if (player.storage.minirerende >= 2) {
                                            var list = [];
                                            for (var i of lib.inpile) {
                                                if (get.type({ name: i }) != 'basic' && get.type({ name: i }) != 'trick') continue;
                                                if (lib.filter.cardUsable({ name: i }, player, event.getParent('chooseToUse')) && player.hasUseTarget({ name: i })) {
                                                    list.push([get.translation(get.type({ name: i })), '', i]);
                                                    if (i == 'sha') {
                                                        for (var i of lib.inpile_nature) {
                                                            if (lib.filter.cardUsable({ name: 'sha', nature: i }, player, event.getParent('chooseToUse')) && game.hasPlayer(function (current) {
                                                                return player.canUse({ name: 'sha', nature: i }, current);
                                                            })) list.push(['基本', '', 'sha', i]);
                                                        }
                                                    }
                                                }
                                            }
                                            if (list.length) {
                                                player.chooseButton(['是否视为使用一张基本牌或普通锦囊牌？', [list, 'vcard']]).set('ai', function (button) {
                                                    var player = _status.event.player;
                                                    var card = { name: button.link[2], nature: button.link[3] };
                                                    return player.getUseValue(card);
                                                });
                                            }
                                            else event.finish();
                                            player.storage.minirerende = -1;
                                        }
                                        else event.finish();
                                    }
                                    else event.finish();
                                    'step 1'
                                    if (result?.bool && result.links[0]) {
                                        var card = { name: result.links[0][2], nature: result.links[0][3] };
                                        player.chooseUseTarget(card, true);
                                    }
                                },
                                ai: {
                                    threaten: 0.8,
                                    fireAttack: true,
                                    order(skill, player) {
                                        if (player.hp < player.maxHp && player.storage.minirerende < 2 && player.countCards('h') > 1) return 10;
                                        return 4;
                                    },
                                    result: {
                                        target(player, target) {
                                            if (target.hasSkillTag('nogain')) return 0;
                                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                                if (target.hasSkillTag('nodu')) return 0;
                                                return -10;
                                            }
                                            if (target.hasJudge('lebu')) return 0;
                                            var nh = target.countCards('h');
                                            var np = player.countCards('h');
                                            if (player.hp == player.maxHp || player.storage.minirerende < 0 || player.countCards('h') <= 1) {
                                                if (nh >= np - 1 && np <= player.hp && !target.hasSkill('haoshi')) return 0;
                                            }
                                            return Math.max(1, 5 - nh);
                                        }
                                    },
                                    effect: {
                                        target(card, player, target) {
                                            if (player == target && get.type(card) == 'equip') {
                                                if (player.countCards('e', { subtype: get.subtype(card) })) {
                                                    if (game.hasPlayer(function (current) {
                                                        return current != player && get.attitude(player, current) > 0;
                                                    })) return 0;
                                                }
                                            }
                                        },
                                    },
                                },
                                subSkill: {
                                    sha: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: "<span style='text-decoration: line-through;'>杀</span>",
                                        intro: { content: '$使用红色【杀】无法指定你为目标' },
                                        mod: {
                                            targetEnabled(card, player, target) {
                                                if (card.name == 'sha' && get.color(card) == 'red' && target.getStorage('minirerende_sha').includes(player)) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minijijiang: {
                                audio: 'jijiang1',
                                audioname: ['ol_liushan', 're_liubei'],
                                unique: true,
                                group: ['minijijiang1', 'minijijiang3'],
                                zhuSkill: true,
                                filter(event, player) {
                                    if (!game.hasPlayer(function (current) {
                                        return current != player && current.group == 'shu';
                                    })) return false;
                                    return !event.jijiang && (event.type != 'phase' || !player.hasSkill('jijiang3'));
                                },
                                enable: ['chooseToUse', 'chooseToRespond'],
                                viewAs: { name: 'sha' },
                                filterCard() { return false },
                                selectCard: -1,
                                ai: {
                                    order() {
                                        return get.order({ name: 'sha' }) + 0.3;
                                    },
                                    respondSha: true,
                                    skillTagFilter(player) {
                                        if (!game.hasPlayer(function (current) {
                                            return current != player && current.group == 'shu';
                                        })) return false;
                                    },
                                },
                            },
                            minijijiang1: {
                                audio: 'jijiang1',
                                audioname: ['ol_liushan', 're_liubei'],
                                trigger: { player: ['useCardBegin', 'respondBegin'] },
                                logTarget: 'targets',
                                filter(event, player) {
                                    return event.skill == 'minijijiang';
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    delete trigger.skill;
                                    trigger.getParent().set('jijiang', true);
                                    'step 1'
                                    if (event.current == undefined) event.current = player.next;
                                    if (event.current == player) {
                                        player.addTempSkill('jijiang3');
                                        event.finish();
                                        trigger.cancel();
                                        trigger.getParent().goto(0);
                                    }
                                    else if (event.current.group == 'shu') {
                                        var next = event.current.chooseToRespond('是否替' + get.translation(player) + '打出一张杀？', { name: 'sha' });
                                        next.set('ai', function () {
                                            var event = _status.event;
                                            return (get.attitude(event.player, event.source) - 2);
                                        });
                                        next.set('source', player);
                                        next.set('jijiang', true);
                                        next.set('skillwarn', '替' + get.translation(player) + '打出一张杀');
                                        next.noOrdering = true;
                                        next.autochoose = lib.filter.autoRespondSha;
                                    }
                                    else {
                                        event.current = event.current.next;
                                        event.redo();
                                    }
                                    'step 2'
                                    if (result.bool) {
                                        game.asyncDraw([player, event.current]);
                                        trigger.card = result.card;
                                        trigger.cards = result.cards;
                                        trigger.throw = false;
                                        if (typeof event.current.ai.shown == 'number' && event.current.ai.shown < 0.95) {
                                            event.current.ai.shown += 0.3;
                                            if (event.current.ai.shown > 0.95) event.current.ai.shown = 0.95;
                                        }
                                        event.finish();
                                    }
                                    else {
                                        event.current = event.current.next;
                                        event.goto(1);
                                    }
                                }
                            },
                            minijijiang3: {
                                audio: 'jijiang1',
                                audioname: ['ol_liushan', 're_liubei'],
                                trigger: { global: ['useCard', 'respond'] },
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.player != player && event.player.group == 'shu' && event.player.isIn() &&
                                        player != _status.currentPhase;
                                },
                                usable: 1,
                                direct: true,
                                content() {
                                    'step 0'
                                    trigger.player.chooseBool('激将：是否令' + get.translation(player) + '摸一张牌？').set('ai', function () {
                                        var evt = _status.event;
                                        return get.attitude(evt.player, evt.getParent().player) > 0;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minijijiang');
                                        trigger.player.line(player, 'fire');
                                        player.draw();
                                    }
                                    else player.storage.counttrigger.minijijiang3--;
                                },
                            },
                            //马超
                            miniyuma: {
                                group: 'mashu',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    var evt = event.getl(player);
                                    if (!evt || evt.player != player || !evt.es || !evt.es.length) return false;
                                    return evt.es.some(card => get.type(card) == 'equip' && ['equip3', 'equip4'].includes(get.subtype(card)));
                                },
                                forced: true,
                                content() {
                                    player.draw(2 * trigger.getl(player).es.filter(card => get.type(card) == 'equip' && ['equip3', 'equip4'].includes(get.subtype(card))).length);
                                },
                            },
                            minitieji: {
                                audio: 'retieji',
                                shaRelated: true,
                                trigger: { player: 'useCardToPlayered' },
                                check(event, player) {
                                    return get.attitude(player, event.target) < 0;
                                },
                                filter(event, player) {
                                    return event.card.name == 'sha';
                                },
                                logTarget: 'target',
                                preHidden: true,
                                content() {
                                    'step 0'
                                    trigger.target.addTempSkill('fengyin');
                                    player.judge(function (card) {
                                        if (get.color(card) == 'red') return 2;
                                        return -1;
                                    }).judge2 = function (result) {
                                        return result.bool;
                                    };
                                    'step 1'
                                    if (result.bool) trigger.getParent().directHit.add(trigger.target);
                                    else player.draw(2);
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (get.attitude(player, arg.target) > 0 || arg.card.name != 'sha' || !ui.cardPile.firstChild || get.color(ui.cardPile.firstChild, player) != 'red') return false;
                                    },
                                },
                            },
                            minijuxiang: {
                                group: 'juxiang1',
                                audio: 'juxiang1',
                                preHidden: ['juxiang1', 'minijuxiang'],
                                trigger: { global: ['useCardAfter', 'loseAfter'] },
                                filter(event, player) {
                                    if (event.name == 'useCard') return (event.cards.filterInD().length || game.hasPlayer2(function (current) {
                                        return current.getHistory('damage', function (evt) {
                                            return evt.card && evt.card == event.card;
                                        }).length;
                                    })) && event.card.name == 'nanman' && event.player != player;
                                    if (event.type != 'discard' || event.getlx === false) return false;
                                    var cards = event.cards2.slice(0);
                                    var evt = event.getl(player);
                                    if (evt?.cards) cards.removeArray(evt.cards);
                                    return cards.filter(function (card) {
                                        return card.name == 'nanman' && get.position(card, true) == 'd';
                                    }).length;
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    if (trigger.name == 'lose') {
                                        var cards = trigger.cards2.slice(0);
                                        var evt = trigger.getl(player);
                                        if (evt?.cards) cards.removeArray(evt.cards);
                                        player.gain(cards.filter(function (card) {
                                            return card.name == 'nanman' && get.position(card, true) == 'd';
                                        }), 'gain2');
                                        event.finish();
                                        return;
                                    }
                                    if (trigger.cards.filterInD().length) player.gain(trigger.cards.filterInD(), 'gain2');
                                    'step 1'
                                    if (game.hasPlayer2(function (current) {
                                        return current.getHistory('damage', function (evt) {
                                            return evt.card && evt.card == trigger.card;
                                        }).length;
                                    })) player.draw();
                                },
                                ai: {
                                    effect: {
                                        target(card) {
                                            if (card.name == 'nanman') return [0, 1];
                                        },
                                    },
                                },
                            },
                            minilieren: {
                                shaRelated: true,
                                audio: 'lieren',
                                trigger: { source: 'damageSource' },
                                filter(event, player) {
                                    if (event._notrigger.includes(event.player)) return false;
                                    return event.card && event.card.name == 'sha' && event.getParent().name == 'sha' &&
                                        event.player.isIn() && event.player.countCards('h');
                                },
                                check(event, player) {
                                    return get.attitude(player, event.player) < 0;
                                },
                                content() {
                                    'step 0'
                                    player.discardPlayerCard('h', trigger.player, true);
                                    'step 1'
                                    if (get.number(result.cards[0]) < get.number(trigger.cards[0])) player.gain(result.cards, 'gain2', 'log');
                                },
                            },
                            minirelieren: {
                                group: 'minirelieren_gain',
                                shaRelated: true,
                                audio: 'lieren',
                                audioname2: { Mmiao_zhurong: 'minimiaolieren' },
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && player.canCompare(event.target);
                                },
                                check(event, player) {
                                    return get.attitude(player, event.target) < 0;
                                },
                                content() {
                                    'step 0'
                                    player.chooseToCompare(trigger.target).clear = false;
                                    'step 1'
                                    if (result.bool) {
                                        if (trigger.target.countGainableCards(player, 'he')) player.gainPlayerCard(trigger.target, true, 'he');
                                        ui.clear();
                                    }
                                },
                                subSkill: {
                                    gain: {
                                        trigger: { player: 'chooseToCompareAfter' },
                                        filter(event, player) {
                                            if (event.getParent().name != 'minirelieren') return false;
                                            return get.position(event.card2, true) == 'o';
                                        },
                                        direct: true,
                                        content() {
                                            player.gain(trigger.card2, 'gain2');
                                        },
                                    },
                                },
                            },
                            minitishen: {
                                group: 'minitishen_tieji',
                                audio: 'retishen',
                                trigger: { target: 'shaUnhirt' },
                                filter(event, player) {
                                    if (player.isPhaseUsing()) return false;
                                    if (get.itemtype(event.cards) != 'cards') return false;
                                    if (event.cards?.length) {
                                        for (var i = 0; i < event.cards.length; i++) {
                                            if (event.cards[i].isInPile()) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    var list = [];
                                    for (var i = 0; i < trigger.cards.length; i++) {
                                        if (trigger.cards[i].isInPile()) {
                                            list.push(trigger.cards[i]);
                                        }
                                    }
                                    player.gain(list, 'gain2');
                                },
                                subSkill: {
                                    tieji: {
                                        audio: 'retishen',
                                        trigger: { player: 'shaMiss' },
                                        filter(event, player) {
                                            return player.isPhaseUsing();
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addTempSkill('minitishen_tieji2', ['phaseBefore', 'phaseZhunbeiAfter', 'phaseJudgeAfter', 'phaseDrawAfter', 'phaseUseAfter', 'phaseDiscardAfter', 'phaseJieshuAfter', 'phaseAfter']);
                                        },
                                    },
                                    tieji2: {
                                        charlotte: true,
                                        audio: 'retishen',
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            return event.card.name == 'sha';
                                        },
                                        forced: true,
                                        content() {
                                            player.removeSkill('minitishen_tieji2');
                                            trigger.directHit.addArray(game.players);
                                            trigger.baseDamage++;
                                        },
                                    },
                                },
                            },
                            miniyajiao: {
                                group: 'miniyajiao_count',
                                audio: 'reyajiao',
                                trigger: { player: ['useCard', 'respond'] },
                                filter(event, player) {
                                    return player != _status.currentPhase && get.itemtype(event.cards) == 'cards';
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    var card = get.cards()[0];
                                    event.card = card;
                                    player.showCards(card, get.translation(player) + '发动了【涯角】');
                                    player.chooseTarget('是否令一名角色获得' + get.translation(card) + '？').set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (_status.event.du) {
                                            if (target.hasSkillTag('nodu')) return 0;
                                            return -att;
                                        }
                                        if (att > 0) return att + Math.max(0, 5 - target.countCards('h'));
                                        return att;
                                    }).set('du', event.card.name == 'du');
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        target.gain(card, 'gain2');
                                    }
                                    else {
                                        player.$throw(card, 1000);
                                        game.delayx();
                                        game.cardsDiscard(card);
                                        game.log(card, '进入了弃牌堆');
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, 'respond') && target.countCards('h') > 1) return [1, 0.2];
                                        },
                                    },
                                },
                                subSkill: {
                                    count: {
                                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                                        forced: true,
                                        popup: false,
                                        filter(event, player) {
                                            return lib.translate[event.skill] == '龙胆' && player == _status.currentPhase;
                                        },
                                        content() {
                                            player.addTempSkill('miniyajiao_draw');
                                            player.addMark('miniyajiao_draw', 1, false);
                                        },
                                    },
                                    draw: {
                                        audio: 'reyajiao',
                                        trigger: { player: 'phaseJieshuBegin' },
                                        forced: true,
                                        charlotte: true,
                                        onremove: true,
                                        filter(event, player) {
                                            return player.hasMark('miniyajiao_draw');
                                        },
                                        content() {
                                            player.draw(player.countMark('miniyajiao_draw'));
                                        },
                                    },
                                },
                            },
                            miniliegong: {
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (card.name == 'sha') return true;
                                    },
                                },
                                shaRelated: true,
                                audio: 'liegong',
                                trigger: { player: 'useCardToPlayered' },
                                check(event, player) {
                                    return get.attitude(player, event.target) <= 0;
                                },
                                forced: true,
                                locked: false,
                                logTarget: 'target',
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    return event.target.countCards('h') <= player.countCards('h') || event.target.hp >= player.hp;
                                },
                                preHidden: true,
                                content() {
                                    if (trigger.target.countCards('h') <= player.countCards('h')) trigger.getParent().directHit.push(trigger.target);
                                    if (trigger.target.hp >= player.hp) {
                                        var id = trigger.target.playerid;
                                        var map = trigger.getParent().customArgs;
                                        if (!map[id]) map[id] = {};
                                        if (typeof map[id].extraDamage != 'number') {
                                            map[id].extraDamage = 0;
                                        }
                                        map[id].extraDamage++;
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg.card.name != 'sha') return false;
                                        return arg.target.countCards('h') <= player.countCards('h');
                                    },
                                },
                            },
                            minikuanggu: {
                                audio: 'kuanggu',
                                trigger: { source: 'damageSource' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    player.chooseDrawRecover(true);
                                    'step 2'
                                    if (event.count > 0 && player.hasSkill('minikuanggu')) event.goto(1);
                                },
                            },
                            minidangxian: {
                                audio: 'dangxian',
                                audioname2: { guansuo: "dangxian_guansuo" },
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    var next = player.phaseUse();
                                    event.next.remove(next);
                                    trigger.next.push(next);
                                    var card = get.cardPile(function (card) {
                                        return card.name == 'sha';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                    game.updateRoundNumber();
                                },
                            },
                            minifuli: {
                                audio: 'fuli',
                                skillAnimation: true,
                                animationColor: 'soil',
                                unique: true,
                                limited: true,
                                enable: 'chooseToUse',
                                mark: true,
                                filter(event, player) {
                                    if (event.type != 'dying') return false;
                                    if (player != event.dying) return false;
                                    return true;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('minifuli');
                                    event.num = game.countGroup();
                                    player.recover(event.num - player.hp);
                                    'step 1'
                                    var num2 = num - player.countCards('h');
                                    if (num2) player.draw(num2);
                                    'step 2'
                                    if (num > 3) player.turnOver();
                                    player.storage.minifuli = true;
                                },
                                ai: {
                                    save: true,
                                    skillTagFilter(player, arg, target) {
                                        return player == target;
                                    },
                                    result: {
                                        player: 10
                                    },
                                },
                                intro: { content: 'limited' },
                            },
                            miniqimou: {
                                unique: true,
                                limited: true,
                                audio: 'qimou',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hp >= 1;
                                },
                                mark: true,
                                intro: { content: 'limited' },
                                skillAnimation: true,
                                animationColor: 'orange',
                                content() {
                                    'step 0'
                                    var shas = player.getCards('h', 'sha');
                                    var num, map = {}, list = [];
                                    if (player.hp >= 4 && shas.length >= 3) num = 3;
                                    else if (player.hp >= 3 && shas.length >= 2) num = 2;
                                    else num = 1;
                                    for (var i = 1; i <= player.hp; i++) {
                                        var cn = get.cnNumber(i, true);
                                        map[cn] = i;
                                        list.push(cn);
                                    }
                                    event.map = map;
                                    player.awakenSkill('miniqimou');
                                    player.storage.miniqimou = true;
                                    player.chooseControl(list, function () {
                                        return get.cnNumber(_status.event.goon, true);
                                    }).set('prompt', '奇谋：选择失去任意点体力').set('goon', num);
                                    'step 1'
                                    var num = event.map[result.control] || 1;
                                    player.storage.miniqimou2 = num;
                                    player.loseHp(num);
                                    player.draw();
                                    player.addTempSkill('miniqimou2');
                                },
                                ai: {
                                    order: 2,
                                    result: {
                                        player(player) {
                                            if (player.hp == 1) return 0;
                                            var shas = player.getCards('h', 'sha');
                                            if (!shas.length) return 0;
                                            var card = shas[0];
                                            if (!lib.filter.cardEnabled(card, player)) return 0;
                                            if (lib.filter.cardUsable(card, player)) return 0;
                                            var mindist;
                                            if (player.hp >= 4 && shas.length >= 3) mindist = 4;
                                            else if (player.hp >= 3 && shas.length >= 2) mindist = 3;
                                            else mindist = 2;
                                            if (game.hasPlayer(function (current) {
                                                return (current.hp <= mindist - 1 &&
                                                    get.distance(player, current, 'attack') <= mindist &&
                                                    player.canUse(card, current, false) &&
                                                    get.effect(current, card, player, player) > 0);
                                            })) return 1;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            miniqimou2: {
                                onremove: true,
                                mod: {
                                    cardUsable(card, player, num) {
                                        if (typeof player.storage.miniqimou2 == 'number' && card.name == 'sha') return num + player.storage.miniqimou2;
                                    },
                                    globalFrom(from, to, distance) {
                                        if (typeof from.storage.miniqimou2 == 'number') return distance - from.storage.miniqimou2;
                                    },
                                },
                            },
                            minilianhuan: {
                                audio: 'lianhuan1',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minilianhuan'), [1, 2]).set('ai', function (target) {
                                        var player = _status.event.player, eff = get.effect(target, { name: 'tiesuo' }, player, player);
                                        if (target == player) return eff * 5;
                                        return eff;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        result.targets.sortBySeat()
                                        player.logSkill('minilianhuan', result.targets);
                                        for (var target of result.targets) target.link();
                                        if (result.targets.includes(player)) player.draw();
                                    }
                                },
                            },
                            minirelianhuan: {
                                audio: 'xinlianhuan',
                                audioname: ['ol_pangtong'],
                                trigger: { player: ['phaseUseBegin', 'useCard2', 'useCardToPlayered'] },
                                filter(event, player, name) {
                                    const card = new lib.element.VCard({ name: 'tiesuo' });
                                    if (event.name == 'phaseUse') return player.hasUseTarget(card, false);
                                    if (event.card.name != 'tiesuo') return false;
                                    if (name == 'useCard2') return game.hasPlayer(current => !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current));
                                    return event.target != player && !event.target.isLinked() && event.target.countCards('h');
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const card = new lib.element.VCard({ name: 'tiesuo' });
                                    if (trigger.name == 'phaseUse') player.chooseUseTarget('###' + get.prompt('minirelianhuan') + '###视为使用【铁索连环】', card, false).set('logSkill', 'minirelianhuan');
                                    else if (event.triggername == 'useCardToPlayered') {
                                        const target = trigger.target;
                                        player.logSkill('minirelianhuan', target);
                                        const cards = target.getDiscardableCards(player, 'h');
                                        if (cards.length) await target.discard(cards.randomGet()).set('discarder', player);
                                    }
                                    else {
                                        const { result: { bool, targets } } = await player.chooseTarget(get.prompt('minirelianhuan'), (card, player, target) => {
                                            const trigger = get.event().getTrigger();
                                            if (trigger.targets.includes(target)) return false;
                                            return lib.filter.targetEnabled2(trigger.card, player, target) && lib.filter.targetInRange(trigger.card, player, target);
                                        }, [1, Infinity]).set('prompt2', '为' + get.translation(trigger.card) + '选择任意额外目标').set('ai', target => {
                                            const player = get.event('player'), trigger = get.event().getTrigger();
                                            return get.effect(target, trigger.card, player, player) * (trigger.targets.includes(target) ? -1 : 1);
                                        });
                                        if (bool) {
                                            player.logSkill('minirelianhuan', targets);
                                            trigger.targets.addArray(targets);
                                            if (targets.includes(player)) await player.draw();
                                        }
                                    }
                                },
                            },
                            mininiepan: {
                                unique: true,
                                limited: true,
                                audio: 'olniepan',
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    return event.type == 'dying' && event.dying == player;
                                },
                                skillAnimation: true,
                                animationColor: 'orange',
                                async content(event, trigger, player) {
                                    player.awakenSkill('mininiepan');
                                    await player.discard(player.getCards('hej'));
                                    await player.link(false);
                                    await player.turnOver(false);
                                    await player.draw(3);
                                    if (player.hp < 3) await player.recover(3 - player.hp);
                                    const map = { '八阵': 'minibazhen', '火计＆看破': ['minihuoji', 'olkanpo'] };
                                    const { result: { control } } = await player.chooseControl(Object.keys(map)).set('prompt', '涅槃：请选择获得其中一个选项的技能').set('ai', () => {
                                        return Object.keys(get.event('map')).randomGet();
                                    }).set('map', map);
                                    if (control) await player.addSkills(map[control]);
                                },
                                derivation: ['minibazhen', 'minihuoji', 'olkanpo'],
                                ai: {
                                    order: 1,
                                    save: true,
                                    skillTagFilter(player, tag, target) {
                                        if (player != target || player.storage.mininiepan) return false;
                                    },
                                    result: {
                                        player(player) {
                                            if (player.hp <= 0) return 10;
                                            if (player.hp <= 2 && player.countCards('he') <= 1) return 10;
                                            return 0;
                                        }
                                    },
                                },
                            },
                            minitiaoxin: {
                                audio: 'tiaoxin',
                                audioname: ['ol_jiangwei', 'sp_jiangwei', 'xiahouba'],
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current.countCards('h') && current != player;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minitiaoxin'), function (card, player, target) {
                                        return target.countCards('h') && target != player;
                                    }, function (target) {
                                        var player = _status.event.player;
                                        if (target.countDiscardableCards(player, 'h') >= 2) return get.effect(target, { name: 'guohe_copy2' }, player, player) * 2;
                                        return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minitiaoxin', target);
                                        player.discardPlayerCard(target, 'h', [1, 2], true);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var bool = false;
                                    for (var i of result.cards) {
                                        if (i.name == 'sha') bool = true;
                                    }
                                    if (bool && player.countCards('he')) player.chooseToDiscard(true, 'he');
                                },
                            },
                            minizhiji: {
                                audio: 'olzhiji',
                                unique: true,
                                juexingji: true,
                                trigger: { player: 'phaseZhunbeiBegin' },
                                forced: true,
                                filter(event, player) {
                                    return player.countCards('h') == 0;
                                },
                                skillAnimation: true,
                                animationColor: 'fire',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minizhiji');
                                    player.chooseDrawRecover(2, true);
                                    'step 1'
                                    player.loseMaxHp();
                                    'step 2'
                                    player.addSkills(lib.skill[event.name].derivation);
                                },
                                derivation: 'minireguanxing',
                            },
                            minihuoshou: {
                                group: ['huoshou1', 'minihuoshou2'],
                                audio: 'huoshou1',
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (card.name == 'nanman') return 0;
                                        },
                                    },
                                },
                            },
                            minihuoshou2: {
                                audio: 'huoshou1',
                                trigger: { global: 'useCard' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'nanman' && event.player != player;
                                },
                                forced: true,
                                content() {
                                    trigger.customArgs.default.customSource = player;
                                    player.draw();
                                },
                            },
                            minirehuoshou: {
                                audio: 'sbhuoshou',
                                trigger: {
                                    player: 'phaseUseBegin',
                                },
                                forced: true,
                                onremove: true,
                                group: ['minirehuoshou_cancel', 'minirehuoshou_source', 'minirehuoshou_nanmaned'],
                                async content(event, trigger, player) {
                                    const card = get.discardPile(card => card.name == 'nanman');
                                    if (card) {
                                        await player.gain(card, 'gain2');
                                    } else {
                                        game.log('但是弃牌堆里并没有', '#y南蛮入侵', '！');
                                        player.addMark(event.name, 1, false);
                                        if (player.countMark(event.name) >= 5 && Math.random() < 0.25) player.chat('我南蛮呢');
                                    }
                                },
                                subSkill: {
                                    cancel: {
                                        audio: 'sbhuoshou',
                                        trigger: {
                                            target: 'useCardToBefore',
                                        },
                                        forced: true,
                                        priority: 15,
                                        filter(event, player) {
                                            return event.card.name == 'nanman';
                                        },
                                        content() {
                                            trigger.cancel();
                                        },
                                    },
                                    source: {
                                        audio: 'sbhuoshou',
                                        trigger: {
                                            global: 'useCardToPlayered',
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            return event.isFirstTarget && event.card?.name == 'nanman' && event.player != player;
                                        },
                                        async content(event, trigger, player) {
                                            trigger.getParent().customArgs.default.customSource = player;
                                            await player.draw();
                                        },
                                        ai: {
                                            halfneg: true,
                                        },
                                    },
                                    nanmaned: {
                                        trigger: {
                                            player: 'useCard1',
                                        },
                                        filter(event, player) {
                                            return event.card.name == 'nanman';
                                        },
                                        forced: true,
                                        popup: false,
                                        charlotte: true,
                                        content() {
                                            player.addTempSkill('minirehuoshou_ban', 'phaseUseAfter');
                                        },
                                    },
                                    ban: {
                                        charlotte: true,
                                        intro: {
                                            content: '此阶段不能再使用【南蛮入侵】',
                                        },
                                    },
                                },
                                mod: {
                                    cardEnabled(card, player) {
                                        if (player.hasSkill('minirehuoshou_ban') && card.name == 'nanman') return false;
                                    },
                                },
                                ai: {
                                    threaten: 1.9,
                                },
                            },
                            minizaiqi: {
                                audio: 'zaiqi',
                                trigger: {
                                    player: ['phaseDrawBegin1', 'phaseJieshuBegin'],
                                },
                                filter(event, player) {
                                    if (event.name == 'phaseJieshu') return player.hasHistory('sourceDamage');
                                    return !event.numFixed && player.hp < player.maxHp;
                                },
                                check(event, player) {
                                    if (event.name == 'phaseJieshu') return true;
                                    if (player.getDamagedHp() < 2) {
                                        return false;
                                    } else if (player.getDamagedHp() == 2) {
                                        return player.countCards('h') >= 2;
                                    }
                                    return true;
                                },
                                async content(event, trigger, player) {
                                    if (trigger.name == 'phaseDraw') trigger.changeToZero();
                                    const number = player.getHistory('sourceDamage').reduce((sum, evt) => sum + evt.num, 0);
                                    event.cards = get.cards(trigger.name == 'phaseJieshu' ? number : player.getDamagedHp());
                                    await game.cardsGotoOrdering(event.cards);
                                    await player.showCards(event.cards);
                                    let num = 0;
                                    for (let i = 0; i < event.cards.length; i++) {
                                        if (get.suit(event.cards[i]) == 'heart') {
                                            num++;
                                            event.cards.splice(i--, 1);
                                        }
                                    }
                                    if (num) await player.recover(num);
                                    if (event.cards.length) {
                                        await player.gain(event.cards, 'gain2');
                                    }
                                },
                                ai: {
                                    threaten(player, target) {
                                        if (target.hp == 1) return 2;
                                        if (target.hp == 2) return 1.5;
                                        return 1;
                                    },
                                },
                            },
                            minifangquan: {
                                audio: 'fangquan',
                                trigger: { player: 'phaseUseBefore' },
                                filter(event, player) {
                                    return !player.hasSkill('minifangquan2');
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    var fang = player.countMark('minifangquan2') == 0 && player.hp >= 2 && player.countCards('h') <= player.hp + 1;
                                    player.chooseBool(get.prompt2('minifangquan')).set('ai', function () {
                                        if (!_status.event.fang) return false;
                                        return game.hasPlayer(function (target) {
                                            if (target.hasJudge('lebu') || target == player) return false;
                                            if (get.attitude(player, target) > 4) {
                                                return (get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1) > 0);
                                            }
                                            return false;
                                        });
                                    }).set('fang', fang).setHiddenSkill(event.name);
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minifangquan');
                                        trigger.cancel();
                                        player.addTempSkill('minifangquan2');
                                    }
                                },
                            },
                            minifangquan2: {
                                trigger: { player: 'phaseEnd' },
                                forced: true,
                                popup: false,
                                audio: false,
                                onremove: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget('放权：请选择进行额外回合的目标角色', lib.filter.notMe).ai = function (target) {
                                        if (target.hasJudge('lebu')) return -1;
                                        if (get.attitude(player, target) > 4) {
                                            return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1);
                                        }
                                        return -1;
                                    };
                                    'step 1'
                                    var target = result.targets[0];
                                    player.line(target, 'fire');
                                    target.markSkillCharacter('minifangquan', player, '放权', '进行一个额外回合');
                                    target.insertPhase();
                                    target.addSkill('minifangquan3');
                                }
                            },
                            minifangquan3: {
                                trigger: { player: ['phaseAfter', 'phaseCancelled'] },
                                forced: true,
                                popup: false,
                                audio: false,
                                content() {
                                    player.unmarkSkill('minifangquan');
                                    player.removeSkill('minifangquan3');
                                },
                            },
                            miniruoyu: {
                                unique: true,
                                keepSkill: true,
                                derivation: 'minijijiang',
                                audio: 'ruoyu',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.isMinHp();
                                },
                                forced: true,
                                juexingji: true,
                                zhuSkill: true,
                                skillAnimation: true,
                                animationColor: 'fire',
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniruoyu');
                                    player.gainMaxHp();
                                    'step 1'
                                    player.recover();
                                    'step 2'
                                    player.addSkills('minijijiang');
                                    'step 3'
                                    if (player.isZhu2()) event.trigger('zhuUpdate');
                                },
                            },
                            //小胖
                            minirexiangle: {
                                audio: 'xiangle',
                                inherit: 'xiangle',
                                group: 'minirexiangle_fangquan',
                                subSkill: {
                                    fangquan: {
                                        audio: 'xiangle',
                                        audioname: ['ol_liushan'],
                                        trigger: { global: 'roundStart' },
                                        filter(event, player) {
                                            if (!player.hasSkill('minirefangquan')) return false;
                                            return game.roundNumber > 1 && !player.getRoundHistory('useCard', () => true, 1).length && game.hasPlayer(current => current != player);
                                        },
                                        async cost(event, trigger, player) {
                                            const num = Math.floor(player.getSeatNum() / 2);
                                            event.result = await player.chooseCardTarget({
                                                prompt: get.prompt('minirexiangle_fangquan'),
                                                prompt2: (num > 0 ? ('弃置' + get.cnNumber(num) + '张牌，') : '') + '令一名其他角色进行一个额外回合',
                                                position: 'he',
                                                filterTarget: lib.filter.notMe,
                                                filterCard(card, player) {
                                                    if (get.event('num') <= 0) return false;
                                                    return lib.filter.cardDiscardable(card, player);
                                                },
                                                selectCard() {
                                                    return get.event('num') <= 0 ? -1 : get.event('num');
                                                },
                                                ai1(card) {
                                                    return 3 / (Math.abs(get.value(card)) + 0.1);
                                                },
                                                ai2(target) {
                                                    const player = get.player();
                                                    if (target.hasJudge('lebu')) return -1;
                                                    if (get.attitude(player, target) > 4) {
                                                        return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1);
                                                    }
                                                    return -1;
                                                },
                                            }).set('num', num).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            const target = event.targets[0];
                                            await player.logSkill('minirefangquan', target);
                                            if (event.cards?.length) await player.discard(event.cards);
                                            await player.turnOver();
                                            if (player.countCards('he')) {
                                                await player.chooseToGive(target, 'he', [1, Infinity]).set('prompt', '放权：是否交给' + get.translation(target) + '任意张牌？');
                                            }
                                            const evt = trigger;
                                            target.markSkillCharacter('minirefangquan', player, '放权', '进行一个额外回合');
                                            target.insertPhase();
                                            target.addSkill('minirefangquan3');
                                            if (evt.player != target && !evt._finished) {
                                                evt.finish();
                                                evt._triggered = 5;
                                                const evtxx = evt.player.insertPhase();
                                                if (trigger.skill) evtxx.skill = trigger.skill;
                                                else delete evtxx.skill;
                                            }
                                        },
                                    }
                                }
                            },
                            minirefangquan: {
                                audio: 'olfangquan',
                                trigger: { player: 'phaseUseBefore' },
                                filter(event, player) {
                                    return !player.hasSkill('minirefangquan3');
                                },
                                async cost(event, trigger, player) {
                                    const fang = player.countMark('minirefangquan2') == 0 && player.hp >= 2 && player.countCards('h') <= player.hp + 2;
                                    const bool = await player.chooseBool(get.prompt2(event.name.slice(0, -5))).set('ai', function () {
                                        if (!_status.event.fang) return false;
                                        return game.hasPlayer(function (target) {
                                            if (target.hasJudge('lebu') || target == player) return false;
                                            if (get.attitude(player, target) > 4) {
                                                return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards('h') + 1) > 0;
                                            }
                                            return false;
                                        });
                                    }).set('fang', fang).forResultBool();
                                    event.result = {
                                        bool: bool,
                                    }
                                },
                                async content(event, trigger, player) {
                                    trigger.cancel();
                                    player.addTempSkill('minirefangquan2');
                                    player.addMark('minirefangquan2', 1, false);
                                },
                            },
                            minirefangquan2: {
                                inherit: 'olfangquan2',
                                async content(event, trigger, player) {
                                    let num = player.countMark(event.name);
                                    player.removeMark(event.name, num, false);
                                    while (num--) {
                                        const { result: { bool, targets } } = await player.chooseTarget('请选择进行额外回合的目标角色', lib.filter.notMe).set('ai', target => {
                                            if (target.hasJudge('lebu')) return -1;
                                            if (get.attitude(player, target) > 4) {
                                                return get.threaten(target) / Math.sqrt(target.hp + 1) / Math.sqrt(target.countCards("h") + 1);
                                            }
                                            return -1;
                                        });
                                        if (bool) {
                                            const target = targets[0];
                                            player.line(target, 'fire');
                                            if (player.countCards('he')) {
                                                await player.chooseToGive(target, 'he', [1, Infinity]).set('prompt', '放权：是否交给' + get.translation(target) + '任意张牌？');
                                            }
                                            target.markSkillCharacter('minirefangquan', player, '放权', '进行一个额外回合');
                                            target.insertPhase();
                                            target.addSkill('minirefangquan3');
                                        }
                                    }
                                },
                            },
                            minirefangquan3: {
                                inherit: 'olfangquan3',
                                async content(event, trigger, player) {
                                    player.unmarkSkill('minirefangquan');
                                    player.removeSkill('minirefangquan3');
                                },
                            },
                            minireruoyu: {
                                audio: 'olruoyu',
                                inherit: 'olruoyu',
                                derivation: ['minijijiang', 'sishu'],
                                filter(event, player) {
                                    if (!player.hasZhuSkill('minireruoyu')) return false;
                                    return player.isMinHp();
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    await player.gainMaxHp();
                                    await player.recover();
                                    await player.addSkills(get.info(event.name).derivation);
                                },
                            },
                            minixuanhuo: {
                                audio: 'xinxuanhuo',
                                trigger: { player: 'phaseDrawBegin1' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minixuanhuo'), function (card, player, target) {
                                        return player != target;
                                    }).set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (target.countCards('he') == 0) return 0;
                                        if (att < 0) return -att * 2;
                                        return att / 3;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minixuanhuo', result.targets);
                                        event.target = result.targets[0];
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.chooseTarget('眩惑：请选择' + get.translation(target) + '出杀的目标', true, function (card, player, target) {
                                        return _status.event.target.canUse('sha', target);
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        if (!_status.event.target.canUse('sha', target) && get.attitude(player, _status.event.target) < 0) return 8 + get.attitude(player, target);
                                        if (!_status.event.target.inRange(target) && get.attitude(player, _status.event.target) < 0) return 5 + get.attitude(player, target);
                                        return get.effect(target, { name: 'sha' }, _status.event.target, player);
                                    }).set('target', event.target);
                                    'step 3'
                                    if (result.bool && result.targets.length) {
                                        game.log(player, '指定的出杀目标为', result.targets[0]);
                                        event.target.line(result.targets[0]);
                                        target.chooseToUse(function (card, player, event) {
                                            if (get.name(card) != 'sha') return false;
                                            return lib.filter.filterCard.apply(this, arguments);
                                        }, '眩惑：对' + get.translation(result.targets[0]) + '使用一张杀，或令' + get.translation(player) + '获得你的一张牌').set('targetRequired', true).set('complexSelect', true).set('filterTarget', function (card, player, target) {
                                            if (target != _status.event.sourcex && !ui.selected.targets.includes(_status.event.sourcex)) return false;
                                            return lib.filter.filterTarget.apply(this, arguments);
                                        }).set('sourcex', result.targets[0]);
                                    }
                                    else event.bool = true;
                                    'step 4'
                                    if (event.bool || result.bool == false) player.gainPlayerCard('he', event.target, true);
                                },
                            },
                            minienyuan: {
                                group: 'minienyuan_draw',
                                subfrequent: ['draw'],
                                audio: 'xinenyuan2',
                                trigger: { player: 'gainEnd' },
                                filter(event, player) {
                                    return event.source && event.source.isIn() && event.source != player;
                                },
                                logTarget: 'source',
                                check(event, player) {
                                    return get.attitude(player, event.source) > 0;
                                },
                                content() {
                                    trigger.source.draw();
                                },
                                subSkill: {
                                    draw: {
                                        audio: 'xinenyuan',
                                        trigger: { global: 'gainAfter' },
                                        frequent: true,
                                        prompt: '是否发动【恩怨】摸一张牌？',
                                        filter(event, player) {
                                            if (event.player != player) {
                                                var evt = event.getl(player);
                                                return evt?.hs?.length > 0;
                                            }
                                            return false;
                                        },
                                        preHidden: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            minireenyuan: {
                                inherit: 'minienyuan',
                                group: ['minienyuan_draw', 'minireenyuan_damage'],
                                subSkill: {
                                    damage: {
                                        audio: 'reenyuan',
                                        trigger: { player: 'damageEnd' },
                                        logTarget: 'source',
                                        filter(event, player) {
                                            return event.source && event.source != player && event.source.isIn() && event.num > 0;
                                        },
                                        getIndex(event, player, triggername) {
                                            return event.num;
                                        },
                                        check(event, player) {
                                            const att = get.attitude(player, event.source);
                                            const num = event.source.countCards("h");
                                            if (att <= 0) return true;
                                            if (num > 2) return true;
                                            if (num) return att < 4;
                                            return false;
                                        },
                                        prompt2: '令该角色选择一项：①失去1点体力。②交给你一张红色手牌。若此牌不为♥，则你摸一张牌。',
                                        async content(event, trigger, player) {
                                            const { source } = trigger;
                                            const result = !source.countCards('h', { color: 'red' }) ? { bool: false } : await source.chooseToGive('h', player, `恩怨：将一张红色手牌交给${get.translation(player)}，否则失去1点体力`, { color: 'red' }).set('ai', card => {
                                                const { player, target } = get.event();
                                                if (get.attitude(player, target) > 0) {
                                                    if (get.suit(card) != 'heart') return 15 - get.value(card);
                                                    return 11 - get.value(card);
                                                } else {
                                                    let num = 12 - player.hp * 2;
                                                    if (get.suit(card) != 'heart') num -= 2;
                                                    return num - get.value(card);
                                                }
                                            }).forResult();
                                            if (!result.bool) await source.loseHp();
                                            else if (get.suit(result.cards[0]) != 'heart') await player.draw();
                                        }
                                    }
                                }
                            },
                            minirexuanhuo: {
                                audio: 'xinxuanhuo',
                                trigger: { player: 'phaseDrawEnd' },
                                filter(event, player) {
                                    return player.countCards('h') && game.countPlayer() > 2;
                                },
                                async cost(event, trigger, player) {
                                    const ai2 = function (target) {
                                        const player = get.player();
                                        const goon = game.hasPlayer(current => get.attitude(player, current) > 0 && player != current);
                                        if (get.attitude(player, target) <= 0 && goon) return 0;
                                        const list = [null, 'juedou'].concat(lib.inpile_nature);
                                        if (target.hasSkill('ayato_zenshen')) list.push('kami');
                                        let num = Math.max.apply(Math, list.map(i => {
                                            if (i == 'juedou') return target.getUseValue({ name: 'juedou', isCard: true }, false);
                                            const card = { name: 'sha', nature: i, isCard: true };
                                            return target.getUseValue(card, false);
                                        }));
                                        if (goon) num += 1;
                                        if (target.hasSkillTag('nogain')) num /= 4;
                                        return num;
                                    };
                                    event.result = await player.chooseCardTarget({
                                        prompt: get.prompt2(event.name.slice(0, -5)),
                                        filterCard: true,
                                        selectCard: [1, 2],
                                        position: 'h',
                                        filterTarget: lib.filter.notMe,
                                        goon: game.hasPlayer(current => current != player && ai2(player, current) > 0),
                                        ai1(card) {
                                            if (!_status.event.goon) return 0;
                                            return 7 - get.value(card);
                                        },
                                        ai2: ai2,
                                    }).forResult();
                                },
                                async content(event, trigger, player) {
                                    const { targets: [target], cards } = event;
                                    await player.give(cards, target);
                                    const targetsx = game.filterPlayer(current => {
                                        if (current == player || current == target) return false;
                                        const list = lib.inpile_nature.slice(0);
                                        list.unshift(null);
                                        if (target.hasSkill('ayato_zenshen')) list.add('kami');
                                        return list.some(nature => target.canUse({ name: 'sha', isCard: true, nature: nature }, current, false)) || target.canUse({ name: 'juedou', isCard: true }, current, false);
                                    });
                                    const goon = targetsx.length > 0;
                                    if (!goon && !target.countCards('h')) return;
                                    let result;
                                    if (goon && target.countCards('h')) {
                                        result = await target.chooseControl().set('choiceList', [`视为对${get.translation(player)}选择的另一名其他角色使用任意一种【杀】或【决斗】`, `${get.translation(player)}观看并获得你任意张牌`]).set('ai', () => {
                                            return [0, 1].randomGet();
                                        }).forResult();
                                    }
                                    else result = { index: goon ? 0 : 1 };
                                    if (result.index == 1) await player.gainPlayerCard(target, 'h', [1, Infinity], true, 'visible').set('ai', button => {
                                        const { player, target } = get.event(), { link } = button;
                                        const att = get.attitude(player, target);
                                        if (att > 0) {
                                            if (ui.selected.buttons.length > 1) return 0;
                                            return 6 - get.value(link);
                                        }
                                        return 1;
                                    });
                                    else {
                                        const { result: { targets } } = await player.chooseTarget((card, player, target) => {
                                            return get.event('targetsx').includes(target);
                                        }, `选择${get.translation(target)}使用【杀】或【决斗】的目标`, true).set('target', target).set('ai', target => {
                                            const evt = _status.event;
                                            const list = [null, 'juedou'].concat(lib.inpile_nature);
                                            if (evt.target.hasSkill('ayato_zenshen')) list.push('kami');
                                            return Math.max.apply(Math, list.map(i => {
                                                const card = { name: 'sha', isCard: true };
                                                if (i == 'juedou') card.name = 'juedou';
                                                else if (i) card.nature = i;
                                                if (!evt.target.canUse(card, target, false)) return 0;
                                                return get.effect(target, card, evt.target, evt.player);
                                            }));
                                        }).set('targetsx', targetsx);
                                        if (!targets?.length) return;
                                        const target2 = targets[0];
                                        player.line(target2);
                                        game.log(player, '选择了', target2);
                                        const list = lib.inpile_nature.slice(0);
                                        list.unshift(null);
                                        const vcards = [];
                                        if (target.hasSkill('ayato_zenshen')) list.add('kami');
                                        for (const i of list) {
                                            if (target.canUse({ name: 'sha', isCard: true, nature: i }, target2, false)) vcards.push(['基本', '', 'sha', i]);
                                        }
                                        if (target.canUse({ name: 'juedou', isCard: true }, target2, false)) vcards.push(['基本', '', 'juedou']);
                                        if (!vcards.length) return;
                                        const links = vcards.length == 1 ? vcards : await target.chooseButton([`请选择要对${get.translation(target2)}使用的牌`, [vcards, 'vcard']], true).set("ai", button => {
                                            const player = get.player();
                                            return get.effect(get.event('target2'), { name: button.link[2], isCard: true, nature: button.link[3] }, player, player);
                                        }).set('target2', target2).forResultLinks();
                                        if (!links?.length) return;
                                        await target.useCard({ name: links[0][2], isCard: true, nature: links[0][3] }, false, target2);
                                    }
                                },
                            },
                            miniqianxi: {
                                audio: 'qianxi',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                preHidden: true,
                                content() {
                                    'step 0'
                                    player.draw(2).gaintag = ['miniqianxi'];
                                    player.chooseToDiscard('hes', true, function (card, player) {
                                        return card.hasGaintag('miniqianxi');
                                    });
                                    'step 1'
                                    player.removeGaintag('miniqianxi');
                                    if (!result.bool) {
                                        event.finish();
                                        return;
                                    }
                                    event.color = get.color(result.cards[0]);
                                    player.chooseTarget(function (card, player, target) {
                                        return player != target && get.distance(player, target) <= 1;
                                    }, true).set('ai', function (target) {
                                        return -get.attitude(_status.event.player, target);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'green');
                                        game.log(player, '选择了', target);
                                        target.storage.miniqianxi2 = event.color;
                                        target.addTempSkill('miniqianxi2');
                                        //game.addVideo('storage',target,['miniqianxi2',event.color]);
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!arg.target.hasSkill('miniqianxi2')) return false;
                                        if (arg.card.name == 'sha') return arg.target.storage.miniqianxi2 == 'red' && (!arg.target.getEquip('bagua') || player.hasSkillTag('unequip', false, {
                                            name: arg.card ? arg.card.name : null,
                                            target: arg.target,
                                            card: arg.card
                                        }) || player.hasSkillTag('unequip_ai', false, {
                                            name: arg.card ? arg.card.name : null,
                                            target: arg.target,
                                            card: arg.card
                                        }));
                                        return arg.target.storage.miniqianxi2 == 'black';
                                    }
                                },
                            },
                            miniqianxi2: {
                                forced: true,
                                mark: true,
                                audio: false,
                                content() {
                                    player.removeSkill('miniqianxi2');
                                    delete player.storage.miniqianxi2;
                                },
                                mod: {
                                    cardEnabled2(card, player) {
                                        if (get.color(card) == player.storage.miniqianxi2 && get.position(card) == 'h') return false;
                                    },
                                },
                                intro: {
                                    content(color) {
                                        return '不能使用或打出' + get.translation(color) + '手牌';
                                    },
                                },
                            },
                            minilongyin: {
                                audio: 'relongyin',
                                shaRelated: true,
                                trigger: { global: 'useCard' },
                                direct: true,
                                filter(event, player) {
                                    return event.card.name == 'sha' && player.countCards('he') && event.player.isPhaseUsing();
                                },
                                content() {
                                    'step 0'
                                    game.delayx();
                                    var go = false;
                                    if (get.attitude(player, trigger.player) > 0) {
                                        if (get.color(trigger.card) == 'red') {
                                            go = true;
                                        }
                                        else if (trigger.addCount === false || !trigger.player.isPhaseUsing()) go = false;
                                        else if (!trigger.player.hasSkill('paoxiao') &&
                                            !trigger.player.hasSkill('tanlin3') &&
                                            !trigger.player.hasSkill('zhaxiang2') &&
                                            !trigger.player.hasSkill('fengnu') &&
                                            !trigger.player.getEquip('zhuge')) {
                                            var nh = trigger.player.countCards('h');
                                            if (player == trigger.player) {
                                                go = (player.countCards('h', 'sha') > 0);
                                            }
                                            else if (nh >= 4) {
                                                go = true;
                                            }
                                            else if (player.countCards('h', 'sha')) {
                                                if (nh == 3) {
                                                    go = Math.random() < 0.8;
                                                }
                                                else if (nh == 2) {
                                                    go = Math.random() < 0.5;
                                                }
                                            }
                                            else if (nh >= 3) {
                                                if (nh == 3) {
                                                    go = Math.random() < 0.5;
                                                }
                                                else if (nh == 2) {
                                                    go = Math.random() < 0.2;
                                                }
                                            }
                                        }
                                    }
                                    var next = player.chooseToDiscard(get.prompt('minilongyin'), '弃置一张牌' + (get.color(trigger.card) == 'red' ? '并摸一张牌' : '') + '，令' + get.translation(trigger.player) + '本次使用的【杀】不计入使用次数', 'he');
                                    next.logSkill = ['minilongyin', trigger.player];
                                    next.set('ai', function (card) {
                                        if (_status.event.go) {
                                            return 6 - get.value(card);
                                        }
                                        return 0;
                                    });
                                    next.set('go', go);
                                    'step 1'
                                    if (result.bool) {
                                        if (trigger.addCount !== false) {
                                            trigger.addCount = false;
                                            trigger.player.getStat().card.sha--;
                                        }
                                        if (get.color(trigger.card) == 'red') {
                                            player.draw();
                                        }
                                        if (get.suit(result.cards[0], player) == get.suit(trigger.card)) player.restoreSkill('jiezhong');
                                    }
                                },
                                ai: { expose: 0.2 },
                            },
                            minixiansi: {
                                audio: 'xiansi',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countDiscardableCards(player, 'he');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.bilibili = false;
                                    player.chooseTarget(get.prompt2('minixiansi'), [1, 2], function (card, player, target) {
                                        return target != player && target.countDiscardableCards(player, 'he');
                                    }).set('ai', function (target) {
                                        var num = 1, player = _status.event.player;
                                        if (!target.inRange(player) || !target.canUse({ name: 'sha', isCard: true }, player, false)) num = 3;
                                        return get.effect(target, { name: 'guohe_copy2' }, player, player) * num;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        if (result.targets.length == 1) event.bilibili = true;
                                        result.targets.sortBySeat();
                                        player.logSkill('minixiansi', result.targets);
                                        event.targets = result.targets;
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (event.targets.length) {
                                        var target = event.targets.shift();
                                        event.target = target;
                                        player.discardPlayerCard(target, 'he', true);
                                    }
                                    else event.goto(4);
                                    'step 3'
                                    if (result.bool) {
                                        if (result.cards[0].original == 'e' && target.inRange(player) && target.canUse({ name: 'sha', isCard: true }, player, false)) target.useCard({ name: 'sha', isCard: true }, player, false);
                                        event.goto(2);
                                    }
                                    'step 4'
                                    if (event.bilibili) player.draw();
                                },
                            },
                            minibingzheng: {
                                audio: 'bingzheng',
                                trigger: { player: 'phaseUseEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minibingzheng')).set('ai', function (target) {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        var nh = target.countCards('h');
                                        if (att > 0) {
                                            if (nh == target.hp - 1) {
                                                if (player == target) return att + 1;
                                                return att + 2;
                                            }
                                            if (player == target && player.needsToDiscard()) return att / 3;
                                            return att;
                                        }
                                        else {
                                            if (nh == target.hp + 1) return -att;
                                            if (nh == 0) return 0;
                                            return -att / 2;
                                        }
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minibingzheng', target);
                                        if (target.countCards('h')) {
                                            player.chooseControl().set('choiceList', [
                                                '令' + get.translation(target) + '摸一张牌',
                                                '令' + get.translation(target) + '弃置一张手牌'
                                            ]).set('ai', function () {
                                                return get.attitude(player, target) > 0 ? 0 : 1;
                                            });
                                        }
                                        else event._result = { index: 0 };
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.index == 0) target.draw();
                                    else target.chooseToDiscard('h', true);
                                    'step 3'
                                    if (target.countCards('h') == target.hp) {
                                        player.draw();
                                        if (target == player) { event.finish(); return; }
                                        var next = player.chooseCard('是否交给' + get.translation(target) + '一张牌？', 'he');
                                        next.set('ai', function (card) {
                                            if (_status.event.du && card.name == 'du') return 114514 + 1919810;
                                            if (get.position(card) != 'h') return 0;
                                            if (_status.event.shan && card.name == 'shan') return 11;
                                            if (_status.event.goon) return 10 - get.value(card);
                                            return -get.value(card);
                                        });
                                        if (get.attitude(player, target) > 1 && player.countCards('h', 'shan') > 1 && player.countCards('h') > target.countCards('h')) next.set('shan', true);
                                        if (get.attitude(player, target) > 0 && player.needsToDiscard()) next.set('goon', true);
                                        if (get.attitude(player, target) <= 0) next.set('du', true);
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (result.bool) target.gain(result.cards, player, 'giveAuto');
                                },
                            },
                            miniliangzhu: {
                                audio: 'liangzhu',
                                trigger: { global: 'recoverAfter' },
                                filter(event, player) {
                                    return event.player.isPhaseUsing();
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var list = ['摸一张', '摸两张'];
                                    if (trigger.player.getEquips(1).length) list.push('拿武器');
                                    list.push('cancel2');
                                    player.chooseControl(list).set('prompt', get.prompt2('miniliangzhu')).set('ai', function () {
                                        var player = _status.event.player;
                                        var trigger = _status.event.getTrigger();
                                        if (get.attitude(player, trigger.player) > 0) return '摸两张';
                                        return '摸一张';
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('miniliangzhu', trigger.player);
                                        switch (result.control) {
                                            case '摸一张':
                                                player.draw();
                                                break;
                                            case '摸两张':
                                                trigger.player.draw(2);
                                                break;
                                            case '拿武器':
                                                player.gain(trigger.player.getEquips(1), trigger.player, 'give');
                                                break;
                                        }
                                    }
                                },
                            },
                            minifanxiang: {
                                skillAnimation: true,
                                animationColor: 'fire',
                                audio: 'fanxiang',
                                unique: true,
                                juexingji: true,
                                forceunique: true,
                                derivation: ['xiaoji', 'miniwujian'],
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.getAllHistory('useSkill', function (evt) {
                                        return evt.skill == 'miniliangzhu';
                                    }).length;
                                },
                                forced: true,
                                content() {
                                    'step 1'
                                    player.awakenSkill('minifanxiang');
                                    player.gainMaxHp();
                                    player.recover();
                                    'step 2'
                                    player.addSkills(lib.skill[event.name].derivation);
                                    'step 3'
                                    player.removeSkills('miniliangzhu');
                                },
                            },
                            miniwujian: {
                                audio: 'ext:活动武将/audio/skill:2',
                                audioname2: { Mbaby_sb_sunshangxiang: 'miniwujian_Mbaby_sb_sunshangxiang' },
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('e', function (card) {
                                        return !player.getStorage('miniwujian_alka').includes(get.subtype(card));
                                    });
                                },
                                filterTarget(card, player, target) {
                                    return target != player && player.canUse({ name: 'sha' }, target);
                                },
                                position: 'e',
                                filterCard(card, player) {
                                    return !player.getStorage('miniwujian_alka').includes(get.subtype(card));
                                },
                                check(card) {
                                    return 1 / (get.value(card) || 0.5);
                                },
                                content() {
                                    player.addTempSkill('miniwujian_alka');
                                    player.markAuto('miniwujian_alka', [get.subtype(cards[0])]);
                                    player.useCard({ name: 'sha' }, target, false);
                                },
                                ai: {
                                    order(item, player) {
                                        return get.order({ name: 'sha' }, player) + 1;
                                    },
                                    result: {
                                        target(player, target) {
                                            return get.effect(target, { name: 'sha' }, player, target);
                                        },
                                    },
                                },
                                subSkill: {
                                    alka: { charlotte: true, onremove: true },
                                    Mbaby_sb_sunshangxiang: { audio: 'ext:活动武将/audio/skill:2' },
                                },
                            },
                            minijujian: {
                                audio: 'xinjujian',
                                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                                filter(event, player) {
                                    return player.countCards('he') > player.countCards('he', { type: 'basic' });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        filterTarget: true,
                                        filterCard(card, player) {
                                            return get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player);
                                        },
                                        ai1(card) {
                                            if (get.tag(card, 'damage') && get.type(card) == 'trick') {
                                                return 20;
                                            }
                                            return 9 - get.value(card);
                                        },
                                        ai2(target) {
                                            var att = get.attitude(_status.event.player, target);
                                            if (att > 0) {
                                                if (target.isTurnedOver()) att += 3;
                                                if (target.hp == 1) att += 3;
                                            }
                                            return att;
                                        },
                                        position: 'he',
                                        prompt: get.prompt2('minijujian')
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minijujian', target);
                                        player.discard(result.cards);
                                        if (target.hp == target.maxHp &&
                                            !target.isTurnedOver() &&
                                            !target.isLinked()) {
                                            target.draw(2);
                                            event.finish();
                                        }
                                        else {
                                            var controls = ['draw_card'];
                                            if (target.hp < target.maxHp) {
                                                controls.push('recover_hp');
                                            }
                                            if (target.isLinked() | target.isTurnedOver()) {
                                                controls.push('reset_character');
                                            }
                                            target.chooseControl(controls).ai = function () {
                                                if (target.isTurnedOver()) {
                                                    return 'reset_character';
                                                }
                                                else if (target.hp == 1 && target.maxHp > 2) {
                                                    return 'recover_hp';
                                                }
                                                else if (target.hp == 2 && target.maxHp > 2 && target.countCards('h') > 1) {
                                                    return 'recover_hp';
                                                }
                                                else {
                                                    return 'draw_card';
                                                }
                                            }
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    event.control = result.control;
                                    switch (event.control) {
                                        case 'recover_hp': event.target.recover(); event.finish(); break;
                                        case 'draw_card': event.target.draw(2); event.finish(); break;
                                        case 'reset_character': if (event.target.isTurnedOver()) event.target.turnOver(); break;
                                    }
                                    'step 3'
                                    if (event.control == 'reset_character' && event.target.isLinked()) event.target.link();
                                },
                            },
                            minihuxiao: {
                                audio: 'huxiao',
                                trigger: { source: 'damageSource' },
                                forced: true,
                                filter(event, player) {
                                    if (event._notrigger.includes(event.player)) return false;
                                    return event.hasNature('fire');
                                },
                                logTarget: 'player',
                                content() {
                                    player.addTempSkill('minihuxiao3');
                                    player.markAuto('minihuxiao3', [trigger.player]);
                                },
                            },
                            minihuxiao3: {
                                charlotte: true,
                                onremove: true,
                                mod: {
                                    cardUsableTarget(card, player, target) {
                                        if (player.getStorage('minihuxiao3').includes(target)) return true;
                                    },
                                },
                                intro: { content: 'players' },
                            },
                            miniwuji: {
                                skillAnimation: true,
                                animationColor: 'orange',
                                audio: 'wuji',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                unique: true,
                                juexingji: true,
                                filter(event, player) {
                                    return player.getStat('damage') >= 3;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniwuji');
                                    player.gainMaxHp();
                                    player.recover();
                                    'step 1'
                                    var card = get.cardPile('qinglong', 'field');
                                    if (card) player.gain(card, 'gain2', 'log');
                                },
                            },
                            minisanyao: {
                                audio: 'sanyao',
                                enable: 'phaseUse',
                                usable: 1,
                                selectCard() {
                                    var player = _status.event.player;
                                    return [Math.max(1, ui.selected.targets.length), Math.min(4, game.players.length - 1)];
                                },
                                selectTarget() {
                                    return ui.selected.cards.length;
                                },
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    var player = _status.event.player;
                                    if (game.countPlayer(function (target) {
                                        return target != player && get.effect(target, 'sanyao', player, player) > 0;
                                    }) <= ui.selected.cards.length) return 0;
                                    return 7 - get.value(card);
                                },
                                position: 'he',
                                filterCard: true,
                                content() {
                                    target.damage('nocard');
                                },
                                ai: {
                                    result: {
                                        target(player, target) {
                                            var disbool = false;
                                            if (player.hasSkill('rezhiman')) {
                                                if (target.countCards('j') && get.attitude(player, target) > 0) {
                                                    return 1;
                                                }
                                                if (target.countCards('he', function (card) {
                                                    return card.name == 'tengjia' || get.value(card) > 0;
                                                })) {
                                                    disbool = true;
                                                }
                                            }
                                            var damage = get.damageEffect(target, player);
                                            if (disbool && get.attitude(player, target) < 0) return Math.min(-1, damage);
                                            return damage;
                                        },
                                    },
                                    order: 7,
                                },
                            },
                            minizhuandui: {
                                shaRelated: true,
                                audio: 'zhuandui',
                                group: ['zhuandui_use', 'zhuandui_respond'],
                                trigger: { player: ['chooseToCompareAfter', 'compareMultipleAfter'], target: ['chooseToCompareAfter', 'compareMultipleAfter'] },
                                filter(event, player) {
                                    if (event.preserve) return false;
                                    if (player == event.player) return event.num1 > event.num2;
                                    return event.num2 > event.num1;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player.draw();
                                },
                            },
                            minizuilun: {
                                audio: 'xinfu_zuilun',
                                trigger: { player: 'phaseEnd' },
                                check(event, player) {
                                    var num = 0;
                                    if (player.hasHistory('lose', function (evt) {
                                        return evt.type == 'discard';
                                    })) num++;
                                    if (!player.isMinHandcard()) num++;
                                    if (!player.getStat('damage')) num++;
                                    if (num == 0) return player.hp >= 2;
                                    return true;
                                },
                                prompt(event, player) {
                                    var num = 3;
                                    if (player.hasHistory('lose', function (evt) {
                                        return evt.type == 'discard';
                                    })) num--;
                                    if (!player.isMinHandcard()) num--;
                                    if (!player.getStat('damage')) num--;
                                    return get.prompt('minizuilun') + '（可获得' + get.cnNumber(num) + '张牌）';
                                },
                                content() {
                                    'step 0'
                                    event.num = 0;
                                    event.cards = get.cards(4);
                                    game.cardsGotoOrdering(cards);
                                    if (!player.hasHistory('lose', function (evt) {
                                        return evt.type == 'discard';
                                    })) event.num++;
                                    if (player.isMinHandcard()) event.num++;
                                    if (player.getStat('damage')) event.num++;
                                    'step 1'
                                    var prompt = '罪论：将' + get.cnNumber(4 - num) + '牌置于牌堆顶';
                                    if (num > 0) prompt += '，并获得其余的牌';
                                    var next = player.chooseToMove(prompt, true);
                                    if (num > 0) {
                                        next.set('list', [
                                            ['牌堆顶', cards],
                                            ['获得'],
                                        ]);
                                        next.set('filterMove', function (from, to, moved) {
                                            if (to == 1 && moved[0].length <= 4 - _status.event.num) return false;
                                            return true;
                                        });
                                        next.set('filterOk', function (moved) {
                                            return moved[0].length == 4 - _status.event.num;
                                        });
                                    }
                                    else {
                                        next.set('list', [
                                            ['牌堆顶', cards],
                                        ]);
                                    }
                                    next.set('num', num);
                                    next.set('processAI', function (list) {
                                        var check = function (card) {
                                            var player = _status.event.player;
                                            var next = player.next;
                                            var att = get.attitude(player, next);
                                            var judge = next.getCards('j')[tops.length];
                                            if (judge) return get.judge(judge)(card) * att;
                                            return next.getUseValue(card) * att;
                                        }
                                        var cards = list[0][1].slice(0), tops = [];
                                        while (tops.length < 4 - _status.event.num) {
                                            list.sort(function (a, b) {
                                                return check(b) - check(a);
                                            });
                                            tops.push(cards.shift());
                                        }
                                        return [tops, cards];
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var list = result.moved[0];
                                        var num = list.length - 1;
                                        for (var i = 0; i < list.length; i++) {
                                            event.cards.remove(list[num - i]);
                                            ui.cardPile.insertBefore(list[num - i], ui.cardPile.firstChild);
                                        }
                                    }
                                    'step 3'
                                    game.updateRoundNumber();
                                    if (event.cards.length) {
                                        player.gain(event.cards, 'draw');
                                        game.log(player, '获得了' + get.cnNumber(event.cards.length) + '张牌');
                                        event.finish();
                                    }
                                    else if (game.countPlayer() > 1) {
                                        player.chooseTarget('请选择一名角色，与其一同失去1点体力', true, lib.filter.notMe).set('ai', function (target) {
                                            return -get.attitude(_status.event.player, target);
                                        });
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (result.bool) {
                                        player.line(result.targets[0], 'fire');
                                        player.loseHp();
                                        result.targets[0].loseHp();
                                    }
                                },
                            },
                            miniqiangwu: {
                                audio: 'qiangwu',
                                enable: 'phaseUse',
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.judge();
                                    'step 1'
                                    if (get.position(result.card, true) == 'd') player.gain(result.card, 'gain2');
                                    player.storage.qiangwu = result.number;
                                    player.addTempSkill('qiangwu3', 'phaseUseAfter');
                                },
                                ai: {
                                    order: 11,
                                    result: { player: 1 },
                                },
                            },
                            minifumian: {
                                audio: 'fumian',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    if (player.storage.minifumian_choice == 'draw') {
                                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸一张牌', '使用红色牌可以多选择两个目标', function (event, player) {
                                            if (player.hp == 1 || player.countCards('h') <= 1) return 0;
                                            return 1;
                                        });
                                    }
                                    else if (player.storage.minifumian_choice == 'red') {
                                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸两张牌', '使用红色牌可以多选择一个目标', function (event, player) {
                                            return 0;
                                        });
                                    }
                                    else {
                                        player.chooseControlList(get.prompt('minifumian'), '摸牌阶段多摸一张牌', '使用红色牌可以多选择一个目标', function (event, player) {
                                            if (player.hp == 1 || player.countCards('h') < player.hp) return 0;
                                            return 1;
                                        });
                                    }
                                    'step 1'
                                    if (player.storage.minifumian_choice == 'draw') {
                                        if (result.index == 0) player.storage.minifumian_draw = 1;
                                        else if (result.index == 1) {
                                            player.storage.minifumian_red = 2;
                                            delete player.storage.minifumian_choice;
                                        }
                                    }
                                    else if (player.storage.minifumian_choice == 'red') {
                                        if (result.index == 0) {
                                            player.storage.minifumian_draw = 2;
                                            delete player.storage.minifumian_choice;
                                        }
                                        else if (result.index == 1) player.storage.minifumian_red = 1;
                                    }
                                    else {
                                        if (result.index == 0) {
                                            player.storage.minifumian_draw = 1;
                                            player.storage.minifumian_choice = 'draw';
                                        }
                                        else if (result.index == 1) {
                                            player.storage.minifumian_red = 1;
                                            player.storage.minifumian_choice = 'red';
                                        }
                                    }
                                    if (result.index == 0) {
                                        player.logSkill('minifumian');
                                        player.addTempSkill('minifumian_draw');
                                    }
                                    else if (result.index == 1) {
                                        player.logSkill('minifumian');
                                        player.addTempSkill('minifumian_red');
                                    }
                                },
                                subSkill: {
                                    draw: {
                                        trigger: { player: 'phaseDrawBegin2' },
                                        forced: true,
                                        popup: false,
                                        onremove: true,
                                        filter(event, player) {
                                            return typeof player.storage.minifumian_draw == 'number' && !event.numFixed;
                                        },
                                        content() {
                                            trigger.num += player.storage.minifumian_draw;
                                        },
                                    },
                                    red: {
                                        trigger: { player: 'useCard2' },
                                        direct: true,
                                        mark: true,
                                        onremove: true,
                                        intro: { content: '使用红色牌可以多选择#个目标' },
                                        filter(event, player) {
                                            if (get.color(event.card) != 'red') return false;
                                            var info = get.info(event.card);
                                            if (info.allowMultiple == false) return false;
                                            if (event.targets && !info.multitarget) {
                                                if (game.hasPlayer(function (current) {
                                                    return lib.filter.targetEnabled2(event.card, player, current) && !event.targets.includes(current);
                                                })) return true;
                                            }
                                            return false;
                                        },
                                        content() {
                                            'step 0'
                                            var prompt2 = '额外指定';
                                            if (player.storage.minifumian_red == 2) prompt2 += '至多两';
                                            else prompt2 += '一';
                                            prompt2 += '名' + get.translation(trigger.card) + '的目标'
                                            player.chooseTarget([1, player.storage.minifumian_red], get.prompt('minifumian'), function (card, player, target) {
                                                var player = _status.event.player;
                                                if (_status.event.targets.includes(target)) return false;
                                                return lib.filter.targetEnabled2(_status.event.card, player, target);
                                            }).set('prompt2', prompt2).set('ai', function (target) {
                                                var trigger = _status.event.getTrigger();
                                                var player = _status.event.player;
                                                return get.effect(target, trigger.card, player, player);
                                            }).set('targets', trigger.targets).set('card', trigger.card);
                                            'step 1'
                                            if (result.bool) {
                                                if (!event.isMine()) game.delayx();
                                                event.targets = result.targets;
                                            }
                                            else event.finish();
                                            'step 2'
                                            if (event.targets) {
                                                player.logSkill('minifumian', event.targets);
                                                trigger.targets.addArray(event.targets);
                                            }
                                        },
                                    },
                                },
                            },
                            minidaiyan: {
                                getList(player) {
                                    var list = [], history = player.actionHistory;
                                    for (var i = history.length - 2; i >= 0; i--) {
                                        if (history[i].isSkipped) continue;
                                        if (history[i].isMe) {
                                            for (var evt of history[i].useSkill) {
                                                if (evt.skill == 'minidaiyan') list.addArray(evt.targets);
                                            }
                                            break;
                                        }
                                    }
                                    return list;
                                },
                                audio: 'daiyan',
                                trigger: { player: 'phaseJieshuBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var str = '', list = lib.skill.minidaiyan.getList(player);
                                    if (list.length) str += '（上回合对' + get.translation(list) + '发动过此技能）';
                                    player.chooseTarget(get.prompt('minidaiyan') + str, lib.translate.minidaiyan_info).set('ai', function (target) {
                                        var player = _status.event.player, list = lib.skill.minidaiyan.getList(player);
                                        return get.attitude(player, target) * (list.includes(target) ? 1 : 3);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minidaiyan', target);
                                        var tao = get.cardPile2(function (card) {
                                            return get.suit(card) == 'heart' && get.type(card) == 'basic';
                                        });
                                        if (tao) target.gain(tao, 'gain2');
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (!lib.skill.minidaiyan.getList(player).includes(target)) player.draw();
                                },
                            },
                            minijili: {
                                audio: 'gzjili',
                                inherit: 'gzjili',
                                group: 'minijili_zhiheng',
                                subSkill: {
                                    zhiheng: {
                                        trigger: { player: 'phaseJieshuBegin' },
                                        filter(event, player) {
                                            return player.countCards('he');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseToDiscard('he', get.prompt('minijili'), '弃置一张牌并摸一张牌').set('ai', lib.skill.zhiheng.check).set('complexCard', true).logSkill = 'minijili';
                                            'step 1'
                                            if (result.bool) player.draw();
                                        },
                                    },
                                },
                            },
                            miniqiaoshi: {
                                audio: 'qiaoshi',
                                inherit: 'qiaoshi',
                                filter(event, player) {
                                    return event.player != player && event.player.countCards('h') >= player.countCards('h') && event.player.isIn();
                                },
                            },
                            miniyanyu: {
                                group: 'miniyanyu2',
                                audio: 'yanyu',
                                inherit: 'yanyu',
                            },
                            miniyanyu2: {
                                trigger: { player: 'phaseEnd' },
                                filter(event, player) {
                                    return player.getHistory('useSkill', evt => evt.skill == 'miniyanyu').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniyanyu'), '令一名角色摸两张牌（若该角色为你则改为摸一张牌）').set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target) * (target == player ? 0.7 : 1);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('miniyanyu', target);
                                        target.draw(target == player ? 1 : 2);
                                    }
                                },
                            },
                            minizhengnan: {
                                derivation: ['minirewusheng', 'minidangxian', 'rezhiman'],
                                audio: 'zhengnan',
                                trigger: { global: 'dying' },
                                filter(event, player) {
                                    return !player.getStorage('minizhengnan').includes(event.player);
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.markAuto('minizhengnan', [trigger.player]);
                                    player.recover(trigger.player == player ? 2 : 1);
                                    var list = lib.skill.minizhengnan.derivation.filter(skill => !player.hasSkill(skill));
                                    if (list.length) {
                                        player.draw(trigger.player == player ? 2 : 1);
                                        event.list = list;
                                    }
                                    else {
                                        player.draw(trigger.player == player ? 4 : 3);
                                        event.finish();
                                    }
                                    'step 1'
                                    if (event.list.length == 1) event._result = { control: event.list[0] };
                                    else player.chooseControl(event.list).set('prompt', '征南：选择获得下列技能中的一个').set('ai', function () {
                                        if (event.list.includes('minidangxian')) return 'minidangxian';
                                        return 0;
                                    });
                                    'step 2'
                                    player.addSkills(result.control);
                                },
                                intro: { content: '已因$发动过技能' },
                            },
                            minixiefang: {
                                getNum() {
                                    var num = game.countPlayer(function (current) {
                                        return current.hasSex('female');
                                    });
                                    return Math.max(1, num);
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + lib.skill.minixiefang.getNum();
                                    },
                                    globalFrom(from, to, distance) {
                                        return distance - lib.skill.minixiefang.getNum();
                                    },
                                },
                            },
                            minifengpo: {
                                shaRelated: true,
                                audio: 'fengpo',
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (!['sha', 'juedou'].includes(event.card.name)) return false;
                                    if (player != _status.currentPhase) return false;
                                    return player.getHistory('useCard', function (evt) {
                                        return ['sha', 'juedou'].includes(evt.card.name);
                                    }).indexOf(event.getParent()) == 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseControl('摸牌', '加伤', 'cancel2').set('prompt', get.prompt2('minifengpo'));
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minifengpo', trigger.target);
                                        var num = Math.min(4, trigger.target.countCards('h', { color: 'red' }));
                                        if (result.control == '摸牌') player.draw(num);
                                        else {
                                            var trigger2 = trigger.getParent();
                                            if (typeof trigger2.baseDamage != 'number') trigger2.baseDamage = 1;
                                            trigger2.baseDamage += num;
                                        }
                                    }
                                },
                            },
                            //王平
                            minifeijun: {
                                intro: { content: '已对$发动过〖飞军〗' },
                                audio: 'nzry_feijun',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    if (!player.countCards('he')) return false;
                                    var count = player.getStat('skill').minifeijun || 0;
                                    if (count > player.countMark('wechatbinglve_count')) return false;
                                    return game.hasPlayer(function (current) {
                                        if (current == player) return false;
                                        return current.countCards('he');
                                    });
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var dialog = ui.create.dialog('飞军：弃置一张牌，然后…', 'hidden');
                                        dialog.add([[
                                            ['give', '令一名有牌的其他角色交给你一张牌'],
                                            ['discard', '令一名装备区有牌的其他角色弃置一张装备区里的牌']
                                        ], 'textbutton']);
                                        return dialog;
                                    },
                                    /*
                                    //手搓一个框用来对比一下
                                    dialog:function(event,player){
                                    var list=[
                                    '令一名有牌的其他角色交给你一张牌',
                                    '令一名装备区有牌的其他角色弃置一张装备区里的牌',
                                    ];
                                    var buttons=['give','discard'];
                                    var choiceList=ui.create.dialog('飞军：弃置一张牌，然后…','forcebutton','hidden');
                                    for(var i=0;i<list.length;i++){
                                    var str='<div class="popup text" style="width:calc(100% - 10px);display:inline-block">';
                                    var bool=lib.skill.minifeijun.chooseButton.filter({link:buttons[i]},player);
                                    if(!bool) str+='<div style="opacity:0.5">';
                                    str+=list[i];
                                    if(!bool) str+='</div>';
                                    str+='</div>';
                                    var next=choiceList.add(str);
                                    next.firstChild.addEventListener(lib.config.touchscreen?'touchend':'click',ui.click.button);
                                    next.firstChild.link=buttons[i];
                                    for(var j in lib.element.button){
                                    next[j]=lib.element.button[j];
                                    }
                                    choiceList.buttons.add(next.firstChild);
                                    }
                                    return choiceList;
                                    },
                                    */
                                    filter(button, player) {
                                        if (button.link == 'discard') return game.hasPlayer(function (current) {
                                            if (current == player) return false;
                                            return current.countCards('e');
                                        });
                                        return true;
                                    },
                                    check(button, player) {
                                        if (button.link == 'discard') return 1;
                                        return 2;
                                    },
                                    backup(links) {
                                        return get.copy(lib.skill['minifeijun_' + links[0]]);
                                    },
                                    prompt(links) {
                                        if (links[0] == 'damage') return '弃置一张牌，令一名有牌的其他角色交给你一张牌';
                                        return '弃置一张牌，令一名装备区有牌的其他角色弃置一张装备区的牌';
                                    },
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    backup: { audio: 'nzry_feijun' },
                                    give: {
                                        audio: 'nzry_feijun',
                                        filterTarget(card, player, target) {
                                            if (target == player) return false;
                                            return target.countCards('he');
                                        },
                                        filterCard: true,
                                        position: 'he',
                                        content() {
                                            'step 0'
                                            player.markAuto('minifeijun', [target]);
                                            target.chooseCard('he', true, '飞军：请交给' + get.translation(player) + '一张牌').set('ai', function (card) {
                                                return -get.value(card);
                                            });
                                            'step 1'
                                            if (result.bool) player.gain(result.cards, target, 'giveAuto');
                                        },
                                        ai: {
                                            result: {
                                                player(player, target) {
                                                    var list = player.getStorage('minifeijun');
                                                    return get.effect(target, { name: 'shunshou_copy2' }, player, player) * (list.includes(target) ? 1 : 3);
                                                },
                                            },
                                        },
                                    },
                                    discard: {
                                        audio: 'nzry_feijun',
                                        filterTarget(card, player, target) {
                                            if (target == player) return false;
                                            return target.countCards('e');
                                        },
                                        filterCard: true,
                                        position: 'he',
                                        content() {
                                            player.markAuto('minifeijun', [target]);
                                            target.chooseToDiscard('e', true, '飞军：请弃置一张装备区的牌');
                                        },
                                        ai: {
                                            result: {
                                                player(player, target) {
                                                    var list = player.getStorage('minifeijun');
                                                    return get.effect(target, { name: 'guohe_copy2' }, player, player) * (list.includes(target) ? 1 : 3);
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            minibinglve: {
                                audio: 'nzry_binglve',
                                trigger: { player: 'useSkill' },
                                filter(event, player) {
                                    return event.skill == 'minifeijun_backup';
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    'step 1'
                                    var target = trigger.targets[0];
                                    var list = player.getStorage('minifeijun');
                                    if (!list.includes(target)) {
                                        player.draw(list.filter(function (i) {
                                            return i.isIn();
                                        }).length + 1);
                                    }
                                },
                                ai: { combo: 'minifeijun' },
                            },
                            miniqiaoshui: {
                                mod: {
                                    ignoredHandcard(card, player) {
                                        if (get.type2(card) == 'trick') return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && get.type2(card) == 'trick') return false;
                                    },
                                },
                                audio: 'qiaoshui',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h') && game.hasPlayer(function (target) {
                                        return player.canCompare(target);
                                    }) && !player.hasSkill('miniqiaoshui_silent');
                                },
                                filterTarget(card, player, target) {
                                    return player.canCompare(target);
                                },
                                content() {
                                    'step 0'
                                    player.chooseToCompare(target);
                                    'step 1'
                                    if (result.bool) player.addTempSkill('qiaoshui3');
                                    else player.addTempSkill('miniqiaoshui_silent');
                                },
                                subSkill: { silent: { charlotte: true } },
                                ai: {
                                    order(item, player) {
                                        if (player.countCards('h', function (card) {
                                            return player.hasValueTarget(card);
                                        })) return 10;
                                        return 1;
                                    },
                                    result: {
                                        target(player, target) {
                                            if (player.countCards('h', function (card) {
                                                return player.hasValueTarget(card);
                                            })) {
                                                if (player.hasSkill('qiaoshui3')) return 0;
                                                var nd = !player.needsToDiscard();
                                                if (player.hasCard(function (card) {
                                                    if (get.position(card) != "h") return false;
                                                    var val = get.value(card)
                                                    if (nd && val < 0) return true;
                                                    if (val <= 5) {
                                                        return get.number(card) >= 12;
                                                    }
                                                    if (val <= 6) {
                                                        return get.number(card) >= 13;
                                                    }
                                                    return false;
                                                })) return -1;
                                                return 0;
                                            }
                                            return -1;
                                        },
                                    },
                                },
                            },
                            miniqirang: {
                                group: 'miniqirang_gain',
                                subfrequent: ['gain'],
                                audio: 'qirang',
                                trigger: { player: 'useCard2' },
                                filter(event, player) {
                                    if (get.type(event.card) != 'trick') return false;
                                    if (!event.targets || event.targets.length != 1) return false;
                                    var info = get.info(event.card);
                                    if (info.allowMultiple == false) return false;
                                    if (event.targets && !info.multitarget) {
                                        if (game.hasPlayer(function (current) {
                                            return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                                        })) return true;
                                    }
                                    return false;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniqirang'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                                        var player = _status.event.player;
                                        return lib.filter.targetEnabled2(_status.event.card, player, target) && lib.filter.targetInRange(_status.event.card, player, target);
                                    }).set('ai', function (target) {
                                        var trigger = _status.event.getTrigger();
                                        var player = _status.event.player;
                                        return get.effect(target, trigger.card, player, player) * (_status.event.targets.includes(target) ? -1 : 1);
                                    }).set('targets', trigger.targets).set('card', trigger.card);
                                    'step 1'
                                    if (result.bool) {
                                        if (!event.isMine() && !event.isOnline()) game.delayx();
                                        event.targets = result.targets;
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (targets) {
                                        player.logSkill('miniqirang', targets);
                                        trigger.targets.addArray(targets);
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.type(card) == 'equip' && !get.cardtag(card, 'gifts')) return [1, 3];
                                        },
                                    },
                                },
                                subSkill: {
                                    gain: {
                                        audio: 'qirang',
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            return get.type(event.card) == 'equip';
                                        },
                                        frequent: true,
                                        content() {
                                            var card = get.cardPile(function (card) {
                                                return get.type2(card) == 'trick';
                                            });
                                            if (card) player.gain(card, 'gain2');
                                        },
                                    },
                                },
                            },
                            miniyuhua: {
                                mod: {
                                    ignoredHandcard(card, player) {
                                        if (get.type(card) != 'basic') return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && get.type(card) != 'basic') return false;
                                    },
                                },
                                audio: 'yuhua',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    'step 0'
                                    var cards = get.cards(2);
                                    game.cardsGotoOrdering(cards);
                                    var next = player.chooseToMove();
                                    next.set('list', [
                                        ['牌堆顶', cards],
                                        ['牌堆底'],
                                        ['自己获得'],
                                    ]);
                                    next.set('prompt', '羽化：将一张牌移动到牌堆顶或牌堆底，然后获得另一张牌');
                                    next.set('filterOk', function (moved) {
                                        return moved[2].length == 1;
                                    });
                                    next.set('processAI', function (list) {
                                        var cards = list[0][1], player = _status.event.player;
                                        var target = (_status.event.getTrigger().name == 'phaseZhunbei') ? player : player.next;
                                        var att = get.sgn(get.attitude(player, target));
                                        var top = [];
                                        var judges = target.getCards('j');
                                        var stopped = false;
                                        if (player != target || !target.hasWuxie()) {
                                            for (var i = 0; i < judges.length; i++) {
                                                var judge = get.judge(judges[i]);
                                                cards.sort(function (a, b) {
                                                    return (judge(b) - judge(a)) * att;
                                                });
                                                if (judge(cards[0]) * att < 0) {
                                                    stopped = true; break;
                                                }
                                                else {
                                                    top.unshift(cards.shift());
                                                }
                                            }
                                        }
                                        var bottom;
                                        if (!stopped) {
                                            cards.sort(function (a, b) {
                                                return (get.value(b, player) - get.value(a, player)) * att;
                                            });
                                            while (cards.length) {
                                                if ((get.value(cards[0], player) <= 5) == (att > 0)) break;
                                                top.unshift(cards.shift());
                                            }
                                        }
                                        bottom = cards;
                                        var TempCards1 = top.slice(0);
                                        var TempCards2 = bottom.slice(0);
                                        var gain = TempCards1.addArray(TempCards2)[TempCards1.addArray(TempCards2).length - 1];
                                        top.remove(gain);
                                        bottom.remove(gain);
                                        return [top, bottom, [gain]];
                                    });
                                    'step 1'
                                    var top = result.moved[0];
                                    var bottom = result.moved[1];
                                    var gain = result.moved[2];
                                    top.reverse();
                                    for (var i = 0; i < top.length; i++) {
                                        ui.cardPile.insertBefore(top[i], ui.cardPile.firstChild);
                                    }
                                    for (i = 0; i < bottom.length; i++) {
                                        ui.cardPile.appendChild(bottom[i]);
                                    }
                                    player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                                    game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                                    game.updateRoundNumber();
                                    player.gain(gain, 'draw');
                                    game.log(player, '获得了一张牌');
                                },
                            },
                            minibazhen: {
                                audio: 'bazhen',
                                audioname: ['ol_pangtong'],
                                group: 'bazhen_bagua',
                                trigger: { player: 'judgeEnd' },
                                filter(event, player) {
                                    return event.skill && event.skill.indexOf('bagua') != -1 && !event.result.bool;
                                },
                                forced: true,
                                content() {
                                    player.draw();
                                },
                            },
                            minihuoji: {
                                audio: 'huoji',
                                audioname: ['ol_pangtong'],
                                trigger: { player: 'chooseToDiscardBegin' },
                                filter(event) {
                                    return event.getParent().name == 'huogong';
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var cards = get.cards(4, true);
                                    player.chooseButton(['火计：是否选择其中一张牌作为弃置牌？', cards]).set('filterButton', function (button) {
                                        var evt = _status.event;
                                        _status.event = _status.event.getTrigger();
                                        var check = _status.event.filterCard(button.link, _status.event.player);
                                        _status.event = evt;
                                        return check;
                                    }).set('ai', button => 1 + Math.random());
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill(event.name);
                                        trigger.getParent().dialog.close();
                                        game.addVideo('cardDialog', null, trigger.getParent().videoId);
                                        game.broadcast('closeDialog', trigger.getParent().videoId);
                                        var cards = result.links;
                                        player.$throw(cards, 1000);
                                        game.delayx();
                                        game.cardsDiscard(cards);
                                        game.log(player, '弃置了', cards, '#g（源自牌堆）');
                                        trigger.finish();
                                        trigger.getParent()._result = { bool: true };
                                    }
                                    'step 2'
                                    game.updateRoundNumber();
                                },
                                ai: { fireAttack: true },
                                group: 'minihuoji_viewAs',
                                subSkill: { viewAs: { inherit: 'rehuoji', audio: 'huoji', audioname: ['ol_pangtong'] } },
                            },
                            minixushen: {
                                derivation: 'decadezhennan',
                                audio: 'xinfu_xushen',
                                trigger: { player: 'dying' },
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'orange',
                                filter(event, player) {
                                    return player.hp < 1;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('minixushen');
                                    player.addTempSkill('minixushen2');
                                    trigger.minixushen = true;
                                    player.recover();
                                    'step 1'
                                    player.addSkills('decadezhennan');
                                },
                            },
                            minixushen2: {
                                trigger: { player: 'dyingAfter' },
                                forced: true,
                                popup: false,
                                charlotte: true,
                                filter(event, player) {
                                    return event.minixushen == true && !game.hasPlayer(function (current) {
                                        return current.name == 'Mbaby_guansuo' || current.name2 == 'Mbaby_guansuo';
                                    });
                                },
                                content() {
                                    'step 0'
                                    player.chooseTarget(lib.filter.notMe, '许身：是否令一名其他角色选择是否将其武将牌替换为“关索”并令其摸三张牌？').set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target);
                                    });
                                    'step 1'
                                    if (!result.bool) {
                                        event.finish();
                                        return;
                                    }
                                    var target = result.targets[0];
                                    event.target = target;
                                    player.line(target, 'fire');
                                    target.chooseBool('许身：是否将自己的一张武将牌替换为“关索”并令' + get.translation(player) + '摸三张牌？');
                                    'step 2'
                                    if (result.bool) {
                                        if (target.name2) target.chooseControl(target.name1, target.name2).set('prompt', '请选择要更换的武将牌');
                                        else event._result = { control: target.name };
                                    }
                                    else event.goto(4);
                                    'step 3'
                                    target.reinitCharacter(result.control, 'Mbaby_guansuo');
                                    if (target.name == 'Mbaby_guansuo' && target.group != 'shu') target.changeGroup('shu');
                                    if (_status.characterlist) {
                                        _status.characterlist.add(result.control);
                                        _status.characterlist.remove('Mbaby_guansuo');
                                    }
                                    'step 4'
                                    target.draw(3);
                                },
                            },
                            //花蔓
                            minisouying: {
                                audio: 'souying',
                                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (!player.countCards('he')) return false;
                                    if (!event.targets || event.targets.length != 1 || event.player == event.target) return false;
                                    if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                                    return event.player != event.target;
                                },
                                direct: true,
                                usable: 1,
                                content() {
                                    'step 0'
                                    var next = player.chooseToDiscard('he'), prompt;
                                    if (event.triggername == 'useCardToTargeted') {
                                        event.target = trigger.player;
                                        prompt = '令' + get.translation(trigger.card) + '对你无效';
                                        next.set('goon', -get.effect(player, trigger.card, trigger.player, player));
                                    }
                                    else {
                                        event.target = trigger.targets[0];
                                        prompt = '弃置一张牌，并获得' + get.translation(trigger.cards.filterInD());
                                        next.set('goon', get.value(trigger.cards.filterInD()));
                                    }
                                    next.set('prompt', get.prompt('minisouying', event.target));
                                    next.set('prompt2', prompt)
                                    next.set('ai', function (card) {
                                        return _status.event.goon - get.value(card);
                                    });
                                    next.set('logSkill', ['minisouying', event.target]);
                                    'step 1'
                                    if (result.bool) {
                                        if (event.triggername == 'useCardToPlayered') player.gain(trigger.cards.filterInD(), 'gain2');
                                        else trigger.excluded.add(player);
                                    }
                                    else player.storage.counttrigger.minisouying--;
                                },
                            },
                            minizhanyuan: {
                                unique: true,
                                derivation: 'hmxili',
                                audio: 'zhanyuan',
                                trigger: { player: 'mansiAfter' },
                                filter(event, player) {
                                    return _status.currentPhase && _status.currentPhase == player && player.countMark('mansi') > 7;
                                },
                                skillAnimation: true,
                                animationColor: 'soil',
                                forced: true,
                                juexingji: true,
                                content() {
                                    'step 0'
                                    player.awakenSkill('minizhanyuan');
                                    'step 1'
                                    player.chooseTarget('战缘：是否选择一名其他角色？', '令一名其他角色和自己一同获得技能〖系力〗，然后失去技能〖蛮嗣〗', lib.filter.notMe).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'fire');
                                        player.addSkills('hmxili');
                                        target.addSkills('hmxili');
                                        player.removeSkills('mansi');
                                    }
                                },
                            },
                            minifuhan: {
                                inherit: 'refuhan',
                                Mbaby_characterlist: true,
                                content() {
                                    'step 0'
                                    if (player.storage.fanghun) player.draw(player.storage.fanghun);
                                    player.removeMark('fanghun', player.storage.fanghun);
                                    player.awakenSkill('minifuhan');
                                    'step 1'
                                    if (!_status.characterlist) lib.skill.pingjian.initList();
                                    var EditList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                                    var list = EditList.filter(i => _status.characterlist.includes(i) && (lib.character[i][1] == 'shu' || (get.is.double(i, true) || []).includes('wu')));
                                    var players = game.players.concat(game.dead);
                                    for (var i = 0; i < players.length; i++) {
                                        list.remove(players[i].name);
                                        list.remove(players[i].name1);
                                        list.remove(players[i].name2);
                                    }
                                    list = list.randomGets(Math.max(4, game.countPlayer()));
                                    var skills = [];
                                    for (var i of list) {
                                        skills.addArray((lib.character[i][3] || []).filter(function (skill) {
                                            var info = get.info(skill);
                                            return info && !info.zhuSkill && !info.limited && !info.juexingji && !info.hiddenSkill && !info.charlotte && !info.dutySkill;
                                        }));
                                    }
                                    if (!list.length || !skills.length) { event.finish(); return; }
                                    if (player.isUnderControl()) {
                                        game.swapPlayerAuto(player);
                                    }
                                    var switchToAuto = function () {
                                        _status.imchoosing = false;
                                        event._result = {
                                            bool: true,
                                            skills: skills.randomGets(2),
                                        };
                                        if (event.dialog) event.dialog.close();
                                        if (event.control) event.control.close();
                                    };
                                    var chooseButton = function (list, skills) {
                                        var event = _status.event;
                                        if (!event._result) event._result = {};
                                        event._result.skills = [];
                                        var rSkill = event._result.skills;
                                        var dialog = ui.create.dialog('请选择获得至多两个技能', [list, 'character'], 'hidden');
                                        event.dialog = dialog;
                                        var table = document.createElement('div');
                                        table.classList.add('add-setting');
                                        table.style.margin = '0';
                                        table.style.width = '100%';
                                        table.style.position = 'relative';
                                        for (var i = 0; i < skills.length; i++) {
                                            var td = ui.create.div('.shadowed.reduce_radius.pointerdiv.tdnode');
                                            td.link = skills[i];
                                            table.appendChild(td);
                                            td.innerHTML = '<span>' + get.translation(skills[i]) + '</span>';
                                            td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                                                if (_status.dragged) return;
                                                if (_status.justdragged) return;
                                                _status.tempNoButton = true;
                                                setTimeout(function () {
                                                    _status.tempNoButton = false;
                                                }, 500);
                                                var link = this.link;
                                                if (!this.classList.contains('bluebg')) {
                                                    if (rSkill.length >= 2) return;
                                                    rSkill.add(link);
                                                    this.classList.add('bluebg');
                                                }
                                                else {
                                                    this.classList.remove('bluebg');
                                                    rSkill.remove(link);
                                                }
                                            });
                                        }
                                        dialog.content.appendChild(table);
                                        dialog.add('　　');
                                        dialog.open();

                                        event.switchToAuto = function () {
                                            event.dialog.close();
                                            event.control.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                        };
                                        event.control = ui.create.control('ok', function (link) {
                                            event.dialog.close();
                                            event.control.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                        });
                                        for (var i = 0; i < event.dialog.buttons.length; i++) {
                                            event.dialog.buttons[i].classList.add('selectable');
                                        }
                                        game.pause();
                                        game.countChoose();
                                    };
                                    if (event.isMine()) {
                                        chooseButton(list, skills);
                                    }
                                    else if (event.isOnline()) {
                                        event.player.send(chooseButton, list, skills);
                                        event.player.wait();
                                        game.pause();
                                    }
                                    else {
                                        switchToAuto();
                                    }
                                    'step 2'
                                    var map = event.result || result;
                                    if (map?.skills?.length) player.addSkills(map.skills);
                                    'step 3'
                                    if (player.isMinHp()) player.recover();
                                },
                            },
                            //夏侯霸
                            minibaobian: {
                                derivation: ['minitiaoxin', 'minisppaoxiao', 'minishensu'],
                                audio: 'rebaobian',
                                trigger: { player: 'damageEnd' },
                                filter(event, player) {
                                    return lib.skill.minibaobian.derivation.some(i => !player.hasSkill(i, null, null, false));
                                },
                                forced: true,
                                content() {
                                    for (var i of lib.skill.minibaobian.derivation) {
                                        if (!player.hasSkill(i, null, null, false)) {
                                            player.addSkills(i);
                                            break;
                                        }
                                    }
                                },
                                ai: {
                                    maixie: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, 'damage') && !target.hasSkill('minitiaoxin', null, null, false)) {
                                                if (!target.hasFriend()) return;
                                                if (target.hp >= 4) return [0, 1];
                                            }
                                        },
                                    },
                                },
                            },
                            //严颜
                            //终于摆脱答辩转换技设计了
                            minijuzhan: {
                                group: 'minijuzhan_gain',
                                audio: 'nzry_juzhan_1',
                                trigger: { target: 'useCardToTargeted' },
                                prompt2: '当你成为其他角色【杀】的目标后，你可以与其各摸一张牌，然后其本回合内不能再对你使用牌。',
                                filter(event, player) {
                                    return event.card.name == 'sha';
                                },
                                logTarget: 'player',
                                content() {
                                    'step 0'
                                    game.asyncDraw([player, trigger.player]);
                                    trigger.player.addTempSkill('minijuzhan_use1');
                                    trigger.player.markAuto('minijuzhan_use1', [player]);
                                    'step 1'
                                    game.delayx();
                                },
                                subSkill: {
                                    gain: {
                                        audio: 'nzry_juzhan_1',
                                        trigger: { player: 'useCardToPlayered' },
                                        prompt2: '当你使用【杀】指定一名角色为目标后，你可以获得其一张牌，然后你本回合内不能再对其使用红色【杀】',
                                        filter(event, player) {
                                            return event.card.name == 'sha' && event.target.countGainableCards(player, 'he');
                                        },
                                        check(event, player) {
                                            return get.effect(event.target, { name: 'guohe_copy2' }, player, player) > 0;
                                        },
                                        logTarget: 'target',
                                        content() {
                                            'step 0'
                                            player.gainPlayerCard(trigger.target, 'he', true);
                                            'step 1'
                                            player.addTempSkill('minijuzhan_use2');
                                            player.markAuto('minijuzhan_use2', [trigger.target]);
                                        },
                                    },
                                    use1: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '拒',
                                        intro: { content: '不能对$使用牌' },
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (player.getStorage('minijuzhan_use1').includes(target)) return false;
                                            },
                                        },
                                    },
                                    use2: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '战',
                                        intro: { content: '不能对$使用红色【杀】' },
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (player.getStorage('minijuzhan_use2').includes(target) && get.name(card) == 'sha' && get.color(card) == 'red') return false;
                                            },
                                        },
                                    },
                                },
                            },
                            //陈到
                            miniwanglie: {
                                mod: {
                                    targetInRange(card, player, target, now) {
                                        if (player.isPhaseUsing()) return true;
                                    },
                                },
                                audio: 'drlt_wanglie',
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    return player.isPhaseUsing() && (event.card.name == 'sha' || get.type(event.card) == 'trick');
                                },
                                preHidden: true,
                                check(event, player) {
                                    if (['wuzhong', 'kaihua', 'dongzhuxianji'].includes(event.card.name)) return false;
                                    player._wanglie_temp = true;
                                    var eff = 0;
                                    for (var i of event.targets) {
                                        eff += get.effect(i, event.card, player, player);
                                    }
                                    delete player._wanglie_temp;
                                    if (eff < 0) return true;
                                    if (!player.countCards('h', function (card) {
                                        return player.hasValueTarget(card, null, true);
                                    })) return true;
                                    if (get.tag(event.card, 'damage') && !player.needsToDiscard() && !player.countCards('h', function (card) {
                                        return get.tag(card, 'damage') && player.hasValueTarget(card, null, true);
                                    })) return true;
                                    return false;
                                },
                                prompt2(event) {
                                    return '令' + get.translation(event.card) + '不能被响应，回合结束时摸等同于此牌造成的伤害数的牌，然后本回合不能再使用牌';
                                },
                                locked: false,
                                content() {
                                    trigger.nowuxie = true;
                                    trigger.directHit.addArray(game.players);
                                    player.addTempSkill('miniwanglie2');
                                    trigger.card.miniwanglie = true;
                                },
                                ai: {
                                    pretao: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag == 'pretao') return true;
                                        if (player._wanglie_temp) return false;
                                        player._wanglie_temp = true;
                                        var bool = function () {
                                            if (['wuzhong', 'kaihua', 'dongzhuxianji'].includes(arg.card.name)) return false;
                                            if (get.attitude(player, arg.target) > 0 || !player.isPhaseUsing()) return false;
                                            var cards = player.getCards('h', function (card) {
                                                return card != arg.card && (!arg.card.cards || !arg.card.cards.includes(card));
                                            });
                                            var sha = player.getCardUsable('sha');
                                            if (arg.card.name == 'sha') sha--;
                                            cards = cards.filter(function (card) {
                                                if (card.name == 'sha' && sha <= 0) return false;
                                                return player.hasValueTarget(card, null, true);
                                            });
                                            if (!cards.length) return true;
                                            if (!get.tag(arg.card, 'damage')) return false;
                                            if (!player.needsToDiscard() && !cards.filter(function (card) {
                                                return get.tag(card, 'damage');
                                            }).length) return true;
                                            return false;
                                        }();
                                        delete player._wanglie_temp;
                                        return bool;
                                    },
                                },
                            },
                            miniwanglie2: {
                                charlotte: true,
                                group: 'drlt_wanglie2',
                                getNum(player) {
                                    var num = 0;
                                    player.getHistory('sourceDamage', function (evt) {
                                        if (evt.card && evt.card.miniwanglie) num += evt.num;
                                    });
                                    return num;
                                },
                                trigger: { player: 'phaseEnd' },
                                filter(event, player) {
                                    return lib.skill.miniwanglie2.getNum(player) > 0;
                                },
                                forced: true,
                                content() {
                                    player.draw(lib.skill.miniwanglie2.getNum(player));
                                },
                            },
                            //李严
                            miniduliang: {
                                audio: 'duliang',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        return lib.skill.miniduliang.filterTarget(null, player, target);
                                    });
                                },
                                filterTarget(card, player, target) {
                                    return player != target && target.countCards('h');
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.gainPlayerCard(target, 'h', true);
                                    'step 1'
                                    var name = get.translation(target);
                                    player.chooseControl(function () {
                                        return '选项二';
                                    }).set('prompt', '督粮：请选择一项').set('choiceList', [
                                        '你观看牌堆顶的两张牌，然后令' + name + '获得其中的基本牌和装备牌',
                                        '令' + name + '于下个摸牌阶段额外摸一张牌，然后其交给你一张牌'
                                    ]);
                                    'step 2'
                                    if (result.control == '选项一') {
                                        var cards = get.cards(2);
                                        event.cards = cards;
                                        target.viewCards('督粮', cards);
                                        game.cardsGotoOrdering(cards);
                                        event.cardx = cards.filter(function (card) {
                                            var type = get.type(card);
                                            return type == 'basic' || type == 'equip';
                                        });
                                        if (!event.cardx.length) event.goto(4);
                                    }
                                    else {
                                        target.addTempSkill('miniduliang2', { player: 'phaseDrawAfter' });
                                        target.addMark('miniduliang2', 1, false);
                                        player.addSkill('miniduliang3');
                                        if (!player.storage.miniduliang3[target.playerid]) player.storage.miniduliang3[target.playerid] = 0;
                                        player.storage.miniduliang3[target.playerid]++;
                                        event.finish();
                                    }
                                    'step 3'
                                    var cardx = event.cardx;
                                    target.gain(cardx, 'draw');
                                    game.log(target, '获得了' + get.cnNumber(cardx.length) + '张牌');
                                    cards.removeArray(cardx);
                                    cards.reverse();
                                    'step 4'
                                    for (var i = 0; i < cards.length; i++) {
                                        ui.cardPile.insertBefore(cards[i], ui.cardPile.firstChild);
                                    }
                                    game.updateRoundNumber();
                                },
                                ai: {
                                    order: 4,
                                    result: {
                                        target: -1,
                                        player: 0.1
                                    },
                                },
                            },
                            miniduliang2: {
                                charlotte: true,
                                onremove: true,
                                marktext: '粮',
                                intro: {
                                    content(storage, player) {
                                        var str = '<li>下回合的摸牌阶段额外摸' + storage + '张牌<br><li>摸牌阶段结束时须交给：';
                                        for (var target of game.filterPlayer2()) {
                                            if (target.storage.miniduliang3 && target.storage.miniduliang3[player.playerid]) str += '<br>→' + get.translation(target) + '：' + get.translation(target.storage.miniduliang3[player.playerid]) + '张牌';
                                        }
                                        return str;
                                    },
                                },
                                trigger: { player: 'phaseDrawBegin' },
                                forced: true,
                                content() {
                                    trigger.num += player.countMark('miniduliang2');
                                },
                            },
                            miniduliang3: {
                                init(player) {
                                    if (!player.storage.miniduliang3) player.storage.miniduliang3 = {};
                                },
                                charlotte: true,
                                trigger: { global: 'phaseDrawEnd' },
                                filter(event, player) {
                                    if (!event.player.countCards('he')) return false;
                                    return player.storage.miniduliang3[event.player.playerid];
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var num = player.storage.miniduliang3[trigger.player.playerid];
                                    delete player.storage.miniduliang3[trigger.player.playerid];
                                    var cards = trigger.player.getCards('he');
                                    if (!cards.length) event.finish();
                                    else if (cards.length <= num) event._result = { bool: true, cards: cards };
                                    else trigger.player.chooseCard('he', '督粮：将' + get.cnNumber(num) + '张牌交给' + get.translation(player), num, true);
                                    'step 1'
                                    if (result.bool) player.gain(result.cards, trigger.player, 'giveAuto');
                                },
                            },
                            //刘谌
                            minizhanjue: {
                                audio: 'zhanjue',
                                enable: 'phaseUse',
                                filterCard(card) {
                                    return !card.hasGaintag('miniqinwang');
                                },
                                selectCard: -1,
                                position: 'h',
                                filter(event, player) {
                                    var stat = player.getStat().skill;
                                    if (stat.minizhanjue_draw && stat.minizhanjue_draw >= 3) return false;
                                    var hs = player.getCards('h', function (card) {
                                        return !card.hasGaintag('miniqinwang');
                                    });
                                    if (!hs.length) return false;
                                    for (var i = 0; i < hs.length; i++) {
                                        var mod2 = game.checkMod(hs[i], player, 'unchanged', 'cardEnabled2', player);
                                        if (mod2 === false) return false;
                                    }
                                    return event.filterCard(get.autoViewAs({ name: 'juedou' }, hs));
                                },
                                viewAs: { name: 'juedou' },
                                onuse(links, player) {
                                    player.addTempSkill('minizhanjue_effect', 'phaseUseEnd');
                                },
                                ai: {
                                    order: 1,
                                    tag: {
                                        respond: 2,
                                        respondSha: 2,
                                        damage: 1,
                                    },
                                    result: {
                                        target: -1.5,
                                        player(player, target) {
                                            if (player.hasSkillTag('directHit_ai', true, {
                                                target: target,
                                                card: { name: 'juedou' },
                                            }, true)) {
                                                return 0;
                                            }
                                            if (get.damageEffect(target, player, target) > 0 && get.attitude(player, target) > 0 && get.attitude(target, player) > 0) {
                                                return 0;
                                            }
                                            var hs1 = target.getCards('h', 'sha');
                                            var hs2 = player.getCards('h', function (card) {
                                                return card.hasGaintag('miniqinwang') && get.name(card) == 'sha';
                                            });
                                            if (hs1.length > hs2.length + 1) {
                                                return -2;
                                            }
                                            var hsx = target.getCards('h');
                                            if (hsx.length > 2 && hs2.length == 0 && hsx[0].number < 6) {
                                                return -2;
                                            }
                                            if (hsx.length > 3 && hs2.length == 0) {
                                                return -2;
                                            }
                                            if (hs1.length > hs2.length && (!hs2.length || hs1[0].number > hs2[0].number)) {
                                                return -2;
                                            }
                                            return -0.5;
                                        },
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove(player) {
                                            delete player.getStat().skill.minizhanjue_draw;
                                        },
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            return event.skill == 'minizhanjue';
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            'step 0'
                                            var stat = player.getStat().skill;
                                            if (!stat.minizhanjue_draw) stat.minizhanjue_draw = 0;
                                            stat.minizhanjue_draw++;
                                            player.draw('nodelay');
                                            var list = game.filterPlayer(function (current) {
                                                if (current.getHistory('damage', function (evt) {
                                                    return evt.card == trigger.card;
                                                }).length > 0) {
                                                    if (current == player) {
                                                        stat.minizhanjue_draw++;
                                                    }
                                                    return true;
                                                }
                                                return false;
                                            });
                                            if (list.length) {
                                                list.sortBySeat();
                                                game.asyncDraw(list);
                                            }
                                            'step 1'
                                            game.delay();
                                            'step 2'
                                            if (player.getHistory('damage', function (evt) {
                                                return evt.card == trigger.card;
                                            }).length) {
                                                for (var i of game.filterPlayer().filter(function (target) {
                                                    return target.getHistory('sourceDamage', function (evt) {
                                                        return evt.card == trigger.card && evt.player == player;
                                                    }).length && target.isIn() && target.countCards('he');
                                                })) player.discardPlayerCard(i, 'he');
                                            }
                                        },
                                    },
                                },
                            },
                            miniqinwang: {
                                audio: 'qinwang1',
                                enable: 'phaseUse',
                                usable: 1,
                                zhuSkill: true,
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.group == 'shu' && player.hasZhuSkill('miniqinwang', current);
                                    });
                                },
                                filterTarget(card, player, current) {
                                    return current != player && current.group == 'shu' && player.hasZhuSkill('miniqinwang', current);
                                },
                                selectTarget: -1,
                                content() {
                                    'step 0'
                                    if (target.hasCard(function (card) {
                                        return _status.connectMode || get.name(card, target) == 'sha';
                                    }, 'h')) {
                                        target.chooseCard('是否交给' + get.translation(player) + '一张基本牌？', function (card, player) {
                                            return get.type(card) == 'basic';
                                        }, 'h').set('goon', get.attitude(target, player) > 0).set('ai', function (card) {
                                            return _status.event.goon ? 1 : 0;
                                        });
                                    }
                                    else event.finish();
                                    'step 1'
                                    if (result.bool) {
                                        var card = result.cards[0];
                                        target.give(card, player).gaintag.add('miniqinwang');
                                        player.addTempSkill('miniqinwang_clear');
                                        player.chooseBool('是否令' + get.translation(target) + '摸一张牌？');
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) target.draw();
                                },
                                ai: {
                                    order: 5,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    clear: {
                                        charlotte: true,
                                        onremove(player) {
                                            player.removeGaintag('miniqinwang');
                                        },
                                    },
                                },
                            },
                            //杨婉
                            miniyouyan: {
                                group: 'miniyouyan_youyan',
                                audio: 'youyan',
                                enable: 'phaseUse',
                                usable: 1,
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                filterCard: lib.filter.cardDiscardable,
                                selectCard: [1, Infinity],
                                position: 'he',
                                check(card) {
                                    if (ui.selected.cards.length) return 0;
                                    return 5 - get.value(card);
                                },
                                delay: 0,
                                prompt: '出牌阶段限一次，你可以弃置任意张牌',
                                content() { },
                                ai: {
                                    order: 10,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    youyan: {
                                        audio: 'youyan',
                                        trigger: { player: 'loseAfter', global: 'loseAsyncAfter' },
                                        filter(event, player) {
                                            if (event.type != 'discard' || event.getlx === false || player != _status.currentPhase) return false;
                                            var evt = event.getl(player);
                                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                                            var list = [];
                                            for (var i of evt.cards2) {
                                                list.add(get.suit(i, player));
                                                if (list.length >= lib.suit.length) return false;
                                            }
                                            var evt = event.getParent('phaseUse');
                                            if (evt?.player == player && !evt.miniyouyaned) return true;
                                            var evt = event.getParent('phaseDiscard');
                                            if (evt?.player == player && !evt.miniyouyaned) return true;
                                            return false;
                                        },
                                        prompt2: '从牌堆中获得本次弃牌中没有的花色的牌各一张',
                                        content() {
                                            var evt = trigger.getParent('phaseUse');
                                            if (evt?.player == player) evt.miniyouyaned = true;
                                            else {
                                                var evt = trigger.getParent('phaseDiscard');
                                                if (evt) evt.miniyouyaned = true;
                                            }
                                            var list = [], cards = [];
                                            var cards2 = trigger.getl(player).cards2;
                                            for (var i of cards2) {
                                                list.add(get.suit(i, player));
                                            }
                                            for (var i of lib.suit) {
                                                if (list.includes(i)) continue;
                                                var card = get.cardPile2(function (card) {
                                                    return get.suit(card, false) == i;
                                                })
                                                if (card) cards.push(card);
                                            }
                                            if (cards.length) player.gain(cards, 'gain2');
                                        },
                                        ai: {
                                            effect: {
                                                player_use(card, player, target) {
                                                    if (typeof card == 'object' && player == _status.currentPhase && player.needsToDiscard() == 1 && card.cards && card.cards.filter(function (i) {
                                                        return get.position(i) == 'h';
                                                    }).length > 0 && !get.tag(card, 'draw') && !get.tag(card, 'gain') && !get.tag(card, 'discard')) return 'zeroplayertarget';
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //黄月英
                            minirejizhi: {
                                audio: 'rejizhi',
                                audioname: ['lukang'],
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    return get.type2(event.card) == 'trick';
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    'step 1'
                                    var card = result[0];
                                    event.card = card;
                                    if (['basic', 'trick', 'equip'].includes(get.type2(card))) {
                                        if (['basic', 'trick'].includes(get.type2(card))) {
                                            player.addTempSkill('minirejizhi_' + get.type2(card));
                                            player.addMark('minirejizhi_' + get.type2(card), 1, false);
                                            event.finish();
                                        }
                                        else player.chooseTarget('集智：是否将' + get.translation(card) + '置入一名其他角色的装备栏？', function (card, player, target) {
                                            return target != player && target.canEquip(_status.event.card);
                                        }).set('card', card).set('ai', function (target) {
                                            var player = _status.event.player;
                                            var card = _status.event.card;
                                            if ((player.canEquip(_status.event.card) || get.equipValue(_status.event.card, target) < 0) && get.equipValue(card) > 0) return 0;
                                            return get.attitude(player, target);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        player.$give(card, target, false);
                                        game.delay(0.5);
                                        target.equip(card);
                                    }
                                },
                                ai: { noautowuxie: true },
                                subSkill: {
                                    basic: {
                                        mark: true,
                                        marktext: '集',
                                        intro: { content: '手牌上限+#' },
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num + player.countMark('minirejizhi_basic');
                                            },
                                        },
                                    },
                                    trick: {
                                        mark: true,
                                        marktext: '智',
                                        intro: { content: '使用【杀】的额定次数+#' },
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + player.countMark('minirejizhi_trick');
                                            },
                                        },
                                    },
                                },
                            },
                            minireqicai: {
                                mod: {
                                    targetInRange(card, player, target, now) {
                                        var type = get.type(card);
                                        if (type == 'trick' || type == 'delay') return true;
                                    },
                                    canBeDiscarded(card) {
                                        if (get.position(card) == 'e' && ['equip1', 'equip2'].includes(get.subtype(card))) return false;
                                    },
                                },
                            },
                            //周仓
                            minizhongyong: {
                                audio: 'zhongyong',
                                trigger: { player: 'useCardAfter' },
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    if (event.cards.filterInD().length) return true;
                                    var shan = [];
                                    game.countPlayer2(function (current) {
                                        current.getHistory('useCard', function (evt) {
                                            if (evt.card.name == 'shan' && evt.getParent(3) == event) shan.addArray(evt.cards);
                                        });
                                    });
                                    return shan.filterInD('d').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.sha = trigger.cards.slice(0).filterInD();
                                    event.shan = [];
                                    game.countPlayer2(function (current) {
                                        current.getHistory('useCard', function (evt) {
                                            if (evt.card.name == 'shan' && evt.getParent(3) == trigger) event.shan.addArray(evt.cards);
                                        });
                                    });
                                    event.shan.filterInD('d');
                                    player.chooseTarget(get.prompt2('minizhongyong'), function (card, player, target) {
                                        return !_status.event.source.includes(target) && target != player;
                                    }).set('ai', function (target) {
                                        return get.attitude(_status.event.player, target);
                                    }).set('source', trigger.targets);
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minizhongyong', target);
                                        if (event.sha.length && event.shan.length) {
                                            player.chooseControl().set('choiceList', [
                                                '将' + get.translation(event.sha) + '交给' + get.translation(target),
                                                '将' + get.translation(event.shan) + '交给' + get.translation(target),
                                            ]).set('ai', function () {
                                                return _status.event.choice;
                                            }).set('choice', function () {
                                                if (get.color(event.sha) != 'black') return 0;
                                                return 1;
                                            }());
                                        }
                                        else event._result = { index: event.sha.length ? 0 : 1 };
                                    }
                                    else event.finish();
                                    'step 2'
                                    var cards = result.index == 0 ? event.sha : event.shan;
                                    target.gain(cards, 'gain2');
                                    event.cards = cards;
                                    'step 3'
                                    if (cards.filter(function (card) {
                                        return get.color(card) == 'red';
                                    }).length) target.chooseToUse('忠勇：是否使用一张【杀】？', { name: 'sha' }).set('filterTarget', function (card, player, target) {
                                        return target != _status.event.sourcex && _status.event.sourcex.inRange(target) && lib.filter.targetEnabled.apply(this, arguments);
                                    }).set('sourcex', player).set('addCount', false);
                                    'step 4'
                                    if (cards.filter(function (card) {
                                        return get.color(card) == 'black';
                                    }).length) {
                                        player.draw('nodelay');
                                        target.draw();
                                    }
                                },
                            },
                            minidaopu: {
                                derivation: 'qinglong_skill',
                                group: 'wechatqinglong',
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (!player.getEquip('qinglong')) return;
                                        if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                                    },
                                },
                                inherit: 'jie',
                                filter(event, player) {
                                    if (!player.getEquip('qinglong')) return false;
                                    return event.card && event.card.name == 'sha' && get.color(event.card) == 'red' && event.notLink();
                                },
                            },
                            //吕凯
                            minitunan: {
                                audio: 'xinfu_tunan',
                                inherit: 'xinfu_tunan',
                                filterTarget: true,
                                selectTarget: [1, 2],
                            },
                            //孙乾
                            miniqianya: {
                                audio: 'qianya',
                                trigger: { target: 'useCardToTargeted' },
                                filter(event, player) {
                                    return get.type2(event.card) == 'trick' && player.countCards('h');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var nh = player.countCards('h');
                                    player.chooseCardTarget({
                                        filterCard: true,
                                        filterTarget: lib.filter.notMe,
                                        selectCard: [1, nh],
                                        ai1(card) {
                                            var player = _status.event.player;
                                            var cardname = _status.event.cardname;
                                            if (_status.event.du) return -get.value(card, player, 'raw');
                                            else if (_status.event.shuimeng) {
                                                if (cardname == 'wuzhong') {
                                                    if (player.needsToDiscard(2 - ui.selected.cards.length)) {
                                                        return 10 - get.value(card, player, 'raw');
                                                    }
                                                }
                                                else if (cardname == 'guohe') {
                                                    if (player.needsToDiscard(-1 - ui.selected.cards.length)) {
                                                        return 10 - get.value(card, player, 'raw');
                                                    }
                                                }
                                                return 0;
                                            }
                                            else if (cardname == 'lebu') {
                                                if (player.needsToDiscard(1 - ui.selected.cards.length)) {
                                                    return 8 - get.value(card, player, 'raw');
                                                }
                                                else {
                                                    if (!ui.selected.cards.length) {
                                                        return 6 - get.value(card, player, 'raw');
                                                    }
                                                    return 0;
                                                }
                                            }
                                            else if (cardname == 'shunshou') {
                                                if (_status.event.nh <= 2) return get.value(card, player, 'raw');
                                            }
                                            else if (cardname == 'huogong') {
                                                if (player.hp == 1) return get.value(card, player, 'raw');
                                            }
                                            if (ui.selected.cards.length) return 0;
                                            return 7 - get.value(card, player, 'raw');
                                        },
                                        ai2(target) {
                                            var att = get.attitude(_status.event.player, target);
                                            var nh2 = target.countCards('h');
                                            var num = Math.sqrt(1 + nh2);
                                            var cardname = _status.event.cardname;
                                            if (_status.event.du) return 0.5 - att;
                                            else if (_status.event.shuimeng) {
                                                return att / num;
                                            }
                                            else if (cardname == 'lebu') {
                                                return att / num;
                                            }
                                            else if (cardname == 'shunshou') {
                                                if (_status.event.nh <= 2) return att / num;
                                            }
                                            else if (cardname == 'huogong') {
                                                if (_status.event.player.hp == 1) return att / num;
                                            }
                                            if (_status.event.nh > nh2 + 1) {
                                                return att / num;
                                            }
                                            return 0;
                                        },
                                        du: player.hasCard(function (card) {
                                            return get.value(card, player, 'raw') < 0;
                                        }),
                                        shuimeng: trigger.getParent(2).name == 'shuimeng',
                                        nh: nh,
                                        cardname: trigger.card.name,
                                        prompt: get.prompt2('miniqianya')
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniqianya', result.targets);
                                        player.give(result.cards, result.targets[0]);
                                        var card = get.cardPile2(function (card) {
                                            return get.type(card) != 'equip';
                                        });
                                        if (card) player.gain(card, 'gain2');
                                    }
                                },
                            },
                            //甘夫人
                            minishushen: {
                                group: 'minishushen_draw',
                                audio: 'shushen',
                                inherit: 'jsrgjishan',
                                usable: Infinity,
                                content() {
                                    'step 0'
                                    trigger.cancel();
                                    player.loseHp();
                                    'step 1'
                                    if (player.isIn() && trigger.player.isIn()) {
                                        var targets = [player, trigger.player];
                                        targets.sortBySeat(_status.currentPhase);
                                        targets[0].draw('nodelay');
                                        targets[1].draw();
                                    }
                                },
                                ai: { threaten: 0.8 },
                                subSkill: {
                                    draw: {
                                        trigger: { player: 'recoverAfter' },
                                        direct: true,
                                        preHidden: true,
                                        content() {
                                            'step 0'
                                            event.num = trigger.num || 1;
                                            'step 1'
                                            player.chooseTarget(get.prompt2('minishushen'), lib.filter.notMe).set('ai', function (target) {
                                                return get.attitude(_status.event.player, target);
                                            }).setHiddenSkill('minishushen');
                                            'step 2'
                                            if (result.bool) {
                                                player.logSkill('minishushen', result.targets);
                                                result.targets[0].draw();
                                                if (event.num > 1) {
                                                    event.num--;
                                                    event.goto(1);
                                                }
                                            }
                                        },
                                        ai: { expose: 0.1 },
                                    },
                                },
                            },
                            minihuangsi: {
                                audio: 'shenzhi',
                                unique: true,
                                enable: 'chooseToUse',
                                mark: true,
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'fire',
                                filter(event, player) {
                                    if (event.type != 'dying') return false;
                                    return event.dying == player;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('minihuangsi');
                                    if (player.hp < 1) player.recover(1 - player.hp);
                                    event.num = player.countCards('h') + 2;
                                    player.discard(player.getCards('h'));
                                    'step 1'
                                    player.chooseTarget('皇思：是否令一名角色摸' + get.cnNumber(num) + '张牌？').set('ai', function (target) {
                                        return get.attitude(_status.event.player, target);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        player.line('minishushen', result.targets);
                                        result.targets[0].draw(num);
                                    }
                                },
                                ai: {
                                    order: 0.5,
                                    skillTagFilter(player, tag, target) {
                                        if (player != target || player.storage.minihuangsi) return false;
                                    },
                                    save: true,
                                    result: {
                                        player(player) {
                                            if (player.hp <= 0) return 10;
                                            if (player.hp <= 1 && player.countCards('he') <= 1) return 10;
                                            return 0;
                                        },
                                    },
                                    threaten(player, target) {
                                        if (!target.storage.minihuangsi) return 0.6;
                                    },
                                },
                            },
                            //刘永
                            minifengxiang: {
                                audio: 'fengxiang',
                                trigger: { player: 'damageEnd' },
                                forced: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    'step 1'
                                    var target = game.findPlayer(target => {
                                        if (!target.isDamaged()) return false;
                                        return !game.hasPlayer(current => {
                                            return current != target && current.countCards('h', card => card.hasGaintag('fengxiang_tag')) >= target.countCards('h', card => card.hasGaintag('fengxiang_tag'));
                                        });
                                    });
                                    if (target) {
                                        player.line(target);
                                        target.recover();
                                    }
                                },
                            },
                            //糜竺
                            miniziyuan: {
                                audio: 'ziyuan',
                                enable: 'phaseUse',
                                filterCard: true,
                                selectCard: [1, Infinity],
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    return lib.skill.rerende.check(card);
                                },
                                discard: false,
                                lose: false,
                                delay: false,
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.give(cards, target);
                                    'step 1'
                                    var num = cards.reduce(function (num, card) {
                                        return num + (get.number(card, player) || 0);
                                    }, 0);
                                    if (num >= 13) target.recover();
                                    if (num <= 13) player.draw();
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        target(player, target) {
                                            return lib.skill.rerende.ai.result.target(player, target);
                                        },
                                    },
                                    effect: {
                                        target(card, player, target) {
                                            return lib.skill.rerende.ai.effect.target_use(card, player, target);
                                        },
                                    },
                                },
                            },
                            minijugu: {
                                audio: 'jugu',
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.maxHp;
                                    },
                                },
                                trigger: { player: 'phaseBegin' },
                                filter(event, player) {
                                    if (typeof player.maxHp != 'number' || player.maxHp < 1) return false;
                                    return player.hasUseTarget(get.autoViewAs({ name: 'wugu' }, []));
                                },
                                direct: true,
                                locked: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minijugu'), '视为对至多' + get.cnNumber(player.maxHp) + '名角色使用【五谷丰登】', [1, player.maxHp], function (card, player, target) {
                                        return player.canUse(get.autoViewAs({ name: 'wugu' }, []), target, false);
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.effect(target, get.autoViewAs({ name: 'wugu' }, []), player, player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('minijugu', targets);
                                        player.useCard(get.autoViewAs({ name: 'wugu' }, []), targets, false);
                                    }
                                },
                            },
                            //糜夫人
                            miniguixiu: {
                                audio: 'guixiu',
                                trigger: { player: ['phaseJieshuBegin', 'dying'] },
                                filter(event, player) {
                                    return event.name == 'phaseJieshu' || player.storage.miniguixiu;
                                },
                                forced: true,
                                usable: 1,
                                content() {
                                    player[player.getHp() % 2 == 0 ? 'recover' : 'draw']();
                                },
                            },
                            minicunsi: {
                                unique: true,
                                derivation: ['miniyongjue', 'miniguixiux'],
                                audio: 'cunsi',
                                enable: 'phaseUse',
                                mark: true,
                                limited: true,
                                filter(event, player) {
                                    return player.hp > 0;
                                },
                                filterTarget: lib.filter.notMe,
                                skillAnimation: true,
                                animationColor: 'orange',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minicunsi');
                                    player.storage.miniguixiu = true;
                                    'step 1'
                                    target.addSkills('miniyongjue');
                                    'step 2'
                                    var num = player.hp;
                                    player.loseHp(num);
                                    target.draw(num + 1);
                                },
                                ai: {
                                    order: 4,
                                    expose: 0.5,
                                    result: {
                                        target(player, target) {
                                            //if(!player.countCards('hs',{name:['tao','jiu']})) return 0;
                                            return lib.skill.cunsi.ai.result.target(player, target);
                                        },
                                    },
                                },
                            },
                            miniyongjue: {
                                audio: 'yongjue',
                                trigger: { global: 'useCardAfter', player: 'damageBegin3' },
                                filter(event, player) {
                                    if (!event.card || event.card.name != 'sha') return false;
                                    if (event.name == 'damage') return typeof get.number(event.card) == 'number' && ((_status.connectMode && player.countCards('he')) || player.getDiscardableCards(player, 'he').some(card => {
                                        if (typeof get.number(card, player) != 'number') return false;
                                        return get.number(card, player) >= get.number(event.card);
                                    }));
                                    if (!event.cards || !event.cards.filterInD().length || event.player == player) return false;
                                    var evt = event.getParent('phaseUse');
                                    return evt?.player == event.player && event.player.getHistory('useCard', function (evt2) {
                                        return evt2.card.name == 'sha' && evt2.getParent('phaseUse') == evt;
                                    }).indexOf(event) == 0;
                                },
                                direct: true,
                                frequent: true,
                                content() {
                                    'step 0'
                                    if (trigger.name == 'useCard') player.chooseBool(get.prompt('miniyongjue'), '获得' + get.translation(trigger.cards.filterInD())).set('frequentSkill', 'miniyongjue');
                                    else {
                                        var num = get.number(trigger.card);
                                        player.chooseToDiscard(get.prompt('miniyongjue'), '弃置一张点数大于等于' + num + '的牌，防止此伤害', 'he', function (card, player) {
                                            return get.number(card, player) >= _status.event.num;
                                        }).set('ai', function (card) {
                                            var player = _status.event.player;
                                            return player.hp * player.hp - get.value(card);
                                        }).set('num', num).logSkill = 'miniyongjue';
                                    }
                                    'step 1'
                                    if (result.bool) {
                                        if (trigger.name == 'useCard') {
                                            player.logSkill('miniyongjue');
                                            player.gain(trigger.cards.filterInD(), 'gain2');
                                        }
                                        else trigger.cancel();
                                    }
                                },
                            },
                            //王悦
                            minihuguan: {
                                audio: 'huguan',
                                audioname: ['wangyue'],
                                trigger: { global: 'useCard' },
                                filter(event, player) {
                                    if (get.color(event.card) != 'red') return false;
                                    var evt = event.getParent('phaseUse');
                                    if (!evt || evt.player != event.player) return false;
                                    return event.player.getHistory('useCard', function (evtx) {
                                        return get.color(evtx.card) == 'red' && evtx.getParent('phaseUse') == evt;
                                    }).indexOf(event) == 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseControl(lib.suit, 'cancel2').set('prompt', get.prompt2('minihuguan', trigger.player)).set('ai', function () {
                                        var player = _status.event.player, target = _status.event.getTrigger().player;
                                        var list = lib.suit.slice(0);
                                        var att = get.attitude(player, trigger.player);
                                        if (att == 0) return 'cancel2';
                                        list.removeArray(target.getStorage(att > 0 ? 'huguan_add' : 'minihuguan_add'));
                                        if (list.length) return list.randomGet();
                                        return 'cancel2';
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        var target = trigger.player;
                                        event.target = target;
                                        player.logSkill('huguan', target);
                                        game.log(player, '选择了', '#g' + get.translation(result.control), '花色');
                                        event.suit = result.control;
                                        var str = get.translation(target);
                                        var suit = get.translation(event.suit);
                                        player.chooseControl().set('choiceList', [
                                            '令' + str + '本回合' + suit + '牌不计入手牌上限',
                                            '令' + str + '本回合不能弃置' + suit + '牌',
                                        ]).set('ai', () => _status.event.att > 0 ? 0 : 1).set('att', get.attitude(player, target));
                                    }
                                    else event.finish();
                                    'step 2'
                                    var skill = (result.index == 0 ? '' : 'mini') + 'huguan_add';
                                    target.addTempSkill(skill);
                                    target.markAuto(skill, [event.suit]);
                                },
                                subSkill: {
                                    add: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            cardDiscardable(card, player) {
                                                if (player.getStorage('minihuguan_add').includes(get.suit(card, player)) && get.position(card) == 'h') return false;
                                            }
                                        },
                                        intro: { content: '本回合不能弃置$花色的手牌' },
                                    },
                                },
                            },
                            minimingluan: {
                                audio: 'mingluan',
                                trigger: { global: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player != event.player && event.player.isIn() && game.getGlobalHistory('changeHp', evt => evt.getParent().name == 'recover').length && event.player.countCards('h');
                                },
                                prompt(event, player) {
                                    return get.translation('minimingluan') + '（摸' + (event.player.countCards('h')) + '弃' + (player.countCards('h') + event.player.countCards('h') - 5) + '）';
                                },
                                check(event, player) {
                                    return player.countCards('h') < 5;
                                },
                                content() {
                                    'step 0'
                                    player.draw(trigger.player.countCards('h'));
                                    'step 1'
                                    if (player.countCards('h') > 5) player.chooseToDiscard('h', player.countCards('h') - 5, true);
                                },
                            },
                            //伊籍
                            minijijie: {
                                onremove: true,
                                intro: { content: '已发动过#次' },
                                audio: 'xinfu_jijie',
                                inherit: 'xinfu_jijie',
                                contentBefore() {
                                    player.addMark('minijijie', 1, false);
                                },
                                group: 'minijijie_log',
                                subSkill: {
                                    log: {
                                        audio: 'xinfu_jijie',
                                        trigger: { global: ['gainAfter', 'loseAsyncAfter'] },
                                        filter(event, player) {
                                            if (player.hasSkill('minijijie_used')) return false;
                                            return game.hasPlayer(current => current.isPhaseUsing() && event.getg(current).length > 1);
                                        },
                                        prompt2: '发动【机捷】',
                                        content() {
                                            player.addTempSkill('minijijie_used', 'roundStart');
                                            player.addMark('minijijie', 1, false);
                                            var next = game.createEvent('minijijie');
                                            next.player = player;
                                            next.setContent(lib.skill.minijijie.content);
                                        },
                                    },
                                    used: { charlotte: true },
                                },
                            },
                            minijiyuan: {
                                audio: 'xinfu_jiyuan',
                                trigger: { global: ['dying', 'gainAfter', 'loseAsyncAfter'] },
                                filter(event, player) {
                                    if (event.name == 'dying') return player.hasMark('minijijie');
                                    if (event.giver != player) return false;
                                    if (event.name == 'gain') {
                                        return event.player != player && event.getg(event.player).length > 0;
                                    }
                                    return game.hasPlayer(function (current) {
                                        return current != player && event.getg(current).length > 0;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    if (trigger.name != 'loseAsync') event.targets = [trigger.player];
                                    else event.targets = game.filterPlayer(function (current) {
                                        return current != player && trigger.getg(current).length > 0;
                                    });
                                    'step 1'
                                    var target = event.targets.shift();
                                    event.target = target;
                                    var str2 = get.translation(target);
                                    var str = (trigger.name == 'dying' ? '令' + str2 + '摸' + get.cnNumber(player.countMark('minijijie')) + '张牌，然后清空【机捷】的发动次数' : '令' + str2 + '摸一张牌');
                                    player.chooseBool(get.prompt('minijiyuan', target)).set('ai', function () {
                                        var evt = _status.event;
                                        return get.attitude(player, evt.getParent().target) > 0;
                                    }).set('prompt2', str);
                                    'step 2'
                                    if (result.bool) {
                                        player.logSkill('minijiyuan', target);
                                        target.draw(trigger.name == 'dying' ? player.countMark('minijijie') : 1);
                                        if (trigger.name == 'dying') {
                                            player.removeMark('minijijie', player.countMark('minijijie'), false);
                                            game.log(player, '清空了', '#g【机捷】', '的发动次数');
                                        }
                                    }
                                    if (targets.length > 0 && (trigger.name != 'dying' || player.hasMark('minijijie'))) event.goto(1);
                                },
                            },
                            //SP张飞
                            minisppaoxiao: {
                                mod: {
                                    cardUsable(card, player) {
                                        if (get.name(card, player) == 'sha') return Infinity;
                                    },
                                    targetInRange(card, player) {
                                        if (get.name(card, player) == 'sha') return true;
                                    },
                                },
                                audio: 'paoxiao',
                                audioname: ['xiahouba'],
                                audioname2: { guanzhang: "paoxiao_guanzhang" },
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    return player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event) > 0;
                                },
                                forced: true,
                                content() {
                                    trigger.baseDamage++;
                                    player.addTempSkill('minisppaoxiao_ai');
                                    if (player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(trigger) > 1) {
                                        trigger.directHit.addArray(game.filterPlayer());
                                        player.addTempSkill('minisppaoxiao_unequip');
                                    }
                                },
                                subSkill: {
                                    ai: {
                                        charlotte: true,
                                        ai: {
                                            directHit_ai: true,
                                            unequip_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.hasSkill('minisppaoxiao')) return false;
                                            },
                                        },
                                    },
                                    unequip: {
                                        charlotte: true,
                                        ai: {
                                            unequip: true,
                                            skillTagFilter(player, tag, arg) {
                                                if (!arg || !arg.card || arg.card.name != 'sha' || !player.hasSkill('minisppaoxiao')) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minixvhe: {
                                audio: 'retishen',
                                trigger: { player: ['shaMiss', 'useCard', 'respond'] },
                                filter(event, player, name) {
                                    return name == 'shaMiss' || event.card.name == 'shan';
                                },
                                async cost(event, trigger, player) {
                                    event.result = { bool: true, targets: [event.triggername == 'shaMiss' ? trigger.target : lib.skill.chongzhen.logTarget(trigger, player)] };
                                },
                                locked: true,
                                content() {
                                    player.draw('nodelay');
                                    event.targets[0].draw();
                                },
                            },
                            //关羽
                            minirewusheng: {
                                group: ['minirewusheng_wusheng', 'minirewusheng_effect'],
                                audio: 'wusheng',
                                audioname: ['jsp_guanyu'],
                                audioname2: {
                                    guanzhang: "wusheng_guanzhang",
                                    guansuo: "wusheng_guansuo",
                                },
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    var card = get.cardPile(function (card) {
                                        return get.color(card) == 'red';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                },
                                subSkill: {
                                    wusheng: {
                                        audio: 'wusheng',
                                        audioname: ['jsp_guanyu'],
                                        audioname2: {
                                            guanzhang: "wusheng_guanzhang",
                                            guansuo: "wusheng_guansuo",
                                        },
                                        enable: ['chooseToRespond', 'chooseToUse'],
                                        filterCard(card, player) {
                                            return get.color(card) == 'red';
                                        },
                                        position: 'hes',
                                        viewAs: { name: 'sha' },
                                        viewAsFilter(player) {
                                            if (!player.countCards('hes', { color: 'red' })) return false;
                                        },
                                        prompt: '将一张红色牌当作【杀】使用或打出',
                                        check(card) {
                                            var val = get.value(card);
                                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                                            return 5 - val;
                                        },
                                        ai: {
                                            respondSha: true,
                                            skillTagFilter(player) {
                                                if (!player.countCards('hes', { color: 'red' })) return false;
                                            },
                                        },
                                    },
                                    effect: {
                                        mod: {
                                            aiOrder(player, card, num) {
                                                if (get.itemtype(card) == 'card' && card.name == 'sha' && get.color(card) == 'red') return num + 0.1;
                                            },
                                        },
                                        audio: 'wusheng',
                                        audioname: ['jsp_guanyu'],
                                        audioname2: {
                                            guanzhang: "wusheng_guanzhang",
                                            guansuo: "wusheng_guansuo",
                                        },
                                        inherit: 'jie',
                                    },
                                },
                            },
                            minituodao: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: ['useCard', 'respond'] },
                                filter(event, player) {
                                    return event.card.name == 'shan';
                                },
                                forced: true,
                                content() {
                                    player.addSkill('minituodao_mark');
                                    player.addMark('minituodao_mark', 1, false);
                                    player.when('useCard')
                                        .filter((event, player) => event.card.name == 'sha')
                                        .then(() => {
                                            trigger.baseDamage += player.countMark('minituodao_mark');
                                            player.removeSkill('minituodao_mark');
                                        });
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '下一张【杀】的伤害基数+#' },
                                    },
                                },
                            },
                            //王桃
                            miniyaopei: {
                                audio: 'yaopei',
                                trigger: { global: 'phaseDiscardEnd' },
                                filter(event, player) {
                                    if (player == event.player || !event.player.isIn() || !event.player.getHistory('lose', function (evt) {
                                        return evt.type == 'discard' && evt.getParent('phaseDiscard') == event;
                                    }).length) return false;
                                    return player.countCards('he');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var suits = [], str = '该角色本阶段弃置的花色：';
                                    trigger.player.getHistory('lose', function (evt) {
                                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == trigger) {
                                            for (var i of evt.cards2) suits.add(get.suit(i, evt.hs.includes(i) ? evt.player : false));
                                        }
                                    });
                                    suits.sort((a, b) => lib.suit.indexOf(a) - lib.suit.indexOf(b));
                                    event.suits = suits;
                                    suits.forEach(suit => str += get.translation(suit));
                                    player.chooseCardTarget({
                                        prompt: get.prompt('miniyaopei', trigger.player),
                                        prompt2: '<span class="text center"><li>操作提示：选择要弃置的牌，若其本阶段未弃置过此花色的牌，再选择执行摸牌选项的角色，另一名角色执行回复体力的选项。<br><li>' + str + '</span>',
                                        suits: suits,
                                        position: 'he',
                                        filterCard(card, player) {
                                            return lib.filter.cardDiscardable(card, player, 'miniyaopei');
                                        },
                                        filterTarget(card, player, target) {
                                            if (!ui.selected.cards.length || _status.event.suits.includes(get.suit(ui.selected.cards[0]))) return false;
                                            return target == player || target == _status.event.getTrigger().player;
                                        },
                                        selectTarget() {
                                            if (!ui.selected.cards.length || _status.event.suits.includes(get.suit(ui.selected.cards[0]))) return -1;
                                            return 1;
                                        },
                                        filterOk() {
                                            if (!ui.selected.cards.length) return false;
                                            return _status.event.suits.includes(get.suit(ui.selected.cards[0])) || ui.selected.targets.length;
                                        },
                                        ai1(card) {
                                            var player = _status.event.player, source = _status.event.getTrigger().player;
                                            if (_status.event.suits.includes(get.suit(card))) return 8 - get.value(card);
                                            if (get.attitude(player, source) > 0 && (get.recoverEffect(player, player, player) > 0 || get.recoverEffect(source, player, player) > 0)) return 12 - get.value(card);
                                            return 0;
                                        },
                                        ai2(target) {
                                            var player = _status.event.player, source = _status.event.getTrigger().player;
                                            var der = get.recoverEffect(source, player, player) > get.recoverEffect(player, player, player) ? player : source;
                                            return target == source ? 10 : 0;
                                        }
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = trigger.player;
                                        player.logSkill('miniyaopei', target);
                                        player.discard(result.cards);
                                        if (!event.suits.some(suit => get.suit(result.cards[0], player) == suit)) {
                                            if (player == result.targets[0]) {
                                                if (target.isDamaged() && target.hp < player.hp && (get.mode() != 'identity' || player.identity != 'nei')) player.addExpose(0.15);
                                                target.recover();
                                                player.draw(2);
                                            }
                                            else {
                                                if ((player.isHealthy() || player.hp > target.hp) && (get.mode() != 'identity' || player.identity != 'nei')) player.addExpose(0.15);
                                                target.draw(2);
                                                player.recover();
                                            }
                                        }
                                        else {
                                            player.draw(2);
                                            player.recover();
                                        }
                                    }
                                },
                            },
                            //龙凤
                            miniyoulong: {
                                zhuanhuanji: true,
                                marktext: '☯',
                                mark: true,
                                intro: {
                                    content(storage, player) {
                                        var str = player.storage.miniyou_luanfeng ? '' : '每回合限一次，';
                                        return str + (storage ? '你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。' : '你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌。');
                                    },
                                },
                                init(player) {
                                    player.storage.miniyoulong = false;
                                    if (!player.storage.miniyoulong2) player.storage.miniyoulong2 = [];
                                },
                                hiddenCard(player, name) {
                                    var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick');
                                    if (!list.some(name2 => name2[2] == name && !player.storage.miniyoulong2.some(cardx => cardx.name == name2[2] && cardx.nature == name2[3]))) return false;
                                    if (player.hasSkill('miniyoulong_' + (player.storage.miniyoulong || false))) return false;
                                    var type = get.type(name);
                                    if (player.storage.miniyoulong) return type == 'basic' && ((_status.connectMode && player.countCards('he')) || player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player)));
                                    return type == 'trick' && player.hasEnabledSlot();
                                },
                                audio: 'youlong',
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    if (player.hasSkill('miniyoulong_' + (player.storage.miniyoulong || false))) return false;
                                    var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick'), type = player.storage.miniyoulong ? 'basic' : 'trick';
                                    if (type == 'basic' && !player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player))) return false;
                                    if (type == 'trick' && !player.hasEnabledSlot()) return false;
                                    return list.some(name => name[0] == type && !player.storage.miniyoulong2.some(cardx => cardx.name == name[2] && cardx.nature == name[3]) && event.filterCard(get.autoViewAs({ name: name[2], nature: name[3] }, 'unsure'), player, event));
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var dialog = ui.create.dialog('游龙', 'hidden');
                                        var list2 = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick'), type = player.storage.miniyoulong ? 'basic' : 'trick';
                                        if (type == 'trick') {
                                            var equips = [];
                                            for (let i = 1; i < 6; i++) {
                                                if (!player.hasEnabledSlot(i)) continue;
                                                equips.push([i, get.translation('equip' + i)]);
                                            }
                                            if (equips.length > 0) dialog.add([equips, 'tdnodes']);
                                        }
                                        var list = list2.filter(name => name[0] == type && !player.storage.miniyoulong2.some(cardx => cardx.name == name[2] && cardx.nature == name[3]) && event.filterCard(get.autoViewAs({ name: name[2], nature: name[3] }, 'unsure'), player, event));
                                        list = list.map(card => {
                                            card[0] = get.translation(card[0]);
                                            return card;
                                        });
                                        dialog.add([list, 'vcard']);
                                        return dialog;
                                    },
                                    filter(button) {
                                        if (ui.selected.buttons.length && typeof button.link == typeof ui.selected.buttons[0].link) return false;
                                        return true;
                                    },
                                    select: () => _status.event.player.storage.miniyoulong ? 1 : 2,
                                    check(button) {
                                        var player = _status.event.player;
                                        if (typeof button.link == 'number') {
                                            var card = player.getEquip(button.link);
                                            if (card) {
                                                var val = get.value(card);
                                                if (val > 0) return 0;
                                                return 5 - val;
                                            }
                                            switch (button.link) {
                                                case 3: return 4.5; break;
                                                case 4: return 4.4; break;
                                                case 5: return 4.3; break;
                                                case 2: return (3 - player.hp) * 1.5; break;
                                                case 1: {
                                                    if (game.hasPlayer(function (current) {
                                                        return (get.realAttitude || get.attitude)(player, current) < 0 && get.distance(player, current) > 1;
                                                    })) return 0;
                                                    return 3.2;
                                                }
                                            }
                                        }
                                        var name = button.link[2];
                                        var evt = _status.event.getParent();
                                        if (name == 'shan') return 2;
                                        if (evt.type == 'dying') {
                                            if (get.attitude(player, evt.dying) < 2) return false;
                                            if (name == 'jiu') return 2.1;
                                            return 1.9;
                                        }
                                        if (evt.type == 'phase') return player.getUseValue({ name: name, nature: button.link[3] });
                                        return 1;
                                    },
                                    backup(links, player) {
                                        if (!links[1]) links = [6, links[0]];
                                        else if (typeof links[1] == 'number') links.reverse();
                                        var equip = links[0];
                                        var name = links[1][2];
                                        var nature = links[1][3];
                                        var next = {
                                            viewAs: {
                                                name: name,
                                                nature: nature,
                                                isCard: true,
                                            },
                                            popname: true,
                                            precontent() {
                                                var skill = 'miniyoulong_' + (player.storage.miniyoulong || false);
                                                player.logSkill('miniyoulong');
                                                if (skill == 'miniyoulong_false') player.disableEquip(lib.skill.miniyoulong_backup.equip);
                                                else {
                                                    player.discard(event.result.cards);
                                                    event.result.card = { name: event.result.card.name, nature: event.result.card.nature };
                                                    event.result.cards = [];
                                                }
                                                delete event.result.skill;
                                                if (!player.storage.miniyou_luanfeng) player.addTempSkill(skill);
                                                player.changeZhuanhuanji('miniyoulong');
                                                player.storage.miniyoulong2.add({ name: event.result.card.name, nature: event.result.card.nature });
                                            },
                                        };
                                        if (player.storage.miniyoulong) {
                                            next.filterCard = (card, player) => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player);
                                            next.ignoreMod = true;
                                            next.position = 'he';
                                            next.check = (card) => 7 - get.value(card);
                                        }
                                        else {
                                            next.equip = equip;
                                            next.filterCard = () => false;
                                            next.selectCard = -1;
                                        }
                                        return next;
                                    },
                                    prompt(links, player) {
                                        if (!links[1]) links = [6, links[0]];
                                        else if (typeof links[1] == 'number') links.reverse();
                                        var equip = 'equip' + links[0];
                                        var name = links[1][2];
                                        var nature = links[1][3];
                                        if (player.storage.miniyoulong) return '弃置一张非基本牌，视为使用' + (get.translation(nature) || '') + get.translation(name);
                                        return '废除自己的' + get.translation(equip) + '栏，视为使用' + (get.translation(nature) || '') + get.translation(name);
                                    },
                                },
                                ai: {
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg == 'respond') return false;
                                        if (!player.storage.miniyoulong || player.hasSkill('miniyoulong_true')) return false;
                                        if (!((_status.connectMode && player.countCards('he')) || player.countCards('he', card => get.type(card) != 'basic' && lib.filter.cardDiscardable(card, player)))) return false;
                                        var list = get.inpileVCardList(info => info[0] == 'basic' && !player.storage.miniyoulong2.some(card => card.name == info[2] && card.nature == info[3]));
                                        var name = (tag == 'respondSha' ? 'sha' : 'shan');
                                        return list.some(name2 => name2[2] == name);
                                    },
                                    order(item, player) {
                                        if (player && _status.event.type == 'phase') {
                                            var list = get.inpileVCardList(info => info[0] == 'basic' || info[0] == 'trick');
                                            var max = 0, type = player.storage.miniyoulong ? 'basic' : 'trick';
                                            list = list.filter(name => name[0] == type && !player.storage.miniyoulong2.some(card => card.name == name[2] && card.nature == name[3]));
                                            list = list.map(namex => { return { name: namex[2], nature: namex[3] } });
                                            for (var card of list) {
                                                if (player.getUseValue(card) > 0) {
                                                    var temp = get.order(card);
                                                    if (temp > max) max = temp;
                                                }
                                            }
                                            if (max > 0) max += 0.3;
                                            return max;
                                        }
                                        return 1;
                                    },
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    true: { charlotte: true },
                                    false: { charlotte: true },
                                },
                            },
                            miniluanfeng: {
                                audio: 'luanfeng',
                                trigger: { global: 'dying' },
                                filter(event, player) {
                                    return event.player.maxHp >= player.maxHp && event.player.hp < 1;
                                },
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'soil',
                                logTarget: 'player',
                                check(event, player) {
                                    return lib.skill.xinwanlan.check(event, player);
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniluanfeng');
                                    trigger.player.recover(3 - trigger.player.hp);
                                    'step 1'
                                    var targets = [player, trigger.player];
                                    while (targets.length) {
                                        var target = targets.shift(), list = [];
                                        for (var i = 1; i < 6; i++) {
                                            for (var j = 0; j < target.countDisabledSlot(i); j++) {
                                                list.push(i);
                                            }
                                        }
                                        if (list.length) target.enableEquip(list);
                                    }
                                    'step 2'
                                    trigger.player.drawTo(6);
                                    'step 3'
                                    player.storage.miniyoulong2 = [];
                                    player.storage.miniyou_luanfeng = true;
                                    player.removeSkill('miniyoulong_true');
                                    player.removeSkill('miniyoulong_false');
                                    game.delayx();
                                },
                            },
                            //关张
                            minifuhun: {
                                audio: 'fuhun',
                                inherit: 'fuhun',
                                derivation: ['minirewusheng', 'minisppaoxiao'],
                                check(card) {
                                    if (_status.event.player.hasSkill('minirewusheng') && get.color(card) == 'red') return 0;
                                    if (_status.event.name == 'chooseToRespond') {
                                        if (card.name == 'sha') return 0;
                                        return 6 - get.useful(card);
                                    }
                                    if (_status.event.player.countCards('hs') < 4) return 6 - get.useful(card);
                                    return 7 - get.useful(card);
                                },
                                ai: {
                                    respondSha: true,
                                    skillTagFilter(player) {
                                        if (player.countCards('hs') < 2) return false;
                                    },
                                    order(item, player) {
                                        if (player.hasSkill('minirewusheng') && player.hasSkill('minisppaoxiao')) return 1;
                                        if (player.countCards('hs') < 4) return 1;
                                        return 4;
                                    },
                                },
                                group: 'minifuhun_effect',
                                subSkill: {
                                    effect: {
                                        audio: 'fuhun',
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            if (!event.card || event.card.name != 'sha') return false;
                                            if (player.storage.minifuhun) return false;
                                            if (player.getHistory('sourceDamage', evt => evt.card && evt.card.name == 'sha').length > 1) return true;
                                            return player.isPhaseUsing() && event.getParent().skill == 'minifuhun';
                                        },
                                        forced: true,
                                        content() {
                                            var skills = lib.skill.minifuhun.derivation.slice();
                                            if (player.getHistory('sourceDamage', evt => evt.card && evt.card.name == 'sha').length > 1) {
                                                player.removeSkills(skills);
                                                player.addSkills(skills);
                                                player.storage.minifuhun = true;
                                            }
                                            else player.addTempSkills(skills);
                                        },
                                    },
                                },
                            },
                            //谋刘备
                            minisbrende: {
                                audio: 'sbrende',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                maxNum: 10,
                                filter(event, player) {
                                    if (player.hasSkill('minisbrende_used')) return false;
                                    for (var name of lib.inpile) {
                                        var card = { name: name, isCard: true };
                                        if (get.type(name) == 'basic') {
                                            if (player.countMark('minisbrende') < 2) continue;
                                            if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                                            if (name == 'sha') {
                                                for (var nature of lib.inpile_nature) {
                                                    card.nature = nature;
                                                    if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                                                }
                                            }
                                        }
                                        if (get.type(name) == 'trick') {
                                            if (player.countMark('minisbrende') < 3) continue;
                                            if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return true;
                                        }
                                    }
                                    return false;
                                },
                                group: ['minisbrende_give', 'minisbrende_gain'],
                                chooseButton: {
                                    dialog(event, player) {
                                        var dialog = ui.create.dialog('仁德');
                                        if (event.type == 'phase') {
                                            dialog._chosenOpt = [];
                                            var table = document.createElement('div');
                                            table.classList.add('add-setting');
                                            table.style.margin = '0';
                                            table.style.width = '100%';
                                            table.style.position = 'relative';
                                            var list = ['视为使用牌', '交给其他角色牌'];
                                            for (var i of list) {
                                                var td = ui.create.div('.shadowed.reduce_radius.pointerdiv.tdnode');
                                                td.innerHTML = '<span>' + i + '</span>';
                                                td.link = i;
                                                if (i == list[0]) {
                                                    td.classList.add('bluebg');
                                                    dialog._chosenOpt.add(td);
                                                }
                                                td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                                                    if (_status.dragged) return;
                                                    if (_status.clicked) return;
                                                    if (_status.justdragged) return;
                                                    _status.tempNoButton = true;
                                                    _status.clicked = true;
                                                    setTimeout(function () {
                                                        _status.tempNoButton = false;
                                                    }, 500);
                                                    var link = this.link;
                                                    if (link == '交给其他角色牌') game.uncheck();
                                                    var current = this.parentNode.querySelector('.bluebg');
                                                    if (current) {
                                                        current.classList.remove('bluebg');
                                                        dialog._chosenOpt.remove(current);
                                                    }
                                                    dialog._chosenOpt.add(this);
                                                    this.classList.add('bluebg');
                                                    game.check();
                                                });
                                                table.appendChild(td);
                                                dialog.buttons.add(td);
                                            }
                                            dialog.content.appendChild(table);
                                        }
                                        var cards = [];
                                        for (var name of lib.inpile) {
                                            var card = { name: name, isCard: true };
                                            if (get.type(name) == 'basic') {
                                                if (player.countMark('minisbrende') < 2) continue;
                                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['基本', '', name]);
                                                if (name == 'sha') {
                                                    for (var nature of lib.inpile_nature) {
                                                        card.nature = nature;
                                                        if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['基本', '', name, nature]);
                                                    }
                                                }
                                            }
                                            if (get.type(name) == 'trick') {
                                                if (player.countMark('minisbrende') < 3) continue;
                                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) cards.push(['锦囊', '', name]);
                                            }
                                        }
                                        dialog.add([cards, 'vcard'])
                                        return dialog;
                                    },
                                    check(button, player) {
                                        if (typeof button.link == 'string') return -1;
                                        if (_status.event.getParent().type != 'phase') return 1;
                                        return _status.event.player.getUseValue({ name: button.link[2], nature: button.link[3] });
                                    },
                                    select() {
                                        var opts = _status.event.dialog._chosenOpt;
                                        return opts?.length && opts[0].link == '交给其他角色牌' ? 0 : 1;
                                    },
                                    backup(links, player) {
                                        var isUse = links.length == 1;
                                        var backup = get.copy(lib.skill['minisbrende_' + (isUse ? 'use' : 'give')]);
                                        if (isUse) backup.viewAs = { name: links[0][2], nature: links[0][3], isCard: true };
                                        return backup;
                                    },
                                    prompt(links, player) {
                                        var isUse = links.length == 1;
                                        return (isUse ? ('移去' + (get.type(links[0][2]) == 'basic' ? '2' : '3') + '枚“仁望”，视为使用或打出' + (get.translation(links[0][3]) || '') + get.translation(links[0][2]))
                                            : '###仁德###出牌阶段每名角色限一次。你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为' + lib.skill.minisbrende.maxNum + '）');
                                    }
                                },
                                hiddenCard(player, name) {
                                    const list = ['basic', 'trick'], num = list.indexOf(get.type(name));
                                    return num != -1 && player.countMark('minisbrende') > 1 + num && !player.hasSkill('minisbrende_used');
                                },
                                marktext: '仁',
                                intro: {
                                    name: '仁望',
                                    name2: '仁望',
                                    content: 'mark',
                                },
                                ai: {
                                    respondSha: true,
                                    respondShan: true,
                                    save: true,
                                    skillTagFilter(player) {
                                        return player.countMark('minisbrende') > 1 && !player.hasSkill('minisbrende_used');
                                    },
                                    order(item, player) {
                                        if (_status.event.type == 'phase' && lib.skill.minisbzhangwu.ai.result.player(player) > 0) return 9.1;
                                        return 0.5;
                                    },
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) {
                                                return get.attitude(player, _status.event.dying);
                                            }
                                            return _status.event.type == 'phase' && player.countMark('minisbrende') <= 2 ? 0 : 1;
                                        },
                                    },
                                },
                                subSkill: {
                                    backup: {},
                                    used: { charlotte: true },
                                    given: { onremove: true },
                                    use: {
                                        audio: 'sbrende',
                                        filterCard: () => false,
                                        selectCard: -1,
                                        popname: true,
                                        precontent() {
                                            player.logSkill('minisbrende_use');
                                            delete event.result.skill;
                                            player.removeMark('minisbrende', 2 + ['basic', 'trick'].indexOf(get.type(event.result.card.name)));
                                            player.addTempSkill('minisbrende_used');
                                        }
                                    },
                                    give: {
                                        audio: 'sbrende',
                                        enable: 'phaseUse',
                                        filterCard: true,
                                        selectCard: [1, Infinity],
                                        position: 'he',
                                        discard: false,
                                        lose: false,
                                        delay: false,
                                        filter(event, player) {
                                            if (player.countMark('minisbrende') < 2 || player.hasSkill('minisbrende_used')) return true;
                                            for (var name of lib.inpile) {
                                                if (get.type(name) != 'basic') continue;
                                                var card = { name: name, isCard: true };
                                                if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return false;
                                                if (name == 'sha') {
                                                    for (var nature of lib.inpile_nature) {
                                                        card.nature = nature;
                                                        if (event.filterCard(get.autoViewAs(card, 'unsure'), player, event)) return false;
                                                    }
                                                }
                                            }
                                            return true;
                                        },
                                        filterTarget(card, player, target) {
                                            if (player.getStorage('minisbrende_given').includes(target)) return false;
                                            return player != target;
                                        },
                                        prompt(event) {
                                            return '出牌阶段每名角色限一次。你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为' + lib.skill.minisbrende.maxNum + '）';
                                        },
                                        check(card) {
                                            var player = get.owner(card);
                                            if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') return 0;
                                            if (ui.selected.cards.length + player.countMark('minisbrende') > lib.skill.minisbrende.maxNum) return 0;
                                            if (!ui.selected.cards.length && card.name == 'du') return 20;
                                            if (ui.selected.cards.length >= Math.max(2, player.countCards('he') - player.hp)) return 0;
                                            if (player.countCards('he') <= 1) {
                                                var players = game.filterPlayer();
                                                for (var i = 0; i < players.length; i++) {
                                                    if (players[i].hasSkill('haoshi') &&
                                                        !players[i].isTurnedOver() &&
                                                        !players[i].hasJudge('lebu') &&
                                                        get.attitude(player, players[i]) >= 3 &&
                                                        get.attitude(players[i], player) >= 3) {
                                                        return 11 - get.value(card);
                                                    }
                                                }
                                                if (player.countCards('he') > player.hp) return 10 - get.value(card);
                                                if (player.countCards('he') > 2) return 6 - get.value(card);
                                                return -1;
                                            }
                                            return 18 - (ui.selected.cards.length + player.countMark('minisbrende')) - get.value(card);
                                        },
                                        content() {
                                            player.addTempSkill('minisbrende_given', 'phaseUseAfter');
                                            player.markAuto('minisbrende_given', [target]);
                                            player.markAuto('minisbrende_givenx', [target]);
                                            player.give(cards, target);
                                            var num = Math.min(lib.skill.minisbrende.maxNum - player.countMark('minisbrende'), cards.length);
                                            if (num > 0) player.addMark('minisbrende', num);
                                        },
                                        ai: {
                                            order(skill, player) {
                                                return player.countMark('minisbrende') < 2 ? 6.8 : 5.8;
                                            },
                                            result: {
                                                target(player, target) {
                                                    if (!player.hasFriend() && player.hasSkill('minisbzhangwu') && ui.selected.cards.length &&
                                                        get.value(ui.selected.cards[0]) > (lib.skill.minisbzhangwu.filterTarget(null, player, target) ? 3 : 5)) return -0.1;
                                                    if (target.hasSkillTag('nogain')) return 0;
                                                    if (ui.selected.cards.length && ui.selected.cards[0].name == 'du') {
                                                        if (target.hasSkillTag('nodu')) return 0;
                                                        return -10;
                                                    }
                                                    if (target.hasJudge('lebu')) return 0;
                                                    var nh = target.countCards('h');
                                                    return Math.max(1, 5 - nh);
                                                }
                                            },
                                        },
                                    },
                                    gain: {
                                        audio: 'sbrende',
                                        trigger: { player: 'phaseUseBegin' },
                                        filter(event, player) {
                                            return player.countMark('minisbrende') < lib.skill.minisbrende.maxNum;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            var num = Math.min(lib.skill.minisbrende.maxNum - player.countMark('minisbrende'), 3);
                                            if (num > 0) player.addMark('minisbrende', num);
                                        }
                                    },
                                },
                            },
                            minisbzhangwu: {
                                audio: 'sbzhangwu',
                                enable: 'phaseUse',
                                skillAnimation: 'epic',
                                animationColor: 'orange',
                                limited: true,
                                filter(event, player) {
                                    if (game.roundNumber <= 1) return false;
                                    if (!game.hasPlayer(current => lib.skill.minisbzhangwu.filterTarget(null, player, current))) return false;
                                    return true;
                                },
                                filterTarget(card, player, target) {
                                    if (target == player) return false;
                                    return player.getStorage('minisbrende_givenx').includes(target);
                                },
                                selectTarget: [-1, -2],
                                multiline: true,
                                content() {
                                    'step 0'
                                    player.awakenSkill('minisbzhangwu');
                                    var num = Math.min(game.roundNumber - 1, 3);
                                    var cards = target.getCards('he'), count = cards.length;
                                    if (count == 0) event.finish();
                                    else if (count <= num) event._result = { bool: true, cards: cards };
                                    else target.chooseCard('章武：交给' + get.translation(player) + get.cnNumber(num) + '张牌', true, 'he', num);
                                    'step 1'
                                    if (result.bool) target.give(result.cards, player);
                                },
                                contentAfter() {
                                    player.recover(3);
                                    player.tempBanSkill('minisbrende', null, false);
                                },
                                ai: {
                                    order: 9,
                                    combo: 'minisbrende',
                                    result: {
                                        player(player, target) {
                                            var targets = game.filterPlayer(current => lib.skill.minisbzhangwu.filterTarget(null, player, current));
                                            if (!targets.length) return 0;
                                            var eff = 0;
                                            for (var target of targets) {
                                                eff += get.effect(target, { name: 'shunshou_copy2' }, player, player);
                                            }
                                            eff += 15 - 5 * Math.max(0, 3 - player.getDamagedHp());
                                            return eff > 15 ? 1 : 0;
                                        },
                                    }
                                }
                            },
                            minisbjijiang: {
                                unique: true,
                                zhuSkill: true,
                                audio: 'sbjijiang',
                                trigger: { player: 'phaseUseEnd' },
                                filter(event, player) {
                                    if (!player.hasZhuSkill('minisbjijiang')) return false;
                                    return game.hasPlayer(current => {
                                        if (current.group != 'shu' || player == current) return false;
                                        return game.hasPlayer(currentx => current.inRange(currentx));
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minisbjijiang'), 2).set('filterTarget', (card, player, target) => {
                                        if (!ui.selected.targets.length) return target.group == 'shu' && target != player && game.hasPlayer(currentx => target.inRange(currentx));
                                        return ui.selected.targets[0].inRange(target);
                                    }).set('targetprompt', ['进行选择', '出杀对象']).set('ai', target => {
                                        var player = _status.event.player;
                                        if (ui.selected.targets.length) return get.effect(target, { name: 'sha' }, player, ui.selected.targets[0], player);
                                        var targets = game.filterPlayer(current => target.inRange(current));
                                        if (targets.some(currentx => get.effect(currentx, { name: 'sha' }, target, player) > 0)) return 2 - Math.abs(get.attitude(player, target));
                                        return 0;
                                    }).set('multitarget', true);
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets;
                                        event.targets = targets;
                                        player.logSkill('minisbjijiang', targets, false);
                                        player.line2(targets);
                                        var choiceList = [
                                            '视为对' + get.translation(targets[1]) + '使用一张【杀】',
                                            '你的下一个出牌阶段开始前，跳过此阶段'
                                        ];
                                        targets[0].chooseControl().set('choiceList', choiceList).set('ai', () => {
                                            return _status.event.choice;
                                        }).set('choice', get.effect(targets[1], { name: 'sha' }, targets[0], targets[0]) > get.effect(targets[0], { name: 'lebu' }, targets[0], targets[0]) ? 0 : 1);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.index == 0) targets[0].useCard({ name: 'sha', isCard: true }, targets[1], false);
                                    else targets[0].addSkill('sbjijiang_skip');
                                },
                            },
                            //谋马超
                            minisbtieji: {
                                audio: 'sbtieji',
                                inherit: 'sbtieji',
                                logAudio: () => 1,
                                async content(event, trigger, player) {
                                    const target = trigger.target;
                                    target.addTempSkill('fengyin');
                                    trigger.directHit.add(target);
                                    const { result } = await player.mini_chooseToMouYi(target).set('namelist', [
                                        '出阵迎战', '拱卫中军', '直取敌营', '扰阵疲敌'
                                    ]).set('ai', button => {
                                        const source = get.event().getParent().player, target = get.event().getParent().target;
                                        if (!target.countCards('he') && button.link[2] == 'db_def2') return 10;
                                        if (!target.countCards('he') && get.attitude(target, source) <= 0 && button.link[2] == 'db_atk1') return 10;
                                        return 1 + Math.random();
                                    }).set('sourceSkill', 'sbtieji');
                                    if (result.bool) {
                                        if (result.player == 'db_def1') player.gainPlayerCard(target, 'he', true);
                                        else player.draw(2);
                                    }
                                },
                                group: 'minisbtieji_mouyi',
                                subSkill: {
                                    mouyi: {
                                        audio: 'sbtieji1.mp3',
                                        trigger: {
                                            player: ['chooseToDuibenAfter', 'mini_chooseToMouYiAfter'],
                                            target: ['chooseToDuibenAfter', 'mini_chooseToMouYiAfter'],
                                        },
                                        filter(event, player) {
                                            if (event.name == 'chooseToDuiben' && event.title !== '谋弈') return false;
                                            return event.result && (event.player == player) === event.result.bool;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            player.addTempSkill('shenzhu_more');
                                            player.addMark('shenzhu_more', 1, false);
                                            const { result: { bool } } = await player.chooseToDiscard('h', '铁骑：是否弃置一张手牌并获得一张【杀】？').set('ai', card => {
                                                if (get.name(card, get.event('player')) == 'sha') return 0;
                                                return lib.skill.zhiheng.check(card);
                                            });
                                            if (bool) {
                                                const card = get.cardPile(card => card.name == 'sha');
                                                if (card) player.gain(card, 'gain2');
                                            }
                                        },
                                    },
                                },
                                init() {
                                    if (!_status.miniMouYi) {
                                        _status.miniMouYi = true;
                                        lib.skill.minisbtieji.initMouYi();
                                    }
                                },
                                initMouYi() {
                                    game.broadcastAll(() => {
                                        lib.element.player.mini_chooseToMouYi = function (target) {
                                            var next = game.createEvent('mini_chooseToMouYi');
                                            next.player = this;
                                            next.target = target;
                                            next.setContent(() => {
                                                'step 0'
                                                if (!target || !event.namelist) {
                                                    event.result = { bool: false };
                                                    event.finish();
                                                    return;
                                                }
                                                game.broadcastAll((list, sourceSkill) => {
                                                    const list2 = ['db_atk1', 'db_atk2', 'db_def1', 'db_def2'];
                                                    for (const name of list2) {
                                                        lib.card[name].image = (event.sourceSkill ? 'card/' : 'ext:活动武将/image/card/') + name + '_' + list[list2.indexOf(name)];
                                                        lib.translate[name] = list[list2.indexOf(name)];
                                                    }
                                                }, event.namelist, event.sourceSkill);
                                                game.log(player, '向', target, '发起了', '#y谋弈');
                                                if (!event.ai) event.ai = () => 1 + Math.random();
                                                if (_status.connectMode) {
                                                    player.chooseButtonOL([
                                                        [player, ['谋弈：请选择一种策略', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true],
                                                        [target, ['谋弈：请选择一种策略', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true],
                                                    ], () => { }, event.ai).set('processAI', () => {
                                                        const buttons = _status.event.dialog.buttons;
                                                        return { bool: true, links: [buttons.randomGet().link] };
                                                    }).set('switchToAuto', () => _status.event.result = 'ai');
                                                }
                                                'step 1';
                                                if (_status.connectMode) {
                                                    event.mes = result[player.playerid].links[0][2];
                                                    event.tes = result[target.playerid].links[0][2];
                                                    event.goto(4);
                                                }
                                                else player.chooseButton(['谋弈：请选择一种策略', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true).set('ai', event.ai);
                                                'step 2';
                                                event.mes = result.links[0][2];
                                                target.chooseButton(['谋弈：请选择一种策略', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true).set('ai', event.ai);
                                                'step 3';
                                                event.tes = result.links[0][2];
                                                'step 4';
                                                game.broadcast(() => ui.arena.classList.add('thrownhighlight'));
                                                ui.arena.classList.add('thrownhighlight');
                                                game.addVideo('thrownhighlight1');
                                                target.$compare(game.createCard(event.tes, '', ''), player, game.createCard(event.mes, '', ''));
                                                game.log(target, '选择的策略为', '#g' + get.translation(event.tes));
                                                game.log(player, '选择的策略为', '#g' + get.translation(event.mes));
                                                game.delay(0, 1500);
                                                'step 5';
                                                let mes = event.mes.slice(6), tes = event.tes.slice(6), str;
                                                if (mes == tes) {
                                                    str = get.translation(player) + '谋弈成功';
                                                    player.popup('胜', 'wood');
                                                    target.popup('负', 'fire');
                                                    game.log(player, '#g胜');
                                                    event.result = { bool: true };
                                                }
                                                else {
                                                    str = get.translation(player) + '谋弈失败';
                                                    target.popup('胜', 'wood');
                                                    player.popup('负', 'fire');
                                                    game.log(target, '#g胜');
                                                    event.result = { bool: false };
                                                }
                                                event.result.player = event.mes;
                                                event.result.target = event.tes;
                                                game.broadcastAll(str => {
                                                    const dialog = ui.create.dialog(str);
                                                    dialog.classList.add('center');
                                                    setTimeout(() => dialog.close(), 1000);
                                                }, str);
                                                if (event.sourceSkill) game.trySkillAudio(event.sourceSkill + '_' + (event.result.bool ? 'true' + mes : 'false'), player);
                                                else game.broadcastAll((name, bool, mes) => {
                                                    game.playAudio('..', 'extension', '活动武将/audio/skill', name + (bool ? parseFloat(1 + parseInt(mes)) : '4'));
                                                }, event.getParent().name, event.result.bool, mes);
                                                game.delay(2);
                                                'step 6';
                                                game.broadcastAll(() => ui.arena.classList.remove('thrownhighlight'));
                                                game.addVideo('thrownhighlight2');
                                                if (event.clear !== false) game.broadcastAll(ui.clear);
                                            });
                                            return next;
                                        };
                                        if (game && (game.players || game.dead)) {
                                            const players = game.players.slice().concat(game.dead);
                                            for (const player of players) {
                                                if (!player.mini_chooseToMouYi) player.mini_chooseToMouYi = lib.element.player.mini_chooseToMouYi;
                                            }
                                        }
                                    });
                                },
                            },
                            //谋黄忠
                            minisbliegong: {
                                audio: 'sbliegong',
                                inherit: 'sbliegong',
                                filter(event, player) {
                                    return !event.getParent()._minisbliegong_player && event.targets.length == 1 && event.card.name == 'sha' && player.getStorage('minisbliegong').length > 0;
                                },
                                prompt2(event, player) {
                                    var str = '', storage = player.getStorage('minisbliegong');
                                    if (storage.length > 1) str += ('亮出并获得牌堆顶的' + get.cnNumber(storage.length - 1) + '张牌并增加伤害；且');
                                    str += ('令' + get.translation(event.target) + '不能使用花色为');
                                    for (var i of storage) str += get.translation(i);
                                    str += ('的牌响应' + get.translation(event.card));
                                    return str;
                                },
                                check(event, player) {
                                    var target = event.target;
                                    if (get.attitude(player, target) > 0) return false;
                                    if (target.hasSkillTag('filterDamage', null, {
                                        player: player,
                                        card: event.card,
                                    })) return false;
                                    var storage = player.getStorage('minisbliegong');
                                    if (storage.length >= 4) return true;
                                    if (storage.length < 3) return false;
                                    if (target.hasShan()) return storage.includes('heart') && storage.includes('diamond');
                                    return true;
                                },
                                async content(event, trigger, player) {
                                    var storage = player.getStorage('minisbliegong').slice();
                                    var num = storage.length - 1;
                                    var evt = trigger.getParent();
                                    if (num > 0) {
                                        if (typeof evt.baseDamage != 'number') evt.baseDamage = 1;
                                        var cards = get.cards(num);
                                        await game.cardsGotoOrdering(cards);
                                        await player.showCards(cards.slice(), get.translation(player) + '发动了【烈弓】');
                                        await player.gain(cards, 'gain2');
                                        for (const card of cards) {
                                            if (storage.includes(get.suit(card, false))) evt.baseDamage++;
                                        }
                                    }
                                    evt._minisbliegong_player = player;
                                    player.when('useCardAfter')
                                        .filter(evtxx => evtxx._minisbliegong_player == player)
                                        .then(() => player.unmarkSkill('minisbliegong'));
                                    var target = trigger.target;
                                    target.addTempSkill('minisbliegong_block');
                                    if (!target.storage.minisbliegong_block) target.storage.minisbliegong_block = [];
                                    target.storage.minisbliegong_block.push([evt.card, storage]);
                                    lib.skill.minisbliegong.updateBlocker(target);
                                },
                                updateBlocker(player) {
                                    var list = [], storage = player.storage.minisbliegong_block;
                                    if (storage?.length) {
                                        for (var i of storage) list.addArray(i[1]);
                                    }
                                    player.storage.minisbliegong_blocker = list;
                                },
                                ai: {
                                    threaten: 3.5,
                                    directHit_ai: true,
                                    halfneg: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg?.card && arg.card.name == 'sha') {
                                            var storage = player.getStorage('minisbliegong');
                                            if (storage.length < 3 || !storage.includes('heart') || !storage.includes('diamond')) return false;
                                            var target = arg.target;
                                            if (target.hasSkill('bagua_skill') || target.hasSkill('bazhen') || target.hasSkill('rw_bagua_skill')) return false;
                                            return true;
                                        }
                                        return false;
                                    },
                                },
                                intro: {
                                    content: '已记录花色：$',
                                    markcount(storage) {
                                        if (!_status.connectMode && game.HasExtension('十周年UI') && lib.config.extension_十周年UI_playerMarkStyle && lib.config.extension_十周年UI_playerMarkStyle == 'decade') return 0;
                                        return storage.length;
                                    },
                                    onunmark: true,
                                },
                                group: 'minisbliegong_count',
                                subSkill: {
                                    block: {
                                        mod: {
                                            cardEnabled(card, player) {
                                                if (!player.storage.minisbliegong_blocker) return;
                                                var suit = get.suit(card);
                                                if (suit == 'none') return;
                                                var evt = _status.event;
                                                if (evt.name != 'chooseToUse') evt = evt.getParent('chooseToUse');
                                                if (!evt || !evt.respondTo || evt.respondTo[1].name != 'sha') return;
                                                if (player.storage.minisbliegong_blocker.includes(suit)) return false;
                                            },
                                        },
                                        trigger: {
                                            player: ['damageBefore', 'damageCancelled', 'damageZero'],
                                            target: ['shaMiss', 'useCardToExcluded', 'useCardToEnd'],
                                            global: ['useCardEnd'],
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        charlotte: true,
                                        onremove(player) {
                                            delete player.storage.minisbliegong_block;
                                            delete player.storage.minisbliegong_blocker;
                                        },
                                        filter(event, player) {
                                            if (!event.card || !player.storage.minisbliegong_block) return false;
                                            for (var i of player.storage.minisbliegong_block) {
                                                if (i[0] == event.card) return true;
                                            }
                                            return false;
                                        },
                                        content() {
                                            var storage = player.storage.minisbliegong_block;
                                            for (var i = 0; i < storage.length; i++) {
                                                if (storage[i][0] == trigger.card) {
                                                    storage.splice(i--, 1);
                                                }
                                            }
                                            if (!storage.length) player.removeSkill('minisbliegong_block');
                                            else lib.skill.minisbliegong.updateBlocker(target);
                                        },
                                    },
                                    count: {
                                        trigger: {
                                            player: 'useCard',
                                            target: 'useCardToTargeted',
                                        },
                                        filter(event, player, name) {
                                            if (name != 'useCard' && player == event.player) return false;
                                            var suit = get.suit(event.card);
                                            if (!lib.suit.includes(suit)) return false;
                                            if (player.storage.minisbliegong && player.storage.minisbliegong.includes(suit)) return false;
                                            return true;
                                        },
                                        direct: true,
                                        content() {
                                            player.markAuto('minisbliegong', [get.suit(trigger.card)]);
                                            player.storage.minisbliegong.sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                                            if (!_status.connectMode && game.HasExtension('十周年UI') && lib.config.extension_十周年UI_playerMarkStyle && lib.config.extension_十周年UI_playerMarkStyle == 'decade') {
                                                game.broadcastAll(function (player, skill) {
                                                    if (player.marks[skill]) player.marks[skill].firstChild.innerHTML = player.getStorage(skill).reduce((str, suit) => str += get.translation(suit), '');
                                                }, player, 'minisbliegong');
                                            }
                                        },
                                    },
                                },
                            },
                            //谋赵云
                            minisblongdan: {
                                audio: 'sblongdan',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                filter(event, player) {
                                    if (event.type == 'wuxie' || !player.hasMark('charge')) return false;
                                    for (var name of lib.inpile) {
                                        if (get.type(name) != 'basic') continue;
                                        if (player.hasCard({ type: 'basic' }, 'hs')) {
                                            if (event.filterCard(get.autoViewAs({ name: name }, 'unsure'), player, event)) return true;
                                            if (name == 'sha') {
                                                for (var nature of lib.inpile_nature) {
                                                    if (event.filterCard(get.autoViewAs({ name: name, nature: nature }, 'unsure'), player, event)) return true;
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                },
                                chargeSkill: 3,
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        for (var name of lib.inpile) {
                                            if (get.type(name) != 'basic') continue;
                                            if (player.hasCard({ type: 'basic' }, 'hs')) {
                                                if (event.filterCard(get.autoViewAs({ name: name }, 'unsure'), player, event)) list.push(['基本', '', name]);
                                                if (name == 'sha') {
                                                    for (var nature of lib.inpile_nature) {
                                                        if (event.filterCard(get.autoViewAs({ name: name, nature: nature }, 'unsure'), player, event)) list.push(['基本', '', name, nature]);
                                                    }
                                                }
                                            }
                                        }
                                        return ui.create.dialog('龙胆', [list, 'vcard'], 'hidden');
                                    },
                                    check(button) {
                                        if (_status.event.getParent().type != 'phase') return 1;
                                        var player = _status.event.player, card = { name: button.link[2], nature: button.link[3] };
                                        if (card.name == 'jiu' && Math.min(player.countMark('charge'), player.countCards('h', { type: 'basic' })) < 2) return 0;
                                        return player.getUseValue(card, null, true);
                                    },
                                    backup(links, player) {
                                        return {
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                            },
                                            filterCard: { type: 'basic' },
                                            position: 'he',
                                            popname: true,
                                            check(card) {
                                                return 6 / Math.max(1, get.value(card));
                                            },
                                            precontent() {
                                                player.removeCharge();
                                                player.addTempSkill('minisblongdan_draw');
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        var card = {
                                            name: links[0][2],
                                            nature: links[0][3],
                                            isCard: true,
                                        };
                                        return '将一张基本牌当做' + get.translation(card) + '使用';
                                    },
                                },
                                hiddenCard(player, name) {
                                    if (get.type(name) != 'basic' || !player.hasMark('charge')) return false;
                                    return player.hasCard({ type: 'basic' }, 'hs');
                                },
                                ai: {
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag) {
                                        return lib.skill.minisblongdan.hiddenCard(player, tag == 'respondSha' ? 'sha' : 'shan');
                                    },
                                    order: 9,
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                group: 'minisblongdan_charge',
                                subSkill: {
                                    backup: { audio: 'minisblongdan' },
                                    draw: {
                                        charlotte: true,
                                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                                        filter(event, player) {
                                            return event.skill == 'minisblongdan_backup';
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    charge: {
                                        audio: 'minisblongdan',
                                        trigger: {
                                            global: ['phaseBefore', 'phaseEnd'],
                                            player: 'enterGame',
                                        },
                                        forced: true,
                                        filter(event, player, name) {
                                            if (!player.countCharge(true)) return false;
                                            return (name != 'phaseBefore' || game.phaseNumber == 0);
                                        },
                                        content() {
                                            player.addCharge();
                                        },
                                    },
                                },
                            },
                            minisbshilve: {
                                audio: 'sbjizhu',
                                trigger: { player: ['useCard', 'respond'] },
                                filter(event, player) {
                                    if (event.card.name != 'sha' && event.card.name != 'shan') return false;
                                    const target = lib.skill.chongzhen.logTarget(event, player);
                                    return target && event.skill && event.skill == 'minisblongdan_backup';
                                },
                                logTarget(event, player) {
                                    return lib.skill.chongzhen.logTarget(event, player);
                                },
                                async content(event, trigger, player) {
                                    const target = lib.skill.chongzhen.logTarget(trigger, player);
                                    const { result } = await player.mini_chooseToMouYi(target).set('namelist', [
                                        '暂避锋芒', '趁虚而入', '偃旗息鼓', '胆壮心雄'
                                    ]).set('ai', button => {
                                        const source = get.event().getParent().player, target = get.event().getParent().target;
                                        const att = get.attitude(source, target);
                                        if (source.countMark('charge') > 2 && (button.link[2] == 'db_atk2' || button.link[2] == 'db_def1')) return att > 0 ? -10 : 10;
                                        return 1 + Math.random();
                                    });
                                    if (result.bool) {
                                        if (result.player == 'db_def1') {
                                            const card = get.cardPile(card => get.type(card) != 'basic');
                                            if (card) await player.gain(card, 'gain2');
                                        }
                                        else if (player.countMark('charge') < 3) player.addMark('charge', 1);
                                    }
                                },
                                init() {
                                    if (!_status.miniMouYi) {
                                        _status.miniMouYi = true;
                                        lib.skill.minisbtieji.initMouYi();
                                    }
                                },
                            },
                            //张嶷
                            minishizhi: {
                                audio: 'reshizhi',
                                inherit: 'reshizhi',
                                mod: {
                                    cardname(card, player) {
                                        if (card.name == 'shan' && _status.currentPhase === player) return 'sha';
                                    },
                                },
                            },
                            //蒋琬费祎
                            minishoucheng: {
                                audio: 'shoucheng',
                                trigger: { global: ['equipAfter', 'addJudgeAfter', 'loseAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'] },
                                filter(event, player) {
                                    const target = _status.currentPhase;
                                    return game.hasPlayer(current => {
                                        if (target && current == target) return false;
                                        const evt = event.getl(current);
                                        return evt?.hs?.length && current.countCards('h') < current.maxHp;
                                    });
                                },
                                async cost(event, trigger, player) {
                                    const targetx = _status.currentPhase;
                                    const targets = game.filterPlayer(current => {
                                        if (targetx && current == targetx || !current.isIn()) return false;
                                        const evt = trigger.getl(current);
                                        return evt?.hs?.length && current.countCards('h') < current.maxHp;
                                    }).sortBySeat(targetx || player);
                                    event.result = await player.chooseTarget((card, player, target) => {
                                        return get.event('targets').includes(target);
                                    }).set('prompt', '是否对' + (targets.length > 1 ? '其中一名角色' : get.translation(targets[0])) + '发动【守成】？')
                                        .set('prompt2', '令其摸两张牌').set('targets', targets).set('ai', target => get.attitude(get.event('player'), target)).forResult();
                                },
                                usable: 1,
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    if (get.mode() != 'identity' || player.identity != 'nei') player.addExpose(0.2);
                                    await target.draw(2);
                                },
                            },
                            //谋孙尚香
                            minisbxiaoji: {
                                audio: 'sbxiaoji',
                                inherit: 'xiaoji',
                                frequent: false,
                                forced: true,
                                locked: false,
                                async content(event, trigger, player) {
                                    await player.draw(2);
                                    const result = await player.chooseTarget('是否弃置场上的一张牌？', (card, player, target) => {
                                        return target.countDiscardableCards(player, 'ej');
                                    }).set('ai', target => {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        if (att > 0 && (target.countCards('j') > 0 || target.countCards('e', function (card) {
                                            return get.value(card, target) < 0;
                                        }))) return 2;
                                        if (att < 0 && target.countCards('e') > 0 && !target.hasSkillTag('noe')) return -1;
                                        return 0;
                                    }).forResult();
                                    if (result.bool) {
                                        await player.discardPlayerCard(result.targets[0], 'ej', true);
                                        player.addExpose(0.2);
                                    }
                                },
                            },
                            minisbjieyin: {
                                audio: 'sbjieyin1.mp3',
                                trigger: { global: 'phaseBefore', player: 'enterGame' },
                                filter(event, player) {
                                    return game.hasPlayer(target => target != player && (!target.hasMark('minisbjieyin') || !target.hasSkill('minisbjieyin', null, false, false))) && (event.name != 'phase' || game.phaseNumber == 0);
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget(get.prompt('minisbjieyin'), '选择一名其他角色，你与其各获得1枚“姻”标记，然后令其获得【结姻】，最后你将势力变更至与其相同', (card, player, target) => {
                                        return target != player && (!target.hasMark('minisbjieyin') || !target.hasSkill('minisbjieyin', null, false, false));
                                    }).set('ai', target => {
                                        const player = get.event('player');
                                        return get.attitude(player, target) + 1145141919810;
                                    }).forResult();
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0], skill = event.name;
                                    if (!player.hasMark(skill)) player.addMark(skill, 1);
                                    if (!target.hasMark(skill)) target.addMark(skill, 1);
                                    if (!target.hasSkill(skill, null, false, false)) await target.addSkills(skill);
                                    if (player.group != target.group) await player.changeGroup(target.group);
                                },
                                marktext: '姻',
                                intro: { content: 'mark' },
                                group: ['minisbjieyin_xingshang', 'minisbjieyin_jieyin'],
                                subSkill: {
                                    xingshang: {
                                        audio: 'sbjieyin1',
                                        inherit: 'xingshang',
                                        filter(event, player) {
                                            if (!event.player.hasMark('minisbjieyin')) return false;
                                            return event.player.countCards('hej') > 0;
                                        },
                                        locked: false,
                                        logTarget: 'player',
                                        content() {
                                            event.togain = trigger.player.getCards('hej');
                                            player.gain(event.togain, trigger.player, 'giveAuto', 'bySelf');
                                        },
                                    },
                                    jieyin: {
                                        audio: 'sbjieyin1',
                                        inherit: 'minijieyin',
                                        filter(event, player) {
                                            return player.countCards('he') && game.hasPlayer(target => target != player && target.hasMark('minisbjieyin'));
                                        },
                                        filterTarget(card, player, target) {
                                            if (!target.hasMark('minisbjieyin')) return false;
                                            const cardx = ui.selected.cards[0];
                                            if (!cardx) return false;
                                            if (get.position(cardx) == 'e' && !target.canEquip(cardx)) return false;
                                            return true;
                                        },
                                        prompt: '出牌阶段限一次，你可以将一张手牌交给一名有“姻”的其他角色或将一张装备牌置入一名有“姻”的其他角色的对应空置装备栏，然后你回复1点体力并摸一张牌。',
                                        async content(event, trigger, player) {
                                            const { target, cards } = event;
                                            let result;
                                            if (get.position(cards[0]) == 'e') result = { index: 1 };
                                            else if (get.type(cards[0]) != 'equip' || !target.canEquip(cards[0])) result = { index: 0 };
                                            else result = await player.chooseControl().set(`choiceList`, [`将${get.translation(cards[0])}交给${get.translation(target)}`, `将${get.translation(cards[0])}置入${get.translation(target)}的装备区`]).set('ai', () => 1).forResult();
                                            if (result.index == 0) {
                                                await player.give(cards, target, true);
                                            }
                                            else {
                                                player.$give(cards, target);
                                                await game.delay(0.5);
                                                await target.equip(cards[0]);
                                            }
                                            await player.recover();
                                            await player.draw();
                                        },
                                        ai: {
                                            order(_, player = get.event('player')) {
                                                const es = player.getCards('e');
                                                for (let i = 0; i < es.length; i++) {
                                                    if (player.countCards('h', { subtype: get.subtype(es[i]) })) return 10;
                                                }
                                                return 2;
                                            },
                                            result: {
                                                target(player, target) {
                                                    const goon = player => {
                                                        const es = player.getCards('e');
                                                        for (let i = 0; i < es.length; i++) {
                                                            if (player.countCards('h', { subtype: get.subtype(es[i]) })) return true;
                                                        }
                                                        return false;
                                                    };
                                                    if (player.isHealthy()) {
                                                        if (!player.needsToDiscard(1) || goon(player)) return 0.1;
                                                        return 0;
                                                    }
                                                    return 1.5;
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            minisbfanxiang: {
                                unique: true,
                                limited: true,
                                audio: 'sbjieyin2.mp3',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(target => lib.skill.minisbfanxiang.filterTarget(null, player, target));
                                },
                                filterTarget(card, player, target) {
                                    return target != player && target.hasMark('minisbjieyin') && target.countGainableCards(player, 'e');
                                },
                                selectTarget: [-1, -2],
                                multiline: true,
                                multitarget: true,
                                skillAnimation: true,
                                animationColor: 'wood',
                                async content(event, trigger, player) {
                                    const targets = event.targets.sortBySeat();
                                    player.awakenSkill('minisbfanxiang');
                                    await player.gain(targets.map(target => target.getGainableCards(player, 'e')).flat(), 'give');
                                    for (const i of game.filterPlayer().sortBySeat()) {
                                        if (i.hasMark('minisbjieyin')) i.removeMark('minisbjieyin', i.countMark('minisbjieyin'));
                                        if (i.hasSkill('minisbjieyin', null, false, false)) await i.removeSkills('minisbjieyin');
                                    }
                                    await player.addSkills('miniwujian');
                                    if (player.group != 'wu') await player.changeGroup('wu');
                                },
                                derivation: 'miniwujian',
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player) {
                                            const targets = game.filterPlayer(target => lib.skill.minisbfanxiang.filterTarget(null, player, target));
                                            return targets.map(target => target.getGainableCards(player, 'e')).flat().length >= Math.max(3, targets.length);
                                        },
                                    },
                                },
                            },
                            //sp夏侯氏
                            minispyanyu: {
                                audio: 'sbyanyu',
                                trigger: { global: 'phaseUseBegin' },
                                filter(event, player) {
                                    return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'he');
                                },
                                async cost(event, trigger, player) {
                                    const name = event.name.slice(0, -5);
                                    const next = player.chooseToDiscard('he', get.prompt(name));
                                    if (player == trigger.player) {
                                        next.set('goon', (function () {
                                            var map = {
                                                basic: 0,
                                                trick: 0.1,
                                            };
                                            var hs = trigger.player.getCards("h");
                                            var sha = false;
                                            var jiu = false;
                                            for (var i = 0; i < hs.length; i++) {
                                                if (trigger.player.hasValueTarget(hs[i])) {
                                                    if (hs[i].name == "sha" && !sha) {
                                                        sha = true;
                                                        map.basic += 2;
                                                    }
                                                    if (hs[i].name == "tao") map.basic += 6;
                                                    if (hs[i].name == "jiu") {
                                                        jiu = true;
                                                        map.basic += 2.5;
                                                    }
                                                    if (get.type(hs[i]) == "trick") map.trick += get.value(hs[i], player, "raw");
                                                }
                                            }
                                            return map;
                                        })());
                                        next.set("ai", card => {
                                            var map = _status.event.goon;
                                            var type = get.type(card, "trick");
                                            if (!map[type]) return -1;
                                            return map[type] - get.value(card);
                                        });
                                    }
                                    else {
                                        next.set("ai", function (cardx) {
                                            var map = {
                                                basic: 0,
                                                trick: 0,
                                            };
                                            var hs = trigger.player.getCards("h");
                                            var sha = false;
                                            var jiu = false;
                                            for (var i = 0; i < hs.length; i++) {
                                                if (hs[i] != cardx && trigger.player.hasValueTarget(hs[i])) {
                                                    if (hs[i].name == "sha" && !sha) {
                                                        sha = true;
                                                        map.basic += 2;
                                                    }
                                                    if (hs[i].name == "tao") map.basic += 6;
                                                    if (hs[i].name == "jiu") {
                                                        jiu = true;
                                                        map.basic += 3;
                                                    }
                                                    if (get.type(hs[i]) == "trick") map.trick += player.getUseValue(hs[i]);
                                                }
                                            }
                                            var type = get.type(cardx, "trick");
                                            if (!map[type]) return -get.value(cardx);
                                            return map[type] - get.value(cardx);
                                        })
                                    }
                                    next.logSkill = name;
                                    event.result = await next.forResult();
                                },
                                popup: false,
                                async content(event, trigger, player) {
                                    player.addTempSkill(event.name + '_effect');
                                    player.markAuto(event.name, [get.type2(event.cards[0])]);
                                },
                                subSkill: {
                                    effect: {
                                        init(player, skill) {
                                            player.storage[skill] = 0;
                                        },
                                        onremove(player, skill) {
                                            delete player.storage.minispyanyu;
                                            delete player.storage.minispyanyu_effect;
                                        },
                                        trigger: {
                                            global: ['loseAfter', 'cardsDiscardAfter', 'loseAsyncAfter', 'equipAfter'],
                                        },
                                        filter(event, player) {
                                            if (player.storage.minispyanyu_effect >= 2) return false;
                                            const evt = event.getParent('phaseUse');
                                            if (!evt || evt.name != 'phaseUse') return false;
                                            const type = player.getStorage('minispyanyu'),
                                                cards = event.getd();
                                            return cards.some(card => type.includes(get.type2(card)) && get.position(card, true) == 'd');
                                        },
                                        direct: true,
                                        async content(event, trigger, player) {
                                            const type = player.getStorage('minispyanyu');
                                            let cards = trigger.getd().filter(card => type.includes(get.type2(card)) && get.position(card, true) == 'd');
                                            while (cards.length && player.storage.minispyanyu_effect < 2) {
                                                const links = await player.chooseCardButton(cards, '【燕语】：是否将其中的一张牌交给一名角色？').set('ai', card => {
                                                    if (card.name == 'du') return 10;
                                                    return get.value(card);
                                                }).forResultLinks();
                                                if (!links || !links.length) return;
                                                player.storage.minispyanyu_effect++;
                                                if (!event.logged) {
                                                    await player.logSkill(event.name);
                                                    player.addExpose(0.25);
                                                    event.logged = true;
                                                }
                                                player.addExpose(0.25);
                                                const togain = links[0];
                                                cards.remove(togain);
                                                const targets = await player.chooseTarget(true, '请选择要获得' + get.translation(togain) + '的角色')
                                                    .set('ai', function (target) {
                                                        var att = get.attitude(_status.event.player, target);
                                                        var card = _status.event.card;
                                                        var val = get.value(card);
                                                        if (player.storage.minispyanyu_effect < 2 && target == _status.currentPhase && target.hasValueTarget(card, null, true)) att = att * 5;
                                                        else if (target == player && !player.hasJudge('lebu') && get.type(card) == 'trick') att = att * 3;
                                                        if (target.hasSkillTag('nogain')) att /= 10;
                                                        return att * val;
                                                    })
                                                    .set('card', togain).forResultTargets();
                                                if (!targets || !targets.length) return;
                                                const target = targets[0];
                                                player.line(target, 'green');
                                                await target.gain(togain, 'gain2');
                                            }
                                        },
                                    }
                                }
                            },
                            //胡金定
                            miniwuyuan: {
                                audio: 'dcwuyuan',
                                inherit: 'dcwuyuan',
                                async content(event, trigger, player) {
                                    const cards = event.cards, target = event.targets[0];
                                    await player.give(cards, target, 'give');
                                    await player.recover();
                                    let num = 1;
                                    if (get.natureList(cards[0]).length) num++;
                                    await player.draw('nodelay');
                                    await target.draw(num);
                                    if (get.color(cards[0]) == 'red') await target.recover();
                                    if (get.color(cards[0]) == 'black') {
                                        if (!target.countMark(event.name + '_buff')) {
                                            target.when({ player: 'phaseBegin' }).then(() => {
                                                let num = player.countMark('miniwuyuan_buff');
                                                player.removeSkill('miniwuyuan_buff');
                                                player.addTempSkill('miniwuyuan_sha');
                                                player.addMark('miniwuyuan_sha', num, false);
                                            });
                                        }
                                        target.addSkill(event.name + '_buff');
                                        target.addMark(event.name + '_buff', 1, false);
                                    }
                                },
                                subSkill: {
                                    buff: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: {
                                            content: '下回合使用【杀】的次数上限+#',
                                        },
                                    },
                                    sha: {
                                        charlotte: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + player.countMark('miniwuyuan_sha');
                                            },
                                        },
                                        onremove: true,
                                        intro: {
                                            content: '本回合使用【杀】的次数上限+#',
                                        },
                                    }
                                }
                            },
                            //邓芝
                            miniweimeng: {
                                audio: 'weimeng',
                                inherit: 'weimeng',
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    let num = player.getHp();
                                    if (player.getAllHistory('useSkill', evt => evt.skill == event.name)?.at(-2)?.[event.name + '_mark']) num++;
                                    const { result } = await player.gainPlayerCard(target, 'h', true, [1, num]);
                                    if (result.bool && target.isIn()) {
                                        const hs = player.getCards('he');
                                        if (!hs.length) return;
                                        const num1 = result.cards.reduce((sum, card) => sum + get.number(card, player), 0);
                                        const cards = await player.chooseToGive(target, true, Math.min(hs.length, result.cards.length), 'he').forResultCards();
                                        const num2 = cards.reduce((sum, card) => sum + get.number(card, player), 0);
                                        if (num2 > num1) await player.draw();
                                        else if (num2 < num1) {
                                            if (target.countDiscardableCards(player, 'hej')) await player.discardPlayerCard(target, true, 'hej');
                                        }
                                        else {
                                            const history = player.getAllHistory('useSkill', evt => evt.skill == event.name);
                                            history[history.length - 1][event.name + '_mark'] = true;
                                        }
                                    }
                                },
                            },
                            //马神
                            minifuman: {
                                audio: 'refuman',
                                inherit: 'refuman',
                                filterTarget(card, player, target) {
                                    if (target == player) return false;
                                    var stat = player.getStat('skill').minifuman_targets;
                                    return !stat || !stat.includes(target);
                                },
                                filter(event, player) {
                                    return player.countCards('he') > 0 && game.hasPlayer(current => lib.skill.minifuman.filterTarget(null, player, current));
                                },
                                position: 'he',
                                check(card) {
                                    return get.cardPile2(card => card.name == 'sha') ? 6 - get.value(card) : 0;
                                },
                                async content(event, trigger, player) {
                                    const { target } = event, card = get.cardPile2(card => card.name == 'sha');
                                    if (card) {
                                        const next = target.gain(card, 'gain2')
                                        next.gaintag.add(event.name);
                                        await next;
                                        player.addSkill(event.name + '_draw');
                                    }
                                    const stat = player.getStat('skill');
                                    if (!stat.minifuman_targets) stat.minifuman_targets = [];
                                    stat.minifuman_targets.push(target);
                                },
                                subSkill: {
                                    draw: {
                                        trigger: {
                                            global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'useCardAfter'],
                                        },
                                        getIndex(event, player) {
                                            if (event.name == 'useCard') {
                                                if (event.player.hasHistory('lose', evt => {
                                                    if (evt.getParent() != event) return false;
                                                    return Object.values(evt.gaintag_map).flat().includes('minifuman');
                                                }) && event.player.hasHistory('sourceDamage', evt => evt.card == event.card)) return [event.player];
                                            }
                                            else return game.filterPlayer(current => {
                                                if (current == player) return false;
                                                const evt = event.getl(current);
                                                if (!evt || !evt.hs || !evt.hs.length) return false;
                                                if (event.name == 'lose') {
                                                    return Object.values(event.gaintag_map).flat().includes('minifuman');
                                                }
                                                return current.hasHistory('lose', evt => {
                                                    if (event != evt.getParent()) return false;
                                                    return Object.values(evt.gaintag_map).flat().includes('minifuman');
                                                });
                                            }).sortBySeat();
                                        },
                                        charlotte: true,
                                        forced: true,
                                        logTarget(event, player, name, target) {
                                            return target;
                                        },
                                        async content(event, trigger, player) {
                                            if (trigger.name == 'useCard') await player.draw();
                                            else await game.asyncDraw([event.targets[0], player]);
                                        },
                                    }
                                }
                            },
                            //关羽
                            //加个忠义，彩蛋不删
                            miniweilin: {
                                audio: 'olsbweilin',
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    return get.inpileVCardList(info => {
                                        const name = info[2];
                                        if (name != 'sha' && name != 'jiu') return false;
                                        return get.type(name) == 'basic';
                                    }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]).some(card => {
                                        return player.hasCard(cardx => event.filterCard({ name: card[2], nature: card[3], cards: [cardx] }, player, event), 'hes');
                                    });
                                },
                                usable: 1,
                                chooseButton: {
                                    dialog(event, player) {
                                        const list = get.inpileVCardList(info => {
                                            const name = info[2];
                                            if (name != 'sha' && name != 'jiu') return false;
                                            return get.type(name) == 'basic';
                                        }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]).filter(card => {
                                            return player.hasCard(cardx => event.filterCard({ name: card[2], nature: card[3], cards: [cardx] }, player, event), 'hes');
                                        });
                                        return ui.create.dialog('威临', [list, 'vcard']);
                                    },
                                    filter(button, player) {
                                        return _status.event.getParent().filterCard({ name: button.link[2], nature: button.link[3] }, player, _status.event.getParent());
                                    },
                                    check(button) {
                                        if (_status.event.getParent().type != 'phase') return 1;
                                        const player = get.event('player'), value = player.getUseValue({ name: button.link[2], nature: button.link[3] });
                                        if (button.link[2] == 'sha' && !player.getHistory('useCard', evt => get.type(evt.card) == 'basic').length) {
                                            if (value > 0) return value + 20;
                                        }
                                        return value;
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: 'olsbweilin',
                                            filterCard: true,
                                            popname: true,
                                            check(card) {
                                                const name = lib.skill.miniweilin_backup.viewAs.name, color = get.color(card);
                                                const phase = (_status.event.getParent().type == 'phase');
                                                if (phase && name == 'sha' && color == 'red') return 10 - get.value(card);
                                                if (name == 'tao') return 7 + [-2, 0, 2][['black', 'red', 'none'].indexOf(color)] - get.value(card);
                                                return 6 - get.value(card);
                                            },
                                            position: 'hse',
                                            viewAs: { name: links[0][2], nature: links[0][3] },
                                            precontent() {
                                                player.addTempSkill('miniweilin_wusheng');
                                            },
                                            ai: {
                                                directHit_ai: true,
                                                skillTagFilter(player, tag, arg) {
                                                    if (get.event('skill') != 'miniweilin_backup') return false;
                                                    return arg?.card?.name == 'sha' && get.color(arg.card) == 'red';
                                                },
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        return '###威临###将一张牌当作' + (get.translation(links[0][3]) || '') + '【' + get.translation(links[0][2]) + '】使用';
                                    },
                                },
                                hiddenCard(player, name) {
                                    return ['sha', 'jiu', 'mini_zhong', 'mini_yi'].includes(name) && !player.getStat('skill').miniweilin && player.countCards('hes');
                                },
                                ai: {
                                    fireAttack: true,
                                    respondSha: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg == 'respond') return false;
                                        if (player.getStat('skill').miniweilin || !player.countCards('hes')) return false;
                                    },
                                    order(item, player) {
                                        if (player && _status.event.type == 'phase' && player.hasValueTarget({ name: 'sha' }, true, true)) {
                                            let max = 0, names = get.inpileVCardList(info => {
                                                const name = info[2];
                                                if (name != 'sha' && name != 'jiu') return false;
                                                return get.type(name) == 'basic';
                                            }).concat([['锦囊', '', 'mini_zhong'], ['锦囊', '', 'mini_yi']]);
                                            names = names.map(namex => { return { name: namex[2], nature: namex[3] } });
                                            names.forEach(card => {
                                                if (player.getUseValue(card) > 0) {
                                                    let temp = get.order(card);
                                                    if (card.name == 'jiu') {
                                                        let cards = player.getCards('hs', cardx => get.value(cardx) < 8);
                                                        cards.sort((a, b) => get.value(a) - get.value(b));
                                                        if (!cards.some(cardx => get.name(cardx) == 'sha' && !cards.slice(0, 2).includes(cardx))) temp = 0;
                                                    }
                                                    if (temp > max) max = temp;
                                                }
                                            });
                                            if (max > 0) max += 15;
                                            return max;
                                        }
                                        return 0.5;
                                    },
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                derivation: ['mini_zhong', 'mini_yi', 'shuiyanqijuny'],
                                group: 'miniweilin_gain',
                                global: 'miniweilin_zhong',
                                subfrequent: ['gain'],
                                subSkill: {
                                    wusheng: {
                                        charlotte: true,
                                        trigger: { global: 'useCardToBegin' },
                                        filter(event, player) {
                                            if (!event.target) return false;
                                            return event.skill === 'miniweilin_backup';
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            const { target } = trigger;
                                            target.addTempSkill('olsbweilin_wusheng');
                                            target.markAuto('olsbweilin_wusheng', [get.color(trigger.card)]);
                                        },
                                    },
                                    zhong: {
                                        sourceSkill: false,
                                        trigger: { global: 'damageBegin4' },
                                        filter(event, player) {
                                            if (event.player === player) return false;
                                            return player.hasUsableCard('mini_zhong');
                                        },
                                        direct: true,
                                        content() {
                                            event.mini_zhong = trigger;
                                            player.chooseToUse((card, player) => {
                                                if (get.name(card) != 'mini_zhong') return false;
                                                return lib.filter.cardEnabled(card, player, 'forceEnable');
                                            }, '是否使用【忠】，将即将对' + get.translation(trigger.player) + '造成的伤害转移给自己？');
                                        },
                                    },
                                    backup: {},
                                    gain: {
                                        audio: 'olsbweilin',
                                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                                        filter(event, player) {
                                            return (game.getAllGlobalHistory('everything', evt => {
                                                return ['useCard', 'respond'].includes(evt.name) && evt.player == player;
                                            }).indexOf(event) + 1) % 7 == 0;
                                        },
                                        frequent: true,
                                        prompt2: '获得一张【水淹七军】',
                                        content() {
                                            if (!_status.miniweilin_syqj || _status.miniweilin_syqj.length > 0) {
                                                if (!lib.inpile.includes('shuiyanqijuny')) lib.inpile.add('shuiyanqijuny');
                                                if (!_status.miniweilin_syqj) _status.miniweilin_syqj = lib.suit.slice(0);
                                                player.gain(game.createCard2('shuiyanqijuny', _status.miniweilin_syqj.randomRemove(), 7), 'gain2');
                                            }
                                            else {
                                                const card = get.cardPile('shuiyanqijuny');
                                                if (card) player.gain(card, 'gain2');
                                            }
                                        },
                                    },
                                },
                            },
                            miniduoshou: {
                                init(player) {
                                    if (player.getHistory('useCard', evt => get.color(evt.card) == 'red').length) player.addTempSkill('miniduoshou_used');
                                },
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (get.color(card) == 'red' && !player.hasSkill('miniduoshou_used')) return true;
                                    },
                                },
                                audio: 'olsbduoshou',
                                trigger: {
                                    player: ['useCard', 'useCardToPlayered'],
                                    source: 'damageSource',
                                },
                                filter(event, player, name) {
                                    if (event.name == 'damage') return player.getHistory('sourceDamage').indexOf(event) == 0 && event.player.isIn() && event.player.countGainableCards(player, event.player != player ? 'he' : 'e');
                                    if (name == 'useCardToPlayered') {
                                        if (event.card.name !== 'sha') return false;
                                        return player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event.getParent()) == 0;
                                    }
                                    if (get.color(event.card) == 'red' && !player.hasSkill('miniduoshou_used')) return true;
                                    return get.type(event.card) == 'basic' && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').indexOf(event) == 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    if (trigger.name == 'damage') player.gainPlayerCard(trigger.player, trigger.player != player ? 'he' : 'e', true);
                                    else if (event.triggername == 'useCardToPlayered') {
                                        player.line(trigger.target);
                                        player.draw(2);
                                    }
                                    else {
                                        if (get.color(trigger.card) == 'red' && !player.hasSkill('miniduoshou_used')) {
                                            game.log(trigger.card, '无距离限制');
                                            player.addTempSkill('miniduoshou_used');
                                        }
                                        if (get.type(trigger.card) == 'basic' && player.getHistory('useCard', evt => get.type(evt.card) == 'basic').indexOf(trigger) == 0) {
                                            game.log(trigger.card, '不计入次数上限');
                                            if (trigger.addCount !== false) {
                                                trigger.addCount = false;
                                                const stat = player.stat[player.stat.length - 1].card;
                                                if (typeof stat[trigger.card.name] === 'number') stat[trigger.card.name]--;
                                            }
                                        }
                                    }
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            //宗预
                            minichengshang: {
                                audio: 'chengshang',
                                trigger: {
                                    player: 'useCardAfter',
                                },
                                filter(event, player) {
                                    if (!lib.suit.includes(get.suit(event.card, false)) || typeof get.number(event.card) != 'number') return false;
                                    return player.isPhaseUsing();
                                },
                                usable: 1,
                                async content(event, trigger, player) {
                                    const suit = get.suit(trigger.card);
                                    const number = get.number(trigger.card);
                                    const cards = [];
                                    for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
                                        const card = ui.cardPile.childNodes[i];
                                        if (card.suit == suit && card.number == number) cards.push(card);
                                    }
                                    if (cards.length) {
                                        const next = player.gain(cards, 'gain2');
                                        next.gaintag.add(event.name + '_effect');
                                        await next;
                                        player.addTempSkill(event.name + '_effect');
                                    }
                                    else delete player.storage.counttrigger[event.name];
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove(player) {
                                            player.removeGaintag('minichengshang_effect');
                                        },
                                        mod: {
                                            ignoredHandcard(card, player) {
                                                if (card.hasGaintag('minichengshang_effect')) return true;
                                            },
                                            cardDiscardable(card, player, name) {
                                                if (name == 'phaseDiscard' && card.hasGaintag('minichengshang_effect')) return false;
                                            },
                                        },
                                    }
                                }
                            },
                            //谋黄月英
                            miniliuma: {
                                init(player) {
                                    if (!_status.miniliuma) _status.miniliuma = [];
                                    player.markSkill('miniliuma');
                                },
                                updateLiuma() {
                                    for (const i of game.players) {
                                        if (i.hasSkill('miniliuma')) i.markSkill('miniliuma');
                                    }
                                },
                                hiddenCard(player, name) {
                                    return _status.miniliuma?.some(card => card.name == name);
                                },
                                enable: ['chooseToUse', 'chooseToRespond'],
                                filter(event, player) {
                                    return _status.miniliuma?.some(card => event.filterCard(card, player, event));
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        return ui.create.dialog('流马', _status.miniliuma, 'hidden');
                                    },
                                    filter(button, player) {
                                        var evt = _status.event.getParent();
                                        if (evt?.filterCard) return evt.filterCard(button.link, player, evt);
                                        return true;
                                    },
                                    check(button) {
                                        if (get.event().getParent().type != 'phase') return 1;
                                        if (button.link.name == 'du') return 0;
                                        const player = get.player();
                                        if (player.getUseValue(button.link) > 0) return get.order(button.link);
                                        return -1;
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: 'miniliuma',
                                            filterCard: () => false,
                                            selectCard: -1,
                                            viewAs: links[0],
                                            onuse(result, player) {
                                                if (_status.miniliuma?.includes(result.cards[0])) {
                                                    _status.miniliuma.remove(result.cards[0]);
                                                    lib.skill.miniliuma.updateLiuma();
                                                }
                                            },
                                            onrespond() {
                                                return this.onuse.apply(this, arguments);
                                            },
                                            precontent() {
                                                const card = lib.skill.miniliuma_backup.viewAs;
                                                event.result.cards = [card];
                                                event.result.card.cards = [card];
                                            },
                                        }
                                    },
                                    prompt(links) {
                                        return '请选择' + get.translation(links) + '的目标';
                                    },
                                },
                                ai: {
                                    save: true,
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag) {
                                        return _status.miniliuma?.some(card => {
                                            switch (tag) {
                                                case 'respondSha': if (card.name == 'sha') return true; break;
                                                case 'respondShan': if (card.name == 'shan') return true; break;
                                                case 'save': {
                                                    if (card.name == 'tao' || card.name == 'spell_zhiliaoshui') return true;
                                                    if (player == _status.event.dying) {
                                                        if (card.name == 'jiu' || card.name == 'tianxianjiu') return true;
                                                    }
                                                    break;
                                                }
                                            }
                                        });
                                    },
                                    order(item, player) {
                                        if (_status.event.type != 'phase') return 4;
                                        if (!player || !_status.miniliuma?.some(card => player.getUseValue(card) > 0)) return 0;
                                        let cards = _status.miniliuma.filter(card => player.getUseValue(card) > 0);
                                        cards.sort((a, b) => get.order(b, player) - get.order(a, player));
                                        if (get.order(cards[0], player) <= 0) return 0;
                                        return get.order(cards[0], player) + 0.1;
                                    },
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                intro: {
                                    markcount: () => _status.miniliuma?.length,
                                    mark(dialog) {
                                        if (_status.miniliuma?.length) dialog.addAuto(_status.miniliuma);
                                        else return '“流马”区暂无卡牌';
                                    },
                                },
                                group: ['miniliuma_put', 'miniliuma_give'],
                                subSkill: {
                                    backup: {},
                                    put: {
                                        trigger: { player: 'phaseUseEnd' },
                                        filter(event, player) {
                                            if (!player.countCards('h') || !player.getHp()) return false;
                                            return _status.miniliuma.length < 5;
                                        },
                                        async cost(event, trigger, player) {
                                            const num = Math.min(player.getHp(), 5 - _status.miniliuma.length);
                                            event.result = await player.chooseCard(get.prompt('miniliuma'), [1, num], '将至多' + get.cnNumber(num) + '张牌置入“流马”区').set('ai', card => {
                                                return get.value(card) * get.useful(card);
                                            }).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            _status.miniliuma.addArray(event.cards);
                                            lib.skill.miniliuma.updateLiuma();
                                            player.$give(event.cards, player, false);
                                            await player.lose(event.cards, ui.special, 'visible');
                                            game.log(player, '将', event.cards, '置入了“流马”区');
                                        },
                                    },
                                    give: {
                                        trigger: { global: 'roundStart' },
                                        filter(event, player) {
                                            if (player.storage.miniliuma_give) return false;
                                            return !game.hasPlayer(target => target !== player && target.hasSkill('miniliuma', null, false, false));
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget(get.prompt('miniliuma'), '令一名其他角色获得【流马】（其不能发动此效果）', lib.filter.notMe).set('ai', target => {
                                                return get.attitude(get.player(), target);
                                            }).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            const target = event.targets[0];
                                            target.storage.miniliuma_give = true;
                                            await target.addSkills('miniliuma');
                                        },
                                    },
                                },
                            },
                            minisbjizhi: {
                                audio: 'sbjizhi',
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    return get.type2(event.card) == 'trick' && event.card.isCard;
                                },
                                forced: true,
                                preHidden: true,
                                async content(event, trigger, player) {
                                    player.draw();
                                },
                                ai: { noautowuxie: true },
                                mod: {
                                    targetInRange(card) {
                                        if (get.type2(card) === 'trick') return true;
                                    },
                                },
                            },
                            minisbqicai: {
                                audio: 'sbqicai',
                                mark: true,
                                marktext: '☯',
                                zhuanhuanji: true,
                                intro: {
                                    content(storage) {
                                        if (!storage) return '每回合限两次，当你使用普通锦囊牌时，你可以为此牌增加或减少一个目标';
                                        return '每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌';
                                    },
                                },
                                trigger: { player: 'useCard2' },
                                filter(event, player) {
                                    if (player.storage.minisbqicai || get.type(event.card) !== 'trick') return false;
                                    if (event.targets?.length > 0) return true;
                                    const info = get.info(event.card);
                                    if (info.allowMultiple == false) return false;
                                    if (event.targets && !info.multitarget) {
                                        if (game.hasPlayer(current => {
                                            return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                                        })) return true;
                                    }
                                    return false;
                                },
                                usable: 2,
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget(get.prompt('minisbqicai'), (card, player, target) => {
                                        const trigger = get.event().getTrigger();
                                        if (trigger.targets?.includes(target)) return true;
                                        return lib.filter.targetEnabled2(trigger.card, player, target) && lib.filter.targetInRange(trigger.card, player, target);
                                    }).set('prompt2', '为' + get.translation(trigger.card) + '增加或减少一个目标').set('ai', target => {
                                        const player = get.player(), trigger = get.event().getTrigger();
                                        return get.effect(target, trigger.card, player, player) * (trigger.targets?.includes(target) ? -1 : 1);
                                    }).forResult();
                                    if (event.result.bool && !event.isMine() && !event.isOnline()) await game.delayx();
                                },
                                async content(event, trigger, player) {
                                    player.changeZhuanhuanji('minisbqicai');
                                    if (trigger.targets.includes(event.targets[0])) trigger.targets.removeArray(event.targets);
                                    else trigger.targets.addArray(event.targets);
                                },
                                group: ['minisbqicai_gain', 'minisbqicai_change'],
                                subSkill: {
                                    gain: {
                                        audio: 'sbqicai',
                                        inherit: 'wechatjifeng',
                                        filter(event, player) {
                                            return player.storage.minisbqicai;
                                        },
                                        usable: 2,
                                        filterCard: { type: 'basic' },
                                        prompt: '弃置一张基本牌，然后从牌堆中获得一张锦囊牌',
                                        contentBefore() {
                                            player.changeZhuanhuanji('minisbqicai');
                                        },
                                    },
                                    change: {
                                        audio: 'sbqicai',
                                        trigger: {
                                            global: 'phaseBefore',
                                            player: 'enterGame',
                                        },
                                        filter(event, player) {
                                            return event.name != 'phase' || game.phaseNumber == 0;
                                        },
                                        prompt2(event, player) {
                                            return "切换【奇才】为状态" + (player.storage.minisbqicai ? '阳' : '阴');
                                        },
                                        check: () => Math.random() > 0.5,
                                        content() {
                                            player.changeZhuanhuanji('minisbqicai');
                                        },
                                    },
                                },
                            },
                            //谋姜维
                            miniranji: {
                                audio: 'olsbranji',
                                trigger: { player: 'phaseJieshuBegin' },
                                prompt2(event, player) {
                                    var str = '获得技能';
                                    var num = lib.skill.olsbranji.getNum(player);
                                    if (num >= player.getHp()) str += '【困奋】';
                                    if (num == player.getHp()) str += '和';
                                    if (num <= player.getHp()) str += '【诈降】';
                                    str += '，然后';
                                    var num1 = (player.countCards('h') - player.getHandcardLimit());
                                    if (num1 || player.isDamaged()) {
                                        if (num1) str += (num1 < 0 ? '摸' + get.cnNumber(-num1) + '张牌' : '弃置' + get.cnNumber(num1) + '张牌');
                                        if (num1 && player.isDamaged()) str += '并';
                                        if (player.isDamaged()) str += ('回复' + player.getDamagedHp() + '点体力');
                                        str += '，最后';
                                    }
                                    str += '你不能回复体力直到你杀死角色。';
                                    return str;
                                },
                                check(event, player) {
                                    var num = lib.skill.olsbranji.getNum(player);
                                    if (num == player.getHp()) return true;
                                    return player.getHandcardLimit() - player.countCards('h') >= 3 || player.getDamagedHp() >= 2;
                                },
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'fire',
                                *content(event, map) {
                                    var player = map.player;
                                    var trigger = map.trigger;
                                    player.awakenSkill('miniranji');
                                    var num = lib.skill.olsbranji.getNum(player);
                                    const skills = [];
                                    if (num >= player.getHp()) skills.push('minikunfen');
                                    if (num <= player.getHp()) skills.push('minisbzhaxiang');
                                    player.addSkills(skills);
                                    if (player.countCards('h') != player.getHandcardLimit() || player.isDamaged()) {
                                        var num1 = player.countCards('h') - player.getHandcardLimit();
                                        if (num1 !== 0) {
                                            if (num1 < 0) yield player.drawTo(player.getHandcardLimit());
                                            else yield player.chooseToDiscard(num1, 'h', true);
                                        }
                                        if (player.isDamaged()) yield player.recover(player.maxHp - player.hp);
                                    }
                                    player.addSkill('miniranji_norecover');
                                    player.when({ source: 'dieAfter' }).then(() => player.removeSkill('miniranji_norecover'));
                                },
                                derivation: ['minikunfen', 'minisbzhaxiang'],
                                subSkill: {
                                    norecover: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '不能回复体力' },
                                        trigger: { player: 'recoverBefore' },
                                        forced: true,
                                        firstDo: true,
                                        content() {
                                            trigger.cancel();
                                        },
                                        ai: {
                                            effect: {
                                                target(card, player, target) {
                                                    if (get.tag(card, 'recover')) return 'zeroplayertarget';
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //雷铜
                            minikuiji: {
                                audio: 'kuiji',
                                enable: "phaseUse",
                                filter(event, player) {
                                    if (player.hasJudge('bingliang')) return false;
                                    return player.countCards('hes', card => {
                                        return get.color(card) == 'black' && get.type(card) == 'basic';
                                    }) > 0;
                                },
                                position: 'hes',
                                discard: false,
                                lose: false,
                                delay: false,
                                prepare(cards, player) {
                                    player.$give(cards, player, false);
                                },
                                filterCard(card, player, event) {
                                    return get.color(card) == 'black' && get.type(card) == 'basic' && player.canAddJudge({ name: 'bingliang', cards: [card] });
                                },
                                selectTarget: -1,
                                filterTarget(card, player, target) {
                                    return player == target;
                                },
                                check(card) {
                                    return 9 - get.value(card);
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.addJudge({ name: 'bingliang' }, cards);
                                    player.draw(2);
                                    'step 1'
                                    var next = player.chooseTarget().set('ai', target => {
                                        let player = _status.event.player;
                                        if (target.hasSkillTag('filterDamage', null, {
                                            player: player
                                        }, true)) return get.damageEffect(target, player, player);
                                        return 2 * get.damageEffect(target, player, player);
                                    });
                                    next.set('prompt', '选择一名除你外体力值最大的角色，对其造成2点伤害');
                                    next.set('filterTarget', function (card, player, target) {
                                        return player != target && !game.hasPlayer(current => {
                                            return current != player && current.hp > target.hp;
                                        });
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        target.damage(2);
                                    }
                                },
                                ai: {
                                    result: {
                                        target(player, target) {
                                            let es;
                                            if (['identity', 'guozhan'].includes(get.mode())) es = game.hasPlayer(i => {
                                                return i != player && !game.hasPlayer(j => {
                                                    return player !== j && j.hp > i.hp;
                                                }) && get.attitude(player, i) < 0;
                                            });
                                            else es = game.hasPlayer(i => {
                                                return i.isEnemyOf(player) && !game.hasPlayer(j => {
                                                    return j.hp > i.hp && j.isEnemyOf(player);
                                                }) && get.attitude(player, i) < 0;
                                            });
                                            if (es) return 2;
                                            return -1.5;
                                        },
                                    },
                                    order: 12,
                                },
                                group: 'minikuiji_dying',
                                subSkill: {
                                    dying: {
                                        trigger: { global: 'dying' },
                                        filter(event, player) {
                                            if (!game.hasPlayer(target => target.isDamaged())) return false;
                                            let evt = event.getParent(2);
                                            return evt && evt.name == 'minikuiji';
                                        },
                                        locked: true,
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget('溃击：是否选择一名角色，令其回复1点体力？', (card, player, target) => {
                                                return target.isDamaged();
                                            }, true).set('ai', target => {
                                                return get.recoverEffect(target, player, _status.event.player);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                let target = result.targets[0];
                                                player.logSkill('minikuiji', target);
                                                target.recover();
                                            }
                                        },
                                    },
                                },
                            },
                            //吴兰
                            minicuorui: {
                                audio: 'wlcuorui',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(current => {
                                        return get.distance(player, current) <= 1 && current.countDiscardableCards(player, 'hej') > 0;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(function (card, player, target) {
                                        return get.distance(player, target) <= 1 && target.countDiscardableCards(player, 'hej') > 0;
                                    }, get.prompt2('minicuorui')).set('ai', function (target) {
                                        if (game.hasPlayer(current => {
                                            return current != target && get.attitude(_status.event.player, current) < 0;
                                        })) return get.effect(target, { name: 'guohe' }, player, player) + 10;
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minicuorui', target);
                                        player.discardPlayerCard(target, 'hej', true);
                                        event.goto(7);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (!result.cards || !result.cards.length) {
                                        event.finish();
                                        return;
                                    }
                                    var color = get.color(result.cards[0], result.cards[0].original == 'j' ? false : target);
                                    event.color = color;
                                    var list = [];
                                    if (game.hasPlayer(function (current) {
                                        return (get.mode() == 'versus' ? current.isEnemyOf(player) : current != player && current != target) && current.countCards('h');
                                    })) list.push('弃置手牌');
                                    if (game.hasPlayer(function (current) {
                                        return (get.mode() == 'versus' ? current.isEnemyOf(player) : current != player && current != target) && current.countCards('e', { color: color });
                                    })) list.push('弃置装备');
                                    if (!list.length) {
                                        event.finish();
                                        return;
                                    }
                                    if (list.length == 1) event._result = { control: list[0] };
                                    else player.chooseControl(list).set('prompt', '挫锐：展示对手的至多两张手牌，或弃置对手装备区内至多两张' + get.translation(color) + '牌').set('ai', function () {
                                        var player = _status.event.player;
                                        var color = _status.event.getParent().color;
                                        if (game.countPlayer(function (current) {
                                            if (!current.isEnemyOf(player)) return false;
                                            return current.countCards('e', function (card) {
                                                return get.color(card) == color && get.value(card) > 0;
                                            });
                                        }) > 1) return 1;
                                        return 0;
                                    });
                                    'step 3'
                                    if (result.control == '弃置装备') event.goto(5);
                                    else {
                                        var dialog = ['请选择要弃置的牌'];
                                        var list = game.filterPlayer(function (current) {
                                            return current.isEnemyOf(player) && current.countCards('h');
                                        }).sortBySeat();
                                        for (var i of list) {
                                            dialog.push('<div class="text center">' + get.translation(i) + '</div>');
                                            if (player.hasSkillTag('viewHandcard', null, i, true)) dialog.push(i.getCards('h'));
                                            else dialog.push([i.getCards('h'), 'blank']);
                                        }
                                        player.chooseButton([1, 2], true).set('createDialog', dialog).set('ai', function (button) {
                                            var color = (get.color(button.link) == _status.event.getParent().color);
                                            return color ? Math.random() : 0.35;
                                        });
                                    }
                                    'step 4'
                                    player.showCards(result.links);
                                    var map = {};
                                    var map2 = {};
                                    for (var i of result.links) {
                                        var id = get.owner(i).playerid;
                                        if (!map[id]) map[id] = [];
                                        map[id].push(i);
                                        if (get.color(i) != event.color) continue;
                                        if (!map2[id]) map2[id] = [];
                                        map2[id].push(i);
                                    }
                                    for (var i in map) {
                                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        if (map2[i]) player.gain(map2[i], source, 'bySelf', 'give');
                                        player.line(source);
                                        game.log(player, '展示了', source, '的', map[i]);
                                    }
                                    event.next.sort(function (a, b) {
                                        return lib.sort.seat(a.source || a.player, b.source || b.player);
                                    });
                                    event.finish();
                                    'step 5'
                                    var dialog = ['请选择要弃置的牌'];
                                    var list = game.filterPlayer(function (current) {
                                        return current.isEnemyOf(player) && current.countCards('e', function (card) {
                                            return get.color(card) == event.color;
                                        });
                                    }).sortBySeat();
                                    for (var i of list) {
                                        dialog.push('<div class="text center">' + get.translation(i) + '</div>');
                                        dialog.push(i.getCards('e', function (card) {
                                            return get.color(card) == event.color;
                                        }));
                                    }
                                    player.chooseButton([1, 2], true).set('createDialog', dialog).set('ai', function (button) {
                                        var owner = get.owner(button.link);
                                        return get.value(button.link, owner)
                                    });
                                    'step 6'
                                    var map = {};
                                    for (var i of result.links) {
                                        if (get.color(i) != event.color) continue;
                                        var id = get.owner(i).playerid;
                                        if (!map[id]) map[id] = [];
                                        map[id].push(i);
                                    }
                                    for (var i in map) {
                                        (_status.connectMode ? lib.playerOL : game.playerMap)[i].discard(map[i], 'notBySelf').discarder = player;
                                    }
                                    event.next.sort(function (a, b) {
                                        return lib.sort.seat(a.player, b.player);
                                    });
                                    event.finish();
                                    'step 7'
                                    if (!result.cards || !result.cards.length) {
                                        event.finish();
                                        return;
                                    }
                                    if (game.hasPlayer(current => {
                                        return current.countCards('he') > 0 && current != player && current != target;
                                    })) {
                                        var color = get.color(result.cards[0], result.cards[0].original == 'j' ? false : target);
                                        event.color = color;
                                        var next = player.chooseTarget(true, '挫锐：选择另一名其他角色', '弃置该角色装备区里至多两张' + get.translation(event.color) + '牌；或弃置该角色的至多两张手牌，然后获得其中的' + get.translation(event.color) + '牌');
                                        next.set('filterTarget', (card, player, target) => {
                                            return target.countCards('he') > 0 && target != player && target != _status.event.getParent().target;
                                        });
                                        next.set('ai', target => {
                                            return -get.attitude(_status.event.player, target) * target.countCards('he') + 0.1;
                                        });
                                    }
                                    else event.finish();
                                    'step 8'
                                    if (result.bool) {
                                        var targetx = result.targets[0];
                                        event.targetx = targetx;
                                        player.line(targetx);
                                        player.choosePlayerCard(targetx, 'he', true, [1, 2]).set('prompt', '弃置至多两张手牌，或弃置至多两张' + get.translation(event.color) + '装备').set('filterButton', button => {
                                            if (ui.selected.buttons.length) {
                                                var linkx = ui.selected.buttons[0].link;
                                                if (get.position(button.link) != get.position(linkx)) return false;
                                            }
                                            if (get.position(button.link) == 'e') return get.color(button.link, _status.event.target) == _status.event.getParent().color;
                                            return true;
                                        }).set('target', targetx);
                                    }
                                    else event.finish();
                                    'step 9'
                                    if (result.bool) {
                                        var cards = event.cards = result.links;
                                        event.targetx.discard(cards, 'notBySelf').discarder = player;
                                        if (get.position(cards[0]) == 'e') event.finish();
                                    }
                                    else event.finish();
                                    'step 10'
                                    var cards2 = cards.filter(card => {
                                        return get.color(card) == event.color;
                                    }).filterInD('d');
                                    if (cards2.length) player.gain(cards2, 'gain2');
                                },
                            },
                            //二赵
                            miniqingren: {
                                audio: 'dcqingren',
                                trigger: { player: 'phaseJieshuBegin' },
                                frequent: true,
                                filter(event, player) {
                                    return get.info('miniqingren').getNum(player);
                                },
                                getNum(player) {
                                    const filter = evt => get.type(evt.card) == 'basic' && !get.is.virtualCard(evt.card);
                                    return player.getHistory('useCard', filter).length + player.getHistory('respond', filter).length;
                                },
                                content() {
                                    player.draw(get.info(event.name).getNum(player));
                                },
                            },
                            //甘夫人糜夫人
                            minixunbie: {
                                audio: 'dcxunbie',
                                inherit: 'dcxunbie',
                                characters() {
                                    const characters = ['Mbaby_ganfuren', 'Mbaby_mifuren'];
                                    game.countPlayer(current => {
                                        if (get.nameList(current).includes('Mbaby_ganfuren')) characters.remove('Mbaby_ganfuren');
                                        if (get.nameList(current).includes('Mbaby_mifuren')) characters.remove('Mbaby_mifuren');
                                    });
                                    return characters;
                                },
                                filter(event, player) {
                                    if (player.hp > 0) return false;
                                    const characters = get.info('minixunbie').characters();
                                    return characters.length && [player.name1, player.name2].some(name => get.character(name, 3).includes('minixunbie'));
                                },
                                derivation: ['minishushen', 'minihuangsi', 'miniguixiu', 'minicunsi', 'miniyongjue'],
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    const characters = get.info(event.name).characters();
                                    const character = characters.length == 1 ? characters[0] : await player.chooseControl(characters).set('dialog', ['选择要替换成的武将', [characters, 'character']]).set('ai', () => [0, 1].randomGet()).forResultControl();
                                    if (!_status.characterlist) lib.skill.pingjian.initList();
                                    await player.reinitCharacter(get.character(player.name2, 3).includes(event.name) ? player.name2 : player.name1, character);
                                    await player.recoverTo(1);
                                    player.addTempSkill('dcxunbie_muteki');
                                },
                            },
                            //吴
                            //孙权
                            minizhiheng: {
                                audio: 'rezhiheng',
                                trigger: { player: 'phaseUseEnd' },
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard('h', get.prompt2('minizhiheng'), [1, Infinity]).set('ai', lib.skill.zhiheng.check).set('complexCard', true).logSkill = 'minizhiheng';
                                    'step 1'
                                    if (result.bool) player.drawTo(4);
                                },
                            },
                            minirezhiheng: {
                                audio: 'rezhiheng',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    var count = (player.getStat('skill').minirezhiheng || 0);
                                    return count < event.minirezhiheng_num && player.countDiscardableCards(player, 'he');
                                },
                                onChooseToUse(event) {
                                    if (event.type == 'phase' && !game.online && !event.minirezhiheng_num) {
                                        var evtx = event.getParent('phaseUse');
                                        var num = 1, player = event.player;
                                        var history = player.getHistory('gain', evt => evt.getParent('phaseUse') == evtx && evt.getParent(3).skill == 'minirezhiheng');
                                        if (history[0] && !history[0].cards.some(card => get.type(card) == 'delay')) num++;
                                        if (history[1] && !history[1].cards.some(card => get.type(card) != 'basic')) num++;
                                        event.set('minirezhiheng_num', num);
                                    }
                                },
                                filterCard: lib.filter.cardDiscardable,
                                selectCard: [1, Infinity],
                                check(card) {
                                    var player = _status.event.player;
                                    if (get.position(card) == 'h' && !player.countCards('h', 'du') && (player.hp > 2 || !player.countCards('h', function (card) {
                                        return get.value(card) >= 8;
                                    }))) return 1;
                                    return 6 - get.value(card);
                                },
                                position: 'he',
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    'step 0'
                                    var num = 1, hs = player.getCards('h');
                                    if (!hs.length || hs.some(i => !cards.includes(i))) num = 0;
                                    event.num = num;
                                    player.discard(cards);
                                    'step 1'
                                    player.draw(num + cards.length);
                                },
                                ai: {
                                    order: 1,
                                    result: { player: 1 },
                                },
                            },
                            minijiuyuan: {
                                group: 'minijiuyuan_tao',
                                audio: 'rejiuyuan',
                                trigger: { global: 'recoverBefore' },
                                filter(event, player) {
                                    if (player == event.player || player.isHealthy() || !_status.currentPhase || _status.currentPhase != event.player) return false;
                                    return event.player.group == 'wu' && event.getParent().name != 'minijiuyuan' && player.hasZhuSkill('minijiuyuan', event.player);
                                },
                                direct: true,
                                zhuSkill: true,
                                content() {
                                    'step 0'
                                    trigger.player.chooseBool('是否对' + get.translation(player) + '发动【救援】？', '改为令其回复1点体力，然后你摸一张牌').set('ai', function () {
                                        var evt = _status.event;
                                        return get.attitude(evt.player, evt.getParent().player) > 0 && evt.getParent().player.hp <= evt.player.hp && !evt.player.isDying();
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minijiuyuan');
                                        trigger.player.line(player, 'green');
                                        trigger.cancel();
                                        player.recover();
                                        trigger.player.draw();
                                    }
                                },
                                subSkill: {
                                    tao: {
                                        audio: 'rejiuyuan',
                                        trigger: { target: 'taoBegin' },
                                        filter(event, player) {
                                            if (!player.hasZhuSkill('minijiuyuan', event.player)) return false;
                                            return event.player != player && event.player.group == 'wu';
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            trigger.baseDamage++;
                                        },
                                    },
                                },
                            },
                            miniqixi: {
                                group: 'qixi',
                                audio: 'qixi',
                                audioname: ['heqi'],
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        return target.countDiscardableCards(player, 'hej');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniqixi'), '弃置一名角色区域里的一张牌', function (card, player, target) {
                                        return target.countDiscardableCards(player, 'hej');
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.effect(target, { name: 'guohe' }, player, player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniqixi', result.targets);
                                        player.discardPlayerCard(result.targets[0], 'hej', true);
                                    }
                                },
                            },
                            minifenwei: {
                                audio: 'fenwei',
                                audioname: ['heqi'],
                                skillAnimation: true,
                                animationColor: 'wood',
                                unique: true,
                                mark: true,
                                limited: true,
                                trigger: { global: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (event.getParent().triggeredTargets3.length > 1) return false;
                                    if (get.type(event.card) != 'trick') return false;
                                    if (get.info(event.card).multitarget) return false;
                                    if (event.targets.length < 2) return false;
                                    return true;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minifenwei'), '令' + get.translation(trigger.card) + '对任意名角色无效', [1, trigger.targets.length], function (card, player, target) {
                                        return _status.event.targets.includes(target);
                                    }).set('ai', function (target) {
                                        var trigger = _status.event.getTrigger();
                                        return -get.effect(target, trigger.card, trigger.player, _status.event.player);
                                    }).set('targets', trigger.targets);
                                    'step 1'
                                    if (result.bool) {
                                        player.addSkill('minifenwei_huifu');
                                        player.logSkill('minifenwei', result.targets);
                                        player.awakenSkill('minifenwei');
                                        trigger.getParent().excluded.addArray(result.targets);
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.draw();
                                },
                                ai: { expose: 0.2 },
                                subSkill: {
                                    huifu: {
                                        charlotte: true,
                                        trigger: {
                                            player: 'loseAfter',
                                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                        },
                                        filter(event, player) {
                                            if (player.countCards('h')) return false;
                                            if (!player.awakenedSkills.includes('minifenwei')) return false;
                                            var evt = event.getl(player);
                                            return evt?.player == player && evt?.hs?.length > 0;
                                        },
                                        direct: true,
                                        firstDo: true,
                                        content() {
                                            player.removeSkill('minifenwei_huifu');
                                            player.restoreSkill('minifenwei');
                                            game.log(player, '复原了技能', '#g【奋威】');
                                        },
                                    },
                                },
                            },
                            miniwanrong: {
                                audio: 'reguose',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    if (event.name == 'gain' && event.player == player) return false;
                                    return event.getl?.(player)?.cards2?.some(card => get.suit(card, player) === 'diamond');
                                },
                                forced: true,
                                locked: true,
                                content() {
                                    player.draw();
                                },
                            },
                            miniguose: {
                                audio: ['wanrong1.mp3', 'wanrong2.mp3'],
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('hes', { suit: 'diamond' }) > 0;
                                },
                                filterTarget(card, player, target) {
                                    if (get.position(ui.selected.cards[0]) != 's' && lib.filter.cardDiscardable(ui.selected.cards[0], player, 'reguose') && target.hasJudge('lebu')) return true;
                                    if (player == target) return false;
                                    if (!game.checkMod(ui.selected.cards[0], player, 'unchanged', 'cardEnabled2', player)) return false;
                                    return player.canUse({ name: 'lebu', cards: ui.selected.cards }, target);
                                },
                                filterCard: { suit: 'diamond' },
                                position: 'hes',
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                usable: 1,
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    if (target.hasJudge('lebu')) {
                                        player.discard(cards);
                                        target.discard(target.getJudge('lebu'));
                                    }
                                    else player.useCard({ name: 'lebu' }, target, cards).audio = false;
                                },
                                ai: {
                                    result: {
                                        target(player, target) {
                                            if (target.hasJudge('lebu')) return -get.effect(target, { name: 'lebu' }, player, target);
                                            return get.effect(target, { name: 'lebu' }, player, target);
                                        },
                                    },
                                    order: 9,
                                },
                            },
                            minizhaxiang: {
                                mod: {
                                    targetInRange(card, player, target, now) {
                                        if (card.name == 'sha' && get.color(card) == 'red') return true;
                                    },
                                    cardUsable(card, player, num) {
                                        if (card.name == 'sha') return num + 1;
                                    }
                                },
                                audio: 'zhaxiang',
                                trigger: { player: 'useCard' },
                                forced: true,
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && get.color(event.card) == 'red';
                                },
                                content() {
                                    trigger.directHit.addArray(game.players);
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        return arg.card.name == 'sha' && get.color(arg.card) == 'red';
                                    },
                                },
                            },
                            minifanjian: {
                                audio: 'refanjian',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minifanjian'), lib.filter.notMe).ai = function (target) {
                                        return get.damageEffect(target, player, player);
                                    };
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minifanjian', target);
                                        target.draw();
                                        target.damage();
                                    }
                                },
                            },
                            minireyingzi: {
                                audio: 'reyingzi',
                                audioname: ['sunce', 're_sunyi'],
                                audioname2: { Mbaby_zhouyu: 'sbyingzi' },
                                trigger: { player: 'phaseDrawBegin2' },
                                filter(event, player) {
                                    return !event.numFixed && lib.skill.sbyingzi.getNum(player) > 0;
                                },
                                forced: true,
                                content() {
                                    trigger.num += lib.skill.sbyingzi.getNum(player);
                                },
                                ai: { threaten: 2 },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + lib.skill.sbyingzi.getNum(player);
                                    },
                                },
                            },
                            minirefanjian: {
                                audio: 'sbfanjian',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                usable: 1,
                                chooseButton: {
                                    dialog(event, player) {
                                        return ui.create.dialog(
                                            '###反间###<div class="text center">' + lib.translate.minirefanjian_info + '</div>',
                                            [lib.suit.slice().reverse().map(i => ['', '', 'lukai_' + i]), 'vcard'], 'hidden');
                                    },
                                    filter(button, player) {
                                        return player.hasCard(card => get.suit(card, player) == button.link[2].slice(6), 'h');
                                    },
                                    check: () => 1 + Math.random(),
                                    backup(links, player) {
                                        return {
                                            audio: 'sbfanjian',
                                            suit: links.map(i => i[2].slice(6))[0],
                                            filterTarget: lib.filter.notMe,
                                            async content(event, trigger, player) {
                                                const playerSuit = lib.skill.minirefanjian_backup.suit, target = event.target;
                                                player.popup(playerSuit);
                                                game.log(player, '选择了', '#g' + get.translation(playerSuit));
                                                const str = [get.translation(player), get.translation(playerSuit)];
                                                const targetSuit = await target.chooseControl(lib.suit.slice().reverse()).set('prompt', '反间：请选择一个花色').set('ai', () => {
                                                    const player = get.event('player'), target = get.event().getParent().player, suit = get.event('suit');
                                                    let players = game.filterPlayer(current => get.damageEffect(current, target, target) > 0);
                                                    if (!players.length || (players.length == 1 && players.includes(player))) return suit;
                                                    const drawEffect = get.effect(player, { name: 'draw' }, player, player);
                                                    players.sort((a, b) => get.damageEffect(b, target, target) - get.damageEffect(a, target, target) - (b == player ? drawEffect : 0) + (a == player ? drawEffect : 0));
                                                    return players[0] != player ? suit : lib.suit.filter(i => i != suit).randomGet();
                                                }).set('suit', playerSuit).set('prompt2', '若你选择的花色为' + str[1] + '，你摸一张牌并受到' + str + '对你造成1点伤害，否则' + str[0] + '对一名角色造成1点伤害').forResult('control');
                                                player.$compare(game.createCard('lukai_' + playerSuit, '', ''), target, game.createCard('lukai_' + targetSuit, '', ''));
                                                await game.asyncDelay(0, 1500);
                                                target.popup(targetSuit);
                                                game.log(target, '选择了', '#g' + get.translation(targetSuit));
                                                await game.asyncDelay(2);
                                                if (playerSuit == targetSuit) {
                                                    player.line(target);
                                                    await target.draw();
                                                    await target.damage();
                                                }
                                                else {
                                                    const aim = await player.chooseTarget('反间：对一名角色造成1点伤害', true).set('ai', target => {
                                                        return get.damageEffect(target, get.event('player'), get.event('player'));
                                                    }).forResult('targets');
                                                    if (aim) {
                                                        player.line(aim[0]);
                                                        await aim[0].damage();
                                                    }
                                                }
                                            },
                                            ai: {
                                                result: {
                                                    target(player, target) {
                                                        return get.damageEffect(target, player, player) * get.sgn(get.sgn(get.attitude(player, target)) - 0.5);
                                                    },
                                                },
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        const suit = get.translation(links.map(i => i[2].slice(6))[0]);
                                        return '###反间###令一名其他角色选择一个花色，若其选择的为' + suit + '，你令其摸一张牌并对其造成1点伤害，否则你对一名角色造成1点伤害';
                                    },
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player) {
                                            return game.countPlayer(target => get.damageEffect(target, player, player) > 0);
                                        },
                                    },
                                },
                                subSkill: { backup: {} },
                            },
                            miniqianxun: {
                                audio: 'reqianxun',
                                trigger: { target: 'useCardToBegin' },
                                filter(event, player) {
                                    if (event.targets && event.targets.length > 1) return false;
                                    return event.card && (get.type(event.card) == 'trick' || get.type(event.card) == 'delay');
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    player.draw();
                                    player.chooseCardTarget({
                                        prompt: '谦逊：是否将一张手牌交给一名其他角色？',
                                        filterCard: true,
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            if (card.name == 'du') return 10;
                                            var player = _status.event.player;
                                            if (!game.hasPlayer(function (current) {
                                                return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                            })) return 0;
                                            return 1 / Math.max(0.1, get.value(card));
                                        },
                                        ai2(target) {
                                            var player = _status.event.player, att = get.attitude(player, target);
                                            if (ui.selected.cards[0].name == 'du') return -att;
                                            if (target.hasSkillTag('nogain')) att /= 6;
                                            return att;
                                        },
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.line(result.targets[0]);
                                        result.targets[0].gain(result.cards, player, 'giveAuto');
                                    }
                                },
                            },
                            minireqianxun: {
                                audio: 'reqianxun',
                                trigger: { target: 'useCardToBegin', player: 'judgeBefore' },
                                filter(event, player) {
                                    if (!player.countCards('h') || !player.getHp()) return false;
                                    if (event.name == 'judge') return event.getParent().name == 'phaseJudge';
                                    if (event.card && get.type(event.card) == 'trick') return true;
                                },
                                direct: true,
                                *content(event, map) {
                                    var player = map.player;
                                    var num = Math.min(player.countCards('h'), player.getHp());
                                    var result = yield player.chooseCard(get.prompt('minireqianxun'), '将至多' + get.cnNumber(num) + '张手牌置于武将牌上', [1, num]).set('ai', card => 1 / (get.value(card) || 0.5));
                                    if (result.bool) {
                                        var cards = result.cards;
                                        player.logSkill('minireqianxun');
                                        player.addSkill('minireqianxun2');
                                        player.addToExpansion(cards, 'giveAuto', player).gaintag.add('minireqianxun2');
                                    }
                                },
                                ai: {
                                    effect(card, player, target) {
                                        if (!target.hasFriend()) return;
                                        var type = get.type(card);
                                        var nh = Math.min(target.countCards(), game.countPlayer(i => get.attitude(target, i) > 0));
                                        if (type == 'trick') {
                                            if (!get.tag(card, 'multitarget') || get.info(card).singleCard) {
                                                if (get.tag(card, 'damage')) return [1.5, nh - 1];
                                                return [1, nh];
                                            }
                                        }
                                        else if (type == 'delay') return [0.5, 0.5];
                                    },
                                },
                            },
                            minireqianxun2: {
                                charlotte: true,
                                audio: 'reqianxun',
                                trigger: { global: 'phaseEnd' },
                                forced: true,
                                content() {
                                    var cards = player.getExpansions('minireqianxun2');
                                    if (cards.length) player.gain(cards, 'draw');
                                    player.removeSkill('minireqianxun2');
                                },
                                intro: {
                                    mark(dialog, storage, player) {
                                        var cards = player.getExpansions('minireqianxun2');
                                        if (player.isUnderControl(true)) dialog.addAuto(cards);
                                        else return '共有' + get.cnNumber(cards.length) + '张牌';
                                    },
                                    markcount: 'expansion',
                                },
                            },
                            minilianying: {
                                audio: 'relianying',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    if (player.countCards('h')) return false;
                                    var evt = event.getl(player);
                                    return evt?.hs?.length;
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.draw(2);
                                    player.chooseCardTarget({
                                        prompt: '连营：是否将一张手牌交给一名其他角色？',
                                        filterCard: true,
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            if (card.name == 'du') return 10;
                                            var player = _status.event.player;
                                            if (!game.hasPlayer(function (current) {
                                                return get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                            })) return 0;
                                            return 1 / Math.max(0.1, get.value(card));
                                        },
                                        ai2(target) {
                                            var player = _status.event.player, att = get.attitude(player, target);
                                            if (ui.selected.cards[0].name == 'du') return -att;
                                            if (target.hasSkillTag('nogain')) att /= 6;
                                            return att;
                                        },
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.line(result.targets[0]);
                                        result.targets[0].gain(result.cards, player, 'giveAuto');
                                    }
                                },
                                ai: {
                                    threaten: 0.8,
                                    effect: {
                                        target(card) {
                                            if (card.name == 'guohe' || card.name == 'liuxinghuoyu') return 0.5;
                                        },
                                    },
                                    noh: true,
                                },
                            },
                            minitianyi: {
                                audio: 'tianyi',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseControl('选项一', '选项二', 'cancel2').set('choiceList', [
                                        '本回合使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力',
                                        '摸一张牌，本回合使用【杀】无距离限制且无视防具'
                                    ]).set('ai', () => {
                                        if ((player.countCards('h', card => {
                                            return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                                        }) - player.getCardUsable('sha')) > 1) return 0;
                                        return 1;
                                    }).set('prompt', get.prompt('minitianyi'));
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minitianyi');
                                        if (result.index == 1) player.draw();
                                        player.addTempSkill('minitianyi_' + result.index);
                                    }
                                },
                                subSkill: {
                                    '0': {
                                        charlotte: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + 1;
                                            },
                                        },
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return player.isDamaged() && event.card && event.card.name == 'sha';
                                        },
                                        direct: true,
                                        content() {
                                            player.recover();
                                        },
                                        mark: true,
                                        intro: { content: '使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力' },
                                    },
                                    '1': {
                                        charlotte: true,
                                        mod: {
                                            targetInRange(card, player, target, now) {
                                                if (card.name == 'sha') return true;
                                            },
                                        },
                                        ai: {
                                            unequip: true,
                                            unequip_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                return arg?.name == 'sha';
                                            },
                                        },
                                        mark: true,
                                        intro: { content: '使用【杀】无距离限制且无视防具' },
                                    },
                                },
                            },
                            miniretianyi: {
                                audio: 'tianyi',
                                audioname: ['re_taishici'],
                                trigger: { player: ['phaseUseBegin', 'useCardToPlayer'] },
                                filter(event, player) {
                                    return event.name == 'phaseUse' || (event.card.name == 'sha' && player.canCompare(event.target));
                                },
                                async cost(event, trigger, player) {
                                    if (trigger.name == 'phaseUse') {
                                        const { result: { bool, links } } = await player.chooseButton([
                                            get.prompt(event.name.slice(0, -5)),
                                            [
                                                [
                                                    ['add', '本回合使用【杀】的次数上限+1'],
                                                    ['recover', `本回合使用【杀】造成伤害后回复1点体力`],
                                                    ['draw', `摸一张牌`],
                                                    ['range', `本回合使用【杀】无距离限制且无视目标角色的防具`],
                                                ],
                                                'textbutton',
                                            ],
                                        ]).set('ai', button => {
                                            const { link } = button, player = get.player();
                                            if (link == 'add' && (player.countCards('h', card => {
                                                return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                                            }) - player.getCardUsable('sha')) > 1) return 2;
                                            if (link == 'recover' && player.isHealthy()) return 0;
                                            if (link == 'range' && game.hasPlayer(current => player.canUse({ name: 'sha' }, current, true) && get.effect(current, { name: 'sha' }, player, player) > 0)) return 0;
                                            return 1;
                                        }).set('selectButton', 2);
                                        event.result = {
                                            bool: bool,
                                            cost_data: links,
                                        }
                                    }
                                    else {
                                        const { target, card } = trigger;
                                        const bool = await player.chooseBool(get.prompt(event.name.slice(0, -5), target), `你可以与其拼点，若你赢，你可以为${get.translation(card)}额外指定一个目标`).set('choice', get.attitude(player, target) <= 0).forResultBool();
                                        event.result = {
                                            bool: bool,
                                            targets: [target],
                                        }
                                    }
                                },
                                async content(event, trigger, player) {
                                    const { cost_data: choices } = event, { target, card } = trigger;
                                    if (trigger.name == 'phaseUse') {
                                        if (choices.includes('add')) {
                                            game.log(player, '选择了', '#y选项一');
                                            player.addTempSkill(event.name + '_add');
                                            player.addMark(event.name + '_add', 1, false);
                                        }
                                        if (choices.includes('recover')) {
                                            game.log(player, '选择了', '#y选项二');
                                            player.addTempSkill(event.name + '_recover');
                                        }
                                        if (choices.includes('draw')) {
                                            game.log(player, '选择了', '#y选项三');
                                            await player.draw();
                                        }
                                        if (choices.includes('range')) {
                                            game.log(player, '选择了', '#y选项四');
                                            player.addTempSkill(event.name + '_range');
                                        }
                                    }
                                    else {
                                        const bool = await player.chooseToCompare(target).forResultBool();
                                        if (!bool || !game.hasPlayer(current => !trigger.targets.includes(current) && lib.filter.targetEnabled2(card, player, current))) return;
                                        const { result } = await player.chooseTarget(get.prompt(event.name), '为' + get.translation(card) + '增加一个目标', (card, player, target) => {
                                            const evt = _status.event.getTrigger();
                                            return !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target);
                                        }).set('ai', target => {
                                            const evt = _status.event.getTrigger();
                                            return get.effect(target, evt.card, evt.player, evt.player);
                                        });
                                        if (!result.bool) return;
                                        if (player != game.me && !player.isOnline()) await game.delayx();
                                        trigger.targets.push(result.targets[0]);
                                        game.log(result.targets[0], '成为了', card, '的额外目标');
                                    }
                                },
                                subSkill: {
                                    add: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + player.countMark('miniretianyi_add');
                                            },
                                        },
                                        intro: { content: '使用【杀】的次数上限+#' },
                                    },
                                    recover: {
                                        charlotte: true,
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return player.isDamaged() && event.card?.name == 'sha';
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.recover();
                                        },
                                        mark: true,
                                        intro: { content: '使用【杀】造成伤害后回复1点体力' },
                                    },
                                    range: {
                                        charlotte: true,
                                        mod: {
                                            targetInRange(card, player, target, now) {
                                                if (card.name == 'sha') return true;
                                            },
                                        },
                                        mark: true,
                                        intro: { content: '使用【杀】无距离限制且无视防具' },
                                    },
                                },
                            },
                            minihanzhan: {
                                audio: 'hanzhan',
                                inherit: 'hanzhan',
                                group: 'minihanzhan_gain',
                                subSkill: {
                                    gain: {
                                        audio: 'hanzhan',
                                        getCards(event) {
                                            const cards = [];
                                            for (const i of event.lose_list) {
                                                if (Array.isArray(i[1])) {
                                                    for (const j of i[1]) {
                                                        if (get.name(j, i[0]) == 'sha' && get.position(j, true) == 'o') cards.push(j)
                                                    }
                                                } else {
                                                    const j = i[1];
                                                    if (get.name(j, i[0]) == 'sha' && get.position(j, true) == 'o') cards.push(j)
                                                }
                                            }
                                            return cards;
                                        },
                                        trigger: { global: 'chooseToCompareAfter' },
                                        filter(event, player) {
                                            if (event.preserve) return false;
                                            if (player != event.player && player != event.target && (!event.targets || !event.targets.includes(player))) return false;
                                            return get.info('minihanzhan_gain').getCards(event).length;
                                        },
                                        frequent: true,
                                        prompt2(event, player) {
                                            const cards = get.info('minihanzhan_gain').getCards(event);
                                            return '获得' + get.translation(cards);
                                        },
                                        async content(event, trigger, player) {
                                            await player.gain(get.info(event.name).getCards(trigger), 'gain2');
                                        },
                                    }
                                }
                            },
                            //鲁肃
                            minihaoshi: {
                                audio: 'haoshi',
                                trigger: { player: 'phaseDrawBegin2' },
                                filter(event, player) {
                                    return !event.numFixed;
                                },
                                preHidden: true,
                                check(event, player) {
                                    if (player.countCards('h') <= 1) return true;
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.isMinHandcard() && get.attitude(player, current) > 0;
                                    });
                                },
                                content() {
                                    trigger.num += 2;
                                    player.addSkill('minihaoshi2');
                                },
                                ai: {
                                    noh: true,
                                    skillTagFilter(player, tag) {
                                        if (tag == 'noh') {
                                            if (player.countCards('h') != 2) return false;
                                        }
                                    },
                                },
                            },
                            minihaoshi2: {
                                trigger: { player: 'phaseDrawEnd' },
                                forced: true,
                                popup: false,
                                audio: false,
                                content() {
                                    'step 0'
                                    player.removeSkill('minihaoshi2');
                                    if (player.countCards('h') <= 5) {
                                        event.finish();
                                        return;
                                    }
                                    else player.chooseCardTarget({
                                        selectCard: Math.floor(player.countCards('h') / 2),
                                        filterTarget(card, player, target) {
                                            return target.isMinHandcard();
                                        },
                                        selectTarget: [0, 1],
                                        prompt: '好施：将一半的手牌交给场上手牌数最少的一名角色或弃置一半的手牌',
                                        forced: true,
                                        ai2(target) {
                                            return get.attitude(_status.event.player, target);
                                        }
                                    });
                                    'step 1'
                                    if (result.targets && result.targets[0]) result.targets[0].gain(result.cards, player, 'giveAuto');
                                    else player.discard(result.cards);
                                },
                            },
                            miniolhaoshi: {
                                audio: 'olhaoshi',
                                inherit: 'olhaoshi',
                                forced: true,
                                locked: false,
                                async content(event, trigger, player) {
                                    trigger.num += 2;
                                },
                                group: 'miniolhaoshi_give',
                                subSkill: {
                                    give: {
                                        audio: 'olhaoshi',
                                        trigger: { player: 'phaseDrawEnd' },
                                        filter(event, player) {
                                            return player.countCards("h") > 5;
                                        },
                                        async cost(event, trigger, player) {
                                            const num = Math.floor(player.countCards("h") / 2);
                                            event.result = await player.chooseCardTarget({
                                                prompt: '好施：是否将' + get.cnNumber(num) + '张手牌交给一名其他角色？',
                                                filterCard: true,
                                                selectCard: num,
                                                position: 'h',
                                                filterTarget: lib.filter.notMe,
                                                ai1(card) {
                                                    const player = get.player();
                                                    if (goon = game.hasPlayer(target => {
                                                        if (target === player) return false;
                                                        return get.attitude(player, target) > 0 && get.attitude(target, player) > 0;
                                                    })) {
                                                        if (!player.hasValueTarget(card) || (card.name == "sha" && player.countCards("h", cardx => {
                                                            return cardx.name == "sha" && !ui.selected.cards.includes(cardx);
                                                        }) > player.getCardUsable("sha"))) return 2;
                                                        return Math.max(2, get.value(card) / 4);
                                                    }
                                                    return 1 / Math.max(1, get.value(card));
                                                },
                                                ai2(target) {
                                                    const player = get.player();
                                                    return get.attitude(player, target);
                                                },
                                            }).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            const target = event.targets[0], cards = event.cards;
                                            player.line(target, 'green');
                                            await player.give(cards, target);
                                            player.markAuto('olhaoshi_help', [target]);
                                            player.addTempSkill('olhaoshi_help', { player: 'phaseBeginStart' });
                                        },
                                    }
                                }
                            },
                            minidimeng: {
                                audio: 'oldimeng',
                                inherit: 'oldimeng',
                                filter(event, player) {
                                    if (player.hasMark('minidimeng')) return false;
                                    return game.hasPlayer(current => lib.skill.minidimeng.filterTarget(null, player, current));
                                },
                                filterTarget(card, player, target) {
                                    if (!ui.selected.targets.length) {
                                        return game.hasPlayer(current => {
                                            if (current == target) return false;
                                            return target.countCards('h') + current.countCards('h') > 0;
                                        });
                                    }
                                    return ui.selected.targets[0].countCards('h') + target.countCards('h') > 0;
                                },
                                async content(event, trigger, player) {
                                    const targets = event.targets;
                                    targets[0].swapHandcards(targets[1]);
                                    const num = Math.abs(targets[0].countCards('h') - targets[1].countCards('h'));
                                    if (num > 0) player.addMark(event.name, num);
                                },
                                marktext: '盟',
                                intro: {
                                    name2: '盟',
                                    content: 'mark',
                                },
                                group: 'minidimeng_discard',
                                subSkill: {
                                    discard: {
                                        trigger: { player: ['phaseDrawEnd', 'phaseEnd'] },
                                        filter(event, player) {
                                            if (!player.hasMark('minidimeng')) return false;
                                            return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'he');
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseToDiscard('he', get.prompt('minidimeng'), '弃置任意张牌并移除等量的“盟”标记', [1, player.countMark('minidimeng')]).set('ai', card => {
                                                const player = get.player();
                                                if (player.countCards('h') < 3) return 0;
                                                if (['haoshi', 'olhaoshi'].some(skill => player.hasSkill(skill)) && !game.hasPlayer(current => current != player && get.attitude(player, current) > 0 && current.isMinHandcard())) return 0;
                                                return 6 - get.value(card);
                                            }).set('logSkill', 'minidimeng').forResult();
                                        },
                                        popup: false,
                                        async content(event, trigger, player) {
                                            player.removeMark('minidimeng', event.cards.length);
                                        },
                                    }
                                }
                            },
                            miniganlu: {
                                moveCheck(player, target) {
                                    if (target == player) return false;
                                    return player.countCards('e', card => {
                                        return target.countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && player.canEquip(cardx, true) && target.canEquip(card, true));
                                    });
                                },
                                audio: 'ganlu',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var list = [];
                                    if (player.canMoveCard(null, true)) list.push('移动牌');
                                    if (game.hasPlayer(current1 => {
                                        return game.hasPlayer(current2 => lib.skill.miniganlu.moveCheck(current1, current2));
                                    })) list.push('交换牌');
                                    list.push('摸牌');
                                    list.push('cancel2');
                                    player.chooseControl(list).set('choiceList', [
                                        '移动场上的一张装备牌',
                                        '交换场上装备区中两张副类别相同的装备牌的位置',
                                        '摸一张牌',
                                    ]).set('prompt', '请选择你要执行的选项').set('ai', function () {
                                        var player = _status.event.player;
                                        if (player.canMoveCard(true, true)) return '移动牌';
                                        return '摸牌';
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        switch (result.control) {
                                            case '摸牌':
                                                player.logSkill('miniganlu');
                                                player.draw();
                                                event.finish();
                                                break;
                                            case '移动牌':
                                                player.logSkill('miniganlu');
                                                player.moveCard().nojudge = true;
                                                event.finish();
                                                break;
                                            case '交换牌':
                                                player.chooseCardTarget({
                                                    prompt: '甘露：请选择两名角色，交换他们装备区的一张副类别相同的一张牌',
                                                    filterCard: false,
                                                    selectCard: -1,
                                                    filterTarget(card, player, target) {
                                                        if (!ui.selected.targets.length) return game.hasPlayer(current => lib.skill.miniganlu.moveCheck(target, current));
                                                        return lib.skill.miniganlu.moveCheck(ui.selected.targets[0], target);
                                                    },
                                                    selectTarget: 2,
                                                    complexSelect: true,
                                                    complexTarget: true,
                                                    forced: true,
                                                });
                                                break;
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    var targets = result.targets;
                                    event.targets = targets;
                                    player.logSkill('miniganlu', targets);
                                    player.chooseButton([
                                        '###甘露###<div class="text center">请选择' + get.translation(targets[0]) + '和' + get.translation(targets[1]) + '交换的装备牌</div>',
                                        '<div class="text center">' + get.translation(targets[0]) + '</div>',
                                        targets[0].getCards('e'),
                                        '<div class="text center">' + get.translation(targets[1]) + '</div>',
                                        targets[1].getCards('e')
                                    ], 2, true).set('filterButton', button => {
                                        var targets = _status.event.targets;
                                        if (!ui.selected.buttons.length) {
                                            if (targets[0].getCards('e', card => {
                                                return targets[1].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[0].canEquip(cardx, true) && targets[1].canEquip(card, true));
                                            }).includes(button.link)) return true;
                                            if (targets[1].getCards('e', card => {
                                                return targets[0].countCards('e', cardx => get.subtype(card) == get.subtype(cardx) && targets[1].canEquip(cardx, true) && targets[0].canEquip(card, true));
                                            }).includes(button.link)) return true;
                                            return false;
                                        }
                                        var card = ui.selected.buttons[0].link;
                                        var owner = get.owner(card);
                                        var target = targets.find(target => target != owner);
                                        return target.getCards('e', cardx => get.subtype(card) == get.subtype(cardx) && owner.canEquip(cardx, true) && target.canEquip(card, true)).includes(button.link);
                                    }).set('targets', targets);
                                    'step 3'
                                    if (result.bool) {
                                        if (get.owner(result.links[0]) != targets[0]) result.links.reverse();
                                        game.log(player, '令', targets[0], '和', targets[1], '交换了', result.links[0], '和', result.links[1]);
                                        event.links = result.links;
                                        game.loseAsync({
                                            player: targets[0],
                                            target: targets[1],
                                            cards1: event.links[0],
                                            cards2: event.links[1],
                                        }).setContent('swapHandcardsx');
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (get.position(event.links[1], true) == 'o') targets[0].equip(event.links[1]);
                                    if (get.position(event.links[0], true) == 'o') targets[1].equip(event.links[0]);
                                },
                            },
                            minibuyi: {
                                audio: 'buyi',
                                trigger: { global: 'dying' },
                                usable: 3,
                                filter(event, player) {
                                    return event.player.hp <= 0 && event.player.countCards('h');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var check;
                                    if (trigger.player.isUnderControl(true, player)) {
                                        check = player.hasCard(function (card) {
                                            return get.type(card) == 'basic';
                                        });
                                    }
                                    else check = (get.attitude(player, trigger.player) > 0);
                                    player.choosePlayerCard(trigger.player, get.prompt('minibuyi', trigger.player), 'h').set('ai', function (button) {
                                        if (!_status.event.check) return 0;
                                        if (_status.event.target.isUnderControl(true, _status.event.player)) {
                                            if (get.type(button.link) == 'basic') {
                                                return 10 - get.value(button.link);
                                            }
                                            return 0;
                                        }
                                        else return Math.random();
                                    }).set('check', check).set('filterButton', function (button) {
                                        if (_status.event.player == _status.event.target) {
                                            return lib.filter.cardDiscardable(button.link, _status.event.player);
                                        }
                                        return true;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minibuyi', trigger.player);
                                        event.card = result.links[0];
                                        player.showCards([event.card], get.translation(player) + '展示的手牌');
                                    }
                                    else {
                                        player.storage.counttrigger.minibuyi--;
                                        event.finish();
                                    }
                                    'step 2'
                                    if (get.type(event.card) == 'basic') {
                                        trigger.player.discard(event.card);
                                        trigger.player.recover();
                                    }
                                },
                            },
                            minipojun: {
                                shaRelated: true,
                                audio: 'decadepojun',
                                trigger: { player: 'useCardToPlayered' },
                                direct: true,
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.target.getHp() > 0 && event.target.countCards('he');
                                },
                                content() {
                                    'step 0'
                                    const num = Math.min(trigger.target.getHp(), trigger.target.countCards('he'));
                                    var next = player.choosePlayerCard(trigger.target, 'he', [1, num], get.prompt(event.name, trigger.target));
                                    next.set('ai', function (button) {
                                        if (!_status.event.goon) return 0;
                                        var val = get.value(button.link);
                                        if (_status.event.target.getEquips(2).some(i => i == button.link)) return 2 * (val + 3);
                                        return val;
                                    });
                                    next.set('goon', get.attitude(player, trigger.target) <= 0);
                                    next.set('forceAuto', true);
                                    'step 1'
                                    if (result.bool) {
                                        event.cards = result.cards;
                                        var target = trigger.target;
                                        player.logSkill(event.name, trigger.target);
                                        target.addSkill('minipojun2');
                                        target.addToExpansion(result.cards, 'giveAuto', target).gaintag.add('minipojun2');
                                    }
                                    else event.finish();
                                    'step 2'
                                    var discard = false, draw = false;
                                    for (var i of cards) {
                                        var type = get.type2(i);
                                        if (type == 'equip') discard = true;
                                        if (i.name == 'shan') draw = true;
                                    }
                                    if (discard) {
                                        event.equip = true;
                                        player.chooseButton(['选择一张装备牌置入弃牌堆', cards.filter(function (card) {
                                            return get.type(card) == 'equip';
                                        })], true).set('ai', function (button) {
                                            return get.value(button.link, _status.event.getTrigger().target);
                                        });
                                    }
                                    if (draw) event.draw = true;
                                    'step 3'
                                    if (event.equip && result.links && result.links.length) trigger.target.loseToDiscardpile(result.links);
                                    if (event.draw) player.draw();
                                },
                                ai: {
                                    unequip_ai: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (get.attitude(player, arg.target) > 0) return false;
                                        if (tag == 'directHit_ai') return arg.target.hp >= Math.max(1, arg.target.countCards('h') - 1);
                                        if (arg?.name == 'sha' && arg.target.getEquips(2).length) return true;
                                        return false;
                                    }
                                },
                            },
                            minipojun2: {
                                trigger: { global: 'phaseEnd' },
                                forced: true,
                                popup: false,
                                charlotte: true,
                                filter(event, player) {
                                    return player.getExpansions('minipojun2').length > 0;
                                },
                                content() {
                                    'step 0'
                                    var cards = player.getExpansions('minipojun2');
                                    player.gain(cards, 'draw');
                                    game.log(player, '收回了' + get.cnNumber(cards.length) + '张〖破军〗牌');
                                    'step 1'
                                    player.removeSkill('minipojun2');
                                },
                                intro: {
                                    markcount: 'expansion',
                                    mark(dialog, storage, player) {
                                        var cards = player.getExpansions('minipojun2');
                                        if (player.isUnderControl(true)) dialog.addAuto(cards);
                                        else return '共有' + get.cnNumber(cards.length) + '张牌';
                                    },
                                },
                            },
                            minirepojun: {
                                inherit: 'minipojun',
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.target.countCards('he');
                                },
                                group: 'minirepojun_damage',
                                subSkill: { damage: { audio: 'decadepojun', inherit: 'repojun3' } },
                            },
                            minirepojunx: {
                                audio: 'decadepojun',
                                trigger: {
                                    player: 'useCardToPlayered',
                                    target: 'useCardToTargeted',
                                },
                                filter(event, player) {
                                    if (event.player == event.target || event.card.name != 'sha') return false;
                                    return player.maxHp > 0 && get.info('minirepojunx').logTarget(event, player).countCards('he') > 0;
                                },
                                async cost(event, trigger, player) {
                                    const target = get.info('minirepojunx').logTarget(trigger, player);
                                    const next = player.choosePlayerCard(target, 'he', [1, Math.min(player.maxHp, target.countCards('he'))], get.prompt(event.name.slice(0, -5), target));
                                    next.set('ai', button => {
                                        if (!_status.event.goon) return 0;
                                        const val = get.value(button.link);
                                        if (button.link == _status.event.target.getEquip(2)) return 2 * (val + 3);
                                        return val;
                                    });
                                    next.set('goon', get.attitude(player, target) <= 0);
                                    next.set('forceAuto', true);
                                    event.result = await next.forResult();
                                },
                                logTarget(event, player) {
                                    return event.player == player ? event.target : event.player;
                                },
                                async content(event, trigger, player) {
                                    const target = get.info(event.name).logTarget(trigger, player);
                                    target.addSkill(event.name + '_gain');
                                    const next = target.addToExpansion("giveAuto", event.cards, target)
                                    next.gaintag.add(event.name + '_gain');
                                    await next;
                                },
                                ai: {
                                    unequip_ai: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        const target = get.info('minirepojunx').logTarget(arg, player);
                                        if (get.attitude(player, target) > 0) return false;
                                        if (tag == 'directHit_ai') return player == arg.player && player.maxHp >= Math.max(1, arg.target.countCards('h') - 1);
                                        return arg?.card?.name == 'sha' && arg.target?.getEquip(2);
                                    },
                                },
                                subSkill: {
                                    gain: {
                                        charlotte: true,
                                        trigger: { global: 'phaseEnd' },
                                        filter(event, player) {
                                            return player.getExpansions('minirepojunx_gain').length > 0;
                                        },
                                        forced: true,
                                        popup: false,
                                        async content(event, trigger, player) {
                                            const cards = player.getExpansions(event.name);
                                            await player.gain(cards, 'draw');
                                            game.log(player, '收回了' + get.cnNumber(cards.length) + '张“破军”牌');
                                            player.removeSkill(event.name);
                                        },
                                        intro: {
                                            markcount: 'expansion',
                                            mark(dialog, storage, player) {
                                                var cards = player.getExpansions('minirepojunx_gain');
                                                if (player.isUnderControl(true)) dialog.addAuto(cards);
                                                else return '共有' + get.cnNumber(cards.length) + '张牌';
                                            },
                                        },
                                    }
                                }
                            },
                            miniyicheng: {
                                audio: ['yicheng1.mp3', 'yicheng2.mp3'],
                                trigger: {
                                    global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                forced: true,
                                getIndex(event, player) {
                                    return game.filterPlayer(current => {
                                        const evt = event.getl(current);
                                        const num = current.getCards('x').map(card => get.type2(card)).toUniqued().length;
                                        return (evt?.xs?.length || (event.name == 'addToExpansion' && event.player == current)) && num > 0 && num <= 3;
                                    }).sortBySeat();
                                },
                                logTarget(event, player, triggername, target) {
                                    return target;
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0], num = target.getCards('x').map(card => get.type2(card)).toUniqued().length;
                                    if (num == 1) {
                                        if (!target.hasSkill('fengyin')) target.addTempSkill('fengyin');
                                        target.addTempSkill(event.name + '_ban');
                                    }
                                    else if (num == 2) {
                                        target.addTempSkill(event.name + '_damage');
                                    }
                                    else {
                                        await player.draw(3);
                                    }
                                },
                                subSkill: {
                                    ban: {
                                        mod: {
                                            cardEnabled2(card) {
                                                if (get.position(card) == 'h') return false;
                                            },
                                        },
                                        mark: true,
                                        intro: {
                                            content: '本回合非锁定技失效且不能使用或打出手牌',
                                        },
                                    },
                                    damage: {
                                        trigger: {
                                            player: 'damageBegin3',
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        forced: true,
                                        popup: false,
                                        content() {
                                            trigger.num++;
                                        },
                                        mark: true,
                                        intro: {
                                            content: '本回合受到伤害的伤害+1',
                                        },
                                    }
                                }
                            },
                            minikeji: {
                                audio: 'keji',
                                audioname: ['re_lvmeng'],
                                audioname2: { Mbaby_sb_lvmeng: 'sbkeji' },
                                trigger: { player: 'phaseDiscardBefore' },
                                filter(event, player) {
                                    if (player.hasSkill('minisbduojing_keji')) return true;
                                    const history = player.getHistory('useCard').concat(player.getHistory('respond'));
                                    return !history.some(evt => evt.card.name == 'sha' && evt.isPhaseUsing());
                                },
                                frequent: true,
                                content() {
                                    trigger.cancel();
                                    player.draw();
                                },
                            },
                            miniqinxue: {
                                skillAnimation: true,
                                animationColor: 'wood',
                                audio: 'qinxue',
                                unique: true,
                                juexingji: true,
                                derivation: 'minigongxin',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                filter(event, player) {
                                    return player.countCards('h') >= player.hp * 3;
                                },
                                content() {
                                    'step 0'
                                    var num = player.maxHp - player.hp;
                                    player.awakenSkill('miniqinxue');
                                    if (num > 0) player.loseMaxHp(num);
                                    player.changeSkills(['minigongxin'], ['minikeji']);
                                },
                            },
                            //谋吕蒙
                            minisbduojing: {
                                audio: 'sbduojing',
                                enable: 'phaseUse',
                                usable: 2,
                                filterTarget: lib.filter.notMe,
                                async content(event, trigger, player) {
                                    const target = event.target;
                                    const { result } = await player.mini_chooseToMouYi(target).set('namelist', [
                                        '半渡而击', '扰袭敌营', '休养生息', '白衣渡江'
                                    ]).set('ai', button => {
                                        const source = get.event().getParent().player, target = get.event().getParent().target;
                                        if (get.effect(target, { name: 'sha', storage: { minisbduojing: true } }, source, source) < 0 && (button.link[2] == 'db_atk2' || button.link[2] == 'db_def1')) return 10;
                                        if (get.effect(target, { name: 'shunshou_copy2' }, source, source) < 0 && (button.link[2] == 'db_atk1' || button.link[2] == 'db_def2')) return 10;
                                        return 1 + Math.random();
                                    });
                                    if (result.bool) {
                                        if (result.player == 'db_def1') {
                                            await player.gainPlayerCard(target, 'he', true);
                                            await player.recover();
                                            const num = player.getDamagedHp();
                                            if (num > 0) {
                                                await player.draw(num);
                                                await player.chooseToDiscard(num, 'he', true);
                                            }
                                        }
                                        else {
                                            const card = new lib.element.VCard({ name: 'sha', storage: { minisbduojing: true } });
                                            if (player.canUse(card, target, false)) await player.useCard(card, target, false);
                                            player.addTempSkill('shenzhu_more');
                                            player.addMark('shenzhu_more', 1, false);
                                            player.addTempSkill('minisbduojing_keji');
                                        }
                                    }
                                },
                                init() {
                                    if (!_status.miniMouYi) {
                                        _status.miniMouYi = true;
                                        lib.skill.minisbtieji.initMouYi();
                                    }
                                },
                                ai: {
                                    order(item, player) {
                                        return get.order({ name: 'sha' }, player) - 0.01;
                                    },
                                    unequip: true,
                                    unequip_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minisbduojing) return false;
                                    },
                                    result: { target: -1 },
                                },
                                subSkill: {
                                    keji: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '本回合无视【克己】发动条件' },
                                    },
                                },
                            },
                            minitianxiang: {
                                audio: 'tianxiang',
                                trigger: { player: 'damageBegin3' },
                                filter(event, player) {
                                    return player.countCards('h', { suit: 'heart' }) && event.num > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        filterCard(card, player) {
                                            return get.suit(card) == 'heart' && lib.filter.cardDiscardable(card, player);
                                        },
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            return 10 - get.value(card);
                                        },
                                        ai2(target) {
                                            var att = get.attitude(_status.event.player, target);
                                            return -att;
                                        },
                                        prompt: get.prompt2('minitianxiang')
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minitianxiang', target);
                                        player.discard(result.cards[0]);
                                        player.addTempSkill('minitianxiang2');
                                        trigger.cancel();
                                        target.damage(trigger.source ? trigger.source : 'nosource', trigger.nature, trigger.num).set('card', trigger.card).set('cards', trigger.cards).minitianxiang2 = [player];
                                    }
                                },
                                ai: {
                                    maixie_defend: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.hasSkillTag('jueqing', false, target)) return;
                                            if (get.tag(card, 'damage') && target.countCards('h') > 1) return 0.7;
                                        },
                                    },
                                    threaten(player, target) {
                                        if (!target.countCards('h')) return 2;
                                    },
                                },
                            },
                            minitianxiang2: {
                                charlotte: true,
                                trigger: { global: ['damageAfter', 'damageCancelled', 'damageZero'] },
                                filter(event, player) {
                                    return event.minitianxiang2 && event.minitianxiang2.includes(player) && event.player.isIn();
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var target = trigger.player;
                                    event.target = target;
                                    player.chooseControl().set('choiceList', [
                                        '令' + get.translation(target) + '摸一张牌',
                                        '令' + get.translation(target) + '摸' + get.cnNumber(Math.min(5, target.getDamagedHp())) + '张牌']).set('ai', function () {
                                            return (get.attitude(player, target) > 0 && target.isDamaged()) ? 1 : 0;
                                        });
                                    'step 1'
                                    player.line(target);
                                    target.draw(result.index == 0 ? 1 : Math.min(5, target.getDamagedHp()));
                                },
                            },
                            minijiang: {
                                audio: 'jiang',
                                inherit: 'jiang',
                                filter(event, player) {
                                    return event.card.name == 'sha' || event.card.name == 'juedou';
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (card.name == 'sha' || card.name == 'juedou') return [1, 0.6];
                                        },
                                        player(card, player, target) {
                                            if (card.name == 'sha' || card.name == 'juedou') return [1, 1];
                                        },
                                    },
                                },
                            },
                            minihunzi: {
                                derivation: ['minireyingzi', 'miniyinghun'],
                                unique: true,
                                audio: 'olhunzi',
                                audioname: ['re_sunyi'],
                                audioname2: { Mbaby_sunce: 'hunzi' },
                                trigger: { player: ['changeHp', 'enterGame'], global: 'phaseBefore' },
                                filter(event, player) {
                                    if (player.hp != 1) return false;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                juexingji: true,
                                forced: true,
                                skillAnimation: true,
                                animationColor: 'wood',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minihunzi');
                                    player.loseMaxHp();
                                    'step 1'
                                    player.addSkills(lib.skill[event.name].derivation);
                                },
                            },
                            minihunzi_old: {
                                unique: true,
                                audio: 'hunzi',
                                audio: 'olhunzi',
                                audioname: ['re_sunyi'],
                                audioname2: { Mbaby_sunce: 'hunzi' },
                                derivation: ['minireyingzi', 'miniyinghun'],
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.hp == 1;
                                },
                                juexingji: true,
                                forced: true,
                                skillAnimation: true,
                                animationColor: 'wood',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minihunzi_old');
                                    player.loseMaxHp();
                                    'step 1'
                                    player.addSkills(lib.skill[event.name].derivation);
                                },
                                ai: {
                                    threaten(player, target) {
                                        if (target.hp == 1) return 2;
                                        return 0.5;
                                    },
                                    maixie: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (!target.hasFriend()) return;
                                            if (get.tag(card, 'damage') == 1 && target.hp == 2 && !target.isTurnedOver() && _status.currentPhase != target && get.distance(_status.currentPhase, target, 'absolute') <= 3) return [0.5, 1];
                                        },
                                    },
                                },
                            },
                            minizhiba: {
                                unique: true,
                                audio: 'zhiba2',
                                global: 'minizhiba2',
                                zhuSkill: true,
                            },
                            minizhiba2: {
                                audio: 'zhiba2',
                                enable: 'phaseUse',
                                discard: false,
                                lose: false,
                                delay: false,
                                line: true,
                                direct: true,
                                clearTime: true,
                                prepare(cards, player, targets) {
                                    targets[0].logSkill('minizhiba');
                                },
                                prompt() {
                                    var player = _status.event.player;
                                    var list = game.filterPlayer(function (target) {
                                        return target != player && target.hasZhuSkill('minizhiba', player);
                                    });
                                    var str = '将一张红色【杀】或【决斗】交给' + get.translation(list);
                                    if (list.length > 1) str += '中的一人';
                                    return str;
                                },
                                filter(event, player) {
                                    if (player.group != 'wu' || player.hasSkill('minizhiba3')) return false;
                                    if (player.countCards('h', function (card) {
                                        return card.name == 'juedou' || card.name == 'sha';
                                    }) <= 0) return false;
                                    return game.hasPlayer(function (target) {
                                        return target != player && target.hasZhuSkill('minizhiba', player);
                                    });
                                },
                                filterCard(card) {
                                    return card.name == 'juedou' || card.name == 'sha';
                                },
                                log: false,
                                visible: true,
                                filterTarget(card, player, target) {
                                    return target != player && target.hasZhuSkill('minizhiba', player);
                                },
                                content() {
                                    player.addTempSkill('minizhiba3', 'phaseUseAfter');
                                    target.gain(cards, player, 'give');
                                },
                                ai: {
                                    expose: 0.3,
                                    order: 10,
                                    result: { target: 1 },
                                },
                            },
                            minizhiba3: { charlotte: true },
                            minibuqu: {
                                audio: 'buqu',
                                trigger: { player: 'chooseToUseBefore' },
                                filter(event, player) {
                                    return event.type == 'dying' && player.isDying() && event.dying == player && player.countMark('minibuqu') < 4;
                                },
                                forced: true,
                                preHidden: true,
                                content() {
                                    player.addMark('minibuqu', 1);
                                    if (player.hp <= 0) player.recover(1 - player.hp);
                                },
                                marktext: '创',
                                intro: { name: '不屈', name2: '创', content: 'mark' },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark('minibuqu');
                                    },
                                },
                                ai: {
                                    save: true,
                                    mingzhi: true,
                                    skillTagFilter(player, tag, target) {
                                        if (player != target || player.countMark('minibuqu') > 3) return false;
                                    },
                                },
                            },
                            minirebuqu: {
                                audio: 'buqu',
                                trigger: { player: ['damageBegin2', 'loseHpBegin'] },
                                filter(event, player) {
                                    return player.countMark('minirebuqu') < 4;
                                },
                                forced: true,
                                preHidden: true,
                                content() {
                                    trigger.cancel();
                                    player.addMark('minirebuqu', 1);
                                },
                                marktext: '创',
                                intro: { name: '不屈', name2: '创', content: 'mark' },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark('minirebuqu');
                                    },
                                },
                            },
                            miniqingchuang: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    if (!player.hasMark('minirebuqu')) return false;
                                    return player.countCards('h', card => lib.skill.miniqingchuang.filterCard(card, player));
                                },
                                filterCard(card, player) {
                                    return get.name(card, player) == 'tao' || get.name(card, player) == 'jiu';
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    return 2 - ['tao', 'jiu'].indexOf(get.name(card, player));
                                },
                                usable: 1,
                                delay: 0,
                                content() {
                                    player.removeMark('minirebuqu', 1);
                                    player.draw();
                                },
                                ai: {
                                    order: 7,
                                    result: { player: 1 },
                                },
                            },
                            minijieyin: {
                                audio: 'jieyin',
                                enable: 'phaseUse',
                                filterCard: true,
                                usable: 1,
                                position: 'he',
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    if (get.position(card) == 'e') {
                                        var subtype = get.subtype(card);
                                        if (!game.hasPlayer(function (current) {
                                            return current != player && current.hp != player.hp && get.attitude(player, current) > 0 && !current.countCards('e', { subtype: subtype });
                                        })) {
                                            return 0;
                                        }
                                        if (player.countCards('h', { subtype: subtype })) return 20 - get.value(card);
                                        return 10 - get.value(card);
                                    }
                                    else {
                                        if (player.countCards('e')) return 0;
                                        if (player.countCards('h', { type: 'equip' })) return 0;
                                        return 8 - get.value(card);
                                    }
                                },
                                filterTarget(card, player, target) {
                                    var card = ui.selected.cards[0];
                                    if (!card) return false;
                                    if (get.position(card) == 'e' && target.countCards('e', { subtype: get.subtype(card) })) return false;
                                    return target != player;
                                },
                                discard: false,
                                delay: 0,
                                lose: false,
                                content() {
                                    'step 0'
                                    if (get.position(cards[0]) == 'e') {
                                        player.$give(cards, target);
                                        target.equip(cards[0]);
                                    }
                                    else player.give(cards, target, true);
                                    'step 1'
                                    player.recover();
                                    player.draw();
                                    'step 2'
                                    if (target.hp < player.hp && target.isHealthy()) { event.finish(); return; }
                                    player.chooseBool('结姻：是否令' + get.translation(target) + (target.hp < player.hp ? '回复1点体力' : '摸一张牌') + '？').set('choice', get.attitude(player, target) > 0);
                                    'step 3'
                                    if (result.bool) {
                                        player.line(target);
                                        target[target.hp < player.hp ? 'recover' : 'draw']();
                                    }
                                },
                                ai: {
                                    order() {
                                        var player = _status.event.player;
                                        var es = player.getCards('e');
                                        for (var i = 0; i < es.length; i++) {
                                            if (player.countCards('h', { subtype: get.subtype(es[i]) })) return 10;
                                        }
                                        return 2;
                                    },
                                    result: {
                                        target(player, target) {
                                            var goon = function () {
                                                var es = player.getCards('e');
                                                for (var i = 0; i < es.length; i++) {
                                                    if (player.countCards('h', { subtype: get.subtype(es[i]) })) return true;
                                                }
                                                return false;
                                            }
                                            if (player.hp > target.hp + (player.isHealthy() ? 0 : 1)) {
                                                if (target.isHealthy()) {
                                                    if (!player.needsToDiscard(1) || goon()) return 0.1;
                                                    return 0;
                                                }
                                                return 1;
                                            }
                                            if (player.isHealthy()) {
                                                if (!player.needsToDiscard(1) || goon()) return 0.1;
                                                return 0;
                                            }
                                            return 1.5;
                                        },
                                    },
                                },
                            },
                            minimeibu: {
                                audio: 'meibu',
                                trigger: { global: 'phaseUseBegin' },
                                filter(event, player) {
                                    return event.player != player && event.player.isIn() && player.countCards('he');
                                },
                                direct: true,
                                derivation: 'rezhixi',
                                content() {
                                    'step 0'
                                    player.chooseToDiscard(get.prompt2('minimeibu', trigger.player), 'he').set('ai', function (card) {
                                        if (_status.event.check) return 6 - get.value(card);
                                        return 0;
                                    }).set('check', lib.skill.new_meibu.checkx(trigger, player)).set('logSkill', ['minimeibu', trigger.player]);
                                    'step 1'
                                    if (result.bool) {
                                        var target = trigger.player;
                                        player.line(target, 'green');
                                        player.addTempSkill('minimeibu_gain');
                                        target.addTempSkill('rezhixi', 'phaseUseAfter');
                                    }
                                },
                                ai: { expose: 0.2 },
                                subSkill: {
                                    gain: {
                                        trigger: { global: 'loseAfter' },
                                        forced: true,
                                        charlotte: true,
                                        popup: false,
                                        onremove: true,
                                        filter(event, player) {
                                            return event.getParent(3).name == 'rezhixi' && get.position(event.cards[0]) == 'd';
                                        },
                                        content() {
                                            player.gain(trigger.cards[0], 'gain2');
                                        },
                                    },
                                },
                            },
                            miniyinbing: {
                                group: 'miniyinbing_discard',
                                audio: 'yinbing',
                                trigger: { player: 'phaseDiscardBefore' },
                                direct: true,
                                filter(event, player) {
                                    return player.countCards('he', { type: 'basic' }) < player.countCards('he');
                                },
                                content() {
                                    'step 0'
                                    player.chooseCard([1, player.countCards('he') - player.countCards('he', { type: 'basic' })], 'he', get.prompt('miniyinbing'), function (card) {
                                        return get.type(card) != 'basic';
                                    }).set('ai', function (card) {
                                        return 6 - get.value(card);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniyinbing');
                                        player.addToExpansion(result.cards, player, 'give').gaintag.add('miniyinbing');
                                    }
                                },
                                marktext: '兵',
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (card.name == 'sha' && current < 0) return 1.2;
                                        },
                                    },
                                    threaten(player, target) {
                                        if (target.getExpansions('miniyinbing').length) return 2;
                                        return 1;
                                    }
                                },
                                subSkill: {
                                    discard: {
                                        audio: 'yinbing',
                                        trigger: { player: 'damageEnd' },
                                        forced: true,
                                        filter(event, player) {
                                            return event.card && player.getExpansions('miniyinbing').length > 0 && event.card.name == 'sha';
                                        },
                                        content() {
                                            'step 0'
                                            player.chooseCardButton('移去一张引兵牌', player.getExpansions('miniyinbing'), true);
                                            'step 1'
                                            if (result.bool) {
                                                player.loseToDiscardpile(result.links);
                                                player.draw();
                                            }
                                        },
                                    },
                                },
                            },
                            minijuedi: {
                                audio: 'juedi',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.getExpansions('miniyinbing').length > 0;
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2(event.name), function (card, player, target) {
                                        return player.hp >= target.hp;
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        if (att < 2) return att - 10;
                                        var num = att / 10;
                                        if (target == player) {
                                            num += player.maxHp - player.countCards('h') + 0.5;
                                        }
                                        else {
                                            num += _status.event.n2 * 2;
                                            if (target.isDamaged()) {
                                                if (target.hp == 1) {
                                                    num += 3;
                                                }
                                                else if (target.hp == 2) {
                                                    num += 2;
                                                }
                                                else {
                                                    num += 0.5;
                                                }
                                            }
                                        }
                                        if (target.hasJudge('lebu')) {
                                            num /= 2;
                                        }
                                        return num;
                                    }, true).set('n2', player.getExpansions('miniyinbing').length);
                                    'step 1'
                                    if (result.bool) {
                                        player.line(result.targets[0], 'green');
                                        var cards = player.getExpansions('miniyinbing');
                                        if (result.targets[0] == player) {
                                            player.loseToDiscardpile(cards);
                                            var num = player.maxHp - player.countCards('h') + (event.name == 'minijuedi' ? 1 : 0);
                                            if (num > 0) player.draw(num);
                                        }
                                        else {
                                            var target = result.targets[0];
                                            target.recover();
                                            target.gain(cards, player, 'give');
                                            target.draw(cards.length);
                                        }
                                    }
                                },
                            },
                            minihongyuan: {
                                audio: 'hongyuan',
                                trigger: { player: 'phaseDrawBegin2' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minihongyuan'), '令至多两名角色各摸一张牌', [1, 2]).set('ai', function (target) {
                                        return Math.sqrt(5 - Math.min(4, target.countCards('h'))) * get.attitude(_status.event.player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('minihongyuan', targets);
                                        if (targets.length == 1) {
                                            targets[0].draw();
                                            event.finish();
                                        }
                                        else game.asyncDraw(targets);
                                    }
                                    else event.finish();
                                    'step 2'
                                    game.delayx();
                                },
                            },
                            minizenhui: {
                                audio: 'chanhui',
                                usable: 1,
                                trigger: { player: 'useCardToPlayer' },
                                filter(event, player) {
                                    if (_status.currentPhase != player) return false;
                                    if (event.targets.length > 1) return false;
                                    var card = event.card;
                                    if (card.name == 'sha' || get.type(card) == 'trick') return true;
                                    return false;
                                },
                                check(event, player) {
                                    return get.attitude(player, event.target) < 0;
                                },
                                logTarget: 'target',
                                content() {
                                    'step 0'
                                    trigger.target.chooseCard('he', '谮毁：交给' + get.translation(player) + '一张牌，或失去1点体力').set('ai', function (card) {
                                        return 7 - get.value(card);
                                    });
                                    'step 1'
                                    if (result.bool) player.gain(result.cards, trigger.target, 'giveAuto');
                                    else trigger.target.loseHp();
                                },
                            },
                            minijiaojin: {
                                audio: 'jiaojin',
                                trigger: { target: 'useCardToTargeted' },
                                filter(event, player) {
                                    return (event.card.name == 'sha' || get.type(event.card) == 'trick') && event.player != player;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var next = player.chooseToDiscard('h', '骄矜：是否弃置一张手牌令' + get.translation(trigger.card) + '对你无效？');
                                    next.set('ai', function (card) {
                                        if (_status.event.goon2) {
                                            return 3 + _status.event.val - get.value(card);
                                        }
                                        return 0;
                                    });
                                    next.set('val', get.value(trigger.cards.filterInD()));
                                    next.set('goon2', get.effect(player, trigger.card, trigger.player, player) < 0)
                                    next.logSkill = ['minijiaojin', trigger.player];
                                    'step 1'
                                    if (result.bool) trigger.excluded.push(player);
                                },
                            },
                            minilihuo: {
                                group: ['minilihuo_target', 'minilihuo_draw'],
                                trigger: { player: 'useCard1' },
                                filter(event, player) {
                                    if (event.card.name == 'sha' && !event.card.nature) return true;
                                    return false;
                                },
                                audio: 'lihuo',
                                check(event, player) {
                                    return player.hp > 2;
                                },
                                content() {
                                    game.setNature(trigger.card, 'fire');
                                    var next = game.createEvent('minilihuo_clear');
                                    next.player = player;
                                    next.card = trigger.card;
                                    event.next.remove(next);
                                    next.forceDie = true;
                                    trigger.after.push(next);
                                    next.setContent(function () {
                                        var num = 0;
                                        player.getHistory('sourceDamage', function (evt) {
                                            if (evt.card == card) num += evt.num;
                                        });
                                        if (num > 1) player.loseHp();
                                        delete card.nature;
                                    });
                                },
                                subSkill: {
                                    target: {
                                        trigger: { player: 'useCard2' },
                                        filter(event, player) {
                                            if (event.card.name != 'sha' || get.nature(event.card) != 'fire') return false;
                                            return game.hasPlayer(function (current) {
                                                return !event.targets.includes(current) && player.canUse(event.card, current);
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('minilihuo'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                                                return !_status.event.sourcex.includes(target) && player.canUse(_status.event.card, target);
                                            }).set('sourcex', trigger.targets).set('card', trigger.card).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.effect(target, _status.event.card, player, player);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                if (!event.isMine() && !_status.connectMode) game.delayx();
                                                event.target = result.targets[0];
                                            }
                                            else event.finish();
                                            'step 2'
                                            player.logSkill('minilihuo', event.target);
                                            trigger.targets.push(event.target);
                                        },
                                    },
                                    draw: {
                                        audio: 'lihuo',
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return event.card && event.card.name == 'sha' && get.nature(event.card) == 'fire';
                                        },
                                        forced: true,
                                        locked: false,
                                        usable: 1,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            minichunlao: {
                                audio: 'chunlao',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.countCards('h') > 0 && (_status.connectMode || player.countCards('h', 'sha') > 0) && !player.getExpansions('minichunlao').length;
                                },
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCard([1, Math.max(1, player.countCards('h', 'sha'))], get.prompt('minichunlao'), '将任意张【杀】置于武将牌上作为“醇”', { name: 'sha' }).set('ai', function () {
                                        return 1;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minichunlao');
                                        player.addToExpansion('gain2', result.cards).gaintag.add('minichunlao');
                                    }
                                },
                                group: 'minichunlao2'
                            },
                            minichunlao2: {
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    return event.type == 'dying' && event.dying && event.dying.hp <= 0 && player.getExpansions('minichunlao').length > 0;
                                },
                                filterTarget(card, player, target) {
                                    return target == _status.event.dying;
                                },
                                direct: true,
                                delay: false,
                                selectTarget: -1,
                                content() {
                                    'step 0'
                                    player.chooseCardButton(get.translation('minichunlao'), player.getExpansions('minichunlao'), true);
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minichunlao');
                                        event.type = 'dying';
                                        player.loseToDiscardpile(result.links);
                                        target.useCard({ name: 'jiu', isCard: true }, target);
                                        var nature = get.color(result.links[0]);
                                        if (nature == 'red') player.recover();
                                        if (nature == 'black') player.draw(2);
                                    }
                                },
                                ai: {
                                    order: 6,
                                    skillTagFilter(player) {
                                        return player.getExpansions('minichunlao').length > 0;
                                    },
                                    save: true,
                                    result: { target: 1 },
                                },
                            },
                            minianxu: {
                                audio: 'anxu',
                                trigger: { player: ['phaseUseBegin', 'phaseUseEnd'] },
                                direct: true,
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.isMaxHandcard() && current.countCards('h');
                                    });
                                },
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minianxu'), function (card, player, target) {
                                        return target.isMaxHandcard() && target.countCards('h') && player != target;
                                    }, function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (target.hasSkill('tuntian')) return att / 10;
                                        return -att;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minianxu', target);
                                        player.gainPlayerCard(target, 'h', true);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (get.suit(result.cards[0]) == 'spade') {
                                        player.line(target);
                                        target.draw();
                                    }
                                },
                            },
                            minixingwu: {
                                enable: 'phaseUse',
                                usable: 1,
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterCard: true,
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    return 8 - get.value(card);
                                },
                                contentBefore() {
                                    _status.event.player = player;
                                    _status.event.trigger('useXingWu');
                                },
                                content() {
                                    'step 0'
                                    player.turnOver();
                                    if (target.countCards('e')) player.discardPlayerCard(target, 'e', true);
                                    'step 1'
                                    var num = 2;
                                    if (target.sex == 'female') num = 1;
                                    target.damage(num, 'nocard');
                                },
                                ai: {
                                    damage: 2,
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            if (get.attitude(player, target) > 0) return 0;
                                            return get.damageEffect(target, player);
                                        },
                                    },
                                },
                            },
                            miniluoyan: {
                                derivation: ['minitianxiang', 'olhongyan'],
                                trigger: { player: 'minixingwuAfter' },
                                forced: true,
                                content() {
                                    const skills = lib.skill.miniluoyan.derivation.slice();
                                    player.changeSkills(skills, []).set('$handle', (player, skills) => {
                                        player.addTempSkill(skills, { player: 'phaseUseBegin' });
                                        for (const skill of skills) {
                                            player.popup(skill);
                                            game.log(player, '获得了技能', '【' + get.translation(skill) + '】');
                                        }
                                    });
                                },
                            },
                            minihuimou: {
                                trigger: { player: ['useCard', 'respond', 'loseAfter'], global: 'loseAsyncAfter' },
                                filter(event, player) {
                                    if (!game.hasPlayer(function (current) {
                                        return current.isTurnedOver();
                                    })) return false;
                                    if (event.name.indexOf('lose') != 0) return player != _status.currentPhase && get.suit(event.card, player) == 'heart';
                                    if (event.type != 'discard' || event.getlx === false || get.translation(event.getParent(2).name) != '天香') return false;
                                    return event.getl(player).cards2.filter(function (card) {
                                        return get.suit(card, player) == 'heart';
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minihuimou'), '令一名背面朝上的角色翻至正面', function (card, player, target) {
                                        return target.isTurnedOver();
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minihuimou', target);
                                        if (target.isTurnedOver()) target.turnOver();
                                    }
                                },
                            },
                            minianguo: {
                                audio: 'anguo',
                                inherit: 'xinanguo',
                                filterTarget: true,
                            },
                            miniyinghun: {
                                audio: 'yinghun',
                                audioname: ['ol_sunjian', 'sunce', 're_sunyi'],
                                trigger: { player: 'phaseZhunbeiBegin' },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('miniyinghun'), lib.filter.notMe).set('ai', function (target) {
                                        var player = _status.event.player, att = get.attitude(player, target);
                                        if (get.attitude(player, target) > 0) return 10 + att;
                                        if (player.getDamagedHp() > 1) return -att;
                                        return -1;
                                    }).setHiddenSkill('miniyinghun');
                                    'step 1'
                                    if (result.bool) {
                                        var num = player.getDamagedHp();
                                        event.num = num;
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('miniyinghun', target);
                                        if (num == 0) {
                                            target.draw();
                                            event.finish();
                                            return;
                                        }
                                        else player.chooseControl(['摸' + get.cnNumber(num) + '张牌', '摸一弃' + get.cnNumber(num, true)]).set('ai', function () {
                                            var player = _status.event.player;
                                            var target = _status.event.target;
                                            var num = (get.attitude(player, target) > 0 ? 0 : 1);
                                            return (player.isHealthy() ? 1 - num : num);
                                        }).set('target', target);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.index == 0 && num > 0) target.draw(num);
                                    if (result.index == 1) {
                                        target.draw();
                                        if (num > 0) target.chooseToDiscard(num, true, 'he');
                                    }
                                },
                            },
                            miniwulie: {
                                unique: true,
                                audio: 'wulie',
                                trigger: { player: 'phaseBegin' },
                                mark: true,
                                limited: true,
                                filter(event, player) {
                                    return player.hp > 0;
                                },
                                direct: true,
                                skillAnimation: true,
                                animationColor: 'wood',
                                content() {
                                    'step 0'
                                    var map = {}, list = [];
                                    for (var i = 1; i <= player.hp; i++) {
                                        var cn = get.cnNumber(i, true);
                                        map[cn] = i;
                                        list.push(cn);
                                    }
                                    list.push('cancel2');
                                    event.map = map;
                                    player.chooseControl(list).set('prompt', get.prompt2('miniwulie')).set('ai', function () {
                                        var player = _status.event.player;
                                        if (player.hasUnknown() || !_status.event.controls.includes(get.cnNumber(_status.event.goon, true))) return 'cancel2';
                                        return get.cnNumber(_status.event.goon, true);
                                    }).set('goon', player.hp - 1 + get.sgn(player.countCards('hs', { name: ['tao', 'jiu'] })));
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        var num = event.map[result.control] || 1;
                                        player.logSkill('miniwulie');
                                        player.awakenSkill('miniwulie');
                                        player.loseHp(num);
                                        player.addSkill('miniwulie2');
                                        player.addMark('miniwulie2', num);
                                        player.chooseTarget([1, num], '是否令至多' + get.cnNumber(num) + '名其他角色各获得1枚「烈」标记？', lib.filter.notMe).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.attitude(player, target);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.line(targets);
                                        for (var i of targets) {
                                            i.addSkill('miniwulie2');
                                            i.addMark('miniwulie2', 1);
                                        }
                                    }
                                },
                            },
                            miniwulie2: {
                                marktext: '烈',
                                intro: { name2: '烈', content: 'mark' },
                                trigger: { player: 'damageBegin3' },
                                nopop: true,
                                content() {
                                    trigger.cancel();
                                    player.removeMark('miniwulie2', 1);
                                    if (!player.storage.miniwulie2) player.removeSkill('miniwulie2');
                                },
                            },
                            minikuizhu: {
                                audio: 'nzry_kuizhu',
                                trigger: { player: 'phaseDiscardEnd' },
                                filter(event, player) {
                                    var cards = [];
                                    player.getHistory('lose', function (evt) {
                                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards2);
                                    });
                                    return cards.length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var cards = [];
                                    player.getHistory('lose', function (evt) {
                                        if (evt.type == 'discard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards2);
                                    });
                                    event.num = cards.length;
                                    event.str1 = '令至多' + event.num + '名角色摸一张牌';
                                    event.str2 = '对任意名体力值之和不大于' + event.num + '的角色造成一点伤害';
                                    player.chooseControl('cancel2').set('ai', function () {
                                        if (game.countPlayer(function (current) { return get.attitude(player, current) < 0 && current.hp <= event.num }) > 0) return 1;
                                        return 0;
                                    }).set('choiceList', [event.str1, event.str2]).set('prompt', get.prompt2('minikuizhu'));
                                    'step 1'
                                    if (result.control == 'cancel2') event.finish();
                                    event.control = [event.str1, event.str2][result.index];
                                    'step 2'
                                    var num = event.num, str = event.control;
                                    player.chooseTarget('请选择〖溃诛〗的目标', str, [0, Infinity], function (card, player, target) {
                                        var num = _status.event.num;
                                        switch (event.control) {
                                            case event.str1:
                                                return ui.selected.targets.length < num;
                                                break;
                                            case event.str2:
                                                if (!ui.selected.targets.length) return target.hp <= num;
                                                var summer = 0;
                                                for (var i of ui.selected.targets) summer += i.hp;
                                                return summer + target.hp <= num;
                                                break;
                                        }
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        switch (event.control) {
                                            case event.str1:
                                                return get.attitude(player, target);
                                                break;
                                            case event.str2:
                                                return get.damageEffect(target, player, player);
                                                break;
                                        }
                                    }).set('num', num).set('complexSelect', true).set('complexTarget', true);
                                    'step 3'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('minikuizhu', targets);
                                        if (event.control == event.str1) game.asyncDraw(targets);
                                        else for (var target of targets) target.damage();
                                    }
                                },
                            },
                            minichezheng: {
                                audio: 'nzry_zhizheng',
                                mod: {
                                    playerEnabled(card, player, target) {
                                        if (target != player && card.name == 'sha' && player.isPhaseUsing() && !target.inRange(player)) return false;
                                    },
                                },
                                trigger: { player: 'phaseUseEnd' },
                                forced: true,
                                content() {
                                    var num = game.countPlayer(function (current) {
                                        if (current == player) return false;
                                        return !current.inRange(player);
                                    });
                                    player.draw(Math.max(2, num));
                                },
                            },
                            minilijun: {
                                unique: true,
                                audio: 'nzry_lijun1',
                                trigger: { global: 'useCardAfter' },
                                filter(event, player) {
                                    if (event.card.name != 'sha' || event.player.group != 'wu') return false;
                                    if (!event.player.isPhaseUsing() || event.player == player) return false;
                                    if (player.hasSkill('minilijun_used')) return false;
                                    return true;
                                },
                                zhuSkill: true,
                                forced: true,
                                locked: false,
                                content() {
                                    'step 0'
                                    player.addTempSkill('minilijun_used', 'phaseUseAfter');
                                    player.draw();
                                    player.chooseBool().set('prompt', '立军：是否令' + get.translation(trigger.player) + '摸一张牌？').set('choice', get.attitude(player, trigger.player) > 0);
                                    'step 1'
                                    if (result.bool) {
                                        player.line(trigger.player);
                                        trigger.player.draw();
                                    }
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            miniguzheng: {
                                audio: 'guzheng',
                                trigger: { global: 'phaseDiscardAfter' },
                                filter(event, player) {
                                    if (event.player != player && event.player.isIn()) {
                                        return event.player.getHistory('lose', function (evt) {
                                            return evt.type == 'discard' && evt.getParent('phaseDiscard') == event && evt.hs.filterInD('d').length > 0;
                                        }).length > 0;
                                    }
                                    return false;
                                },
                                checkx(event, player, cards, cards2) {
                                    if (cards.length > 2 || get.attitude(player, event.player) > 0) return true;
                                    for (var i = 0; i < cards2.length; i++) {
                                        if (get.value(cards2[i], event.player, 'raw') < 0) return true;
                                    }
                                    return false;
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    var cards = [];
                                    var cards2 = [];
                                    game.getGlobalHistory('cardMove', function (evt) {
                                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards.filterInD('d'));
                                    });
                                    game.countPlayer2(function (current) {
                                        current.getHistory('lose', function (evt) {
                                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != trigger) return;
                                            cards.addArray(evt.cards.filterInD('d'));
                                            if (current == trigger.player) cards2.addArray(evt.hs.filterInD('d'));
                                        })
                                    });
                                    event.cards = cards;
                                    var check = lib.skill.miniguzheng.checkx(trigger, player, cards, cards2);
                                    player.chooseCardButton(cards, '固政：选择令' + get.translation(trigger.player) + '收回的牌').set('ai', function (button) {
                                        if (_status.event.check) {
                                            return 20 - get.value(button.link, _status.event.getTrigger().player);
                                        }
                                        return 0;
                                    }).set('check', check).set('cards', cards2).set('filterButton', function (button) {
                                        return _status.event.cards.includes(button.link);
                                    }).setHiddenSkill(event.name);
                                    'step 1'
                                    if (result.bool) {
                                        game.delay(0.5);
                                        player.logSkill('miniguzheng', trigger.player);
                                        trigger.player.gain(result.links[0]);
                                        trigger.player.$gain2(result.links[0]);
                                        game.log(trigger.player, '收回了', result.links[0]);
                                        event.cards.remove(result.links[0]);
                                        if (event.cards.length) {
                                            player.gain(event.cards);
                                            player.$gain2(event.cards);
                                            game.log(player, '收回了', event.cards);
                                        }
                                        else player.draw();
                                        game.delay();
                                    }
                                },
                                ai: { expose: 0.2 },
                            },
                            miniliangyin: {
                                group: 'miniliangyin_discard',
                                audio: 'liangyin',
                                trigger: { global: ['loseAfter', 'addToExpansionAfter', 'cardsGotoSpecialAfter', 'loseAsyncAfter'] },
                                filter(event, player, name) {
                                    if (event.name == 'lose' || event.name == 'loseAsync') return event.getlx !== false && event.toStorage == true;
                                    if (event.name == 'cardGotoSpecial') return !event.notrigger;
                                    return true;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniliangyin'), '令一名角色摸一张牌').set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.attitude(player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniliangyin', result.targets);
                                        result.targets[0].draw();
                                    }
                                },
                                subSkill: {
                                    discard: {
                                        trigger: { global: ['gainAfter', 'loseAfter'] },
                                        filter(event, player) {
                                            return event.fromStorage == true || game.hasPlayer2(function (current) {
                                                var evt = event.getl(current);
                                                return evt?.xs?.length > 0;
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('miniliangyin'), '令一名角色弃置一张牌').set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('miniliangyin', result.targets);
                                                result.targets[0].chooseToDiscard('he', 1, true);
                                            }
                                        },
                                    },
                                },
                            },
                            miniaocai: {
                                audio: 'aocai',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                hiddenCard(player, name) {
                                    if (player != _status.currentPhase && get.type(name) == 'basic' && lib.inpile.includes(name)) return true;
                                },
                                filter(event, player) {
                                    if (event.responded || player == _status.currentPhase || event.miniaocai) return false;
                                    for (var i of lib.inpile) {
                                        if (get.type(i) == 'basic' && event.filterCard(get.autoViewAs({ name: i }, 'unsure'), player, event)) return true;
                                    }
                                    return false;
                                },
                                delay: false,
                                content() {
                                    'step 0'
                                    var evt = event.getParent(2), aozhan = player.hasSkill('aozhan');
                                    evt.set('miniaocai', true);
                                    var cards = get.cards(player.countCards('h') == 0 ? 4 : 3);
                                    for (var i = cards.length - 1; i >= 0; i--) {
                                        ui.cardPile.insertBefore(cards[i].fix(), ui.cardPile.firstChild);
                                    }
                                    player.chooseButton(['傲才：选择要' + (evt.name == 'chooseToUse' ? '使用' : '打出') + '的牌', cards]).set('filterButton', function (button) {
                                        return _status.event.cards.includes(button.link);
                                    }).set('cards', cards.filter(function (card) {
                                        if (aozhan && card.name == 'tao') return false;
                                        return evt.filterCard(card, evt.player, evt);
                                    })).set('ai', function (button) {
                                        var evt = _status.event.getParent(3);
                                        if (evt?.ai) {
                                            var tmp = _status.event;
                                            _status.event = evt;
                                            var result = (evt.ai || event.ai1)(button.link, _status.event.player, evt);
                                            _status.event = tmp;
                                            return result;
                                        }
                                        return 1;
                                    });
                                    'step 1'
                                    var evt = event.getParent(2);
                                    if (result.bool && result.links && result.links.length) {
                                        var name = result.links[0].name;
                                        if (evt.name == 'chooseToUse') {
                                            game.broadcastAll(function (result, name) {
                                                lib.skill.aocai_backup.viewAs = { name: name, cards: [result], isCard: true };
                                                lib.skill.aocai_backup.prompt = '请选择' + get.translation(result) + '的目标';
                                            }, result.links[0], name);
                                            evt.set('_backupevent', 'aocai_backup');
                                            evt.backup('aocai_backup');
                                        }
                                        else {
                                            delete evt.result.skill;
                                            delete evt.result.used;
                                            evt.result.card = get.autoViewAs(result.links[0]);
                                            evt.result.cards = [result.links[0]];
                                            evt.redo();
                                            return;
                                        }
                                    }
                                    evt.goto(0);
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, effect) {
                                            if (get.tag(card, 'respondShan')) return 0.7;
                                            if (get.tag(card, 'respondSha')) return 0.7;
                                        },
                                    },
                                    order: 11,
                                    respondShan: true,
                                    respondSha: true,
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                            },
                            miniduwu: {
                                audio: 'duwu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return !player.hasSkill('miniduwu2') && game.hasPlayer(function (current) {
                                        return current.hp > 0 && current.hp <= player.countCards('he') && player.inRange(current);
                                    });
                                },
                                filterCard() {
                                    return !ui.selected.targets.length;
                                },
                                position: 'he',
                                selectCard: [1, Infinity],
                                complexSelect: true,
                                complexCard: true,
                                filterTarget(card, player, target) {
                                    return target != player && target.hp > 0 && player.inRange(target) && ui.selected.cards.length == target.hp;
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    if (game.hasPlayer(function (current) {
                                        return current != player && current.hp > 0 && player.inRange(current) && ui.selected.cards.length == current.hp && get.damageEffect(current, player, player) > 0;
                                    })) return 0;
                                    switch (ui.selected.cards.length) {
                                        case 0: return 8 - get.value(card);
                                        case 1: return 6 - get.value(card);
                                        case 2: return 3 - get.value(card);
                                        default: return 0;
                                    }
                                },
                                content() {
                                    player.addTempSkill('miniduwu3');
                                    target.damage('nocard');
                                },
                                ai: {
                                    expose: 0.3,
                                    damage: true,
                                    order: 2,
                                    result: {
                                        target(player, target) {
                                            return get.damageEffect(target, player);
                                        },
                                    },
                                },
                            },
                            miniduwu2: { charlotte: true },
                            miniduwu3: {
                                trigger: { global: 'dyingAfter' },
                                charlotte: true,
                                filter(event, player) {
                                    return event.player.isIn() && event.reason && event.reason.getParent().name == 'miniduwu';
                                },
                                forced: true,
                                popup: false,
                                content() {
                                    player.draw();
                                    player.addTempSkill('miniduwu2');
                                },
                            },
                            miniwengua: {
                                global: 'miniwengua2',
                                audio: 'wengua',
                            },
                            miniwengua2: {
                                audio: 'wengua',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he') && game.hasPlayer(function (current) {
                                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                                    });
                                },
                                prompt: () => lib.translate.miniwengua_info,
                                filterTarget(card, player, target) {
                                    return target.hasSkill('miniwengua') && !target.hasSkill('miniwengua3');
                                },
                                selectTarget() {
                                    if (game.countPlayer(function (current) {
                                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                                    }) == 1) return -1;
                                    return 1;
                                },
                                filterCard: true,
                                selectCard: [0, 1],
                                check(card) {
                                    var list = game.filterPlayer(function (current) {
                                        return current.hasSkill('miniwengua') && !current.hasSkill('miniwengua3');
                                    });
                                    list.sort(function (a, b) {
                                        var p = _status.event.player;
                                        return get.attitude(p, b) - get.attitude(p, a);
                                    });
                                    if (get.type2(card) == 'trick' && (list[0].isDamaged() || list[0].maxHp < 5)) return 10;
                                    if (card.name == 'sha') return 5;
                                    return 8 - get.value(card);
                                },
                                filterOk() {
                                    return ui.selected.targets.length && ui.selected.cards.length;
                                },
                                direct: true,
                                delay: false,
                                discard: false,
                                lose: false,
                                position: 'he',
                                content() {
                                    'step 0'
                                    target.logSkill('miniwengua', player);
                                    target.addTempSkill('miniwengua3', 'phaseUseAfter');
                                    if (target != player) player.give(cards, target);
                                    player.showCards(cards, get.translation(player) + '发动了【问卦】');
                                    'step 1'
                                    var card = cards[0];
                                    if (get.type2(card) == 'trick') {
                                        if (target.maxHp < 5) target.gainMaxHp();
                                        target.recover();
                                    }
                                    'step 2'
                                    var choiceList = [
                                        '将' + get.translation(cards[0]) + '置于牌堆顶',
                                        '将' + get.translation(cards[0]) + '置于牌堆底'
                                    ];
                                    if (target != player) choiceList.push('将' + get.translation(cards[0]) + '留给自己');
                                    if (target.getCards('he').includes(cards[0])) {
                                        target.chooseControl().set('choiceList', choiceList).set('ai', () => target != player && get.attitude(target, player) < 0 ? 2 : 1);
                                    }
                                    else event.finish();
                                    'step 3'
                                    event.index = result.index;
                                    if (event.index == 0 || event.index == 1) {
                                        var next = event.target.lose(cards[0], ui.cardPile);
                                        if (event.index == 0) next.insert_card = true;
                                        target.$throw(cards, 1000);
                                    }
                                    else event.finish();
                                    'step 4'
                                    game.delayx();
                                    'step 5'
                                    if (event.index == 1) {
                                        game.log(target, '将', cards, '置于', '#y牌堆底');
                                        if (player == target) player.draw('nodelay');
                                        else game.asyncDraw([player, target], null, null);
                                    }
                                    else {
                                        game.log(target, '将', cards, '置于', '#g牌堆顶');
                                        if (player == target) player.draw('nodelay', 'bottom');
                                        else game.asyncDraw([player, target], null, null, true);
                                    }
                                },
                                ai: {
                                    order: 9,
                                    result: { target: 1 },
                                },
                            },
                            miniwengua3: { charlotte: true },
                            minifuzhu: {
                                audio: 'fuzhu',
                                inherit: 'fuzhu',
                                filter(event, player) {
                                    return event.player != player && ui.cardPile.childElementCount <= player.maxHp * 10;
                                },
                                onWash() {
                                    _status.event.getParent('minifuzhu').washed = false;
                                    return 'remove';
                                },
                                content() {
                                    'step 0'
                                    event.washed = false;
                                    lib.onwash.push(lib.skill.minifuzhu.onWash);
                                    event.total = game.countPlayer2();
                                    'step 1'
                                    event.total--;
                                    var card = get.cardPile2(function (card) {
                                        return card.name == 'sha' && player.canUse(card, trigger.player, false);
                                    });
                                    if (card) {
                                        card.remove();
                                        game.updateRoundNumber();
                                        player.useCard(card, trigger.player, false);
                                    }
                                    'step 2'
                                    if (event.total > 0 && !event.washed && ui.cardPile.childElementCount <= player.maxHp * 10 && trigger.player.isIn()) event.goto(1);
                                    else lib.onwash.remove(lib.skill.minifuzhu.onWash);
                                    'step 3'
                                    var cards = get.cards(ui.cardPile.childElementCount + 1);
                                    for (var i = 0; i < cards.length; i++) {
                                        ui.cardPile.insertBefore(cards[i], ui.cardPile.childNodes[get.rand(ui.cardPile.childElementCount)]);
                                    }
                                    game.updateRoundNumber();
                                },
                            },
                            minihongde: {
                                group: 'minihongde_hongde',
                                audio: 'hongde',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                frequent: true,
                                filter(event, player) {
                                    if (event.name == 'gain' && event.player == player) return false;
                                    var evt = event.getl(player);
                                    return evt?.cards2?.length > 0;
                                },
                                usable: 2,
                                frequent: true,
                                content() {
                                    player.draw();
                                },
                                subSkill: {
                                    hongde: {
                                        trigger: { player: 'gainAfter' },
                                        filter(event, player) {
                                            return event.cards?.length > 1;
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('minihongde'), '令一名其他角色摸一张牌', lib.filter.notMe).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.attitude(player, target);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                var target = result.targets[0]
                                                player.logSkill('minihongde', target);
                                                target.draw();
                                            }
                                        },
                                    },
                                },
                            },
                            minidingpan: {
                                audio: 'dingpan',
                                inherit: 'dingpan',
                                filter(event, player) {
                                    return (player.getStat().skill.minidingpan || 0) < game.countGroup();
                                },
                            },
                            minijueyan: {
                                derivation: 'minirejizhi',
                                audio: 'drlt_jueyan',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return Array.from({ length: 4 }).map((_, i) => i + 1).some(i => player.hasEnabledSlot(i));
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    var list = [];
                                    for (var i = 1; i <= 4; i++) {
                                        if (player.hasEnabledSlot(i)) list.push('equip' + i);
                                    }
                                    if (list.includes('equip3') && list.includes('equip4')) list.push('equip3_4');
                                    list.remove('equip3');
                                    list.remove('equip4');
                                    player.chooseControl(list).set('ai', function () {
                                        var player = _status.event.player;
                                        if (list.includes('equip2')) return 'equip2';
                                        if (list.includes('equip1') && (player.countCards('h', function (card) {
                                            return get.name(card, player) == 'sha' && player.hasUseTarget(card);
                                        }) - player.getCardUsable('sha')) > 1) return 'equip1';
                                        if (list.includes('equip3_4') && player.countCards('h', function (card) {
                                            return get.type2(card, player) == 'trick' && player.hasUseTarget(card, false);
                                        }) > 1) return 'equip3_4';
                                    }).set('prompt', '决堰：请选择你要废除的装备栏');
                                    'step 1'
                                    if (result.control == 'equip3_4') {
                                        player.disableEquip(3, 4);
                                        player.recover();
                                        player.addTempSkills('minirejizhi');
                                    }
                                    else player.disableEquip(result.control);
                                    if (result.control == 'equip2') player.draw(3);
                                    player.addTempSkill(['drlt_jueyan1', 'drlt_jueyan3', 'drlt_jueyan2'][['equip1', 'equip2', 'equip3_4'].indexOf(result.control)]);
                                },
                                ai: {
                                    order: 13,
                                    result: {
                                        player(player) {
                                            if (!player.isDisabled('equip2')) return 1;
                                            if (!player.isDisabled('equip1') && (player.countCards('h', function (card) {
                                                return get.name(card, player) == 'sha' && player.hasValueTarget(card);
                                            }) - player.getCardUsable('sha')) > 1) return 1;
                                            if ((player.hasEnabledSlot(3) && player.hasEnabledSlot(4)) && player.countCards('h', function (card) {
                                                return get.type2(card, player) == 'trick' && player.hasUseTarget(card, false);
                                            }) > 1) return 1;
                                            return -1;
                                        },
                                    },
                                },
                            },
                            minihuairou: {
                                audio: 'drlt_huairou',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    var list = [], bool = false;
                                    for (var i = 1; i <= 5; i++) {
                                        if (!player.hasEnabledSlot(i)) list.push('equip' + i);
                                    }
                                    for (var name of lib.inpile) {
                                        if (get.type(name) != 'basic' && get.type2(name) != 'trick') continue;
                                        var storage = player.getStorage('minihuairou_used');
                                        if (!storage.includes(name)) {
                                            bool = true;
                                            break;
                                        }
                                    }
                                    return bool && player.countCards('he', function (card) {
                                        return list.includes(get.subtype(card));
                                    });
                                },
                                filterCard(card, player) {
                                    var list = [];
                                    for (var i = 1; i <= 5; i++) {
                                        if (!player.hasEnabledSlot(i)) list.push('equip' + i);
                                    }
                                    return get.type(card) == 'equip' && list.includes(get.subtype(card));
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    if (player.isDisabled(get.subtype(card))) return 5;
                                    return 6 - get.value(card);
                                },
                                position: 'he',
                                discard: false,
                                visible: true,
                                loseTo: 'discardPile',
                                delay: 0.5,
                                prepare(cards, player) {
                                    player.addTempSkill('minihuairou_used');
                                    player.$throw(cards, 1000);
                                    game.log(player, '将', cards, '置入了弃牌堆');
                                },
                                content() {
                                    'step 0'
                                    var list = [];
                                    for (var name of lib.inpile) {
                                        if (get.type(name) != 'basic' && get.type2(name) != 'trick') continue;
                                        var storage = player.getStorage('minihuairou_used');
                                        if (!storage.includes(name)) {
                                            list.push([get.translation(get.type2({ name: name })), '', name]);
                                            if (name == 'sha') {
                                                for (var nature of lib.inpile_nature) list.push(['基本', '', name, nature]);
                                            }
                                        }
                                    }
                                    player.chooseButton(['怀柔：选择获得一种基本牌或锦囊牌', [list, 'vcard']], true);
                                    'step 1'
                                    player.markAuto('minihuairou_used', [result.links[0][2]]);
                                    var card = get.cardPile(function (card) {
                                        return card.name == result.links[0][2] && (get.nature(card) == result.links[0][3] || !result.links[0][3]);
                                    });
                                    if (card) player.gain(card, 'gain2');
                                    else {
                                        player.popup('杯具');
                                        game.log('但是牌堆中已经没有', '#y' + get.translation(result.links[0][2]), '了！')
                                    }
                                },
                                ai: {
                                    order: 10,
                                    result: { player: 1 },
                                },
                                subSkill: { used: { charlotte: true, onremove: true } },
                            },
                            miniyanxiao: {
                                audio: 'yanxiao',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he', { suit: 'diamond' }) && game.hasPlayer(function (target) {
                                        return target.canAddJudge({ name: 'miniyanxiao_card' });
                                    });
                                },
                                filterTarget(card, player, target) {
                                    return target.canAddJudge({ name: 'miniyanxiao_card' });
                                },
                                filterCard: { suit: 'diamond' },
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                position: 'he',
                                discard: false,
                                lose: false,
                                delay: false,
                                prepare: 'give',
                                content() {
                                    'step 0'
                                    game.addGlobalSkill('miniyanxiao_global');
                                    target.addJudge({ name: 'miniyanxiao_card' }, cards);
                                    'step 1'
                                    game.delayx();
                                },
                                ai: {
                                    order: 8,
                                    result: {
                                        target(player, target) {
                                            if (target.countCards('j', function (card) {
                                                return get.effect(target, {
                                                    name: card.viewAs || card.name,
                                                    cards: [card],
                                                }, target, target) < 0;
                                            })) return 3;
                                            return 1;
                                        },
                                    },
                                },
                                subSkill: {
                                    global: {
                                        audio: 'yanxiao',
                                        forceaudio: true,
                                        trigger: { player: 'phaseJudgeBegin' },
                                        filter(event, player) {
                                            return player.countCards('j') && player.hasJudge('miniyanxiao_card');
                                        },
                                        forced: true,
                                        content() {
                                            'step 0'
                                            player.gain(player.getCards('j'), 'gain2');
                                            player.judge();
                                            'step 1'
                                            if (result.color == 'red') player.draw();
                                            else player.addTempSkill('miniyanxiao_sha');
                                        },
                                        ai: {
                                            effect: {
                                                target(card, player, target) {
                                                    if (get.type(card) == 'delay' && target.hasJudge('miniyanxiao_card')) return [0, 0, 0, 0.1];
                                                },
                                            },
                                        },
                                    },
                                    sha: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: '+1',
                                        intro: { content: '出【杀】次数+1' },
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + 1;
                                            },
                                        },
                                    },
                                },
                            },
                            minianxian: {
                                audio: 'anxian',
                                group: 'minianxian_target',
                                trigger: { player: 'useCardToPlayer' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.target.countCards('h') && !event.card.minianxian;
                                },
                                check(event, player) {
                                    return get.attitude(player, event.target) <= 0;
                                },
                                prompt2(event, player) {
                                    return '令' + get.translation(event.target) + '弃置一张手牌';
                                },
                                logTarget: 'target',
                                content() {
                                    trigger.target.chooseToDiscard('h', true);
                                },
                                subSkill: {
                                    target: {
                                        trigger: { target: 'useCardToTarget' },
                                        filter(event, player) {
                                            return event.card.name == 'sha' && player.countCards('h');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseToDiscard(get.prompt('minianxian'), '弃置一张手牌令' + get.translation(trigger.card) + '对你无效，然后' + get.translation(trigger.player) + '摸一张牌' + (player.canUse({ name: 'sha', isCard: true }, trigger.player, false) ? '，若你弃置了方片花色的牌，则你视为对' + get.translation(trigger.player) + '使用一张不触发〖安娴〗的【杀】' : '')).set('ai', function (card) {
                                                var player = _status.event.player;
                                                var trigger = _status.event.getTrigger();
                                                if (get.suit(card) == 'diamond' && player.canUse({ name: 'sha', isCard: true }, trigger.player, false)) return get.attitude(player, trigger.player) > 0 ? 0 : 9 - get.value(card);
                                                return 6 - get.value(card);
                                            }).logSkill = ['minianxian', trigger.player];
                                            'step 1'
                                            if (result.bool) {
                                                trigger.player.draw();
                                                trigger.getParent().excluded.push(player);
                                                if (get.suit(result.cards[0], player) == 'diamond') {
                                                    var card = { name: 'sha', isCard: true };
                                                    if (player.canUse(card, trigger.player, false)) player.useCard(card, trigger.player).card.minianxian = true;
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            minicanshi: {
                                audio: 'canshi',
                                trigger: { player: 'phaseDrawBegin2' },
                                check(event, player) {
                                    if (player.skipList.includes('phaseUse') || !player.countCards('h', function (card) {
                                        return get.type2(card) == 'trick' && player.hasUseTarget(card);
                                    })) return true;
                                    var num = game.countPlayer(function (current) {
                                        if (player.hasSkill('guiming') && current.group == 'wu') return true;
                                        return current.isDamaged();
                                    });
                                    return num > 1;
                                },
                                prompt(event, player) {
                                    var num = game.countPlayer(function (current) {
                                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                                        return current.isDamaged();
                                    });
                                    return get.prompt('minicanshi') + '（可多摸' + get.cnNumber(num) + '张牌，且本回合使用【杀】须弃置一张牌）';
                                },
                                filter(event, player) {
                                    return !event.numFixed && game.hasPlayer(function (current) {
                                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                                        return current.isDamaged();
                                    });
                                },
                                content() {
                                    var num = game.countPlayer(function (current) {
                                        if (player.hasSkill('guiming') && current.group == 'wu' && current != player) return true;
                                        return current.isDamaged();
                                    });
                                    if (num > 0) trigger.num += num;
                                    player.addTempSkill('minicanshi2');
                                },
                            },
                            minicanshi2: {
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    if (!player.countCards('he')) return false;
                                    return event.card.name == 'sha';
                                },
                                forced: true,
                                autodelay: true,
                                content() {
                                    player.chooseToDiscard(true, 'he');
                                },
                            },
                            minichouhai: {
                                audio: 'chouhai',
                                trigger: { player: 'damageBegin3' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && !player.countCards('he');
                                },
                                forced: true,
                                content() {
                                    trigger.num++;
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (card.name == 'sha' && !target.countCards('he')) return [1, -2];
                                        },
                                    },
                                },
                            },
                            miniguolun: {
                                audio: 'xinfu_guolun',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('h');
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.choosePlayerCard(target, true, 'h');
                                    'step 1'
                                    event.cardt = result.cards[0];
                                    target.showCards(event.cardt);
                                    player.chooseCard('he').set('ai', function (card) {
                                        var event = _status.event.getParent(), player = event.player;
                                        var numt = get.number(event.cardt);
                                        var att = get.attitude(player, target);
                                        var value = get.value(event.cardt);
                                        var num = get.number(card);
                                        if (num < numt || att > 2) return value + 6 - get.value(card);
                                        else if (num == numt) return value - get.value(card);
                                        return -1;
                                    });
                                    'step 2'
                                    if (!result.bool) event.finish();
                                    else {
                                        player.showCards(result.cards);
                                        event.cardp = result.cards[0];
                                    }
                                    'step 3'
                                    player.swapHandcards(target, [event.cardp], [event.cardt]);
                                    'step 4'
                                    var nump = get.number(event.cardp, player);
                                    var numt = get.number(event.cardt, target);
                                    if (nump < numt) {
                                        player.draw(2);
                                    }
                                    else if (nump > numt) {
                                        target.draw();
                                        player.recover();
                                    }
                                },
                                ai: {
                                    order: 8,
                                    result: {
                                        player(player, target) {
                                            if (get.attitude(player, target) > 0) return 1.5;
                                            return 0.5;
                                        },
                                    },
                                },
                            },
                            minisongsang: {
                                audio: 'xinfu_songsang',
                                inherit: 'gongao',
                            },
                            minizhente: {
                                audio: 'zhente',
                                inherit: 'zhente',
                                filter(event, player) {
                                    var color = get.color(event.card);
                                    if (player == event.player || event.player.isDead() || color == 'none') return false;
                                    var type = get.type(event.card);
                                    return type == 'basic' || type == 'trick';
                                },
                                usable: Infinity,
                            },
                            minizhiwei: {
                                audio: 'zhiwei',
                                trigger: { global: 'phaseBefore', player: ['enterGame', 'phaseZhunbeiBegin'] },
                                filter(event, player, name) {
                                    if (game.countPlayer() < 2) return false;
                                    return (name != 'phaseBefore' || game.phaseNumber == 0) && !player.hasSkill('minizhiwei2');
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget('请选择【至微】的目标', '选择一名其他角色。该角色造成伤害后，你摸一张牌，该角色受到伤害后，你可以交给其一张牌。你弃牌阶段弃置的牌可以交给该角色。', true, lib.filter.notMe).set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (att > 0) return 1 + att;
                                        return Math.random();
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line('minizhiwei', target);
                                        player.storage.minizhiwei2 = target;
                                        player.addSkill('minizhiwei2');
                                    }
                                },
                            },
                            minizhiwei2: {
                                group: ['minizhiwei2_draw', 'minizhiwei2_discard', 'minizhiwei2_gain', 'minizhiwei2_clear'],
                                charlotte: true,
                                onremove: true,
                                mark: 'character',
                                intro: { content: '$造成伤害后你摸一张牌；$受到伤害后你可以交给其一张牌；你于弃牌阶段弃置牌后可以交给$' },
                                subSkill: {
                                    draw: {
                                        audio: 'zhiwei',
                                        trigger: { global: 'damageSource' },
                                        filter(event, player) {
                                            return event.source == player.storage.minizhiwei2;
                                        },
                                        forced: true,
                                        logTarget: 'source',
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    discard: {
                                        trigger: { global: 'damageEnd' },
                                        filter(event, player) {
                                            return event.player == player.storage.minizhiwei2 && player.countCards('h');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            var target = player.storage.minizhiwei2;
                                            event.target = target;
                                            player.chooseCard('h', '至微：是否将一张手牌交给' + get.translation(target) + '？').set('ai', function (card) {
                                                if (_status.event.goon) return 5 - get.value(card);
                                                return -get.value(card);
                                            }).set('goon', get.attitude(player, target) > 0);
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('minizhiwei', target);
                                                target.gain(result.cards, player, 'giveAuto');
                                            }
                                        },
                                    },
                                    gain: {
                                        audio: 'zhiwei',
                                        trigger: { player: 'loseAfter', global: 'loseAsyncAfter' },
                                        filter(event, player) {
                                            if (event.type != 'discard' || event.getlx === false || event.getParent('phaseDiscard').player != player || !player.storage.minizhiwei2 || !player.storage.minizhiwei2.isIn()) return false;
                                            var evt = event.getl(player);
                                            return evt?.cards2.someInD('d');
                                        },
                                        logTarget(event, player) {
                                            return player.storage.minizhiwei2;
                                        },
                                        check(event, player) {
                                            return get.attitude(player, player.storage.minizhiwei2) > 0;
                                        },
                                        prompt: (event, player) => '是否对' + get.translation(player.storage.minizhiwei2) + '发动【至微】？',
                                        prompt2: (event, player) => '将' + get.translation(event.getl(player).cards2.filterInD('d')) + '交给' + get.translation(player.storage.minizhiwei2),
                                        content() {
                                            if (trigger.delay === false) game.delay();
                                            player.storage.minizhiwei2.gain(trigger.getl(player).cards2.filterInD('d'), 'gain2');
                                        },
                                    },
                                    clear: {
                                        audio: 'zhiwei',
                                        trigger: { global: 'die' },
                                        filter(event, player) {
                                            return event.player == player.storage.minizhiwei2;
                                        },
                                        forced: true,
                                        content() {
                                            player.removeSkill('minizhiwei2');
                                        },
                                    },
                                },
                            },
                            //朱桓
                            minifenli: {
                                audio: 'fenli',
                                trigger: { player: ['phaseJudgeBefore', 'phaseUseBefore', 'phaseDiscardBefore'] },
                                filter(event, player) {
                                    switch (event.name) {
                                        case 'phaseJudge': return player.isMaxHandcard(); break;
                                        case 'phaseUse': return player.isMaxHp(); break;
                                        case 'phaseDiscard': return player.isMaxEquip(); break;
                                    }
                                    return false;
                                },
                                check(event, player) {
                                    switch (event.name) {
                                        case 'phaseJudge': {
                                            if (player.hasJudge('lebu') || player.hasJudge('bingliang')) return true;
                                            if (player.getHistory('skipped').length > 0) return false;
                                            return game.hasPlayer(function (current) {
                                                return get.attitude(player, current) < 0 && current.hp == 1 && get.damageEffect(current, player, player) > 0;
                                            });
                                            break;
                                        }
                                        case 'phaseUse': {
                                            if (!player.needsToDiscard() || (player.countCards('e') && player.isMaxEquip())) return true;
                                            if (player.getHistory('skipped').length > 0) return false;
                                            return game.hasPlayer(function (current) {
                                                return get.attitude(player, current) < 0 && current.hp == 1 && get.damageEffect(current, player, player) > 0;
                                            });
                                            break;
                                        }
                                        case 'phaseDiscard': {
                                            return true;
                                            break;
                                        }
                                    }
                                    return false;
                                },
                                prompt(event, player) {
                                    return get.prompt('minifenli') + '（可跳过' + get.translation(event.name) + (event.name == 'phaseJudge' ? '和摸牌阶段' : '') + '）';
                                },
                                content() {
                                    trigger.cancel();
                                    game.log(player, '跳过了', '#y' + get.translation(trigger.name));
                                    if (trigger.name == 'phaseJudge') {
                                        player.skip('phaseDraw');
                                        game.log(player, '跳过了', '#y摸牌阶段');
                                    }
                                },
                            },
                            minipingkou: {
                                audio: 'pingkou',
                                trigger: { player: 'phaseEnd' },
                                filter(event, player) {
                                    return player.getHistory('skipped').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget([1, player.getHistory('skipped').length], get.prompt2('minipingkou'), lib.filter.notMe).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.damageEffect(target, player, player) * (target.countCards('e') ? 2 : 1);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        event.targets = targets;
                                        player.logSkill('minipingkou', targets);
                                        for (var i of targets) i.damage();
                                        if (targets.length == player.getHistory('skipped').length || !game.hasPlayer(function (current) {
                                            return current.countGainableCards(player, 'e') && targets.includes(current);
                                        })) event.finish();
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.chooseTarget('请选择一名目标角色，获得其装备区中的一张牌', true, function (card, player, target) {
                                        return target.countGainableCards(player, 'e') && _status.event.targets.includes(target);
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return 1 + Math.random() - get.attitude(player, target);
                                    }).set('targets', targets);
                                    'step 3'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        player.gainPlayerCard(target, 'e', true);
                                    }
                                },
                                ai: {
                                    combo: 'minifenli',
                                    effect: {
                                        target(card) {
                                            if (card.name == 'lebu' || card.name == 'bingliang') return 0.5;
                                        },
                                    },
                                },
                            },
                            //严畯
                            miniguanchao: {
                                audio: 'xinfu_guanchao',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var list = ['递增', '递减', '取消'];
                                    player.chooseControl(list).set('prompt', get.prompt2('miniguanchao')).set('ai', function () {
                                        return [0, 1].randomGet();
                                    }).set('choiceList', [
                                        '使用【杀】的次数上限+1，使用牌严格递增摸一张牌',
                                        '计算与其他角色之间的距离-1，使用牌严格递减摸一张牌'
                                    ]);
                                    'step 1'
                                    switch (result.control) {
                                        case '递增': {
                                            player.logSkill('miniguanchao');
                                            player.addTempSkill('miniguanchao_dizeng');
                                            break;
                                        }
                                        case '递减': {
                                            player.logSkill('miniguanchao');
                                            player.addTempSkill('miniguanchao_dijian');
                                            break;
                                        }
                                        case '取消': {
                                            break;
                                        }
                                    }
                                },
                                subSkill: {
                                    dizeng: {
                                        mark: true,
                                        marktext: '增',
                                        intro: { content: '使用【杀】的次数上限+1，使用牌严格递增摸一张牌' },
                                        trigger: { player: 'useCard' },
                                        audio: 'xinfu_guanchao',
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha') return num + 1;
                                            },
                                            aiOrder(player, card, num) {
                                                if (typeof card.number != 'number') return;
                                                var history = player.getHistory('useCard');
                                                if (history.length == 0) return num + 10 * (14 - card.number);
                                                var num = get.number(history[0].card);
                                                if (!num) return;
                                                for (var i = 1; i < history.length; i++) {
                                                    var num2 = get.number(history[i].card);
                                                    if (!num2 || num2 <= num) return;
                                                    num = num2;
                                                }
                                                if (card.number > num) return num + 10 * (14 - card.number);
                                            },
                                        },
                                        filter(event, player) {
                                            var history = player.getHistory('useCard');
                                            if (history.length < 2) return false;
                                            var num = get.number(history[0].card);
                                            if (!num) return false;
                                            for (var i = 1; i < history.length; i++) {
                                                var num2 = get.number(history[i].card);
                                                if (!num2 || num2 <= num) return false;
                                                num = num2;
                                            }
                                            return true;
                                        },
                                        forced: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    dijian: {
                                        mark: true,
                                        marktext: '减',
                                        intro: { content: '计算与其他角色之间的距离-1，使用牌严格递减摸一张牌' },
                                        trigger: { player: 'useCard' },
                                        audio: 'xinfu_guanchao',
                                        mod: {
                                            globalFrom(from, to, distance) {
                                                return distance - 1;
                                            },
                                            aiOrder(player, card, num) {
                                                if (typeof card.number != 'number') return;
                                                var history = player.getHistory('useCard');
                                                if (history.length == 0) return num + 10 * card.number;
                                                var num = get.number(history[0].card);
                                                if (!num) return;
                                                for (var i = 1; i < history.length; i++) {
                                                    var num2 = get.number(history[i].card);
                                                    if (!num2 || num2 >= num) return;
                                                    num = num2;
                                                }
                                                if (card.number < num) return num + 10 * card.number;
                                            },
                                        },
                                        filter(event, player) {
                                            var history = player.getHistory('useCard');
                                            if (history.length < 2) return false;
                                            var num = get.number(history[0].card);
                                            if (!num) return false;
                                            for (var i = 1; i < history.length; i++) {
                                                var num2 = get.number(history[i].card);
                                                if (!num2 || num2 >= num) return false;
                                                num = num2;
                                            }
                                            return true;
                                        },
                                        forced: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            minixunxian: {
                                audio: 'xinfu_xunxian',
                                trigger: { global: 'cardsDiscardAfter' },
                                filter(event, player) {
                                    if (!event.cards.filterInD('d').length) return false;
                                    var evt = event.getParent();
                                    if (evt.name != 'orderingDiscard') return false;
                                    var evtx = (evt.relatedEvent || evt.getParent());
                                    if (evtx.player != player) return false;
                                    return player.hasHistory('lose', function (evtxx) {
                                        return evtx == (evtxx.relatedEvent || evtxx.getParent()) && evtxx.cards2.length;
                                    });
                                },
                                usable: 1,
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minixunxian'), '令一名其他角色获得' + get.translation(trigger.cards.filterInD('d')), lib.filter.notMe).set('ai', function (target) {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        if (att < 3) return 0;
                                        if (target.hasJudge('lebu')) att /= 5;
                                        if (target.hasSha() && _status.event.sha) att /= 5;
                                        if (_status.event.wuxie && target.needsToDiscard(1)) att /= 5;
                                        return att / (1 + get.distance(player, target, 'absolute'));
                                    }).set('sha', trigger.cards.filterInD('d').filter(function (card) {
                                        return card.name == 'sha';
                                    }).length).set('wuxie', trigger.cards.filterInD('d').filter(function (card) {
                                        return card.name == 'wuxie';
                                    }).length);
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minixunxian', target);
                                        target.gain(trigger.cards.filterInD('d'), 'gain2');
                                    }
                                    else player.storage.counttrigger.minixunxian--;
                                },
                                ai: { expose: 0.25 },
                            },
                            //孙翊
                            minisyxiongyi: {
                                derivation: ['minihunzi_old', 'reyingzi', 'miniyinghun'],
                                audio: 'syxiongyi',
                                skillAnimation: true,
                                animationColor: 'wood',
                                limited: true,
                                enable: 'chooseToUse',
                                filter(event, player) {
                                    if (event.type != 'dying') return false;
                                    if (player != event.dying) return false;
                                    return true;
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill('minisyxiongyi');
                                    if (!_status.characterlist) lib.skill.pingjian.initList();
                                    if (_status.characterlist.includes('Mbaby_xushi')) {
                                        if (player.name2 && get.character(player.name2)[3].includes('minisyxiongyi')) {
                                            await player.reinitCharacter(player.name2, 'Mbaby_xushi');
                                        }
                                        else await player.reinitCharacter(player.name1, 'Mbaby_xushi');
                                        if (player.hp < 3) await player.recover(3 - player.hp);
                                    }
                                    else {
                                        await player.addSkills('minihunzi_old');
                                        if (player.hp < 1) await player.recover(1 - player.hp);
                                    }
                                },
                                ai: {
                                    order: 1,
                                    save: true,
                                    skillTagFilter(player, arg, target) {
                                        return player == target;
                                    },
                                    result: { player: 10 },
                                },
                            },
                            //璇天帝
                            minishezang: {
                                audio: 'shezang',
                                inherit: 'shezang',
                                round: 0,
                                usable: 1,
                            },
                            //托尼
                            miniyoudi: {
                                audio: 'xinfu_youdi',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('miniyoudi'), function (card, player, target) {
                                        return player != target;
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        if (player.countCards('h', 'sha') > player.countCards('h') / 3 && player.countCards('h', { color: 'red' }) > player.countCards('h') / 2) return 0;
                                        if (target.countCards('he') == 0) return 0.1;
                                        return -get.attitude(_status.event.player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        game.delay();
                                        player.logSkill('miniyoudi', result.targets);
                                        event.target = result.targets[0];
                                        event.target.discardPlayerCard(player, 'h', true);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.links[0].name != 'sha' && event.target.countCards('he')) {
                                        player.gainPlayerCard('he', event.target, true);
                                        player.draw();
                                    }
                                    if (get.color(result.links[0]) != 'black' && player.maxHp < 5) player.gainMaxHp();
                                },
                                ai: { expose: 0.25 },
                            },
                            //朱自清の父亲
                            minizhenglun: {
                                audio: 'nzry_zhenglun',
                                trigger: { player: 'phaseDrawBegin2' },
                                filter(event, player) {
                                    if (event.numFixed) return false;
                                    return !player.hasMark('nzry_huaiju');
                                },
                                content() {
                                    trigger.num--;
                                    player.addMark('nzry_huaiju', 1);
                                },
                                ai: { combo: 'nzry_huaiju' },
                            },
                            //孙登
                            minikuangbi: {
                                group: ['minikuangbi_gain', 'minikuangbi_effect'],
                                audio: 'kuangbi',
                                enable: 'phaseUse',
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('he') > 0;
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    target.chooseCard('he', [1, 3], '匡弼：将至多三张牌置于' + get.translation(player) + '的武将牌上', true).set('ai', function (card) {
                                        if (get.attitude(_status.event.player, _status.event.getParent().player) > 0) {
                                            return 7 - get.value(card);
                                        }
                                        return -get.value(card);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        event.num = result.cards.length;
                                        player.addToExpansion(result.cards, target, 'give').gaintag.add('minikuangbi');
                                        player.chooseBool('匡弼：是否令' + get.translation(target) + '摸' + get.cnNumber(event.num) + '张牌？').set('choice', get.attitude(player, target) > 0);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        player.line(target);
                                        target.draw(num);
                                    }
                                },
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    player.removeGaintag(skill);
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        player: 1,
                                        target(player, target) {
                                            if (get.attitude(player, target) > 0) {
                                                return Math.sqrt(target.countCards('he'));
                                            }
                                            return 0;
                                        },
                                    },
                                },
                                subSkill: {
                                    gain: {
                                        audio: 'kuangbi',
                                        trigger: { player: 'phaseZhunbeiBegin' },
                                        filter(event, player) {
                                            return player.getExpansions('minikuangbi').length;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.gain(player.getExpansions('minikuangbi'), 'gain2').gaintag.add('minikuangbi');
                                        },
                                    },
                                    effect: {
                                        audio: 'kuangbi',
                                        trigger: {
                                            player: 'loseAfter',
                                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                        },
                                        filter(event, player) {
                                            var evt = event.getl(player);
                                            if (!evt || !evt.hs || !evt.hs.length) return false;
                                            if (player.countCards('h', function (card) {
                                                return card.hasGaintag('minikuangbi');
                                            })) return false;
                                            if (event.name == 'lose') {
                                                for (var i in event.gaintag_map) {
                                                    if (event.gaintag_map[i].includes('minikuangbi')) return true;
                                                }
                                                return false;
                                            }
                                            return player.hasHistory('lose', function (evt) {
                                                if (event != evt.getParent()) return false;
                                                for (var i in evt.gaintag_map) {
                                                    if (evt.gaintag_map[i].includes('minikuangbi')) return true;
                                                }
                                                return false;
                                            });
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.draw();
                                            player.recover();
                                        },
                                    },
                                },
                            },
                            //潘濬
                            miniguanwei: {
                                audio: 'xinfu_guanwei',
                                trigger: { global: 'phaseUseEnd' },
                                filter(event, player) {
                                    var map = {};
                                    event.player.getHistory('useCard', function (evt) {
                                        if (evt.getParent('phaseUse') == event) {
                                            var suit = get.suit(evt.card, event.player);
                                            if (!map[suit]) map[suit] = 1;
                                            else map[suit]++;
                                        }
                                    });
                                    for (var i in map) {
                                        if (map[i] > 1) return true;
                                    }
                                    return false;
                                },
                                direct: true,
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard(get.prompt('miniguanwei', trigger.player), '弃置一张牌，令其摸两张牌并进行一个额外的出牌阶段', 'he').set('ai', function (card) {
                                        if (get.attitude(_status.event.player, _status.currentPhase) <= 0) return 0;
                                        return 9 - get.value(card);
                                    }).set('logSkill', 'miniguanwei');
                                    'step 1'
                                    if (result.bool) {
                                        if (trigger.player != player) player.addExpose(0.5);
                                        player.line(trigger.player, 'green');
                                        trigger.player.draw(2);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var next = trigger.player.phaseUse();
                                    event.next.remove(next);
                                    trigger.getParent('phase').next.push(next);
                                },
                            },
                            minigongqing: {
                                audio: 'xinfu_gongqing',
                                trigger: { player: 'damageBegin4' },
                                filter(event, player, name) {
                                    if (!event.source) return false;
                                    var num = event.source.getAttackRange();
                                    if (num < 3) return event.num > 1;
                                    return true;
                                },
                                preHidden: true,
                                forced: true,
                                content() {
                                    var range = trigger.source.getAttackRange();
                                    if (range < 3 && trigger.num > 1) trigger.num = 1;
                                    if (range >= 3) player.draw();
                                },
                                ai: {
                                    filterDamage: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg?.player) {
                                            if (arg.player.hasSkillTag('jueqing', false, player)) return false;
                                            if (arg.player.getAttackRange() < 3) return true;
                                        }
                                        return false;
                                    }
                                },
                            },
                            //丁奉
                            miniduanbing: {
                                audio: 'duanbing',
                                group: 'miniduanbing_sha',
                                preHidden: ['miniduanbing_sha'],
                                inherit: 'reduanbing',
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('miniduanbing'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                                        return !_status.event.sourcex.includes(target) && get.distance(player, target) <= 1 && player.canUse(_status.event.card, target);
                                    }).set('sourcex', trigger.targets).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.effect(target, _status.event.card, player, player);
                                    }).set('card', trigger.card).setHiddenSkill(event.name);
                                    'step 1'
                                    if (result.bool) {
                                        if (!event.isMine() && !event.isOnline()) game.delayx();
                                        event.targets = result.targets;
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.logSkill('miniduanbing', targets);
                                    trigger.targets.addArray(targets);
                                },
                                subSkill: {
                                    sha: {
                                        audio: 'duanbing',
                                        audioname: ['heqi'],
                                        trigger: { player: 'useCardToPlayered' },
                                        forced: true,
                                        filter(event, player) {
                                            if (player.getHistory('useCard', evt => evt.card.name == 'sha').indexOf(event.getParent()) != 0) return false;
                                            return event.card.name == 'sha' && !event.getParent().directHit.includes(event.target) && get.distance(player, event.target) <= 1;
                                        },
                                        logTarget: 'target',
                                        content() {
                                            var id = trigger.target.playerid;
                                            var map = trigger.getParent().customArgs;
                                            if (!map[id]) map[id] = {};
                                            if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                                            else map[id].shanRequired = 2;
                                        },
                                        ai: {
                                            directHit_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                if (arg.card.name != 'sha' || arg.target.countCards('h', 'shan') > 1 || player.getHistory('useCard', evt => evt.card.name == 'sha').length || get.distance(player, arg.target) > 1) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minifenxun: {
                                group: 'minifenxun_draw',
                                audio: 'fenxun',
                                inherit: 'refenxun',
                                content() {
                                    player.addTempSkill('minifenxun2');
                                    player.markAuto('minifenxun2', targets);
                                },
                                subSkill: {
                                    draw: {
                                        audio: 'fenxun',
                                        trigger: { player: 'phaseEnd' },
                                        filter(event, player) {
                                            return game.hasPlayer(current => get.distance(player, current) <= 1 && current.getHistory('damage').length);
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.draw(game.filterPlayer(current => get.distance(player, current) <= 1 && current.getHistory('damage').length).reduce((sum, target) => {
                                                return sum + target.getHistory('damage').reduce((num, evt) => num + evt.num, 0);
                                            }, 0));
                                        },
                                    },
                                },
                            },
                            minifenxun2: {
                                charlotte: true,
                                onremove: true,
                                mod: {
                                    globalFrom(from, to) {
                                        if (from.getStorage('minifenxun2').includes(to)) return -Infinity;
                                    },
                                },
                            },
                            //薛综
                            minifunan: {
                                audio: 'funan',
                                trigger: { global: ['useCard', 'respond'] },
                                filter(event, player) {
                                    if (!event.respondTo) return false;
                                    if (event.player == player) return false;
                                    if (player != event.respondTo[0]) return false;
                                    return event.cards.filterInD('od').length;
                                },
                                logTarget: 'player',
                                content() {
                                    player.gain(trigger.cards.filterInD('od'), 'gain2');
                                },
                            },
                            minijiexun: {
                                audio: 'jiexun',
                                trigger: { player: 'phaseJieshuBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var suits = {};
                                    game.countPlayer(current => {
                                        for (var card of current.getCards('ej')) {
                                            if (typeof suits[get.suit(card)] != 'number') suits[get.suit(card)] = 0;
                                            suits[get.suit(card)]++;
                                        }
                                    });
                                    var choices = lib.suit.slice();
                                    choices.push('cancel2');
                                    var str = lib.suit.map(suit => {
                                        return get.translation(suit) + '：' + get.cnNumber(suits[suit] || 0) + '张'
                                    }).join('；');
                                    player.chooseControl(choices).set('prompt', get.prompt('minijiexun') + '（已发动过' + get.cnNumber(player.countMark('minijiexun')) + '次）').set('ai', function () {
                                        var player = _status.event.player;
                                        var map = {};
                                        game.countPlayer(current => {
                                            for (var card of current.getCards('ej')) {
                                                if (typeof map[get.suit(card)] != 'number') map[get.suit(card)] = 0;
                                                map[get.suit(card)]++;
                                            }
                                        });
                                        for (var suit in map) map[suit] = Math.abs(map[suit]);
                                        var bool = game.hasPlayer(current => get.attitude(player, current) > 0);
                                        var list = lib.suit.slice().sort((a, b) => (bool ? 1 : -1) * ((map[b] || 0) - (map[a] || 0)));
                                        if (bool && map[list[0]] > 0 || !bool || player.hasMark('minijiexun')) return list[0];
                                        return 'cancel2';
                                    }).set('prompt2', get.skillInfoTranslation('minijiexun', player) + '<br>' + str);
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        var suit = result.control;
                                        event.suit = suit;
                                        var num1 = game.countPlayer(function (current) {
                                            return current.countCards('ej', { suit: suit });
                                        });
                                        var num2 = player.countMark('minijiexun');
                                        event.num1 = num1;
                                        event.num2 = num2;
                                        var str = '令一名角色摸' + get.cnNumber(num1) + '张牌';
                                        if (num2) str += '，然后弃置' + get.cnNumber(num2) + '张牌';
                                        player.chooseTarget('请选择【诫训】的目标', str).set('ai', function (target) {
                                            var player = _status.event.player, att = get.attitude(player, target);
                                            return _status.event.eff * get.sgn(att) + att / 114514;
                                        }).set('eff', num1 >= num2 && num1 > 0 ? 1 : -1);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minijiexun', target);
                                        if (player.hasMark('minijiexun') || event.num1) player.addExpose(0.2);
                                        player.popup(event.suit);
                                        game.log(player, '选择了', '#y' + get.translation(event.suit));
                                        player.addMark('minijiexun', 1, false);
                                        if (event.num1) target.draw(event.num1);
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (event.num2) target.chooseToDiscard(event.num2, true, 'he');
                                    else event.finish();
                                    'step 4'
                                    if (result.bool && result.autochoose && result.cards.length == result.rawcards.length) {
                                        player.removeMark('minijiexun', player.countMark('minijiexun'), false);
                                        game.log(player, '清空了', '#g【诫训】', '的发动次数');
                                    }
                                },
                                onremove: true,
                                intro: { content: '已发动#次' },
                            },
                            minisbkurou: {
                                audio: 'sbkurou',
                                enable: 'phaseUse',
                                usable: 1,
                                content() {
                                    player.loseHp();
                                    player.addTempSkill('minisbkurou_effect', { player: 'phaseBegin' });
                                    player.gainMaxHp();
                                    player.addMark('minisbkurou_effect', 1, false);
                                },
                                ai: {
                                    order: 8,
                                    result: {
                                        player(player) {
                                            return get.effect(player, { name: 'losehp' }, player, player);
                                        },
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove(player) {
                                            player.loseMaxHp(player.countMark('minisbkurou_effect'));
                                            delete player.storage.minisbkurou_effect;
                                        },
                                        intro: { content: '手牌上限和体力上限+#' },
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num + player.countMark('minisbkurou_effect');
                                            },
                                        },
                                        trigger: { player: 'recoverEnd' },
                                        filter(event, player) {
                                            return player.isPhaseUsing() && player.getStat('skill').minisbkurou;
                                        },
                                        forced: true,
                                        content() {
                                            delete player.getStat('skill').minisbkurou;
                                            player.popup('苦肉');
                                            game.log(player, '重置了技能', '#g【苦肉】');
                                        },
                                    },
                                },
                            },
                            minisbzhaxiang: {
                                audio: 'sbzhaxiang',
                                audioname2: { Mbaby_ol_sb_jiangwei: 'zhaxiang_ol_sb_jiangwei' },
                                trigger: { player: 'loseHpEnd' },
                                forced: true,
                                content() {
                                    player.draw(3 * trigger.num);
                                },
                                ai: {
                                    maihp: true,
                                    effect(card, player, target) {
                                        if (get.tag(card, 'damage')) {
                                            if (player.hasSkillTag('jueqing', false, target)) return [1, 1];
                                            return 1.2;
                                        }
                                        if (get.tag(card, 'loseHp')) {
                                            if (target.hp <= 1) return;
                                            var using = target.isPhaseUsing();
                                            if (target.hp <= 2) return [1, player.countCards('h') <= 1 && using ? 3 : 0];
                                            if (using && target.countCards('h', { name: 'sha', color: 'red' })) return [1, 3];
                                            return [1, (target.countCards('h') <= target.hp || using && game.hasPlayer(function (current) {
                                                return current != player && get.attitude(player, current) < 0 && player.inRange(current);
                                            })) ? 3 : 2]
                                        }
                                    },
                                },
                                group: ['minisbzhaxiang_draw', 'minisbzhaxiang_effect'],
                                subSkill: {
                                    draw: {
                                        audio: 'sbzhaxiang',
                                        trigger: { player: 'phaseEnd' },
                                        filter(event, player) {
                                            return player.isDamaged();
                                        },
                                        forced: true,
                                        content() {
                                            player.draw(Math.ceil(player.getDamagedHp() / 2));
                                        },
                                    },
                                    effect: {
                                        audio: 'sbzhaxiang',
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            if (event.card.name != 'sha') return false;
                                            return player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2);
                                        },
                                        forced: true,
                                        content() {
                                            player.addTempSkill('minisbzhaxiang_count');
                                            player.addMark('minisbzhaxiang_count', 1, false);
                                            trigger.directHit.addArray(game.filterPlayer());
                                            trigger.addCount = false;
                                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                                        },
                                        ai: {
                                            directHit_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                return arg.card && arg.card.name == 'sha' && player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2);
                                            },
                                        },
                                        mod: {
                                            targetInRange(card, player) {
                                                if (card.name == 'sha' && player.countMark('minisbzhaxiang_count') < Math.ceil(player.getDamagedHp() / 2)) return true;
                                            },
                                            //cardUsable:function(card,player){
                                            //if(card.name=='sha'&&player.countMark('minisbzhaxiang_count')<Math.ceil(player.getDamagedHp()/2)) return Infinity;
                                            //},
                                        },
                                    },
                                    count: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                            },
                            //张奋
                            miniwanglu: {
                                derivation: 'miniwanglu_faq',
                                audio: 'dcwanglu',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                forced: true,
                                content() {
                                    if (!player.hasEquipableSlot(5) || player.getEquip('minidagongche')) {
                                        var next = player.phaseUse();
                                        event.next.remove(next);
                                        trigger.getParent().next.push(next);
                                    }
                                    else {
                                        var card = game.createCard('minidagongche', 'spade', 9);
                                        player.$gain2(card);
                                        game.delayx();
                                        player.equip(card);
                                    }
                                },
                                broadcast(player) {
                                    var card = player.getEquip('minidagongche');
                                    if (card) game.broadcast(function (card, storage) {
                                        card.storage = storage;
                                    }, card, card.storage);
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (target == player && get.type(card) == 'equip' && get.subtype(card) == 'equip1') return 'zerotarget';
                                        },
                                    },
                                },
                            },
                            minixianzhu: {
                                derivation: 'minixianzhu_faq',
                                audio: 'dcxianzhu',
                                trigger: { source: 'damageSource' },
                                filter(event, player) {
                                    if (!event.card || event.card.name != 'sha') return false;
                                    var card = player.getEquip('minidagongche');
                                    if (!card) return false;
                                    var num = 0;
                                    for (var i = 1; i <= 3; i++) {
                                        var key = '大攻车选项' + get.cnNumber(i, true);
                                        if (card.storage[key]) num += card.storage[key];
                                    }
                                    return num < 5;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var choiceList = [
                                        '令【杀】无距离限制且无视防具',
                                        '令【杀】的可选目标数+1',
                                        '令【杀】造成伤害后的弃牌数+1',
                                    ];
                                    var list = [];
                                    var card = player.getEquip('minidagongche');
                                    for (var i = 1; i <= 3; i++) {
                                        var key = '大攻车选项' + get.cnNumber(i, true);
                                        var num = card.storage[key];
                                        if (i == 1) {
                                            if (!num) list.push('选项一');
                                            else choiceList[0] = ('<span style="opacity:0.5; ">' + choiceList[0] + '（已强化）</span>');
                                        }
                                        else {
                                            list.push('选项' + get.cnNumber(i, true));
                                            if (num) choiceList[i - 1] += ('（已强化' + num + '次）');
                                        }
                                    }
                                    player.chooseControl(list, 'cancel2').set('prompt', '是否发动【陷筑】强化【大攻车】？').set('choiceList', choiceList).set('ai', function () {
                                        var player = _status.event.player, controls = _status.event.controls.slice(0);
                                        var getval = function (choice) {
                                            var card = player.getEquip('minidagongche');
                                            if (choice == '选项一') {
                                                card.storage.大攻车选项一 = 1;
                                                var goon = false;
                                                if (game.hasPlayer(function (current) {
                                                    var eff1 = 0, eff2 = 0;
                                                    var cardx = { name: 'sha', isCard: true };
                                                    if (player.canUse(cardx, current)) eff1 = get.effect(current, cardx, player, player);
                                                    cardx.storage = { minidagongche: true };
                                                    if (player.canUse(cardx, current)) eff2 = get.effect(current, cardx, player, player);
                                                    return (eff2 > eff1);
                                                })) goon = true;
                                                delete card.storage.大攻车选项一;
                                                if (goon) return 5;
                                                return 0;
                                            }
                                            else if (choice == '选项二') {
                                                var num = 1;
                                                if (card.storage.大攻车选项二) num += card.storage.大攻车选项二;
                                                var cardx = { name: 'sha', isCard: true };
                                                if (game.countPlayer(function (current) {
                                                    return player.canUse(cardx, current) && get.effect(current, cardx, player, player) > 0;
                                                }) > num) return 2;
                                            }
                                            else if (choice == '选项三') return 1;
                                            return 0;
                                        };
                                        var eff = 0, current = 'cancel2';
                                        for (var i of controls) {
                                            var effx = getval(i);
                                            if (effx > eff) {
                                                eff = effx;
                                                current = i;
                                            }
                                        }
                                        return current;
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minixianzhu');
                                        var card = player.getEquip('minidagongche'), key = '大攻车' + result.control;
                                        if (!card.storage[key]) card.storage[key] = 0;
                                        card.storage[key]++;
                                        lib.skill.miniwanglu.broadcast(player);
                                    }
                                },
                                group: 'minixianzhu_sha',
                                subSkill: {
                                    sha: {
                                        audio: 'dcxianzhu',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            return /*player.getCardUsable('sha')>0&&*/game.hasPlayer(target => player.canUse({ name: 'sha' }, target, false)) && player.countCards('h', card => lib.skill.minixianzhu.subSkill.sha.filterCard(card, player));
                                        },
                                        filterCard(card, player) {
                                            return get.type(card) == 'equip' && get.subtype(card) == 'equip1';
                                        },
                                        filterTarget(card, player, target) {
                                            return player.canUse({ name: 'sha', isCard: true }, target, false);
                                        },
                                        usable: 1,
                                        check: (card) => 1 / (get.value(card) || 0.5),
                                        prompt: '弃置一张手牌中的武器牌，视为对一名其他角色使用一张无视距离且不计入次数的【杀】',
                                        content() {
                                            player.useCard({ name: 'sha', isCard: true }, target, false);
                                        },
                                    },
                                },
                            },
                            minichaixie: {
                                audio: 'dcchaixie',
                                trigger: {
                                    player: ['loseAfter'],
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                forced: true,
                                filter(event, player) {
                                    var evt = event.getl(player);
                                    if (!evt || !evt.es || !evt.es.length) return false;
                                    for (var card of evt.es) {
                                        if (card.name == 'minidagongche') {
                                            for (var i = 1; i <= 3; i++) {
                                                if (card.storage['大攻车选项' + get.cnNumber(i, true)]) return true;
                                            }
                                        }
                                    }
                                    return false;
                                },
                                content() {
                                    var num = 0;
                                    var evt = trigger.getl(player);
                                    for (var card of evt.es) {
                                        if (card.name == 'minidagongche') {
                                            for (var i = 1; i <= 3; i++) {
                                                var key = '大攻车选项' + get.cnNumber(i, true);
                                                if (card.storage[key]) num += card.storage[key];
                                            }
                                        }
                                    }
                                    player.draw(num);
                                },
                            },
                            minidagongche_skill: {
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                filter(event, player) {
                                    var cardx = {
                                        name: 'sha',
                                        isCard: true,
                                        storage: { minidagongche: true },
                                    };
                                    return player.hasUseTarget(cardx);
                                },
                                equipSkill: true,
                                content() {
                                    var card = {
                                        name: 'sha',
                                        isCard: true,
                                        storage: { minidagongche: true },
                                    };
                                    lib.skill.miniwanglu.broadcast(player);
                                    player.chooseUseTarget(card, '大攻车：是否视为使用【杀】？', false).logSkill = 'minidagongche_skill';
                                },
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (card.storage && card.storage.minidagongche) {
                                            var cardx = player.getEquip('minidagongche');
                                            if (cardx?.storage?.大攻车选项一) return true;
                                        }
                                    },
                                    selectTarget(card, player, range) {
                                        if (card.storage && card.storage.minidagongche && range[1] != -1) {
                                            var cardx = player.getEquip('minidagongche');
                                            if (cardx?.storage?.大攻车选项二) range[1] += cardx.storage.大攻车选项二;
                                        }
                                    },
                                    canBeDiscarded(card) {
                                        if (card.name == 'minidagongche' && get.position(card) == 'e') {
                                            for (var i = 1; i <= 3; i++) {
                                                if (card.storage['大攻车选项' + get.cnNumber(i, true)]) return;
                                            }
                                            return false;
                                        }
                                    },
                                },
                                ai: {
                                    unequip: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minidagongche) return false;
                                        var card = player.getEquip('minidagongche');
                                        if (!card || !card.storage.大攻车选项一) return false;
                                    },
                                },
                                group: 'minidagongche_skill_discard',
                                subSkill: {
                                    discard: {
                                        trigger: { source: 'damageSource' },
                                        equipSkill: true,
                                        forced: true,
                                        filter(event, player) {
                                            if (!event.card || !event.card.storage || !event.card.storage.minidagongche) return false;
                                            if (event.getParent().type != 'card') return false;
                                            return event.player.hasCard(function (card) {
                                                return lib.filter.canBeDiscarded(card, event.player, player);
                                            }, 'he');
                                        },
                                        logTarget: 'player',
                                        content() {
                                            var num = 1;
                                            var cardx = player.getEquip('minidagongche');
                                            if (cardx?.storage?.大攻车选项三) num += cardx.storage.大攻车选项三;
                                            player.discardPlayerCard(trigger.player, true, num, 'he');
                                        },
                                    },
                                },
                            },
                            miniyanzhu: {
                                audio: 'yanzhu',
                                enable: 'phaseUse',
                                filterTarget: lib.filter.notMe,
                                usable: 1,
                                content() {
                                    'step 0'
                                    if (!target.countCards('e') || player.storage.miniyanzhu) event._result = { index: 0 };
                                    else target.chooseControl().set('prompt', get.translation(player) + '发动了【宴诛】，请选择一项').set('choiceList', [
                                        '弃置一张牌，并令下次受到的伤害+1直到下回合开始',
                                        '将装备区内的所有牌交给' + get.translation(player) + '并令其发动【宴诛】无法选择此项',
                                    ]).set('ai', function () {
                                        if (_status.event.player.countCards('e') >= 3) return 0;
                                        return 1;
                                    });
                                    'step 1'
                                    if (result.index == 1) {
                                        target.give(target.getCards('e'), player);
                                        player.storage.miniyanzhu = true;
                                    }
                                    else {
                                        if (target.countCards('he') > 0) target.chooseToDiscard('he', true);
                                        target.addTempSkill('reyanzhu2', { player: 'phaseBegin' });
                                        target.addMark('reyanzhu2', 1, false);
                                    }
                                },
                                ai: {
                                    order: 6,
                                    result: {
                                        target(player, target) {
                                            if (player.storage.miniyanzhu) return -1;
                                            var ne = target.countCards('e');
                                            if (!ne) return -2;
                                            if (ne >= 2) return -ne;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            minixingxue: {
                                audio: 'xingxue',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.maxHp > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget([1, player.maxHp], get.prompt2('minixingxue')).set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        if (target.countCards('he')) return att;
                                        return att / 10;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        event.targets = result.targets;
                                        player.logSkill('minixingxue', targets);
                                        event.targets2 = event.targets.slice(0);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (event.targets.length) {
                                        var target = event.targets.shift();
                                        target.draw();
                                        event.current = target;
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (event.current && event.current.countCards('he')) {
                                        if (event.targets2.length == 1) event.current.chooseCard('选择一张牌置于牌堆顶', 'he', true);
                                        else event.current.chooseCardTarget({
                                            prompt: '将一张牌置于牌堆顶，或交给其他目标角色',
                                            filterCard: true,
                                            position: 'he',
                                            filterTarget(card, player, target) {
                                                return target != player && _status.event.getParent().targets2.includes(target);
                                            },
                                            forced: true,
                                            selectTarget: [0, 1],
                                            ai1: (card) => 6 - get.value(card),
                                            ai2: (target) => get.attitude(_status.event.player, target),
                                        });
                                    }
                                    else event.goto(2);
                                    'step 4'
                                    if (result?.cards?.length) {
                                        if (!result?.targets?.length) {
                                            event.current.lose(result.cards, ui.cardPile, 'insert');
                                            event.current.$throw(result.cards.length, 1000);
                                        }
                                        else event.current.give(result.cards, result.targets[0]);
                                    }
                                    'step 5'
                                    event.goto(2);
                                },
                            },
                            minizhaofu: {
                                zhuSkill: true,
                                audio: 'zhaofu',
                                enable: 'phaseUse',
                                filterTarget: lib.filter.notMe,
                                selectTarget: [1, 2],
                                usable: 1,
                                content() {
                                    target.addTempSkill('minizhaofu_effect', 'roundStart');
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            var targets = game.filterPlayer(function (current) {
                                                return current.group == 'wu' && get.attitude(player, current) > 0;
                                            });
                                            if (targets.length) {
                                                for (var targetx of targets) {
                                                    if (!targetx.inRange(target)) return -1;
                                                }
                                                return -0.5;
                                            }
                                            return 0;
                                        },
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '已视为在所有吴势力角色的攻击范围内' },
                                        mod: {
                                            inRangeOf(from, to) {
                                                if (from.group == 'wu') return true;
                                            },
                                        },
                                    },
                                },
                            },
                            //孙茹
                            minixiecui: {
                                audio: 'xiecui',
                                trigger: { global: 'damageBegin1' },
                                filter(event, player) {
                                    var source = event.source;
                                    if (!source || source != _status.currentPhase || event.getParent().type != 'card') return false;
                                    return !source.hasHistory('sourceDamage', function (evt) {
                                        return evt.getParent().type == 'card';
                                    });
                                },
                                logTarget: 'source',
                                prompt2(event, player) {
                                    var source = event.source;
                                    var str = ('令' + get.translation(event.player) + '即将受到的');
                                    str += ('' + event.num + '点');
                                    if (event.hasNature('linked')) {
                                        str += (get.translation(event.nature) + '属性');
                                    }
                                    str += '伤害+1';
                                    if (source.countCards('h') > source.getHp()) {
                                        var cards = event.cards.filterInD();
                                        if (cards.length) {
                                            str += ('；然后' + get.translation(event.source) + '获得' + get.translation(cards) + '，且本回合的手牌上限+1');
                                        }
                                    }
                                    return str;
                                },
                                check(event, player) {
                                    var source = event.source;
                                    var att = get.attitude(player, event.player);
                                    if (att < 0) {
                                        if (source.countCards('h') <= source.getHp() || !event.cards.filterInD().length) return true;
                                        return get.attitude(player, source) > 0;
                                    }
                                    return false;
                                },
                                content() {
                                    trigger.num++;
                                    var source = trigger.source;
                                    if (source.countCards('h') > source.getHp()) {
                                        var cards = trigger.cards.filterInD();
                                        if (cards.length > 0) {
                                            source.gain(cards, 'gain2');
                                            source.addMark('xiecui_effect', 1, false);
                                            source.addTempSkill('xiecui_effect');
                                        }
                                    }
                                },
                                ai: { threaten: 2 },
                            },
                            //虞翻
                            minizongxuan: {
                                audio: 'zongxuan',
                                trigger: {
                                    player: 'loseAfter',
                                    global: 'loseAsyncAfter',
                                },
                                filter(event, player) {
                                    if (event.type != 'discard') return false;
                                    var evt = event.getl(player);
                                    if (!evt || !evt.cards2) return false;
                                    for (var i = 0; i < evt.cards2.length; i++) {
                                        if (get.position(evt.cards2[i]) == 'd') {
                                            return true;
                                        }
                                    }
                                    return false;
                                },
                                check(trigger, player) {
                                    if (trigger.getParent(3).name == 'phaseDiscard') return true;
                                    if (!game.hasPlayer(function (current) {
                                        return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                    })) return false;
                                    var cards = trigger.getl(player).cards2;
                                    for (var i = 0; i < cards.length; i++) {
                                        if (get.position(cards[i], true) == 'd' && get.type2(cards[i], false) == 'trick') {
                                            return true;
                                        }
                                    }
                                    return false;
                                },
                                content() {
                                    'step 0'
                                    var cards = [], cards2 = trigger.getl(player).cards2;
                                    for (var i = 0; i < cards2.length; i++) {
                                        if (get.position(cards2[i], true) == 'd') {
                                            cards.push(cards2[i]);
                                        }
                                    }
                                    var next = player.chooseToMove('纵玄：将任意张牌置于牌堆顶', true);
                                    next.set('list', [
                                        ['本次弃置的牌（请将要给出的牌也留在这里）', cards],
                                        ['牌堆顶'],
                                    ]);
                                    next.set('filterOk', function (moved) {
                                        if (moved[0].length == 1) return true;
                                        return moved[1].length > 0;
                                    });
                                    next.set('processAI', function (list) {
                                        var cards = list[0][1].slice(0), player = _status.event.player;
                                        var result = [[], []];
                                        if (game.hasPlayer(function (current) {
                                            return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                        })) {
                                            var max_val = 0;
                                            var max_card = false;
                                            for (var i of cards) {
                                                var val = get.value(i, 'raw');
                                                if (val > max_val) {
                                                    max_card = i;
                                                    max_val = val;
                                                }
                                            }
                                            if (max_card) {
                                                result[0].push(max_card);
                                                cards.remove(max_card);
                                            }
                                        }
                                        if (cards.length) {
                                            var max_val = 0;
                                            var max_card = false;
                                            var equip = game.hasPlayer(function (current) {
                                                return current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                                            })
                                            for (var i of cards) {
                                                var val = get.value(i);
                                                var type = get.type2(i, false);
                                                if (type == 'basic') val += 3;
                                                if (type == 'equip' && equip) val += 9;
                                                if (max_val == 0 || val > max_val) {
                                                    max_card = i;
                                                    max_val = val;
                                                }
                                            }
                                            if (max_card) {
                                                result[1].push(max_card);
                                                cards.remove(max_card);
                                            }
                                            result[0].addArray(cards);
                                        }
                                        return result;
                                    })
                                    'step 1'
                                    if (result.bool) {
                                        var cards = result.moved[1].slice(0);
                                        event.cards = cards;
                                        var list = result.moved[0].slice(0);
                                        if (list.length && game.hasPlayer((current) => (current != player))) {
                                            var next = player.chooseButton([(cards.length ? '是否' : '') + '将其中一张牌交给一名其他角色，然后你摸一张牌' + (cards.length ? '？' : ''), list]).set('ai', function (button) {
                                                if (_status.event.goon) return Math.max(0.1, get.value(button.link, 'raw'));
                                                return 0;
                                            }).set('goon', game.hasPlayer(function (current) {
                                                return current != player && get.attitude(player, current) > 0 && !current.hasSkillTag('nogain');
                                            }));
                                            if (!result.moved[1].length) next.set('forced', true);
                                        }
                                        else event.goto(4);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var card = result.links[0];
                                        event.card = card;
                                        player.chooseTarget('令一名其他角色获得' + get.translation(card), lib.filter.notMe, true).set('ai', function (target) {
                                            var card = _status.event.card, player = _status.event.player;
                                            var eff = Math.max(0.1, get.value(card, target)) * get.attitude(player, target);
                                            if (target.hasSkill('nogain')) eff /= 10;
                                            return eff;
                                        }).set('card', card);
                                    }
                                    else event.goto(4);
                                    'step 3'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'green');
                                        target.gain(card, 'gain2');
                                        player.draw();
                                    }
                                    'step 4'
                                    if (cards.length) {
                                        game.log(player, '将', cards, '置于了牌堆顶');
                                        while (cards.length) ui.cardPile.insertBefore(cards.pop().fix(), ui.cardPile.firstChild);
                                    }
                                },
                            },
                            minizhiyan: {
                                audio: 'zhiyan',
                                trigger: { player: 'phaseJieshuBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('zhiyan'), '令一名角色摸一张牌并展示之。若为非装备牌则你摸一张牌；若为装备牌则其使用此牌并回复1点体力').set('ai', function (target) {
                                        return get.attitude(_status.event.player, target) * (target.isDamaged() ? 2 : 1);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        event.target = result.targets[0];
                                        player.logSkill('minizhiyan', result.targets);
                                        event.bool = false;
                                        event.target.draw('visible');
                                    }
                                    else {
                                        event.finish();
                                    }
                                    'step 2'
                                    var card = result[0];
                                    if (get.type(card) == 'equip') {
                                        if (target.getCards('h').includes(card) && target.hasUseTarget(card)) {
                                            event.target.chooseUseTarget(card, true, 'nopopup');
                                            game.delay();
                                        }
                                    }
                                    else {
                                        player.draw();
                                        event.finish();
                                    }
                                    'step 3'
                                    target.recover();
                                },
                                ai: {
                                    expose: 0.2,
                                    threaten: 1.2
                                },
                            },
                            //全琮
                            miniyaoming: {
                                audio: 'yaoming',
                                trigger: {
                                    player: ['damageEnd', 'phaseEnd'],
                                    source: 'damageSource',
                                },
                                filter(event, player) {
                                    const storage = player.storage.miniyaoming_kanon || { '摸牌': 0, '弃牌': 0, '制衡': 0 };
                                    if (event.name == 'phase' && player.getHistory('useSkill', evt => evt.skill == 'miniyaoming').length) return false;
                                    return game.hasPlayer(target => {
                                        return ['摸牌', '弃牌', '制衡'].some(control => {
                                            if (storage[control] > 1) return false;
                                            if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                                            return true;
                                        });
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.addTempSkill('miniyaoming_kanon');
                                    var func = function () {
                                        game.countPlayer(target => {
                                            var list = ['摸牌', '弃牌', '制衡'].filter(control => {
                                                var num = player.storage.miniyaoming_kanon[control];
                                                if (num > 1) return false;
                                                if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                                                return true;
                                            }), str = '';
                                            for (var i of list) str += (i + '<br>');
                                            str = str.slice(0, -4);
                                            target.prompt(str);
                                        });
                                    };
                                    if (event.player == game.me) func();
                                    else if (event.isOnline()) player.send(func);
                                    player.chooseTarget(get.prompt2('miniyaoming'), (card, player, target) => {
                                        var storage = player.storage.miniyaoming_kanon;
                                        if (storage['摸牌'] < 2 || storage['制衡'] < 2) return true;
                                        return storage['弃牌'] < 2 && target != player && target.countCards('h');
                                    }).set('ai', target => {
                                        var player = _status.event.player;
                                        var storage = player.storage.miniyaoming_kanon;
                                        if (get.attitude(player, target) > 0 && storage['摸牌'] < 2) return get.effect(target, { name: 'draw' }, player, player);
                                        if (get.attitude(player, target) < 0 && storage['弃牌'] < 2 && target != player && target.countCards('h')) return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                        if (get.attitude(player, target) > 0 && storage['制衡'] < 2) return get.effect(target, { name: 'kaihua' }, player, player);
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('miniyaoming', target);
                                        var controls = ['摸牌', '弃牌', '制衡'].filter(control => {
                                            var num = player.storage.miniyaoming_kanon[control];
                                            if (num > 1) return false;
                                            if (control == '弃牌' && (target == player || !target.countCards('h'))) return false;
                                            return true;
                                        });
                                        if (controls.length == 1) event._result = { control: controls[0] };
                                        else {
                                            var str = get.translation(target);
                                            var choiceList = [
                                                '令' + str + '摸一张牌',
                                                '弃置' + str + '一张手牌',
                                                '令' + str + '摸两张牌，然后其弃置两张牌',
                                            ];
                                            var list = ['摸牌', '弃牌', '制衡'];
                                            for (var i = 0; i < 3; i++) {
                                                if (!controls.includes(list[i])) {
                                                    choiceList[i] = '<span style="opacity:0.5">' + choiceList[i] + '</span>';
                                                }
                                            }
                                            player.chooseControl(controls).set('choiceList', choiceList).set('ai', () => {
                                                var player = _status.event.player;
                                                var target = _status.event.target;
                                                var controls = _status.event.controls.slice();
                                                var map = {
                                                    '摸牌': get.effect(target, { name: 'draw' }, player, player),
                                                    '弃牌': get.effect(target, { name: 'guohe_copy2' }, player, player),
                                                    '制衡': get.effect(target, { name: 'kaihua' }, player, player),
                                                };
                                                controls.sort((a, b) => map[b] - map[a]);
                                                return controls[0];
                                            }).set('target', target);
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.storage.miniyaoming_kanon[result.control]++;
                                    switch (result.control) {
                                        case '摸牌':
                                            target.draw();
                                            break;
                                        case '弃牌':
                                            player.discardPlayerCard(target, 'h', true);
                                            break;
                                        case '制衡':
                                            target.draw(2);
                                            break;
                                    }
                                    if (result.control != '制衡') event.finish();
                                    'step 3'
                                    target.chooseToDiscard(2, 'he', true);
                                },
                                subSkill: {
                                    kanon: {
                                        charlotte: true,
                                        onremove: true,
                                        init(player) {
                                            if (!player.storage.miniyaoming_kanon) player.storage.miniyaoming_kanon = { '摸牌': 0, '弃牌': 0, '制衡': 0 };
                                        },
                                    },
                                },
                            },
                            //顾雍
                            minishenxing: {
                                audio: 'reshenxing',
                                enable: 'phaseUse',
                                usable: 20,
                                async content(event, trigger, player) {
                                    const num = Math.min(2, player.getStat('skill').minishenxing - 1);
                                    await player.draw();
                                    if (num) {
                                        await player.chooseToDiscard('he', num, true);
                                        if (!player.countDiscardableCards(player, 'he')) player.tempBanSkill('minishenxing', 'phaseUseAfter', false);
                                    }
                                },
                                ai: {
                                    order(item, player) {
                                        const num = player.getStat('skill').minishenxing || 0;
                                        if (!num) return 10;
                                        if (num == 1) return 1;
                                        return 0;
                                    },
                                    result: { player: 1 },
                                },
                            },
                            miniligong: {
                                audio: 'dcligong',
                                inherit: 'dcligong',
                                filter(event, player) {
                                    var list = lib.skill.dchuishu.getList(player);
                                    return list.some(i => i >= 5);
                                },
                                Mbaby_characterlist: true,
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniligong');
                                    player.gainMaxHp();
                                    player.recover();
                                    'step 1'
                                    player.removeSkills('dcyishu');
                                    'step 2'
                                    if (!_status.characterlist) lib.skill.pingjian.initList();
                                    let EditList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                                    let list = EditList.filter(name => _status.characterlist.includes(name) && (get.character(name, 1) == 'wu' || (get.is.double(name, true) || []).includes('wu')) && ['female', 'double'].includes(get.character(name, 0)));
                                    var players = game.players.concat(game.dead);
                                    for (var i = 0; i < players.length; i++) {
                                        list.remove(players[i].name);
                                        list.remove(players[i].name1);
                                        list.remove(players[i].name2);
                                    }
                                    list = list.filter(i => {
                                        return (lib.character[i][3] || []).some(skill => {
                                            var info = get.info(skill);
                                            return info && !info.charlotte;
                                        });
                                    }).randomGets(4);
                                    var skills = [];
                                    for (var i of list) {
                                        skills.addArray((lib.character[i][3] || []).filter(skill => {
                                            var info = get.info(skill);
                                            return info && !info.charlotte;
                                        }));
                                    }
                                    if (!list.length || !skills.length) {
                                        event.result = {
                                            bool: false,
                                            skills: [],
                                        };
                                        return;
                                    }
                                    if (player.isUnderControl()) game.swapPlayerAuto(player);
                                    var switchToAuto = function () {
                                        _status.imchoosing = false;
                                        event._result = {
                                            bool: true,
                                            skills: skills.randomGets(2),
                                        };
                                        if (event.dialog) event.dialog.close();
                                        if (event.control) event.control.close();
                                    };
                                    var chooseButton = function (list, skills) {
                                        var event = _status.event;
                                        if (!event._result) event._result = {};
                                        event._result.skills = [];
                                        var rSkill = event._result.skills;
                                        var dialog = ui.create.dialog('请选择获得至多两个技能', [list, 'character'], 'hidden');
                                        event.dialog = dialog;
                                        var table = document.createElement('div');
                                        table.classList.add('add-setting');
                                        table.style.margin = '0';
                                        table.style.width = '100%';
                                        table.style.position = 'relative';
                                        for (var i = 0; i < skills.length; i++) {
                                            var td = ui.create.div('.shadowed.reduce_radius.pointerdiv.tdnode');
                                            td.link = skills[i];
                                            table.appendChild(td);
                                            td.innerHTML = '<span>' + get.translation(skills[i]) + '</span>';
                                            td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                                                if (_status.dragged) return;
                                                if (_status.justdragged) return;
                                                _status.tempNoButton = true;
                                                setTimeout(function () {
                                                    _status.tempNoButton = false
                                                }, 500);
                                                var link = this.link;
                                                if (!this.classList.contains('bluebg')) {
                                                    if (rSkill.length >= 2) return;
                                                    rSkill.add(link);
                                                    this.classList.add('bluebg');
                                                }
                                                else {
                                                    this.classList.remove('bluebg');
                                                    rSkill.remove(link);
                                                }
                                            });
                                        }
                                        dialog.content.appendChild(table);
                                        dialog.add('　　');
                                        dialog.open();

                                        event.switchToAuto = function () {
                                            event.dialog.close();
                                            event.control.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                        };
                                        event.control = ui.create.control('ok', function (link) {
                                            event.dialog.close();
                                            event.control.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                        });
                                        for (var i = 0; i < event.dialog.buttons.length; i++) {
                                            event.dialog.buttons[i].classList.add('selectable');
                                        }
                                        game.pause();
                                        game.countChoose();
                                    };
                                    if (event.isMine()) chooseButton(list, skills);
                                    else if (event.isOnline()) {
                                        event.player.send(chooseButton, list, skills);
                                        event.player.wait();
                                        game.pause();
                                    }
                                    else switchToAuto();
                                    'step 3'
                                    var map = event.result || result;
                                    if (map.skills && map.skills.length) player.changeSkills(map.skills, ['dchuishu']);
                                    else player.draw(3);
                                },
                            },
                            //蒋钦
                            minijianyi: {
                                audio: 'spjianyi',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    return player != event.player && game.getGlobalHistory('cardMove', evt => {
                                        if (evt.name != 'lose' || evt.type != 'discard') return false;
                                        return evt.cards.some(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd');
                                    }).length > 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const cards = game.getGlobalHistory('cardMove', evt => {
                                        if (evt.name != 'lose' || evt.type != 'discard') return false;
                                        return evt.cards.some(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd');
                                    }).reduce((list, evt) => {
                                        return list.add(...evt.cards.filter(i => ['equip1', 'equip2'].includes(get.subtype(i, false)) && get.position(i, true) == 'd'));
                                    }, []);
                                    const result = await player.chooseButton(['俭衣：选择获得其中一张牌', cards], true).set('ai', button => {
                                        return get.value(button.link, get.event('player'));
                                    }).forResult();
                                    if (result.bool) await player.gain(result.links, 'gain2');
                                },
                            },
                            minishangyi: {
                                inherit: 'twshangyi',
                                content() {
                                    'step 0'
                                    target.viewHandcards(player);
                                    var chooseButton;
                                    if (player.countCards('h')) chooseButton = player.chooseButton([1, 2], ['###尚义###<div class="text center">选择' + get.translation(target) + '的一张手牌获得之，或选择你与其的各一张牌以交换</div>', '<div class="text center">' + get.translation(target) + '的手牌</div>', target.getCards('h'), '<div class="text center">你的手牌</div>', player.getCards('h')], true);
                                    else chooseButton = player.chooseButton(['###尚义###<div class="text center">弃置' + get.translation(target) + '的一张手牌</div>', '<div class="text center">' + get.translation(target) + '的手牌</div>', target.getCards('h')], true);
                                    chooseButton.set('target', target);
                                    chooseButton.set('ai', button => {
                                        var player = _status.event.player, owner = get.owner(button.link), color = get.color(button.link, owner), value = get.value(button.link, owner);
                                        if (player.countCards('h')) {
                                            if (!ui.selected.buttons.length) {
                                                if (player.countCards('h', card => {
                                                    return get.color(card, player) == 'red' && get.value(card) < 6;
                                                }) && color == 'red' && value > 7) return value * 3;
                                                return value;
                                            }
                                            else {
                                                if (get.value(ui.selected.buttons[0].link) < 4) return 0;
                                                return 4 + (get.color(ui.selected.buttons[0].link, get.owner(ui.selected.buttons[0].link)) == 'red' ? 3 : 1) - value;
                                            }
                                        }
                                        else {
                                            if (color == 'black') return value * 1.5;
                                            return value;
                                        }
                                    });
                                    chooseButton.set('filterButton', button => {
                                        if (get.itemtype(button.link) != 'card') return false;
                                        if (!ui.selected.buttons.length && get.owner(button.link) != _status.event.target) return false;
                                        if (ui.selected.buttons.length && get.owner(ui.selected.buttons[0].link) == get.owner(button.link)) return false;
                                        return true;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        if (result.links.length == 1) {
                                            player.gain(result.links, target, 'give');
                                            if (get.color(result.links[0], target) != 'black') event.finish();
                                        }
                                        else {
                                            var links = result.links.slice();
                                            if (get.owner(links[0]) != player) links.reverse();
                                            var card1 = links[0], card2 = links[1];
                                            player.swapHandcards(target, [card1], [card2]);
                                            if (get.color(card1, player) != 'red' || get.color(card2, target) != 'red') event.finish();
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.draw();
                                },
                            },
                            //吕岱
                            miniqinguo: {
                                inherit: 'xinfu_qinguo',
                                async content(event, trigger, player) {
                                    const result = await player.chooseUseTarget({ name: 'sha' }, get.prompt('xinfu_qinguo'), '视为使用一张【杀】，若此【杀】造成伤害，则你摸一张牌', false).set('logSkill', 'miniqinguo').forResult();
                                    if (result.bool && game.hasPlayer2(target => {
                                        return target.getHistory('damage', evt => evt.getParent(4) == event).length;
                                    })) await player.draw();
                                },
                                group: 'miniqinguo_recover',
                                subSkill: {
                                    recover: {
                                        audio: 'qinguo_use',
                                        trigger: {
                                            player: 'loseAfter',
                                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                        },
                                        filter(event, player) {
                                            if (player.isHealthy() || player.countCards('e') < player.hp) return false;
                                            var evt = event.getl(player);
                                            if (event.name == 'equip' && event.player == player) return !evt || evt.cards.length != 1;
                                            return evt?.es?.length;
                                        },
                                        frequent: true,
                                        prompt: '是否发动【勤国】回复1点体力？',
                                        content() {
                                            player.recover();
                                        },
                                    },
                                },
                            },
                            //新贺齐
                            miniqizhou: {
                                audio: 'qizhou',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'phaseBefore'],
                                },
                                filter(event, player) {
                                    if (event.name != 'phase' && (event.name != 'equip' || event.player != player)) {
                                        var evt = event.getl(player);
                                        if (!evt || !evt.es || !evt.es.length) return false;
                                    }
                                    var num = player.countMark('miniqizhou');
                                    return lib.skill.miniqizhou.getSuitNum(player) != num;
                                },
                                forced: true,
                                popup: false,
                                content() {
                                    lib.skill.miniqizhou.init(player);
                                },
                                getSuitNum(player) {
                                    var suits = [], es = player.getCards('e');
                                    for (var i of es) suits.add(get.suit(i, player));
                                    return Math.min(4, suits.length);
                                },
                                init(player) {
                                    player.removeAdditionalSkill('miniqizhou');
                                    var num = lib.skill.miniqizhou.getSuitNum(player);
                                    player.storage.miniqizhou = num;
                                    if (num > 0) player.addAdditionalSkill('miniqizhou', lib.skill.miniqizhou.derivation.slice(0, num));
                                },
                                onremove: true,
                                derivation: ['reyingzi', 'miniqixi', 'fenwei', 'miniduanbing'],
                            },
                            minishanxi: {
                                audio: 'shanxi',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer((current) => lib.skill.minishanxi.filterTarget(null, player, current));
                                },
                                filterTarget(card, player, target) {
                                    return target != player && player.countCards('h') + target.countCards('h') > 0 && !player.inRangeOf(target);
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    var cards1 = player.getCards('h'), cards2 = target.getCards('h');
                                    var num = Array.from({ length: 5 }).map((_, i) => i + 1).reduce((sum, i) => sum + target.countEmptySlot(i), 1);
                                    var dialog = ['闪袭：选择展示至多' + get.cnNumber(num) + '张牌'];
                                    if (cards1.length > 0) {
                                        dialog.push('<div class="text center">你的手牌</div>');
                                        dialog.push(cards1);
                                    }
                                    if (cards2.length > 0) {
                                        dialog.push('<div class="text center">' + get.translation(target) + '的手牌</div>');
                                        if (player.hasSkillTag('viewHandcard', null, target, true)) dialog.push(cards2);
                                        else dialog.push([cards2.randomSort(), 'blank']);
                                    }
                                    player.chooseButton(dialog, [1, num], true).set('ai', function (button) {
                                        var player = _status.event.player, target = _status.event.getParent().target;
                                        var card = button.link, cards = ui.selected.buttons.map(button => button.link);
                                        var hs = player.getCards('h'), discard = false;
                                        for (var i of cards) {
                                            if (hs.includes(i)) {
                                                discard = true;
                                                break;
                                            }
                                        }
                                        if (hs.includes(card)) {
                                            if (discard || get.name(card) != 'shan') return 0;
                                            if (target.hasCard(card => get.value(card, target) > 5, 'e')) return 2;
                                            return 0;
                                        }
                                        if (discard && !target.hasCard(function (cardx) {
                                            return cardx != card && !cards.includes(cardx) && get.value(cardx, target) > 0;
                                        }, 'he')) return 0;
                                        return 1 + Math.random();
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        event.cards = result.links;
                                        var list1 = [], list2 = [];
                                        var hs = player.getCards('h');
                                        for (var card of result.links) {
                                            if (hs.includes(card)) {
                                                list1.push(card);
                                            }
                                            else {
                                                list2.push(card);
                                            }
                                        }
                                        event.list1 = list1;
                                        event.list2 = list2;
                                        event.videoId = lib.status.videoId++;
                                        game.broadcastAll(function (player, target, list1, list2, id) {
                                            var dialog = ui.create.dialog(player + '对' + target + '发动了【闪袭】');
                                            dialog.videoId = id;
                                            if (list1.length > 0) {
                                                dialog.add('<div class="text center">' + player + '展示的牌</div>');
                                                dialog.add(list1);
                                            }
                                            if (list2.length > 0) {
                                                dialog.add('<div class="text center">' + target + '被展示的牌</div>');
                                                dialog.add(list2);
                                            }
                                        }, get.translation(player), get.translation(target), list1, list2, event.videoId)
                                        game.delay(4);
                                    }
                                    else event.finish();
                                    'step 2'
                                    game.broadcastAll('closeDialog', event.videoId);
                                    var list1 = event.list1.filter((card) => get.name(card, player) == 'shan');
                                    var list2 = event.list2.filter((card) => get.name(card, target) == 'shan');
                                    if (list1.length && list2.length) {
                                        game.loseAsync({
                                            lose_list: [
                                                [player, list1],
                                                [target, list2]
                                            ],
                                            discarder: player,
                                        }).setContent('discardMultiple');
                                    }
                                    else if (list2.length) {
                                        target.discard(list2);
                                    }
                                    else if (list1.length) player.discard(list1);
                                    else event.finish();
                                    'step 3'
                                    if (target.hasCard(function (card) {
                                        return !cards.includes(card) && lib.filter.canBeGained(card, player, target);
                                    }, 'he')) player.gainPlayerCard(target, true, 'he').set('filterButton', function (button) {
                                        return !_status.event.cards.includes(button.link);
                                    }).set('cards', cards);
                                },
                                ai: {
                                    order: 14,
                                    result: {
                                        target(player, target) {
                                            return -target.countCards('h');
                                        },
                                    },
                                },
                            },
                            //孙寒华
                            minihuiling: {
                                audio: 'dchuiling',
                                inherit: 'dchuiling',
                                trigger: {
                                    player: ['useCard', 'loseAfter'],
                                    global: 'loseAsyncAfter',
                                },
                                filter(event, player) {
                                    if (!ui.discardPile.childNodes.length) return false;
                                    if (event.name == 'useCard') return true;
                                    return event.type == 'discard' && event.getl(player).cards2.length > 0;
                                },
                                content() {
                                    'step 0';
                                    var mark = false;
                                    var red = 0,
                                        black = 0;
                                    for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                                        var color = get.color(ui.discardPile.childNodes[i]);
                                        if (color == 'red') red++;
                                        if (color == 'black') black++;
                                    }
                                    if (red == black) event.finish();
                                    else if (red > black) {
                                        player.logSkill(event.name);
                                        player.recover();
                                        event.finish();
                                        if (get.color(trigger.card) == 'black') mark = true;
                                        event.logged = true;
                                    } else {
                                        if (!event.isMine() && !event.isOnline()) game.delayx();
                                        player
                                            .chooseTarget(get.prompt(event.name), '弃置一名角色区域内的一张牌', (card, player, target) => {
                                                return target.countDiscardableCards(player, 'hej') > 0;
                                            })
                                            .set('ai', target => {
                                                return get.effect(target, { name: 'guohe_copy2' }, _status.event.player);
                                            });
                                        if (get.color(trigger.card) == 'red') mark = true;
                                    }
                                    if (mark) {
                                        if (!event.logged) player.logSkill(event.name);
                                        player.addMark(event.name, 1);
                                        event.logged = true;
                                    }
                                    'step 1';
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        if (!event.logged) player.logSkill(event.name, target);
                                        else player.line(target);
                                        player.discardPlayerCard(target, 'hej', true);
                                    }
                                },
                            },
                            minichongxu: {
                                audio: 'dcchongxu',
                                inherit: 'dcchongxu',
                                prompt() {
                                    return '限定技。你可以失去〖汇灵〗，增加' + Math.min(game.countPlayer(), _status.event.player.countMark('minihuiling')) + '点体力上限，然后获得〖踏寂〗和〖清荒〗。';
                                },
                                filter(event, player) {
                                    return player.countMark('minihuiling') >= 4;
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    const num = player.countMark('minihuiling');
                                    await player.removeSkills('minihuiling');
                                    await player.gainMaxHp(Math.min(game.countPlayer(), num));
                                    await player.addSkills(['dctaji', 'dcqinghuang']);
                                },
                                ai: {
                                    combo: 'minihuiling',
                                    order(itemp, player) {
                                        if (
                                            player.hasCard(card => {
                                                return get.type(card) != 'equip' && player.getUseValue(card) > 1;
                                            }, 'h')
                                        )
                                            return 12;
                                        return 0.1;
                                    },
                                    result: {
                                        player(player) {
                                            var count = player.countMark('minihuiling');
                                            if (count >= game.countPlayer() - 1) return 1;
                                            return count >= 6 || player.hp <= 2 ? 1 : 0;
                                        },
                                    },
                                },
                            },
                            //张温
                            minisongshu: {
                                audio: 'songshu',
                                inherit: 'songshu',
                                usable: 1,
                                filter(event, player) {
                                    return game.hasPlayer(current => get.info('songshu').filterTarget(null, player, current));
                                },
                                async content(event, trigger, player) {
                                    const { target } = event;
                                    const bool = await player.chooseToCompare(target).set('small', get.attitude(player, target) > 0).forResultBool();
                                    if (!bool) {
                                        const draw = await player.chooseBool(`是否与${get.translation(target)}各摸两张牌`).forResultBool();
                                        if (draw) await game.asyncDraw([player, target], 2);
                                    }
                                    else {
                                        delete player.getStat().skill.minisongshu;
                                        game.log(player, '重置了', '#g【颂蜀】');
                                    }
                                },
                            },
                            minisibian: {
                                audio: 'sibian',
                                inherit: 'sibian',
                                async content(event, trigger, player) {
                                    trigger.changeToZero();
                                    const cards = get.cards(4);
                                    await game.cardsGotoOrdering(cards);
                                    await player.showCards(event.cards);
                                    cards.sort(function (a, b) {
                                        return b.number - a.number;
                                    });
                                    const gains = [];
                                    const mx = [cards[0].number, cards[3].number];
                                    for (var i = 0; i < cards.length; i++) {
                                        if (mx.includes(cards[i].number)) gains.addArray(cards.splice(i--, 1));
                                    }
                                    await player.gain(gains, 'gain2');
                                    if (!cards.length || !game.hasPlayer(current => current.isMinHandcard() || current.isMaxHandcard())) return;
                                    const targets = await player.chooseTarget('是否令一名手牌数最少或最多的角色获得' + get.translation(cards), (card, player, target) => {
                                        return target.isMinHandcard() || target.isMaxHandcard();
                                    }).set('ai', target => {
                                        return get.attitude(_status.event.player, target);
                                    }).forResultTargets();
                                    if (!targets || !targets.length) return;
                                    player.line(targets[0]);
                                    player.addExpose(0.2);
                                    await targets[0].gain(cards, 'gain2');
                                },
                            },
                            // 卫诸
                            minifuhai: {
                                inherit: 'jsrgfuhai',
                                async content(event, trigger, player) {
                                    const targets = event.targets.sortBySeat();
                                    const next = player.chooseCardOL(targets, '请展示一张手牌', true).set('ai', card => {
                                        return -get.value(card);
                                    }).set('aiCard', target => {
                                        const hs = target.getCards('h');
                                        return { bool: true, cards: [hs.randomGet()] };
                                    });
                                    next._args.remove('glow_result');
                                    const { result } = await next;
                                    const cards = [];
                                    const videoId = lib.status.videoId++;
                                    for (let i = 0; i < targets.length; i++) {
                                        cards.push(result[i].cards[0]);
                                        game.log(targets[i], '展示了', result[i].cards[0]);
                                    }
                                    game.broadcastAll((targets, cards, id, player) => {
                                        var dialog = ui.create.dialog(get.translation(player) + '发动了【浮海】', cards);
                                        dialog.videoId = id;
                                        const getName = target => {
                                            if (target._tempTranslate) return target._tempTranslate;
                                            var name = target.name;
                                            if (lib.translate[name + '_ab']) return lib.translate[name + '_ab'];
                                            return get.translation(name);
                                        };
                                        for (let i = 0; i < targets.length; i++) {
                                            dialog.buttons[i].querySelector('.info').innerHTML = getName(targets[i]) + '|' + get.strNumber(cards[i].number);
                                        }
                                    }, targets, cards, videoId, player);
                                    await game.delay(4);
                                    game.broadcastAll('closeDialog', videoId);
                                    let clock = -1, anticlock = -1;
                                    for (let j = 0; j < 2; j++) {
                                        let increase = -Infinity, decrease = Infinity, count = 0;
                                        for (let i = 0; i < targets.length; i++) {
                                            const number = get.number(cards[i], false);
                                            let flag = false;
                                            if (number > increase) {
                                                increase = number;
                                                flag = true;
                                            } else increase = Infinity;
                                            if (number < decrease) {
                                                decrease = number;
                                                flag = true;
                                            } else decrease = -Infinity;
                                            if (flag) count++;
                                            else break;
                                        }
                                        targets.reverse();
                                        cards.reverse();
                                        if (j == 0) anticlock = Math.max(2, count);
                                        else clock = Math.max(2, count);
                                    }
                                    const { result: { index } } = await player.chooseControl(`↖顺时针(${clock})`, `逆时针(${anticlock})↗`).set('prompt', '请选择一个方向，摸对应数量的牌').set('ai', () => get.event('choice')).set('choice', clock > anticlock ? 0 : 1);
                                    await player.draw(index == 0 ? clock : anticlock);
                                },
                            },
                            // 潘马
                            miniduodao: {
                                audio: 'reduodao',
                                inherit: 'reduodao',
                                async cost(event, trigger, player) {
                                    const { player: target, card } = trigger, goon = get.color(card) === 'red';
                                    let prompt = '弃置一张牌，然后', cards = target.getEquips(1).filter(card => {
                                        return lib.filter.canBeGained(card, player, target);
                                    });
                                    if (goon) {
                                        if (target.countGainableCards(player, 'hej')) prompt += '获得' + get.translation(target) + '区域内的一张牌';
                                        else prompt += '无事发生';
                                    }
                                    else {
                                        if (cards.length) prompt += '获得' + get.translation(target) + '装备区中的' + get.translation(cards);
                                        else prompt += '无事发生';
                                    }
                                    event.result = await player.chooseToDiscard('he', get.prompt(event.name.slice(0, -5), target), prompt).set('ai', card => {
                                        const { player, target, goon, eff } = get.event();
                                        if (goon) {
                                            let att = get.attitude(player, target);
                                            if (att < 0) att = -Math.sqrt(-att);
                                            else att = Math.sqrt(att);
                                            if (att * lib.card.shunshou.ai.result.target(player, target) > 0) return 6.5 - get.value(card);
                                            return 0;
                                        }
                                        if (typeof eff === 'number') return eff - get.value(card);
                                        return 0;
                                    }).set('eff', function () {
                                        let es = trigger.player.getEquips(1).filter(card => {
                                            return lib.filter.canBeGained(card, player, trigger.player);
                                        });
                                        if (!es.length) return false;
                                        if (get.attitude(player, trigger.player) > 0) return -2 * es.reduce((acc, card) => {
                                            return acc + get.value(card, trigger.player);
                                        }, 0);
                                        return 2 * es.reduce((acc, card) => {
                                            return acc + get.value(card, player);
                                        }, 0);
                                    }()).set('target', target).set('goon', goon).forResult();
                                },
                                async content(event, trigger, player) {
                                    const { player: target, card } = trigger;
                                    if (get.color(card) == 'red') {
                                        if (target.countGainableCards(player, 'hej')) await player.gainPlayerCard(target, 'hej', true);
                                    }
                                    else {
                                        const cards = target.getEquips(1).filter(card => {
                                            return lib.filter.canBeGained(card, player, target);
                                        });
                                        if (cards.length) await player.gain(cards, target, 'give', 'bySelf');
                                    }
                                },
                            },
                            minianjian: {
                                audio: 'reanjian',
                                inherit: 'xinanjian',
                                async content(event, trigger, player) {
                                    const { card, target } = trigger, str1 = get.translation(card), str2 = get.translation(target);
                                    if (!card.storage) card.storage = {};
                                    card.storage[event.name] = true;
                                    target.when({ player: 'dyingBegin' }).filter(evt => evt.getParent(3) == trigger.getParent()).then(() => {
                                        player.addTempSkill('minianjian_ban', { global: ['dyingEnd', 'phaseEnd'] });
                                    })
                                    const { result: { index } } = await player.chooseControl().set('prompt', '暗箭：请选择一项').set('choiceList', [`令${str2}不能响应${str1}`, `令${str1}对${str2}的伤害值基数+1`]).set('ai', () => {
                                        const target = get.event().getTrigger().target;
                                        const player = get.event().player;
                                        let num = target.mayHaveShan(player, 'use', target.getCards('h', i => {
                                            return i.hasGaintag('sha_notshan');
                                        })) ? 0 : 1;
                                        if (get.attitude(player, target) > 0) num = 1 - num;
                                        return num;
                                    });
                                    if (index == 0) {
                                        game.log(player, '令', card, '不能被', target, '响应');
                                        trigger.directHit.push(target);
                                    } else {
                                        game.log(player, '令', card, '对', target, '的伤害+1');
                                        const id = target.playerid;
                                        const map = trigger.customArgs;
                                        if (!map[id]) map[id] = {};
                                        if (!map[id].extraDamage) map[id].extraDamage = 0;
                                        map[id].extraDamage++;
                                    }
                                },
                                ai: {
                                    unequip: true,
                                    unequip_ai: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag == 'unequip' && (!arg || !arg.card || !arg.card.storage || !arg.card.storage.minianjian)) return false;
                                        if (tag == 'unequip_ai' && (!arg || arg.name != 'sha')) return false;
                                        if (tag == 'directHit_ai' && (!arg || !arg.card || !arg.target || arg.card.name != 'sha' || arg.target.inRange(player) || get.attitude(player, arg.target) > 0)) return false;
                                    },
                                },
                                subSkill: {
                                    ban: {
                                        charlotte: true,
                                        mod: {
                                            cardSavable(card) {
                                                if (card.name == 'tao') return false;
                                            },
                                        },
                                    }
                                }
                            },
                            // 阚泽
                            minikuanshi: {
                                audio: 'rekuanshi',
                                trigger: { player: 'phaseJieshuBegin' },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget(get.prompt2(event.name.slice(0, -5))).set('animate', false).set('ai', target => {
                                        let att = get.attitude(get.player(), target);
                                        if (target.hp < 3) att /= 1.5;
                                        return att;
                                    }).forResult();
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    const history = target.getAllHistory('damage');
                                    if (history.length) history[history.length - 1][event.name + '_mark'] = true;
                                    player.addTempSkill(event.name + '_effect', { player: 'phaseBegin' });
                                    player.markAuto(event.name + '_effect', [target]);
                                    await game.delayx();
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '当$于每两次受到伤害后，其回复1点体力' },
                                        trigger: { global: 'damageEnd' },
                                        filter(event, player) {
                                            const { player: target } = event;
                                            if (!player.getStorage('minikuanshi_effect').includes(target) || target.isHealthy()) return false;
                                            let history = target.getAllHistory('damage', null, event), num = 0;
                                            for (let i = history.length - 1; i >= 0; i--) {
                                                const evt = history[i];
                                                if (evt['minikuanshi_mark']) break;
                                                num++;
                                            }
                                            return num % 2 == 0;
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        content() {
                                            trigger.player.recover();
                                        },
                                    },
                                },
                            },
                            //谋甘宁
                            minisbfenwei: {
                                audio: 'sbfenwei',
                                inherit: 'sbfenwei',
                                usable: 1,
                                prompt: '将至多三张牌称为“威”分别置于等量名角色的武将牌上，然后你摸等量牌',
                                content() {
                                    'step 0'
                                    for (var i = 0; i < cards.length; i++) {
                                        targets[i].addToExpansion(cards[i], player, 'give').gaintag.add(event.name);
                                    }
                                    'step 1'
                                    player.draw(cards.length);
                                },
                                limited: false,
                                skillAnimation: false,
                                animationColor: false,
                                marktext: '威',
                                intro: {
                                    name: '威',
                                    markcount: 'expansion',
                                    content: 'expansion',
                                },
                                group: 'minisbfenwei_effect',
                                subSkill: {
                                    effect: {
                                        audio: 'sbfenwei',
                                        trigger: { global: 'useCardToTarget' },
                                        filter(event, player) {
                                            return event.target.getExpansions('minisbfenwei').length > 0 && get.type2(event.card) === 'trick';
                                        },
                                        forced: true,
                                        logTarget: 'target',
                                        async content(event, trigger, player) {
                                            const target = trigger.target, str = get.translation(target), cards = target.getExpansions('minisbfenwei');
                                            const result = await player.chooseControl().set('choiceList', [
                                                '令' + str + '获得' + get.translation(cards),
                                                '移去' + str + '的“威”，令' + get.translation(trigger.card) + '对其无效',
                                                '移去' + str + '的“威”，令其不可响应' + get.translation(trigger.card),
                                                '移去' + str + '的“威”，你摸一张牌',
                                            ]).set('prompt', '奋威：请选择一项').set('ai', () => {
                                                const player = get.player(), trigger = get.event().getTrigger(), target = trigger.target;
                                                const map = {
                                                    0: target.getExpansions('minisbfenwei').reduce((sum, card) => {
                                                        return sum + get.value(card, target) * Math.sign(get.attitude(player, target));
                                                    }, 0),
                                                    1: -get.effect(target, trigger.card, trigger.player, player),
                                                    2: (() => {
                                                        let num = 1.3;
                                                        if (trigger.card.name == 'sha' && (() => {
                                                            if (target.mayHaveShan(player, 'use', current.getCards('h', i => {
                                                                return i.hasGaintag('sha_notshan');
                                                            })) && get.attitude(player, target) <= 0) {
                                                                if (target.hasSkillTag('useShan')) num = 1.9;
                                                                return true;
                                                            }
                                                            return false;
                                                        })()) return num + Math.random();
                                                        return 0.5 + Math.random();
                                                    })(),
                                                    3: get.effect(player, { name: 'draw' }, player, player),
                                                };
                                                return Array.from({ length: 4 }).map((_, i) => i).sort((a, b) => map[b] - map[a])[0];
                                            }).forResult();
                                            if (result.index === 0) {
                                                await target.gain(cards, target, 'give');
                                            }
                                            else {
                                                await target.loseToDiscardpile(cards);
                                                switch (result.index) {
                                                    case 1:
                                                        trigger.targets.remove(target);
                                                        trigger.getParent().triggeredTargets2.remove(target);
                                                        trigger.untrigger();
                                                        game.log(trigger.card, '对', target, '无效');
                                                        break;
                                                    case 2:
                                                        trigger.getParent().directHit.add(target);
                                                        game.log(target, '不能响应', trigger.card);
                                                        break;
                                                    case 3:
                                                        await player.draw();
                                                        break;
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            //陈武董袭
                            miniduanxie: {
                                audio: 'duanxie',
                                inherit: 'duanxie',
                                selectTarget() {
                                    return [1, game.hasPlayer(current => current.isLinked()) ? 1 : 2];
                                },
                            },
                            minifenming: {
                                audio: 'fenming',
                                inherit: 'fenming',
                                filter(event, player) {
                                    return get.info('minifenming').logTarget(event, player).length;
                                },
                                logTarget(event, player) {
                                    return game.filterPlayer(current => current.isLinked() && current.countDiscardableCards(player, "he")).sortBySeat();
                                },
                                async content(event, trigger, player) {
                                    let num = 0;
                                    for (const target of event.targets) {
                                        if (!target.countDiscardableCards(player, "he")) continue;
                                        const bool = await player.discardPlayerCard(target, 'he', true).forResultBool();
                                        if (bool) num++;
                                    }
                                    if (num > 0) await player.draw(num);
                                },
                            },
                            //群
                            miniqieting: {
                                audio: 'qieting',
                                trigger: { global: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return event.player.countCards('h') > player.countCards('h');
                                },
                                forced: true,
                                content() {
                                    player.draw();
                                },
                            },
                            minireqieting: {
                                audio: 'reqieting',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    if (event.player == player) return false;
                                    return event.player.countCards('h') > player.countCards('h') || !event.player.getHistory('sourceDamage', function (evt) {
                                        return evt.player != event.player;
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.logged = false;
                                    if (trigger.player.countCards('h') <= player.countCards('h')) event.goto(2);
                                    'step 1'
                                    player.logSkill('minireqieting', trigger.player);
                                    player.draw();
                                    if (trigger.player.getHistory('sourceDamage', function (evt) {
                                        return evt.player != trigger.player;
                                    }).length) event.finish();
                                    else event.logged = true;
                                    'step 2'
                                    var list = ['摸一张牌'], target = trigger.player, str = get.translation(target);
                                    event.target = target;
                                    event.addIndex = 0;
                                    if (target.countCards('h') > 0) list.push('观看' + str + '的两张手牌并获得其中一张');
                                    else event.addIndex++;
                                    if (target.countCards('e', function (card) {
                                        return player.canEquip(card);
                                    }) > 0) list.push('将' + str + '装备区内的一张牌移动至自己的装备区');
                                    player.chooseControl('cancel2').set('choiceList', list).set('prompt', get.prompt('minireqieting', target)).set('ai', function () {
                                        var evt = _status.event.getParent();
                                        if (get.attitude(evt.player, evt.target) > 0) return 0;
                                        var val = evt.target.hasSkillTag('noe') ? 6 : 0;
                                        if (evt.target.countCards('e', function (card) {
                                            return evt.player.canEquip(card) && get.value(card, evt.target) > val && get.effect(evt.player, card, evt.player, evt.player) > 0;
                                        }) > 0) return 2 - evt.addIndex;
                                        if (evt.target.countCards('h') > 0) return 1;
                                        return 0;
                                    });
                                    'step 3'
                                    if (result.control != 'cancel2') {
                                        if (!event.logged) player.logSkill('minireqieting', target);
                                        else player.line(target);
                                        if (result.index == 0) {
                                            player.draw();
                                            event.finish();
                                        }
                                        else if (result.index + event.addIndex == 1) {
                                            player.choosePlayerCard(target, 'h', 2, true);
                                            player.addExpose(0.2);
                                            event.goto(5);
                                        }
                                        else {
                                            player.addExpose(0.1);
                                            player.choosePlayerCard(target, 'e', true).set('filterButton', function (button) {
                                                return _status.event.player.canEquip(button.link);
                                            }).set('ai', function (button) {
                                                var player = _status.event.player;
                                                return get.effect(player, button.link, player, player);
                                            });
                                        }
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (result.bool) {
                                        var card = result.cards[0];
                                        target.$give(card, player, false);
                                        game.delay(0.5);
                                        player.equip(card);
                                    }
                                    event.finish();
                                    'step 5'
                                    if (result.bool) player.chooseButton(['选择获得一张牌', result.cards], true);
                                    else event.finish();
                                    'step 6'
                                    if (result.bool) {
                                        var card = result.links[0];
                                        if (lib.filter.canBeGained(card, player, target)) player.gain(card, target, 'giveAuto', 'bySelf');
                                        else game.log('但', card, '不能被', player, '获得！');
                                    }
                                },
                            },
                            minixianzhou: {
                                audio: 'xianzhou',
                                enable: 'phaseUse',
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'gray',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterCard: true,
                                position: 'h',
                                selectCard: -1,
                                filterTarget: lib.filter.notMe,
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    'step 0'
                                    player.awakenSkill('minixianzhou');
                                    target.gain(cards, player, 'give');
                                    'step 1'
                                    var list = game.filterPlayer(function (current) {
                                        return target.inRange(current);
                                    });
                                    if (list.length) {
                                        var max = Math.min(list.length, cards.length);
                                        target.chooseTarget(true, [1, max], '对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害', function (card, player, target) {
                                            return _status.event.list.includes(target);
                                        }).set('list', list).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.damageEffect(target, player, player);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        target.line(targets, 'green');
                                        for (var i of targets) i.damage('nocard', target);
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target: 1,
                                        player(player) {
                                            var bool = true, players = game.filterPlayer();
                                            for (var i = 0; i < players.length; i++) {
                                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) bool = false; break;
                                            }
                                            if (bool) return -10;
                                            if (game.phaseNumber < game.players.length) return -10;
                                            if (player.countCards('h') + player.hp > player.maxHp) return 1;
                                            return -10;
                                        },
                                    },
                                },
                            },
                            minirexianzhou: {
                                unique: true,
                                limited: true,
                                audio: 'rexianzhou',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he') > 0;
                                },
                                filterCard: true,
                                position: 'he',
                                selectCard: [1, Infinity],
                                check(card) {
                                    var player = _status.event.player;
                                    if (ui.selected.cards.length >= player.hp) return 0;
                                    return 7 - get.value(card);
                                },
                                filterTarget: lib.filter.notMe,
                                discard: false,
                                lose: false,
                                delay: false,
                                skillAnimation: true,
                                animationColor: 'gray',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minirexianzhou');
                                    player.give(cards, target);
                                    player.recover(cards.length)
                                    'step 1'
                                    var list = game.filterPlayer(function (current) {
                                        return target.inRange(current);
                                    });
                                    if (list.length) {
                                        var max = Math.min(list.length, cards.length);
                                        player.chooseTarget(true, [1, max], '对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害', function (card, player, target) {
                                            return _status.event.list.includes(target);
                                        }).set('list', list).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.damageEffect(target, player, player);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.line(targets, 'green');
                                        for (var i of targets) i.damage('nocard');
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target: 1,
                                        player(player) {
                                            var bool = true, players = game.filterPlayer();
                                            for (var i = 0; i < players.length; i++) {
                                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) {
                                                    bool = false; break;
                                                }
                                            }
                                            if (bool) return -10;
                                            if (player.hp == 1) return 1;
                                            return -10;
                                        }
                                    },
                                },
                            },
                            minibiyue: {
                                audio: 'biyue',
                                trigger: { player: 'phaseJieshuBegin' },
                                frequent: true,
                                content() {
                                    var num = 1;
                                    if (player.isTurnedOver()) num = 3;
                                    player.draw(num);
                                },
                            },
                            minijianchu: {
                                shaRelated: true,
                                audio: 'jianchu',
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.target.countDiscardableCards(player, 'he') > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.discardPlayerCard(trigger.target, get.prompt('minijianchu', trigger.target)).set('ai', function (button) {
                                        if (!_status.event.att) return 0;
                                        if (get.position(button.link) == 'e') {
                                            if (get.subtype(button.link) == 'equip2') return 2 * get.value(button.link);
                                            return get.value(button.link);
                                        }
                                        return 1;
                                    }).set('logSkill', ['minijianchu', trigger.target]).set('att', get.attitude(player, trigger.target) <= 0);
                                    'step 1'
                                    if (result.bool && result.links && result.links.length) {
                                        if (get.type(result.links[0], null, result.links[0].original == 'h' ? player : false) != 'basic') {
                                            player.draw();
                                            trigger.getParent().directHit.add(trigger.target);
                                        }
                                        else {
                                            trigger.addCount = false;
                                            if (player.stat[player.stat.length - 1].card.sha > 0) {
                                                player.stat[player.stat.length - 1].card.sha--;
                                            }
                                        }
                                    }
                                },
                                ai: {
                                    unequip_ai: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag == 'directHit_ai') return arg.card.name == 'sha' && arg.target.countCards('e', function (card) {
                                            return get.value(card) > 1;
                                        }) > 0;
                                        if (arg?.name == 'sha' && arg.target.getEquips(2).length) return true;
                                        return false;
                                    }
                                },
                            },
                            minichenglve: {
                                enable: 'phaseUse',
                                usable: 1,
                                audio: 'nzry_chenglve',
                                content() {
                                    'step 0'
                                    player.draw();
                                    player.chooseToDiscard('h', true);
                                    'step 1'
                                    if (result.bool) {
                                        player.addTempSkill('minichenglve_use');
                                        player.markAuto('minichenglve_use', [get.suit(result.cards[0], player)]);
                                        player.storage.minichenglve_use.sort(function (a, b) {
                                            return lib.suit.indexOf(b) - lib.suit.indexOf(a);
                                        });
                                        if (game.HasExtension('十周年UI')) {
                                            game.broadcastAll(function (player) {
                                                var str = '成略';
                                                for (var suit of player.getStorage('minichenglve_use')) str += get.translation(suit);
                                                if (player.marks.minichenglve_use) player.marks.minichenglve_use.firstChild.innerHTML = str;
                                            }, player);
                                        }
                                    }
                                },
                                ai: {
                                    order: 10,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    use: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: {
                                            markcount: () => undefined,
                                            content: '使用$花色的牌无距离和次数限制',
                                        },
                                        mod: {
                                            cardUsable(card, player) {
                                                const suit = get.suit(card);
                                                if (suit == 'unsure' || player.getStorage('minichenglve_use').includes(suit)) return Infinity;
                                            },
                                            targetInRange(card, player) {
                                                const suit = get.suit(card);
                                                if (suit == 'unsure' || player.getStorage('minichenglve_use').includes(suit)) return true;
                                            },
                                        },
                                    },
                                },
                            },
                            minijijun: {
                                audio: 'xinfu_jijun',
                                trigger: { global: 'useCardToPlayer' },
                                filter(event, player) {
                                    var bool1 = (event.targets.length == 1 && (event.card.name == 'sha' || get.type2(event.card) == 'trick'));
                                    var bool2 = (event.card.name == 'sha');
                                    if (event.player == player && bool1) return true;
                                    if (event.target == player && bool2) return true;
                                    return false;
                                },
                                forced: true,
                                content() {
                                    player.judge(function (card) {
                                        return get.color(card) == 'black' ? 1.5 : -1.5;
                                    }).set('callback', function () {
                                        if (event.judgeResult.color == 'black' && get.position(card, true) == 'o') player.addToExpansion('gain2', [card]).gaintag.add('minijijun');
                                    });
                                },
                                marktext: '兵',
                                //避免重复换了一个字眼
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                            },
                            minifangtong: {
                                audio: 'xinfu_fangtong',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.getExpansions('minijijun').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseButton([1, 3], [get.prompt2('minifangtong'), player.getExpansions('minijijun')]).set('ai', function (button) {
                                        var player = _status.event.player;
                                        if (player.getExpansions('minijijun').length >= 3 && game.hasPlayer(function (current) {
                                            return get.damageEffect(current, player, player, 'thunder') > 0;
                                        })) return 3;
                                        if (ui.selected.buttons.length == 1 && player.isDamaged()) return 2;
                                        if (!ui.selected.buttons.length) return 1;
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.links) {
                                        player.logSkill('minifangtong');
                                        var num = result.links.length;
                                        player.loseToDiscardpile(result.links);
                                        event.num = num;
                                    }
                                    else event.finish();
                                    'step 2'
                                    switch (num) {
                                        case 1:
                                            player.draw();
                                            break;
                                        case 2:
                                            if (player.isDamaged()) player.recover();
                                            break;
                                        case 3:
                                            player.chooseTarget('对一名角色造成2点雷属性伤害', true).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.damageEffect(target, player, player, 'thunder');
                                            });
                                            break;
                                    }
                                    if (num != 3) event.finish();
                                    'step 3'
                                    if (result.bool) {
                                        player.line(result.targets[0]);
                                        result.targets[0].damage(2, 'thunder');
                                    }
                                },
                            },
                            minizhoufu: {
                                audio: 'zhoufu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                filterCard: true,
                                selectCard: [0, 1],
                                filterTarget(card, player, target) {
                                    if (player == target) return false;
                                    if (!ui.selected.cards.length) return target.getExpansions('minizhoufu2').length;
                                    return !target.getExpansions('minizhoufu2').length;
                                },
                                check(card) {
                                    return 6 - get.value(card);
                                },
                                usable: 1,
                                position: 'he',
                                discard: false,
                                lose: false,
                                delay: false,
                                content() {
                                    if (!cards.length && target.getExpansions('minizhoufu2').length) {
                                        var cardx = target.getExpansions('minizhoufu2');
                                        target.loseToDiscardpile(cardx);
                                    }
                                    else {
                                        if (!target.storage.minizhoufu2_markcount) target.storage.minizhoufu2_markcount = 0;
                                        target.addToExpansion(cards, player, 'give').gaintag.add('minizhoufu2');
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            if (target.getExpansions('minizhoufu2').length && target.hp < 3) return -1;
                                            return -2;
                                        },
                                    },
                                },
                                group: ['minizhoufu_judge', 'minizhoufu_losehp'],
                                subSkill: {
                                    judge: {
                                        audio: 'zhoufu',
                                        trigger: { global: 'judgeBefore' },
                                        forced: true,
                                        filter(event, player) {
                                            return !event.directresult && event.player.getExpansions('minizhoufu2').length;
                                        },
                                        logTarget: 'player',
                                        content() {
                                            var cards = [trigger.player.getExpansions('minizhoufu2')[0]];
                                            trigger.directresult = cards[0];
                                        },
                                    },
                                    losehp: {
                                        audio: 'zhoufu',
                                        trigger: { global: 'phaseEnd' },
                                        forced: true,
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.hasHistory('lose', function (evt) {
                                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                                    for (var i in evt.gaintag_map) {
                                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                                    }
                                                    return false;
                                                });
                                            });
                                        },
                                        logTarget(current) {
                                            return game.filterPlayer(function (current) {
                                                return current.hasHistory('lose', function (evt) {
                                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                                    for (var i in evt.gaintag_map) {
                                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                                    }
                                                    return false;
                                                });
                                            }).sortBySeat();
                                        },
                                        content() {
                                            var targets = game.filterPlayer(function (current) {
                                                return current.hasHistory('lose', function (evt) {
                                                    if (!evt || !evt.xs || !evt.xs.length) return false;
                                                    for (var i in evt.gaintag_map) {
                                                        if (evt.gaintag_map[i].includes('minizhoufu2')) return true;
                                                    }
                                                    return false;
                                                });
                                            }).sortBySeat();
                                            while (targets.length) {
                                                targets.shift().loseHp();
                                            }
                                        },
                                    },
                                },
                            },
                            minizhoufu2: { intro: { content: 'expansion' } },
                            minizhoufu3: {},
                            miniyingbing: {
                                audio: 'yingbin',
                                trigger: { global: 'useCard' },
                                forced: true,
                                filter(event, player) {
                                    var cards = event.player.getExpansions('minizhoufu2');
                                    return cards.length && get.color(cards[0]) == get.color(event.card);
                                },
                                logTarget: 'player',
                                content() {
                                    'step 0'
                                    player.draw();
                                    'step 1'
                                    trigger.player.storage.minizhoufu2_markcount++;
                                    if (trigger.player.storage.minizhoufu2_markcount >= 2) {
                                        var cards = trigger.player.getExpansions('minizhoufu2');
                                        trigger.player.loseToDiscardpile(cards);
                                    }
                                    else trigger.player.markSkill('minizhoufu2');
                                },
                            },
                            miniguhuo: {
                                audio: 'guhuo_guess',
                                trigger: { player: 'useCardAfter' },
                                filter(event, player) {
                                    var bool = player.getHistory('sourceDamage', function (evt) {
                                        return evt.card && evt.card == event.card;
                                    }).length;
                                    if (bool && player.hasSkill('miniguhuo_silent')) return false;
                                    if (get.type(event.card) != 'trick' && event.card.name != 'sha') return false;
                                    return get.tag(event.card, 'damage');
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    var bool = player.getHistory('sourceDamage', function (evt) {
                                        return evt.card && evt.card == trigger.card;
                                    }).length, cards = trigger.cards.filterInD();
                                    if (bool) player.addTempSkill('miniguhuo_silent');
                                    else if (cards.length) {
                                        player.addTempSkill('miniguhuo_card', 'phaseEnd');
                                        player.addToExpansion(cards, 'gain2').gaintag.add('miniguhuo_card');
                                    }
                                    'step 1'
                                    player.draw();
                                },
                                subSkill: {
                                    silent: { charlotte: true },
                                    card: {
                                        charlotte: true,
                                        intro: {
                                            content: 'expansion',
                                            markcount: 'expansion',
                                        },
                                        onremove(player, skill) {
                                            var cards = player.getExpansions(skill);
                                            if (cards.length) player.gain(cards, 'gain2');
                                        },
                                    },
                                },
                            },
                            miniyaowu: {
                                audio: 'new_reyaowu',
                                audioname: ['sb_huaxiong'],
                                trigger: { player: 'damageBegin3' },
                                filter(event, player) {
                                    if (!event.card || event.card.name != 'sha') return false;
                                    return ['red', 'black'].includes(get.color(event.card)) || (get.itemtype(event.cards) == 'cards' && get.position(event.cards[0], true) == 'o');
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    if (get.color(trigger.card) == 'red') trigger.source.draw();
                                    else if (get.color(trigger.card) == 'black') player.draw();
                                    'step 1'
                                    if (get.itemtype(trigger.cards) == 'cards' && get.position(trigger.cards[0], true) == 'o') player.gain(trigger.cards, 'gain2', 'log');
                                },
                            },
                            miniyangwei: {
                                mod: {
                                    cardUsable(card, player, num) {
                                        if (typeof card == 'object' && player == _status.currentPhase) {
                                            var cardx = player.storage.miniyangwei_mark;
                                            if (cardx && get.name(card) == 'sha' && get.color(cardx) != 'none' && get.color(cardx) != get.color(card)) {
                                                return Infinity;
                                            }
                                        }
                                    },
                                    aiOrder(player, card, num) {
                                        if (typeof card == 'object' && player.isPhaseUsing()) {
                                            var cardx = player.storage.miniyangwei_mark;
                                            if (cardx && get.name(card) == 'sha' && get.color(cardx) != 'none' && get.color(cardx) != get.color(card)) {
                                                return num + 10;
                                            }
                                        }
                                    },
                                },
                                audio: 'sbyangwei',
                                trigger: { player: 'phaseUseEnd' },
                                filter(event, player) {
                                    return player.isDamaged() && player.getHistory('useCard', evt => evt.card.name == 'sha').length > 2;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player.recover();
                                },
                                group: 'miniyangwei_phase',
                                subSkill: {
                                    phase: {
                                        audio: 'sbyangwei',
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            return player.isPhaseUsing() && event.card.name == 'sha' && ['black', 'red'].includes(get.color(event.card));
                                        },
                                        forced: true,
                                        content() {
                                            'step 0'
                                            if (!player.storage.miniyangwei_mark) {
                                                player.when('phaseUseAfter').then(() => delete player.storage.miniyangwei_mark);
                                            }
                                            player.storage.miniyangwei_mark = trigger.card;
                                            player.addTempSkill('miniyangwei_count', 'phaseUseAfter');
                                            'step 1'
                                            game.broadcastAll((ind, player) => {
                                                var bgColor = lib.skill.dchuiling.subSkill.hint.markColor[ind][0];
                                                var text = '<span style="color: ' + lib.skill.dchuiling.subSkill.hint.markColor[ind][1] + '">杀</span>';
                                                if (!player.marks.miniyangwei_count) player.markSkill('miniyangwei_count');
                                                player.marks.miniyangwei_count.firstChild.style.backgroundColor = bgColor;
                                                player.marks.miniyangwei_count.firstChild.innerHTML = text;
                                            }, ['black', 'none', 'red'].indexOf(get.color(trigger.card)), player);
                                        },
                                    },
                                    count: {
                                        trigger: { player: 'useCard1' },
                                        filter(event, player) {
                                            var card = player.storage.miniyangwei_mark;
                                            if (!card || !player.isPhaseUsing()) return false;
                                            return get.name(event.card) == 'sha' && get.color(card) != 'none' && get.color(card) != get.color(event.card);
                                        },
                                        direct: true,
                                        firstDo: true,
                                        content() {
                                            player.removeSkill('miniyangwei_count');
                                            trigger.addCount = false;
                                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                                        },
                                        mark: true,
                                        marktext: '杀',
                                        intro: { content: storage => '本阶段可使用一张无次数限制且不计入次数的' + ['黑', '红'][['black', 'red'].indexOf(get.color(storage))] + '色【杀】' },
                                    },
                                },
                            },
                            miniqiaomeng: {
                                audio: 'qiaomeng',
                                trigger: { source: 'damageBegin1' },
                                direct: true,
                                filter(event, player) {
                                    if (event._notrigger.includes(event.player)) return false;
                                    return event.card && event.card.name == 'sha' && event.player.countGainableCards(player, 'hej');
                                },
                                content() {
                                    'step 0'
                                    player.gainPlayerCard(get.prompt('miniqiaomeng', trigger.player), 'hej', trigger.player).set('logSkill', ['miniqiaomeng', trigger.player]);
                                    'step 1'
                                    if (result.bool) {
                                        var card = result.cards[0];
                                        if (get.subtype(card) == 'equip3' || get.subtype(card) == 'equip4') trigger.num++;
                                    }
                                },
                            },
                            miniyicong: {
                                mod: {
                                    globalFrom(from, to, current) {
                                        return current - Math.max(0, from.hp);
                                    },
                                    globalTo(from, to, current) {
                                        return current + Math.max(0, to.getDamagedHp());
                                    },
                                },
                                ai: { threaten: 0.8 },
                            },
                            minishuangxiong: {
                                audio: 'shuangxiong',
                                group: ['minishuangxiong_effect', 'minishuangxiong_jianxiong'],
                                subSkill: {
                                    effect: {
                                        audio: 'shuangxiong1',
                                        trigger: { player: 'phaseDrawBegin1' },
                                        filter(event, player) {
                                            return !event.numFixed;
                                        },
                                        prompt2: () => '放弃摸牌，亮出牌堆顶的三张牌并选择获得其中一种颜色的所有牌，本回合你可以将与这些牌颜色不同的一张手牌当作【决斗】使用。',
                                        *content(event, map) {
                                            var player = map.player, trigger = map.trigger;
                                            trigger.changeToZero();
                                            var cards = get.cards(3, true);
                                            var videoId = lib.status.videoId++;
                                            game.broadcastAll(function (player, id, cards) {
                                                var str = ('双雄' + ((player == game.me && !_status.auto) ? '：获得其中一种颜色的牌' : ''));
                                                var dialog = ui.create.dialog(str, cards);
                                                dialog.videoId = id;
                                            }, player, videoId, cards);
                                            var time = get.utc();
                                            game.addVideo('showCards', player, ['双雄', get.cardsInfo(cards)]);
                                            game.addVideo('delay', null, 2);
                                            var result, list = cards.reduce((list, card) => list.add(get.color(card)), []);
                                            if (list.length == 1) result = { control: list[0] };
                                            else {
                                                //加大颜色兼容性
                                                var colors = ['red', 'black', 'none'];
                                                list.sort((a, b) => colors.indexOf(b) - colors.indexOf(a));
                                                if (list.includes('none')) list[list.indexOf('none')] = 'none2';
                                                list.reverse();
                                                result = yield player.chooseControl(list).set('ai', () => {
                                                    var getNum = (cards, color) => cards.reduce((num, card) => num + (get.color(card) == color ? 1 : 0), 0);
                                                    var controls = _status.event.controls.slice();
                                                    controls.sort((a, b) => getNum(_status.event.cards, b) - getNum(_status.event.cards, a));
                                                    return controls[0];
                                                }).set('cards', cards);
                                            }
                                            var color = result.control;
                                            if (color == 'none2') color = 'none';
                                            cards = cards.filter(card => get.color(card) == color);
                                            time = 1000 - (get.utc() - time);
                                            if (time > 0) game.delay(0, time);
                                            game.broadcastAll('closeDialog', videoId);
                                            if (cards.length) {
                                                player.gain(cards, 'gain2');
                                                player.addTempSkill('shuangxiong2');
                                                player.markAuto('shuangxiong2', [get.color(cards[0])]);
                                            }
                                        },
                                    },
                                    jianxiong: {
                                        audio: 'shuangxiong',
                                        trigger: { player: 'damageEnd' },
                                        filter(event, player) {
                                            var evt = event.getParent();
                                            if (!evt || evt.name != 'juedou') return false;
                                            return lib.skill.minishuangxiong.subSkill.jianxiong.getCards(event, player).length;
                                        },
                                        prompt: (event, player) => '获得' + get.translation(lib.skill.minishuangxiong.subSkill.jianxiong.getCards(event, player)),
                                        content() {
                                            player.gain(lib.skill.minishuangxiong.subSkill.jianxiong.getCards(trigger, player), 'gain2');
                                        },
                                        getCards(event, player) {
                                            var evt = event.getParent();
                                            var cards = evt[player == evt.player ? 'targetCards' : 'playerCards'].slice();
                                            return cards.filter(card => get.position(card) == 'd');
                                        },
                                    },
                                },
                            },
                            minixianzhen: {
                                group: 'minixianzhen_miss',
                                audio: 'xianzhen',
                                usable: 1,
                                trigger: { source: 'damageBegin1' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && event.notLink();
                                },
                                forced: true,
                                content() {
                                    trigger.num++;
                                },
                                subSkill: {
                                    miss: {
                                        audio: 'xianzhen',
                                        trigger: { player: 'shaMiss' },
                                        filter(event, player) {
                                            return player.countUsed('sha', true) == 1;
                                        },
                                        usable: 1,
                                        forced: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            minijinjiu: {
                                mod: {
                                    cardname(card, player) {
                                        if (card.name == 'jiu') return 'sha';
                                    },
                                },
                                ai: {
                                    respondSha: true,
                                    skillTagFilter(player) {
                                        if (!player.countCards('h', 'jiu')) return false;
                                    },
                                },
                                group: 'minijinjiu_gain',
                                global: 'minijinjiu_usejiu',
                                audio: 'jinjiu',
                                popup: false,
                                silent: true,
                                firstDo: true,
                                trigger: { player: 'useCard1' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && event.addCount !== false && event.cards &&
                                        event.cards.length == 1 && event.cards[0].name == 'jiu';
                                },
                                forced: true,
                                content() {
                                    trigger.addCount = false;
                                    if (player.stat[player.stat.length - 1].card.sha > 0) {
                                        player.stat[player.stat.length - 1].card.sha--;
                                    }
                                },
                                subSkill: {
                                    gain: {
                                        trigger: { global: 'useCardAfter' },
                                        forced: true,
                                        audio: 'jinjiu',
                                        filter(event, player) {
                                            return event.player != player && event.card.isCard && event.card.name == 'jiu' && event.cards.filterInD().length > 0;
                                        },
                                        logTarget: 'player',
                                        content() {
                                            player.gain(trigger.cards.filterInD(), 'gain2');
                                        },
                                    },
                                    usejiu: {
                                        mod: {
                                            cardEnabled(card, player) {
                                                if (card.name == 'jiu' && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.hasSkill('minijinjiu')) return false;
                                            },
                                            cardSavable(card, player) {
                                                if (card.name == 'jiu' && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.hasSkill('minijinjiu')) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minishendao: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'judge' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var str = '你的' + (trigger.judgestr || '') + '判定牌为' + get.translation(trigger.player.judging[0]) + '，是否修改判定花色？';
                                    player.chooseControl('spade', 'heart', 'diamond', 'club', 'cancel2').set('prompt', str).set('ai', function () {
                                        var judging = _status.event.judging;
                                        var trigger = _status.event.getTrigger();
                                        var res1 = trigger.judge(judging);
                                        var list = lib.suit.slice(0);
                                        var attitude = get.attitude(player, trigger.player);
                                        if (attitude == 0) return 0;
                                        var getj = function (suit) {
                                            return trigger.judge({
                                                name: get.name(judging),
                                                nature: get.nature(judging),
                                                suit: suit,
                                                number: get.number(judging),
                                            })
                                        };
                                        list.sort(function (a, b) {
                                            return (getj(b) - getj(a)) * get.sgn(attitude);
                                        });
                                        if ((getj(list[0]) - res1) * attitude > 0) return list[0];
                                        return 'cancel2';
                                    }).set('judging', trigger.player.judging[0]);
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minishendao');
                                        player.popup(result.control + 2);
                                        game.log(player, '将判定结果改为了', '#y' + get.translation(result.control + 2));
                                        trigger.fixedResult = {
                                            suit: result.control,
                                            color: get.color({ suit: result.control }),
                                        };
                                    }
                                },
                                ai: {
                                    rejudge: true,
                                    tag: {
                                        rejudge: 0.3,
                                    },
                                },
                            },
                            minixinsheng: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'damageEnd' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    event.cards = get.cards(3);
                                    game.cardsGotoOrdering(event.cards);
                                    event.videoId = lib.status.videoId++;
                                    game.broadcastAll(function (player, id, cards) {
                                        var str;
                                        if (player == game.me && !_status.auto) str = '新生：获得花色各不相同的牌各一张';
                                        else str = '新生';
                                        var dialog = ui.create.dialog(str, cards);
                                        dialog.videoId = id;
                                    }, player, event.videoId, event.cards);
                                    event.time = get.utc();
                                    game.addVideo('showCards', player, ['新生', get.cardsInfo(event.cards)]);
                                    game.addVideo('delay', null, 2);
                                    'step 1'
                                    var next = player.chooseButton([0, 3], true);
                                    next.set('dialog', event.videoId);
                                    next.set('filterButton', function (button) {
                                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                                            if (get.suit(ui.selected.buttons[i].link) == get.suit(button.link)) return false;
                                        }
                                        return true;
                                    });
                                    next.set('ai', function (button) {
                                        return get.value(button.link, _status.event.player);
                                    });
                                    'step 2'
                                    if (result.bool && result.links) event.cards2 = result.links;
                                    else event.finish();
                                    var time = 1000 - (get.utc() - event.time);
                                    if (time > 0) game.delay(0, time);
                                    'step 3'
                                    game.broadcastAll('closeDialog', event.videoId);
                                    var cards2 = event.cards2;
                                    player.gain(cards2, 'gain2');
                                    'step 4'
                                    lib.skill.old_shenzhu.caidan(player);
                                },
                            },
                            miniweidi: {
                                audio: 'weidi',
                                preHidden: true,
                                trigger: { player: 'phaseDiscardEnd' },
                                filter(event, player) {
                                    var cards = [];
                                    game.getGlobalHistory('cardMove', function (evt) {
                                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards.filterInD('d'));
                                    });
                                    game.countPlayer2(function (current) {
                                        current.getHistory('lose', function (evt) {
                                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != event) return;
                                            cards.addArray(evt.cards.filterInD('d'));
                                        })
                                    });
                                    return cards.length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var cards = [];
                                    game.getGlobalHistory('cardMove', function (evt) {
                                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == trigger) cards.addArray(evt.cards.filterInD('d'));
                                    });
                                    game.countPlayer2(function (current) {
                                        current.getHistory('lose', function (evt) {
                                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != trigger) return;
                                            cards.addArray(evt.cards.filterInD('d'));
                                        })
                                    });
                                    player.chooseCardButton(cards, '伪帝：是否将一张牌交给一名其他角色？').set('ai', function (button) {
                                        var player = _status.event.player;
                                        if (game.hasPlayer(function (current) {
                                            return current != player && get.attitude(player, current) > 0;
                                        })) return get.value(button.link);
                                        return 0;
                                    }).set('cards', cards).set('filterButton', function (button) {
                                        return _status.event.cards.includes(button.link);
                                    }).setHiddenSkill('miniweidi');
                                    'step 1'
                                    if (result.bool) {
                                        event.card = result.links[0];
                                        player.chooseTarget('将' + get.translation(event.card) + '交给一名其他角色', lib.filter.notMe, true).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.attitude(player, target) * get.value(event.card, target) * (target.hasSkillTag('nogain') ? 0.1 : 1);
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('miniweidi', target);
                                        target.gain(card, 'gain2');
                                    }
                                },
                            },
                            minimingce: {
                                audio: 'mingce',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        return target != player && game.hasPlayer(function (current) {
                                            return target.canUse({ name: 'sha' }, current, false) && target.inRange(current);
                                        });
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        prompt: get.prompt2('minimingce'),
                                        filterTarget(card, player, target) {
                                            if (ui.selected.targets.length) return ui.selected.targets[0].canUse({ name: 'sha' }, target, false) && ui.selected.targets[0].inRange(target);
                                            return target != player;
                                        },
                                        selectTarget: 2,
                                        filterCard: () => false,
                                        selectCard: -1,
                                        complexSelect: true,
                                        targetprompt: ['出杀者', '出杀目标'],
                                        ai2(target) {
                                            var player = _status.event.player, list = [];
                                            for (var i of game.filterPlayer()) {
                                                if (i == player) continue;
                                                for (var j of game.filterPlayer()) {
                                                    if (j == i || !i.inRange(j)) continue;
                                                    list.push([get.effect(j, { name: 'sha', isCard: true }, i, player), i, j]);
                                                }
                                            }
                                            if (!list.length) return 0;
                                            list.sort((a, b) => b[0] - a[0]);
                                            if (list[0][0] <= 0) return 0;
                                            if (!ui.selected.targets.length) return target == list[0][1] ? 10 : 0;
                                            return target == list[0][2] ? 10 : 0;
                                        },
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minimingce');
                                        player.line2(result.targets);
                                        result.targets[0].useCard({ name: 'sha', isCard: true }, result.targets[1], false, 'noai');
                                    }
                                },
                            },
                            miniremingce: {
                                audio: 'mingce',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(target => {
                                        return target != player || game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                                    });
                                },
                                async cost(event, trigger, player) {
                                    const goon = game.hasPlayer(target => {
                                        return game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                                    });
                                    const choiceList = ['令一名角色视为对其攻击范围内另一名你指定的角色使用一张【杀】，此【杀】结算后若此【杀】造成伤害，你摸两张牌', '选择一名其他角色，与其各摸一张牌，且其下回合使用【杀】的次数上限+1'];
                                    const choices = [];
                                    if (goon) choices.push('选项一');
                                    else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                                    if (game.hasPlayer(target => player != target)) choices.push('选项二');
                                    else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                                    const control = await player.chooseControl(choices, 'cancel2').set('choiceList', choiceList).set('prompt', get.prompt(event.name.slice(0, -5))).set('ai', () => {
                                        const player = get.player();
                                        const eff1 = Math.max.apply(Math, game.filterPlayer().map(i => i.getUseValue({ name: 'sha', isCard: true }, false))), eff2 = Math.max.apply(Math, game.filterPlayer(i => player != i).map(i => get.effect(i, { name: 'draw' }, player, player) + get.effect(player, { name: 'draw' }, player, player)));
                                        if (eff1 < 0 && eff1 < 0) return 'cancel2';
                                        return eff1 > eff2 ? 0 : 1;
                                    }).forResultControl();
                                    if (control == 'cancel2') return;
                                    const bool = control == '选项一';
                                    const index = bool ? 0 : 1, num = bool ? 2 : 1;
                                    const next = player.chooseTarget(get.prompt(event.name.slice(0, -5)), choiceList[index], true, num);
                                    if (bool) {
                                        next.set('filterTarget', (card, player, target) => {
                                            if (ui.selected.targets.length) return ui.selected.targets[0].canUse({ name: 'sha' }, target, false) && ui.selected.targets[0].inRange(target);
                                            return game.hasPlayer(current => target.canUse({ name: 'sha' }, current, false) && target.inRange(current));
                                        });
                                        next.set('complexSelect', true);
                                        next.set('targetprompt', ['出杀者', '出杀目标']);
                                        next.set('ai', target => {
                                            const player = get.player();
                                            let list = [];
                                            for (var i of game.filterPlayer()) {
                                                for (var j of game.filterPlayer()) {
                                                    if (j == i || !i.inRange(j)) continue;
                                                    list.push([get.effect(j, { name: 'sha', isCard: true }, i, player), i, j]);
                                                }
                                            }
                                            if (!list.length) return 0;
                                            list.sort((a, b) => b[0] - a[0]);
                                            if (list[0][0] <= 0) return 0;
                                            if (!ui.selected.targets.length) return target == list[0][1] ? 10 : 0;
                                            return target == list[0][2] ? 10 : 0;
                                        });
                                    }
                                    else {
                                        next.set('filterTarget', lib.filter.notMe);
                                        next.set('ai', target => {
                                            const player = get.player();
                                            return get.effect(target, { name: 'draw' }, player, player);
                                        });
                                    }
                                    event.result = await next.forResult();
                                },
                                async content(event, trigger, player) {
                                    const { targets } = event;
                                    if (targets.length > 1) {
                                        await targets[0].useCard({ name: 'sha', isCard: true }, targets[1], false, 'noai');
                                        if (targets[0].hasHistory('sourceDamage', evt => evt.getParent(3) == event)) await player.draw(2);
                                    }
                                    else {
                                        await game.asyncDraw([player, targets[0]].sortBySeat());
                                        targets[0].addTempSkill(event.name + '_effect', { player: 'phaseAfter' });
                                        targets[0].addMark(event.name + '_effect', 1, false);
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == 'sha' && player == _status.currentPhase) return num + player.countMark('miniremingce_effect');
                                            },
                                        },
                                        intro: { content: '使用【杀】的次数上限+#' },
                                    }
                                },
                            },
                            minizhichi: {
                                audio: 'zhichi',
                                inherit: 'zhichi',
                                content() {
                                    player.addTempSkill(event.name + '_effect');
                                },
                                subSkill: {
                                    effect: {
                                        audio: 'zhichi',
                                        trigger: { player: 'damageBegin4', target: 'useCardToBefore' },
                                        charlotte: true,
                                        forced: true,
                                        filter(event, player) {
                                            return get.type(event.card) == 'trick' || event.name == 'damage';
                                        },
                                        content() {
                                            player.chat('喜！');
                                            trigger.cancel();
                                        },
                                        mark: true,
                                        intro: { content: '防止你受到的伤害且普通锦囊牌对你无效' },
                                        ai: {
                                            maixie: true,
                                            maixie_hp: true,
                                            nofire: true,
                                            nothunder: true,
                                            nodamage: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.type(card) == 'trick' || get.tag(card, 'damage')) return 'zeroplayertarget';
                                                },
                                            },
                                        },
                                    }
                                }
                            },
                            miniluanji: {
                                audio: 'reluanji',
                                enable: 'phaseUse',
                                viewAs: { name: 'wanjian' },
                                filterCard(card, player) {
                                    if (!player.storage.miniluanji) return true;
                                    return !player.storage.miniluanji.includes(get.suit(card));
                                },
                                position: 'hs',
                                selectCard: 2,
                                check(card) {
                                    var player = _status.event.player;
                                    var targets = game.filterPlayer(function (current) {
                                        return player.canUse('wanjian', current);
                                    });
                                    var num = 0;
                                    for (var i = 0; i < targets.length; i++) {
                                        var eff = get.sgn(get.effect(targets[i], { name: 'wanjian' }, player, player));
                                        if (targets[i].hp == 1) {
                                            eff *= 1.5;
                                        }
                                        num += eff;
                                    }
                                    if (!player.needsToDiscard(-1)) {
                                        if (targets.length >= 7) {
                                            if (num < 2) return 0;
                                        }
                                        else if (targets.length >= 5) {
                                            if (num < 1.5) return 0;
                                        }
                                    }
                                    return 6 - get.value(card);
                                },
                                ai: {
                                    basic: {
                                        order: 8.9
                                    }
                                },
                                group: ['miniluanji_count', 'miniluanji_reset', 'miniluanji_damage', 'miniluanji_draw'],
                                subSkill: {
                                    reset: {
                                        trigger: { player: 'phaseAfter' },
                                        silent: true,
                                        content() {
                                            delete player.storage.miniluanji;
                                            delete player.storage.miniluanji2;
                                        }
                                    },
                                    count: {
                                        trigger: { player: 'useCard' },
                                        silent: true,
                                        filter(event) {
                                            return event.skill == 'miniluanji';
                                        },
                                        content() {
                                            player.storage.miniluanji2 = trigger.card;
                                            if (!player.storage.miniluanji) {
                                                player.storage.miniluanji = [];
                                            }
                                            for (var i = 0; i < trigger.cards.length; i++) {
                                                player.storage.miniluanji.add(get.suit(trigger.cards[i]));
                                            }
                                        }
                                    },
                                    damage: {
                                        trigger: { source: 'damage' },
                                        forced: true,
                                        silent: true,
                                        popup: false,
                                        filter(event, player) {
                                            return player.storage.miniluanji2 && event.card == player.storage.miniluanji2;
                                        },
                                        content() {
                                            delete player.storage.miniluanji2;
                                        },
                                    },
                                    draw: {
                                        trigger: { player: 'useCardAfter' },
                                        forced: true,
                                        silent: true,
                                        popup: false,
                                        filter(event, player) {
                                            return player.storage.miniluanji2 && event.card == player.storage.miniluanji2;
                                        },
                                        content() {
                                            player.draw(trigger.targets.length);
                                            delete player.storage.miniluanji2;
                                        },
                                    },
                                }
                            },
                            minixueyi: {
                                unique: true,
                                audio: 'xueyi',
                                enable: 'chooseToUse',
                                trigger: { global: 'phaseBefore', player: 'enterGame' },
                                filter(event, player) {
                                    if (event.name == 'chooseToUse') {
                                        if (!player.hasMark('minixueyi')) return false;
                                        if (event.type == 'dying') return player == event.dying;
                                        if (event.parent.name == 'phaseUse') return true;
                                        return false;
                                    }
                                    if (!game.hasPlayer(current => current.group == 'qun')) return false
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                forced: true,
                                zhuSkill: true,
                                content() {
                                    if (event.getParent(2).name == 'chooseToUse') {
                                        player.removeMark('minixueyi', 1);
                                        player.recover();
                                        player.draw();
                                    }
                                    else player.addMark('minixueyi', game.countPlayer(current => current.group == 'qun'));
                                },
                                marktext: '裔',
                                intro: {
                                    name2: '裔',
                                    content: 'mark',
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + (player.countMark('minixueyi') * 2);
                                    },
                                },
                                ai: {
                                    order: 7,
                                    save: true,
                                    skillTagFilter(player, tag, target) {
                                        if (player != target || !player.hasMark('minixueyi')) return false;
                                    },
                                    result: {
                                        player(player) {
                                            return player.isDamaged() ? 1 : -1;
                                        },
                                    },
                                },
                            },
                            minijiuchi: {
                                audio: 'jiuchi',
                                enable: 'chooseToUse',
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                viewAs: { name: 'jiu' },
                                viewAsFilter(player) {
                                    if (!player.countCards('hs', { color: 'black' })) return false;
                                    return true;
                                },
                                prompt: '将一张黑色手牌当酒使用',
                                check(card) {
                                    if (_status.event.type == 'dying') return 1 / Math.max(0.1, get.value(card));
                                    return 4 - get.value(card);
                                },
                            },
                            minibenghuai: {
                                audio: 'benghuai',
                                inherit: 'benghuai',
                                content() {
                                    var next = game.createEvent('minibenghuai_benghuai');
                                    next.player = player;
                                    next.setContent(lib.skill.benghuai.content);
                                    player.draw();
                                },
                            },
                            miniwansha: {
                                audio: 'wansha',
                                audioname: ['re_jiaxu'],
                                audioname2: { shen_simayi: "jilue_wansha" },
                                global: 'miniwansha2',
                                trigger: { global: 'dying' },
                                forced: true,
                                preHidden: true,
                                filter(event, player, name) {
                                    return _status.currentPhase == player && event.player != player;
                                },
                                content() { },
                            },
                            miniwansha2: {
                                mod: {
                                    cardSavable(card, player) {
                                        const target = _status.currentPhase;
                                        if (!target?.isIn()) return;
                                        if ((target.hasSkill('miniwansha') || target.hasSkill('minirewansha')) && target != player) {
                                            if (card.name == 'tao') return false;
                                        }
                                    },
                                    cardEnabled(card, player) {
                                        return lib.skill.miniwansha2.mod.cardSavable.apply(this, arguments);
                                    },
                                },
                            },
                            minirewansha: {
                                inherit: 'miniwansha',
                                group: 'minirewansha_effect',
                                subSkill: {
                                    effect: {
                                        audio: 'wansha',
                                        audioname: ['re_jiaxu'],
                                        audioname2: { shen_simayi: "jilue_wansha" },
                                        trigger: {
                                            player: 'phaseUseBegin',
                                        },
                                        filter(event, player) {
                                            return game.hasPlayer(current => current != player && current.hp > 1);
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget(get.prompt('minirewansha'), '令一名体力值大于1的其他角色失去1点体力，本阶段结束时其回复1点体力', (card, player, target) => {
                                                return target != player && target.hp > 1;
                                            }).set('ai', target => {
                                                const player = get.player();
                                                return get.effect(target, { name: 'losehp' }, player, player);
                                            }).forResult();
                                        },
                                        async content(event, trigger, player) {
                                            const target = event.targets[0];
                                            player.line(target);
                                            await target.loseHp();
                                            player.when('phaseUseEnd').then(() => {
                                                if (target.isIn()) target.recover();
                                            }).vars({ target: target });
                                        },
                                    }
                                }
                            },
                            minimieji: {
                                audio: 'xinmieji',
                                enable: 'phaseUse',
                                usable: 1,
                                filter(event, player) {
                                    return player.countCards('he', { color: 'black' }) > 0;
                                },
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                position: 'he',
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('h');
                                },
                                discard: false,
                                delay: false,
                                check(card) {
                                    return 8 - get.value(card);
                                },
                                loseTo: 'cardPile',
                                insert: true,
                                content() {
                                    'step 0'
                                    player.$throw(1, 1000);
                                    game.log(player, '将一张牌置于了牌堆顶');
                                    game.delayx();
                                    'step 1'
                                    target.chooseToDiscard('he', true).set('prompt', '请弃置一张锦囊牌，或依次弃置两张非锦囊牌。');
                                    'step 2'
                                    if ((!result.cards || get.type(result.cards[0], 'trick', result.cards[0].original == 'h' ? target : false) != 'trick') && target.countCards('he', function (card) {
                                        return get.type2(card) != 'trick';
                                    })) {
                                        target.chooseToDiscard('he', true, function (card) {
                                            return get.type2(card) != 'trick';
                                        }).set('prompt', '请弃置第二张非锦囊牌');
                                    }
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target: -1,
                                    },
                                },
                            },
                            minishibei: {
                                audio: 'shibei',
                                trigger: { player: 'damageEnd' },
                                forced: true,
                                check(event, player) {
                                    return player.getHistory('damage', function (evt) {
                                        return evt != event
                                    }).length == 0;
                                },
                                content() {
                                    if (player.getHistory('damage', function (evt) {
                                        return evt != trigger
                                    }).length > 0) {
                                        player.loseHp();
                                    }
                                    else {
                                        player.recover();
                                        player.draw();
                                    }
                                },
                                subSkill: {
                                    damaged: {},
                                    ai: {},
                                },
                                ai: {
                                    maixie_defend: true,
                                    threaten: 0.9,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.hasSkillTag('jueqing')) return;
                                            if (target.hujia) return;
                                            if (player._minishibei_tmp) return;
                                            if (target.hasSkill('minishibei_ai')) return;
                                            if (_status.event.getParent('useCard', true) || _status.event.getParent('_wuxie', true)) return;
                                            if (get.tag(card, 'damage')) {
                                                if (target.getHistory('damage').length > 0) {
                                                    return [1, -2];
                                                }
                                                else {
                                                    if (get.attitude(player, target) > 0 && target.hp > 1) {
                                                        return 0;
                                                    }
                                                    if (get.attitude(player, target) < 0 && !player.hasSkillTag('damageBonus')) {
                                                        if (card.name == 'sha') return;
                                                        var sha = false;
                                                        player._minishibei_tmp = true;
                                                        var num = player.countCards('h', function (card) {
                                                            if (card.name == 'sha') {
                                                                if (sha) {
                                                                    return false;
                                                                }
                                                                else {
                                                                    sha = true;
                                                                }
                                                            }
                                                            return get.tag(card, 'damage') && player.canUse(card, target) && get.effect(target, card, player, player) > 0;
                                                        });
                                                        delete player._minishibei_tmp;
                                                        if (player.hasSkillTag('damage')) {
                                                            num++;
                                                        }
                                                        if (num < 2) {
                                                            var enemies = player.getEnemies();
                                                            if (enemies.length == 1 && enemies[0] == target && player.needsToDiscard()) {
                                                                return;
                                                            }
                                                            return 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            //华佗
                            minijijiu: {
                                mod: {
                                    aiValue(player, card, num) {
                                        if (get.name(card) != 'tao' && get.color(card) != 'red') return;
                                        var cards = player.getCards('hs', function (card) {
                                            return get.name(card) == 'tao' || get.color(card) == 'red';
                                        });
                                        cards.sort(function (a, b) {
                                            return (get.name(a) == 'tao' ? 1 : 2) - (get.name(b) == 'tao' ? 1 : 2);
                                        });
                                        var geti = function () {
                                            if (cards.includes(card)) {
                                                return cards.indexOf(card);
                                            }
                                            return cards.length;
                                        };
                                        return Math.max(num, [6.5, 4, 3, 2][Math.min(geti(), 2)]);
                                    },
                                    aiUseful() {
                                        return lib.skill.minijijiu.mod.aiValue.apply(this, arguments);
                                    },
                                },
                                locked: false,
                                audio: 'jijiu',
                                enable: 'chooseToUse',
                                viewAsFilter(player) {
                                    return player != _status.currentPhase && player.countCards('hes', { color: 'red' }) > 0;
                                },
                                filterCard(card) {
                                    return get.color(card) == 'red';
                                },
                                position: 'hes',
                                viewAs: { name: 'tao' },
                                prompt: '将一张红色牌当作【桃】使用，然后你可以弃置一名其他角色的一张手牌',
                                check(card) {
                                    return 1 / (get.value(card) || 0.5);
                                },
                                onuse(result, player) {
                                    player.addTempSkill('minijijiu_qixi');
                                },
                                subSkill: {
                                    qixi: {
                                        charlotte: true,
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            return event.skill == 'minijijiu' && game.hasPlayer(function (target) {
                                                return target != player && target.countDiscardableCards(player, 'h');
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('minijijiu'), '弃置一名其他角色的一张手牌', function (card, player, target) {
                                                return target != player && target.countDiscardableCards(player, 'h');
                                            }).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                player.line(result.targets);
                                                player.discardPlayerCard(result.targets[0], 'h', true);
                                            }
                                        },
                                    },
                                },
                            },
                            minireqingnang: {
                                audio: 'qingnang',
                                enable: 'phaseUse',
                                filterTarget: true,
                                selectTarget: [1, Infinity],
                                multitarget: true,
                                multiline: true,
                                usable: 1,
                                content() {
                                    'step 0'
                                    targets.forEach(target => {
                                        target.gainMaxHp();
                                        target.recover();
                                    });
                                    player.when('phaseBegin').vars({ targets: targets }).then(() => targets.forEach(target => target.loseMaxHp()));
                                    'step 1'
                                    if (targets.length > 1) player.chooseToDiscard(targets.length - 1, 'he', true);
                                },
                                ai: {
                                    order: 1,
                                    result: { target: 1 },
                                },
                            },
                            miniqingnang: {
                                audio: 'qingnang',
                                inherit: 'qingnang',
                                filterCard: false,
                            },
                            minileiji: {
                                mod: { maxHandcard: (player, num) => num + 2 },
                                audio: 'releiji',
                                trigger: { player: ['useCard', 'respond'] },
                                filter(event, player) {
                                    return event.card.name == 'shan' || event.card.name == 'shandian';
                                },
                                direct: true,
                                content() {
                                    'step 0';
                                    player.chooseTarget(get.prompt('minileiji'), '令一名其他角色进行判定', lib.filter.notMe).set('ai', function (target) {
                                        if (target.hasSkill('hongyan')) return 0;
                                        return get.damageEffect(target, _status.event.player, _status.event.player, 'thunder');
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minileiji', result.targets, 'thunder');
                                        event.target = result.targets[0];
                                        event.target.judge(function (card) {
                                            var suit = get.suit(card);
                                            if (suit == 'spade') return -4;
                                            if (suit == 'club') return -2;
                                            return 0;
                                        }).judge2 = function (result) {
                                            return result.bool == false ? true : false;
                                        };
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.suit == 'club') {
                                        target.damage('thunder');
                                        player.recover();
                                    }
                                    else if (result.suit == 'spade') target.damage(2, 'thunder');
                                },
                                ai: {
                                    useShan: true,
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondShan') && !player.hasSkillTag('directHit_ai', true, {
                                                target: target,
                                                card: card,
                                            }, true)) {
                                                var hastarget = game.hasPlayer(function (current) {
                                                    return get.attitude(target, current) < 0;
                                                });
                                                var be = target.countCards('e', { color: 'black' });
                                                if (target.countCards('h', 'shan') && be) {
                                                    if (!target.hasSkill('xinguidao')) return 0;
                                                    return [0, hastarget ? target.countCards('he') / 2 : 0];
                                                }
                                                if (target.countCards('h', 'shan') && target.countCards('h') > 2) {
                                                    if (!target.hasSkill('xinguidao')) return 0;
                                                    return [0, hastarget ? target.countCards('h') / 4 : 0];
                                                }
                                                if (target.countCards('h') > 3 || (be && target.countCards('h') >= 2)) {
                                                    return [0, 0];
                                                }
                                                if (target.countCards('h') == 0) {
                                                    return [1.5, 0];
                                                }
                                                if (target.countCards('h') == 1 && !be) {
                                                    return [1.2, 0];
                                                }
                                                if (!target.hasSkill('xinguidao')) return [1, 0.05];
                                                return [1, Math.min(0.5, (target.countCards('h') + be) / 4)];
                                            }
                                        },
                                    },
                                },
                            },
                            minihuangtian: {
                                audio: 'huangtian2',
                                unique: true,
                                zhuSkill: true,
                                global: 'minihuangtian2',
                                group: 'minihuangtian4',
                            },
                            minihuangtian2: {
                                audio: 'huangtian2',
                                enable: 'phaseUse',
                                discard: false,
                                lose: false,
                                delay: false,
                                line: true,
                                direct: true,
                                clearTime: true,
                                prepare(cards, player, targets) {
                                    targets[0].logSkill('minihuangtian');
                                },
                                prompt() {
                                    var player = _status.event.player;
                                    var list = game.filterPlayer(function (target) {
                                        return target != player && target.hasZhuSkill('minihuangtian', player);
                                    });
                                    var str = '将一张【闪】或【闪电】或黑桃手牌交给' + get.translation(list);
                                    if (list.length > 1) str += '中的一人';
                                    return str;
                                },
                                filter(event, player) {
                                    if (player.group != 'qun') return false;
                                    if (player.countCards('h', { name: ['shan', 'shandian'] }) + player.countCards('h', { suit: 'spade' }) == 0) return false;
                                    return game.hasPlayer(function (target) {
                                        return target != player && target.hasZhuSkill('minihuangtian', player) && !target.hasSkill('minihuangtian3');
                                    });
                                },
                                filterCard(card) {
                                    return card.name == 'shan' || card.name == 'shandian' || get.suit(card) == 'spade';
                                },
                                log: false,
                                visible: true,
                                filterTarget(card, player, target) {
                                    return target != player && target.hasZhuSkill('minihuangtian', player) && !target.hasSkill('minihuangtian3');
                                },
                                content() {
                                    target.gain(cards, player, 'giveAuto');
                                    target.addTempSkill('minihuangtian3', 'phaseUseEnd');
                                },
                                ai: {
                                    expose: 0.3,
                                    order: 10,
                                    result: { target: 1 },
                                },
                            },
                            minihuangtian3: {},
                            minihuangtian4: {
                                audio: 'huangtian2',
                                trigger: { global: ['useCardAfter', 'responseAfter'] },
                                filter(event, player) {
                                    return event.card.name == 'shan' && event.player != player && event.cards.filterInD().length > 0 && event.player.group == 'qun';
                                },
                                prompt2(event, player) {
                                    return '获得' + get.translation(event.cards.filterInD());
                                },
                                usable: 1,
                                logTarget: 'player',
                                content() {
                                    player.gain(trigger.cards.filterInD(), 'gain2');
                                },
                            },
                            miniyinlang: {
                                global: 'miniyinlang_use',
                                audio: 'yinlang',
                                trigger: { player: 'phaseUseEnd' },
                                direct: true,
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current.group && current.group != 'unknown';
                                    });
                                },
                                content() {
                                    'step 0'
                                    var list = [];
                                    game.countPlayer(function (current) {
                                        if (current.group && current.group != 'unknown') list.add(current.group);
                                    });
                                    list.sort(function (a, b) {
                                        return lib.group.indexOf(a) - lib.group.indexOf(b);
                                    });
                                    list.push('cancel2');
                                    player.chooseControl(list).set('prompt', get.prompt2('miniyinlang')).set('ai', function () {
                                        return _status.event.choice;
                                    }).set('choice', function () {
                                        var getn = function (group) {
                                            return game.countPlayer(function (current) {
                                                if (current.group != group || current == player) return false;
                                                if (get.attitude(current, player) > 0) return -0.5;
                                                if (!current.inRange(player)) return 1;
                                                return 0.6;
                                            });
                                        }
                                        list.sort((a, b) => getn(b) - getn(a));
                                        return list[0];
                                    }());
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('miniyinlang', game.filterPlayer(function (current) {
                                            return current.group == result.control;
                                        }));
                                        game.log(player, '选择了', '#y' + get.translation(result.control + 2));
                                        for (var i of game.players) {
                                            if (i == player || i.group == result.control) i.addMark('miniyinlang', 1);
                                        }
                                    }
                                },
                                marktext: '生', intro: { name: '引狼', name2: '生', content: 'mark' },
                                subSkill: {
                                    use: {
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (game.hasPlayer(function (current) {
                                                    return current.hasSkill('miniyinlang');
                                                }) && player.hasMark('miniyinlang') && !target.hasMark('miniyinlang')) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minixiusheng: {
                                audio: 'xiusheng',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current.hasMark('miniyinlang');
                                    });
                                },
                                forced: true,
                                logTarget(event, player) {
                                    return game.filterPlayer(function (current) {
                                        return current.hasMark('miniyinlang');
                                    });
                                },
                                content() {
                                    var num = 0;
                                    for (var i of game.players) {
                                        if (i.hasMark('miniyinlang')) {
                                            var numx = i.countMark('miniyinlang');
                                            i.removeMark('miniyinlang', numx);
                                            num += numx;
                                        }
                                    }
                                    player.draw(num);
                                },
                                ai: { combo: 'miniyinlang' },
                            },
                            minihuaibi: {
                                mod: {
                                    maxHandcard(player, num) {
                                        if (player.storage.miniyinlang) return num + game.countPlayer(function (current) {
                                            return current.countMark('miniyinlang');
                                        });
                                    },
                                },
                                group: 'minihuaibi_discard',
                                audio: 'huaibi',
                                unique: true,
                                trigger: { player: 'damageEnd' },
                                filter(event, player) {
                                    return event.source && event.source.hasMark('miniyinlang');
                                },
                                forced: true,
                                zhuSkill: true,
                                content() {
                                    player.draw();
                                },
                                ai: { combo: 'miniyinlang' },
                                subSkill: {
                                    discard: {
                                        audio: 'huaibi',
                                        trigger: { player: 'phaseDiscardBefore' },
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.hasMark('miniyinlang');
                                            }) && player.countCards('h') > player.hp;
                                        },
                                        forced: true,
                                        firstDo: true,
                                        content() { },
                                    },
                                },
                            },
                            minikuangfu: {
                                audio: 'xinkuangfu',
                                enable: 'phaseUse',
                                filterTarget(card, player, target) {
                                    if (player == target) return player.countCards('e', function (card) {
                                        return lib.filter.cardDiscardable(card, player);
                                    }) > 0;
                                    return target.countDiscardableCards(player, 'e') > 0;
                                },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current.countCards('e');
                                    });
                                },
                                usable: 1,
                                delay: false,
                                content() {
                                    'step 0'
                                    if (player == target) player.chooseToDiscard('e', true);
                                    else player.discardPlayerCard(target, 'e', true);
                                    'step 1'
                                    player.chooseUseTarget('sha', true, false, 'nodistance');
                                    'step 2'
                                    var bool = game.hasPlayer2(function (current) {
                                        return current.getHistory('damage', function (evt) {
                                            return evt.getParent(4) == event;
                                        }).length > 0
                                    });
                                    if (bool) player.draw(2);
                                },
                                ai: {
                                    order() {
                                        return get.order({ name: 'sha' }) - 0.3;
                                    },
                                    result: {
                                        target(player, target) {
                                            var att = get.attitude(player, target);
                                            if (att < 0) return -2;
                                            if (target == player) return 1;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            minilihun: {
                                audio: 'lihun',
                                inherit: 'lihun',
                                filterTarget: lib.filter.notMe,
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards('h');
                                    });
                                },
                                filterCard: () => false,
                                selectCard: -1,
                            },
                            minizhuiji: {
                                mod: {
                                    globalFrom(from, to) {
                                        if (from.hp >= to.hp) return -Infinity;
                                    },
                                },
                                shaRelated: true,
                                trigger: { player: 'useCardToPlayered' },
                                logTarget: 'target',
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    return event.target.hp >= player.hp;
                                },
                                forced: true,
                                preHidden: true,
                                logTarget: 'target',
                                content() {
                                    trigger.getParent().directHit.push(trigger.target);
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg.card.name != 'sha') return false;
                                        return arg.target.hp > player.hp;
                                    },
                                },
                            },
                            minishichou: {
                                group: ['minishichou2', 'minishichou4'],
                                audio: 'ol_shichou',
                                trigger: { player: 'useCard2' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && game.hasPlayer(function (current) {
                                        return !event.targets.includes(current) && lib.filter.filterTarget(event.card, player, current);
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var num = Math.min(player.getDamagedHp() + 1, game.countPlayer(function (current) {
                                        return !trigger.targets.includes(current) && lib.filter.filterTarget(trigger.card, player, current);
                                    }));
                                    player.chooseTarget(get.prompt('minishichou'), '令至多' + get.cnNumber(num) + '名其他角色也成为' + get.translation(trigger.card) + '的目标', [1, num], function (card, player, target) {
                                        var evt = _status.event.getTrigger();
                                        return target != player && !evt.targets.includes(target) && lib.filter.targetEnabled2(evt.card, player, target) && lib.filter.targetInRange(evt.card, player, target);
                                    }).ai = function (target) {
                                        return get.effect(target, { name: 'sha' }, _status.event.player);
                                    };
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets;
                                        player.logSkill('minishichou', targets);
                                        player.line(targets, trigger.card.nature);
                                        trigger.targets.addArray(targets);
                                    }
                                },
                            },
                            minishichou2: {
                                audio: 'ol_shichou',
                                trigger: { source: 'damageSource' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && player.countMark('minishichou3') < 3;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    var num = Math.min(trigger.num, 3 - player.countMark('minishichou3'));
                                    player.draw(num);
                                    player.addTempSkill('minishichou3');
                                    player.addMark('minishichou3', num, false);
                                },
                            },
                            minishichou3: { charlotte: true, onremove: true },
                            minishichou4: {
                                audio: 'ol_shichou',
                                trigger: { player: 'useCardAfter' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && !player.getHistory('sourceDamage', function (evt) {
                                        return evt.card == event.card;
                                    }).length;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    var card = get.cardPile2(function (card) {
                                        return card.name == 'sha';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                },
                            },
                            minilijian: {
                                audio: 'lijian',
                                trigger: { player: ['useCard2', 'useCardToPlayer'] },
                                filter(event, player) {
                                    if (event.minilijian || !event.targets) return false;
                                    return (event.card.name == 'sha' || event.card.name == 'juedou') && game.hasPlayer(function (current) {
                                        return current != player && current.hasSex('male') && !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current);
                                    });
                                },
                                usable: 1,
                                direct: true,
                                content() {
                                    'step 0'
                                    trigger.minilijian = true;
                                    player.chooseTarget(get.prompt('minilijian'), '为' + get.translation(trigger.card) + '增加一个目标', function (card, player, target) {
                                        var evt = _status.event.getTrigger();
                                        return !evt.targets.includes(target) && target != player && target.hasSex('male') && lib.filter.targetEnabled2(evt.card, player, target);
                                    }).set('ai', function (target) {
                                        var evt = _status.event.getTrigger();
                                        return get.effect(target, evt.card, evt.player, evt.player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        if (player != game.me && !player.isOnline()) game.delayx();
                                        event.target = result.targets[0];
                                    }
                                    else {
                                        player.storage.counttrigger.minilijian--;
                                        event.finish();
                                    }
                                    'step 2'
                                    player.logSkill('minilijian', target);
                                    trigger.targets.push(target);
                                    game.log(target, '成为了', trigger.card, '的额外目标');
                                },
                            },
                            minijiqiao: {
                                audio: 'jiqiao',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return player.countCards('he') - player.countCards('he', { type: 'trick' }) > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard(get.prompt2('minijiqiao'), [1, player.countCards('he') - player.countCards('he', { type: 'trick' })], 'he', function (card) {
                                        return get.type2(card) != 'trick';
                                    }).set('ai', function (card) {
                                        if (card.name == 'bagua') return 10;
                                        return 7 - get.value(card);
                                    }).logSkill = 'jiqiao';
                                    'step 1'
                                    if (result.bool) {
                                        event.cards = get.cards(2 * result.cards.length);
                                        player.showCards(event.cards);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var gained = [];
                                    var tothrow = [];
                                    if (event.cards?.length) {
                                        for (var i = 0; i < event.cards.length; i++) {
                                            if (get.type2(event.cards[i]) == 'trick') gained.push(event.cards[i]);
                                            else tothrow.push(event.cards[i]);
                                        }
                                    }
                                    if (gained.length) player.gain(gained, 'gain2');
                                    else {
                                        var card = get.cardPile(function (card) {
                                            return get.type2(card) == 'trick';
                                        });
                                        if (card) player.gain(card, 'gain2');
                                    }
                                    if (tothrow.length) game.cardsDiscard(tothrow);
                                },
                            },
                            minilinglong: {
                                derivation: ['bagua_skill', 'minirejizhi', 'qicai'],
                                audio: 'linglong',
                                group: ['linglong_bagua', 'minilinglong_jizhi'],
                                locked: true,
                                mod: {
                                    maxHandcard(player, num) {
                                        if (player.getEquips(3).length || player.getEquips(4).length) return;
                                        return num + 1;
                                    },
                                    targetInRange(card, player, target, now) {
                                        if (player.countCards('e')) return;
                                        var type = get.type(card);
                                        if (type == 'trick' || type == 'delay') return true;
                                    },
                                },
                            },
                            minilinglong_jizhi: {
                                audio: 'rejizhi',
                                inherit: 'minirejizhi',
                                filter(event, player) {
                                    return !player.countCards('e') && get.type2(event.card) == 'trick';
                                },
                            },
                            minifuqi: {
                                group: 'minifuqi_tieji',
                                audio: 'fuqi',
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    return event.card && (get.type(event.card) == 'trick' || get.type(event.card) == 'basic' && !['shan', 'tao', 'jiu', 'du'].includes(event.card.name)) && game.hasPlayer(function (current) {
                                        return current != player && get.distance(current, player) <= 2;
                                    });
                                },
                                forced: true,
                                content() {
                                    var targets = game.filterPlayer(function (current) {
                                        return current != player && get.distance(current, player) <= 2;
                                    });
                                    for (var target of targets) target.popup('无法响应');
                                    trigger.directHit.addArray(targets);
                                },
                                ai: {
                                    ignoreSkill: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag == 'directHit_ai') return get.distance(arg.target, player) <= 2;
                                        if (!arg || arg.isLink || !arg.card || !get.tag(arg.card, 'damage')) return false;
                                        if (!arg.skill || !lib.skill[arg.skill] || lib.skill[arg.skill].charlotte || get.is.locked(arg.skill) || !arg.target.getSkills(true, false).includes(arg.skill)) return false;
                                    },
                                },
                                subSkill: {
                                    tieji: {
                                        audio: 'fuqi',
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return event.player != player && event.player.isIn();
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        content() {
                                            trigger.player.addTempSkill('fengyin');
                                        },
                                    },
                                },
                            },
                            minijiaozi: {
                                audio: 'jiaozi',
                                trigger: { source: 'damageBegin1' },
                                filter(event, player) {
                                    return player.isMaxHandcard();
                                },
                                forced: true,
                                content() {
                                    trigger.num++;
                                },
                                ai: { presha: true },
                            },
                            minitianming: {
                                audio: 'tianming',
                                trigger: { target: 'useCardToTargeted' },
                                filter(event, player) {
                                    return event.card.name == 'sha';
                                },
                                check(event, player) {
                                    var cards = player.getCards('he');
                                    if (cards.length <= 2) {
                                        for (var i = 0; i < cards.length; i++) {
                                            if (cards[i].name == 'shan' || cards[i].name == 'tao') return false;
                                        }
                                    }
                                    return true;
                                },
                                content() {
                                    'step 0'
                                    player.chooseToDiscard(2, true, 'he');
                                    player.draw(2);
                                    'step 1'
                                    player.chooseTarget('是否令一名角色弃置两张牌，然后摸两张牌？').set('ai', function (target) {
                                        var cards = target.getCards('he');
                                        if (cards.length <= 2) {
                                            for (var i = 0; i < cards.length; i++) {
                                                if (cards[i].name == 'shan' || cards[i].name == 'tao') return 0;
                                            }
                                        }
                                        return get.attitude(player, target) * (target == player ? 1.2 : 1);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        target.chooseToDiscard(2, true, 'he');
                                        target.draw(2);
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (card.name == 'sha') return [1, 0.5];
                                        },
                                    },
                                },
                            },
                            minimizhao: {
                                audio: 'mizhao',
                                inherit: 'mizhao',
                                check(card) {
                                    var player = _status.event.player;
                                    if (ui.selected.cards.length && !game.hasPlayer(function (current) {
                                        return get.attitude(player, current) > 0;
                                    })) return -1;
                                    return 1 / (get.value(card) || 0.5);
                                },
                                selectCard: [1, Infinity],
                                ai: {
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            var num1 = game.countPlayer(function (current) {
                                                return get.attitude(player, current) > 0;
                                            }), num2 = game.countPlayer(function (current) {
                                                return get.attitude(player, current) < 0;
                                            });
                                            if (target.hasSkillTag('nogain')) return 0;
                                            if (num1 > 0 && num2 > 0) return 1;
                                            if (player.countCards('h', card => get.value(card) > 0)) return 0;
                                            if (num1 == 0 && num2 > 1) return -1;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            minibeige: {
                                audio: 'beige',
                                trigger: { global: 'damageEnd' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && event.source && event.player.isIn() && player.countCards('he');
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard('he', get.prompt2('minibeige', trigger.player)).set('ai', function (card) {
                                        var player = _status.event.player;
                                        var target = _status.event.list[0];
                                        var source = _status.event.list[1];
                                        var att1 = get.attitude(player, target);
                                        var att2 = get.attitude(player, source);
                                        switch (get.suit(card)) {
                                            case 'heart': case 'diamond':
                                                if (att1 > 0) return 10 - get.value(card);
                                                return 0;
                                                break;
                                            case 'club':
                                                if (att2 < 0) return (7 - get.value(card)) * (source.countCards('he') ? 1 : 0);
                                                return 0;
                                                break;
                                            case 'spade':
                                                if (att2 > 0 && source.isTurnedOver()) return 20 - get.value(card);
                                                if (att2 < 0 && !source.isTurnedOver()) return 10 - get.value(card);
                                                return 0;
                                                break;
                                        }
                                    }).setHiddenSkill('minibeige').set('list', [trigger.player, trigger.source]).logSkill = 'minibeige';
                                    'step 1'
                                    if (result.bool) {
                                        switch (get.suit(result.cards[0])) {
                                            case 'heart': case 'diamond':
                                                player.line(trigger.player);
                                                trigger.player.recover();
                                                trigger.player.draw(2);
                                                break;
                                            case 'club':
                                                player.line(trigger.source);
                                                trigger.source.chooseToDiscard('he', 2, true);
                                                break;
                                            case 'spade':
                                                player.line(trigger.source);
                                                trigger.source.turnOver();
                                                break;
                                        }
                                    }
                                },
                                ai: { expose: 0.25 },
                            },
                            minizhuikong: {
                                audio: 'zhuikong',
                                trigger: { global: 'phaseZhunbeiBegin' },
                                check(event, player) {
                                    if (get.attitude(player, event.player) < -2) {
                                        var cards = player.getCards('h');
                                        if (cards.length > player.hp) return true;
                                        for (var i = 0; i < cards.length; i++) {
                                            var useful = get.useful(cards[i]);
                                            if (useful < 5) return true;
                                            if (get.number(cards[i]) > 9 && useful < 7) return true;
                                        }
                                    }
                                    return false;
                                },
                                filter(event, player) {
                                    return player.canCompare(event.player);
                                },
                                logTarget: 'player',
                                content() {
                                    'step 0'
                                    player.chooseToCompare(trigger.player);
                                    'step 1'
                                    if (result.bool) trigger.player.addTempSkill('zishou2');
                                    else {
                                        trigger.player.addTempSkill('minizhuikong_distance');
                                        trigger.player.storage.minizhuikong_distance.push(player);
                                    }
                                },
                                subSkill: {
                                    distance: {
                                        init(player) {
                                            player.storage.minizhuikong_distance = [];
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            globalFrom(from, to, distance) {
                                                if (from.storage.minizhuikong_distance.includes(to)) return -Infinity;
                                            },
                                        },
                                    },
                                },
                            },
                            miniqiuyuan: {
                                audio: 'qiuyuan',
                                trigger: { target: 'useCardToTarget' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && game.players.length > 2;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('miniqiuyuan'), [1, 3], function (card, player, target) {
                                        return target != player && !_status.event.targets.includes(target) && _status.event.playerx.canUse('sha', target, false);
                                    }).set('ai', function (target) {
                                        var trigger = _status.event.getTrigger();
                                        var player = _status.event.player;
                                        return get.effect(target, trigger.card, trigger.player, player);
                                    }).set('targets', trigger.targets).set('playerx', trigger.player);
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        event.targets = targets;
                                        player.logSkill('miniqiuyuan', targets);
                                        event.num = 0;
                                        event.list = [];
                                    }
                                    else event.finish();
                                    'step 2'
                                    var target = targets[num];
                                    event.target = target;
                                    target.chooseCard({ name: 'shan' }, '交给' + get.translation(player) + '一张【闪】，或成为' + get.translation(trigger.card) + '的额外目标并弃置一张牌');
                                    'step 3'
                                    if (result.bool) player.gain(result.cards, target, 'giveAuto');
                                    else {
                                        trigger.getParent().targets.push(target);
                                        trigger.getParent().triggeredTargets2.push(target);
                                        game.log(target, '成为了', trigger.card, '的额外目标');
                                        target.chooseToDiscard('he', true);
                                    }
                                    if (event.num < event.targets.length - 1) {
                                        event.num++;
                                        event.goto(2);
                                    }
                                    'step 4'
                                    game.delayx();
                                },
                                ai: {
                                    expose: 0.2,
                                    effect: {
                                        target(card, player, target) {
                                            if (card.name != 'sha') return;
                                            var players = game.filterPlayer();
                                            if (get.attitude(player, target) <= 0) {
                                                for (var i = 0; i < players.length; i++) {
                                                    var target2 = players[i];
                                                    if (player != target2 && target != target2 && player.canUse(card, target2, false) &&
                                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, target) > 0 &&
                                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, player) < 0) {
                                                        if (target.hp == target.maxHp) return 0.3;
                                                        return 0.6;
                                                    }
                                                }
                                            }
                                            else {
                                                for (var i = 0; i < players.length; i++) {
                                                    var target2 = players[i];
                                                    if (player != target2 && target != target2 && player.canUse(card, target2, false) &&
                                                        get.effect(target2, { name: 'shacopy', nature: card.nature, suit: card.suit }, player, player) > 0) {
                                                        if (player.canUse(card, target2)) return;
                                                        if (target.hp == target.maxHp) return [0, 1];
                                                        return [0, 0];
                                                    }
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            //张琪瑛
                            minidianhua: {
                                audio: 'xinfu_dianhua',
                                trigger: { player: ['phaseZhunbeiBegin', 'phaseJieshuBegin'] },
                                frequent: true,
                                content() {
                                    'step 0'
                                    var num = 1;
                                    for (var i = 0; i < lib.suit.length; i++) {
                                        if (player.hasMark('xinfu_falu_' + lib.suit[i])) num++;
                                    }
                                    var cards = get.cards(num);
                                    if (lib.config.extension_十周年UI_enable) {
                                        var dialog = decadeUI.content.chooseGuanXing(player, cards, cards.length);
                                        dialog.caption = '【点化】';
                                        game.broadcast(function (player, cards, callback) {
                                            if (!window.decadeUI) return;
                                            var dialog = decadeUI.content.chooseGuanXing(player, cards, cards.length);
                                            dialog.caption = '【点化】';
                                            dialog.callback = callback;
                                        }, player, cards, dialog.callback);
                                        event.switchToAuto = function () {
                                            var cards = dialog.cards[0].concat();
                                            var cheats = [];
                                            var next = player.getNext();
                                            var friend = (event.triggername == 'phaseJieshuBegin' ? player.getNext() : player);
                                            var judges = friend.node.judges.childNodes;
                                            if (judges.length > 0) cheats = decadeUI.get.cheatJudgeCards(cards, judges, friend != null);
                                            if (friend) cards = decadeUI.get.bestValueCards(cards, friend);
                                            else {
                                                cards.sort(function (a, b) {
                                                    return get.value(a, next) - get.value(b, next);
                                                });
                                            }
                                            cards = cheats.concat(cards);
                                            var time = 500;
                                            for (var i = 0; i < cards.length; i++) {
                                                setTimeout(function (card, index, finished) {
                                                    dialog.move(card, index, 0);
                                                    if (finished) dialog.finishTime(cards.length <= 1 ? 250 : 1000);;
                                                }, time, cards[i], i, i >= cards.length - 1);
                                                time += 500;
                                            }
                                        }
                                        if (event.isOnline()) {
                                            event.player.send(function () {
                                                if (!window.decadeUI && decadeUI.eventDialog) _status.event.finish();
                                            }, event.player);
                                            event.player.wait();
                                            decadeUI.game.wait();
                                        }
                                        else if (!event.isMine()) {
                                            event.switchToAuto();
                                        }
                                        event.finish();
                                        return;
                                    }
                                    game.cardsGotoOrdering(cards);
                                    var next = player.chooseToMove('点化：将卡牌以任意顺序置于牌堆顶');
                                    next.set('list', [['牌堆顶', cards]]);
                                    next.set('processAI', function (list) {
                                        var player = _status.event.player, target = (_status.event.getTrigger().name == 'phaseZhunbei' ? player : player.next);
                                        var att = get.sgn(get.attitude(player, target));
                                        var check = function (card) {
                                            var judge = player.getCards('j')[cards.length];
                                            if (judge) return get.judge(judge)(card) * att;
                                            return player.getUseValue(card) * att;
                                        };
                                        var cards = list[0][1].slice(0);
                                        cards.sort(function (a, b) {
                                            return check(b) * att - check(a) * att;
                                        });
                                        return [cards];
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var list = result.moved[0].slice(0);
                                        while (list.length) {
                                            ui.cardPile.insertBefore(list.pop(), ui.cardPile.firstChild);
                                        }
                                        game.updateRoundNumber();
                                        game.delayx();
                                    }
                                },
                            },
                            minizhenyi: {
                                group: ['oldzhenyi_spade', 'zhenyi_club', 'zhenyi_heart'],
                                audio: 'xinfu_zhenyi',
                                inherit: 'xinfu_zhenyi',
                            },
                            minicangchu: {
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark('minicangchu');
                                    },
                                },
                                group: ['minicangchu2', 'minicangchu3'],
                                audio: 'cangchu',
                                trigger: { global: 'phaseBefore', player: 'enterGame' },
                                filter(event, player) {
                                    if (event.name == 'phase' && game.phaseNumber != 0) return false;
                                    return player.countMark('minicangchu') < game.countPlayer();
                                },
                                forced: true,
                                content() {
                                    player.addMark('minicangchu', Math.min(3, game.countPlayer() - player.countMark('minicangchu')));
                                },
                                marktext: '粮',
                                intro: { content: 'mark', name: '粮' },
                            },
                            minicangchu2: {
                                audio: 'cangchu',
                                trigger: { player: ['gainAfter', 'recoverEnd'], global: 'loseAsyncAfter' },
                                filter(event, player) {
                                    return player != _status.currentPhase && player.countMark('minicangchu') < game.countPlayer() && (event.name == 'recover' || event.getg(player).length);
                                },
                                forced: true,
                                usable: 1,
                                content() {
                                    player.addMark('minicangchu', 1);
                                },
                            },
                            minicangchu3: {
                                audio: 'cangchu',
                                trigger: { global: 'die' },
                                filter(event, player) {
                                    return player.countMark('minicangchu') > game.countPlayer();
                                },
                                forced: true,
                                content() {
                                    player.removeMark('minicangchu', player.countMark('minicangchu') - game.countPlayer());
                                },
                            },
                            miniliangying: {
                                audio: 'reliangying',
                                trigger: { player: 'phaseDiscardBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var map = {};
                                    var list = [];
                                    for (var i = 1; i <= player.countMark('minicangchu'); i++) {
                                        var cn = get.cnNumber(i, true);
                                        map[cn] = i;
                                        list.push(cn);
                                    }
                                    list.push('cancel2');
                                    event.map = map;
                                    player.chooseControl(list).set('prompt', get.prompt('miniliangying')).set('prompt2', '摸至多' + get.cnNumber(player.countMark('minicangchu')) + '张牌，然后交给等量的角色各一张牌').set('ai', function () {
                                        var player = _status.event.player;
                                        var num = Math.min(player.countMark('minicangchu'), game.countPlayer(function (current) {
                                            return get.attitude(player, current) > 0;
                                        }));
                                        if (num > 0) return get.cnNumber(num, true);
                                        return 'cancel2';
                                    });
                                    'step 1'
                                    event.list = [];
                                    if (result.control == 'cancel2') { event.finish(); return; }
                                    player.logSkill('miniliangying');
                                    var num = event.map[result.control] || 1;
                                    event.num = num;
                                    player.draw(num);
                                    if (_status.connectMode) game.broadcastAll(function () { _status.noclearcountdown = true });
                                    'step 2'
                                    var num = Math.min(event.num, player.countCards('he'), game.players.length - 1);
                                    var next = player.chooseCardTarget({
                                        prompt: '粮营：将' + get.cnNumber(num - 1) + '至' + get.cnNumber(num) + '张牌交给其他角色',
                                        position: 'he',
                                        animate: false,
                                        filterCard(card) {
                                            for (var CT of _status.event.list) {
                                                if (CT.card == card) return false;
                                            }
                                            return true;
                                        },
                                        filterTarget(card, player, target) {
                                            for (var CT of _status.event.list) {
                                                if (CT.target == target) return false;
                                            }
                                            return target != player;
                                        },
                                        ai1(card) {
                                            if (card.name == 'shan') return 1;
                                            return Math.random();
                                        },
                                        ai2(target) {
                                            var player = _status.event.player;
                                            return get.attitude(player, target);
                                        },
                                    });
                                    next.set('list', event.list);
                                    if (num - event.list.length > 1) next.set('forced', true);
                                    'step 3'
                                    if (result.bool) {
                                        var num = Math.min(event.num, player.countCards('he'), game.players.length - 1);
                                        var CT = {
                                            target: result.targets[0],
                                            card: result.cards[0],
                                        };
                                        player.addGaintag(result.cards, 'olsujian_given');
                                        event.list.push(CT);
                                        if (num - event.list.length >= 1) event.goto(2);
                                    }
                                    else if (!event.list.length > 0) event.finish();
                                    'step 4'
                                    if (_status.connectMode) {
                                        game.broadcastAll(function () { delete _status.noclearcountdown; game.stopCountChoose() });
                                    }
                                    var list = [];
                                    var cards = [];
                                    for (var obj of event.list) {
                                        cards.push(obj.card);
                                        list.push([obj.target, obj.card]);
                                        player.line(obj.target);
                                    }
                                    game.loseAsync({
                                        gain_list: list,
                                        player: player,
                                        cards: cards,
                                        giver: player,
                                        animate: 'giveAuto',
                                    }).setContent('gaincardMultiple');
                                },
                            },
                            minishishou: {
                                audio: 'reshishou',
                                trigger: { player: ['useCard', 'damageEnd'] },
                                filter(event, player) {
                                    if (!player.countMark('minicangchu')) return false;
                                    return (event.name == 'damage') ? (event.hasNature('fire')) : (event.card && event.card.name == 'jiu');
                                },
                                forced: true,
                                content() {
                                    player.removeMark('minicangchu', 1);
                                },
                            },
                            minizongkui: {
                                audio: 'zongkui',
                                trigger: { global: 'phaseBefore', player: ['phaseBegin', 'enterGame'] },
                                filter(event, player, name) {
                                    if (name == 'phaseBefore' && game.phaseNumber > 0) return false;
                                    return game.hasPlayer(function (current) {
                                        if ((name == 'phaseBefore' || name == 'enterGame') && !current.isMinHp()) return false;
                                        return current != player && !current.hasMark('zongkui_mark');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.logged = false;
                                    if (event.triggername == 'phaseBefore' || event.triggername == 'enterGame') {
                                        player.logSkill('minizongkui');
                                        event.logged = true;
                                    }
                                    var targets = game.filterPlayer(function (current) {
                                        if ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') && !current.isMinHp()) return false;
                                        return current != player && !current.hasMark('zongkui_mark');
                                    });
                                    if ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') && targets.length == 1) {
                                        event._result = { bool: true, targets: targets };
                                    }
                                    else {
                                        var next = player.chooseTarget(event.logged ? '请选择【纵傀】的目标' : get.prompt('zongkui'), '令一名' + ((event.triggername == 'phaseBefore' || event.triggername == 'enterGame') ? '体力值最小的' : '') + '其他角色获得“傀”标记', function (card, player, target) {
                                            if (_status.event.round && !target.isMinHp()) return false;
                                            return target != player && !target.hasMark('zongkui_mark');
                                        }).set('ai', function (target) {
                                            var num = target.isMinHp() ? 0.5 : 1;
                                            return num * get.threaten(target);
                                        }).set('round', event.triggername == 'phaseBefore' || event.triggername == 'enterGame');
                                        if (event.triggername == 'phaseBefore' || event.triggername == 'enterGame') next.set('forced', true);
                                    }
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        if (!event.logged) player.logSkill('minizongkui', target);
                                        else player.line(target);
                                        target.addMark('zongkui_mark', 1);
                                        game.delayx();
                                    }
                                },
                            },
                            miniguju: {
                                audio: 'guju',
                                inherit: 'guju',
                                content() {
                                    player.draw();
                                },
                            },
                            minilianzhu: {
                                audio: 'lianzhu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                filterTarget: lib.filter.notMe,
                                filterCard: true,
                                check(card) {
                                    var num = get.value(card);
                                    if (get.color(card) == 'black') {
                                        if (num >= 6) return 0;
                                        return 9 - num;
                                    }
                                    else return 7 - num;
                                },
                                usable: 1,
                                discard: false,
                                lose: false,
                                delay: false,
                                position: 'he',
                                content() {
                                    'step 0'
                                    player.give(cards, target);
                                    'step 1'
                                    if (get.color(cards[0], player) == 'red') {
                                        player.chooseDrawRecover(2, true);
                                        event.finish();
                                    }
                                    else {
                                        target.chooseToDiscard('he', 2, '弃置两张牌，或令' + get.translation(player) + '摸两张牌').set('ai', function (card) {
                                            if (!_status.event.goon) return -get.value(card);
                                            return 6 - get.value(card);
                                        }).set('goon', get.attitude(target, player) <= 0);
                                    }
                                    'step 2'
                                    if (!result.bool) player.draw(2);
                                },
                                ai: {
                                    order: 3,
                                    expose: 0.2,
                                    result: {
                                        target(player, target) {
                                            if (ui.selected.cards.length && get.color(ui.selected.cards[0]) == 'red') {
                                                var att = get.attitude(player, target);
                                                return 2 + get.sgn(att) + att / 114514;
                                            }
                                            return -1;
                                        },
                                    },
                                },
                            },
                            minixiahui: {
                                audio: 'xiahui',
                                mod: {
                                    ignoredHandcard(card, player) {
                                        if (get.color(card, player) == 'black') return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && get.color(card, player) == 'black') return false;
                                    },
                                },
                                trigger: { global: 'phaseEnd' },
                                forced: true,
                                logTarget: 'player',
                                filter(event, player) {
                                    var target = event.player;
                                    return target != player && target.getHistory('lose', function (evt) {
                                        for (var i in evt.gaintag_map) {
                                            if (evt.gaintag_map[i].includes('minixiahui')) return true;
                                        }
                                    }).length;
                                },
                                content() {
                                    trigger.player.loseHp();
                                },
                                group: 'minixiahui_gain',
                                subSkill: {
                                    gain: {
                                        trigger: { global: 'gainEnd' },
                                        forced: true,
                                        popup: false,
                                        filter(event, player) {
                                            if (player == event.player) return false;
                                            var evt = event.getl(player);
                                            return evt?.cards2 && evt.cards2.filter(function (card) {
                                                return get.color(card, player) == 'black';
                                            }).length > 0;
                                        },
                                        content() {
                                            trigger.player.addSkill('minixiahui_block');
                                            var cards = trigger.getl(player).cards2.filter(function (card) {
                                                return get.color(card, player) == 'black';
                                            });
                                            trigger.player.addGaintag(cards, 'minixiahui');
                                        },
                                    },
                                    block: {
                                        mod: {
                                            cardEnabled2(card) {
                                                if (get.itemtype(card) == 'card' && card.hasGaintag('minixiahui')) return false;
                                            },
                                            cardDiscardable(card) {
                                                if (card.hasGaintag('minixiahui')) return false;
                                            },
                                        },
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        trigger: { player: 'changeHp' },
                                        filter(event, player) {
                                            return event.num < 0;
                                        },
                                        content() {
                                            player.removeSkill('minixiahui_block');
                                        },
                                        onremove(player) {
                                            player.removeGaintag('minixiahui');
                                        },
                                    },
                                },
                            },
                            minilveming: {
                                audio: 'xinfu_lveming',
                                inherit: 'xinfu_lveming',
                                filterTarget(card, player, target) {
                                    return player != target && target.countCards('e') <= player.countCards('e');
                                },
                                mark: false,
                                content() {
                                    'step 0'
                                    var list = Array.from({ length: 13 }).map((_, i) => i + 1);
                                    list = list.map((i) => get.strNumber(i));
                                    target.chooseControl(list).set('ai', function () {
                                        return get.rand(0, 12);
                                    }).set('prompt', '掠命：请选择一个点数').set('prompt2', '若' + get.translation(player) + '的判定点数与你选择的点数相同，则对你造成2点伤害，否则其随机获得你区域里的一张牌');
                                    'step 1'
                                    if (result.control) {
                                        target.$damagepop(result.control, 'thunder');
                                        event.num = result.index + 1;
                                        game.log(target, '选择的点数为', '#y' + get.strNumber(event.num));
                                        player.judge(function (card) {
                                            if (card.number == _status.event.getParent('minilveming').num) return 4;
                                            return 0;
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) target.damage(2);
                                    else player.gain(target.getCards('hej').randomGet(), target, 'giveAuto', 'bySelf');
                                },
                            },
                            minitunjun: {
                                unique: true,
                                mark: true,
                                limited: true,
                                audio: 'xinfu_tunjun',
                                enable: 'phaseUse',
                                filterTarget: true,
                                skillAnimation: true,
                                animationColor: 'metal',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minitunjun');
                                    event.num = player.getAllHistory('useSkill', function (evt) {
                                        return evt.skill == 'minilveming';
                                    }).length + 1;
                                    event.toequip = [];
                                    'step 1'
                                    var equip = get.cardPile(function (card) {
                                        var bool1 = true;
                                        for (var i = 0; i < event.toequip.length; i++) {
                                            if (get.type(card) == 'equip' && get.subtype(card) == get.subtype(event.toequip[i])) bool1 = false;
                                        }
                                        return (get.type(card) == 'equip' && !event.toequip.includes(card) && target.canEquip(card) && bool1);
                                    });
                                    if (equip) event.toequip.push(equip);
                                    else event.num = 0;
                                    event.num--;
                                    'step 2'
                                    if (event.num > 0) event.goto(1);
                                    'step 3'
                                    for (var i = 0; i < event.toequip.length; i++) {
                                        target.chooseUseTarget(event.toequip[i], true).set('animate', false).set('nopopup', true);
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        player(player, target) {
                                            if (get.attitude(player, target) <= 0) return 0;
                                            if (target.countCards('e') + player.getAllHistory('useSkill', function (evt) {
                                                return evt.skill == 'minilveming';
                                            }).length < 3) return 0;
                                            return 1 / (target.countCards('e') + 1);
                                        },
                                    },
                                },
                            },
                            minijixu: {
                                audio: 'xinfu_jixu',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                filterTarget: lib.filter.notMe,
                                selectTarget: [1, 4],
                                usable: 1,
                                multitarget: true,
                                multiline: true,
                                content() {
                                    'step 0'
                                    targets.sortBySeat();
                                    event.num = 0;
                                    'step 1'
                                    if (!event.caicuolist) event.caicuolist = [];
                                    targets[event.num].chooseBool('是否押杀？').ai = function (event, player) {
                                        var evt = _status.event.getParent();
                                        if (get.attitude(targets[event.num], evt.player) > 0) return evt.player.countCards('h', 'sha') ? false : true;
                                        return Math.random() < 0.5;
                                    };
                                    'step 2'
                                    var target = targets[event.num];
                                    var num1 = result.bool ? 1 : -1;
                                    var num2 = player.countCards('h', 'sha') ? 1 : -1;
                                    if (num1 != num2) {
                                        event.caicuolist.push(target);
                                        target.chat('猜错');
                                        game.log(target, '猜', '#y错', '了');
                                    }
                                    else {
                                        target.chat('猜对');
                                        game.log(target, '猜', '#g对', '了');
                                    }
                                    event.num++;
                                    game.delay();
                                    if (event.num < targets.length) event.goto(1);
                                    'step 3'
                                    if (event.caicuolist.length) {
                                        for (var i of event.caicuolist) {
                                            player.discardPlayerCard(i, 'he', true);
                                            player.useCard({ name: 'sha', isCard: true }, i, false);
                                        }
                                    }
                                    var num = targets.length - event.caicuolist.length + 1;
                                    player.addTempSkill('minijixu_hand');
                                    player.draw(num);
                                    player.addMark('minijixu_hand', num, false);
                                },
                                ai: {
                                    order() {
                                        return get.order({ name: 'sha' }) + 0.6;
                                    },
                                    result: {
                                        target(player, target) {
                                            return get.effect(target, { name: 'guohe_copy2' }, player, target);
                                        },
                                    },
                                    expose: 0.25,
                                },
                                subSkill: {
                                    hand: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num + player.countMark('minijixu_hand');
                                            },
                                        },
                                        intro: { content: '手牌上限+#' },
                                    },
                                },
                            },
                            //许劭
                            minipingjian: {
                                getList() {
                                    const list = Object.keys(lib.characterPack.MiNikill).concat(_status.extra_pingjianList || []);
                                    return list.filter(i => !_status.banned_pingjianList?.includes(i) && (!get.character(i, 4) || !get.character(i, 4).includes('unseen')));
                                },
                                Mbaby_characterlist: true,
                                init(player) {
                                    player.addSkill('minipingjian_remove');
                                    if (!player.storage.minipingjian_remove) player.storage.minipingjian_remove = {};
                                },
                                onremove(player) {
                                    player.removeSkill('minipingjian_remove');
                                },
                                group: 'minipingjian_use',
                                audio: 'pingjian',
                                trigger: { player: ['damageEnd', 'phaseJieshuBegin'] },
                                frequent: true,
                                content() {
                                    'step 0'
                                    var allList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                                    var list = [], skills = [], map = [];
                                    allList.randomSort();
                                    var name2 = event.triggername;
                                    for (var i = 0; i < allList.length; i++) {
                                        var name = allList[i];
                                        var skills2 = lib.character[name][3];
                                        for (var j = 0; j < skills2.length; j++) {
                                            if (player.getStorage('minipingjian').includes(skills2[j])) continue;
                                            if (skills2[j] == 'minipingjian') continue;
                                            if (skills.includes(skills2[j])) {
                                                list.add(name);
                                                if (!map[name]) map[name] = [];
                                                map[name].push(skills2[j]);
                                                skills.add(skills2[j]);
                                                continue;
                                            }
                                            var list2 = [skills2[j]];
                                            game.expandSkills(list2);
                                            for (var k = 0; k < list2.length; k++) {
                                                var info = lib.skill[list2[k]];
                                                if (!info || !info.trigger || !info.trigger.player || info.silent || info.limited || info.juexingji || info.hiddenSkill ||
                                                    info.dutySkill || (info.zhuSkill && !player.isZhu2()) || info.groupSkill || (info.priority && typeof info.priority == 'number') || info.firstDo || info.lastDo) continue;
                                                if (info.trigger.player == name2 || Array.isArray(info.trigger.player) && info.trigger.player.includes(name2)) {
                                                    if (/*info.init||*/info.onChooseToUse || info.ai && (info.ai.combo || info.ai.notemp || info.ai.neg)) continue;
                                                    if (info.init) info.init(player, list2[k]);
                                                    if (info.filter) {
                                                        try {
                                                            var bool = info.filter(trigger, player, name2);
                                                            if (!bool) continue;
                                                        }
                                                        catch (e) {
                                                            continue;
                                                        }
                                                    }
                                                    list.add(name);
                                                    if (!map[name]) map[name] = [];
                                                    map[name].push(skills2[j]);
                                                    skills.add(skills2[j]);
                                                    break;
                                                }
                                            }
                                        }
                                        if (list.length > 2) break;
                                    }
                                    if (skills.length) player.chooseControl(skills).set('dialog', ['请选择要发动的技能', [list, 'character']]);
                                    else event.finish();
                                    'step 1'
                                    player.markAuto('minipingjian', [result.control]);
                                    player.addTempSkill(result.control);
                                    player.storage.minipingjian_remove[result.control] = (trigger.name == 'damage' ? trigger : 'phaseJieshu');
                                },
                            },
                            minipingjian_use: {
                                audio: 'pingjian',
                                enable: 'phaseUse',
                                usable: 1,
                                content() {
                                    'step 0'
                                    var allList = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                                    var list = [], skills = [], map = [];
                                    allList.randomSort();
                                    for (var i = 0; i < allList.length; i++) {
                                        var name = allList[i];
                                        var skills2 = lib.character[name][3];
                                        for (var j = 0; j < skills2.length; j++) {
                                            if (player.getStorage('minipingjian').includes(skills2[j])) continue;
                                            if (skills2[j] == 'minipingjian' || get.is.locked(skills2[j], player)) continue;
                                            var info = lib.translate[skills2[j] + '_info'];
                                            if (skills.includes(skills2[j]) || (info && info.indexOf('当你于出牌阶段') != -1 && info.indexOf('当你于出牌阶段外') != -1)) {
                                                list.add(name);
                                                if (!map[name]) map[name] = [];
                                                map[name].push(skills2[j]);
                                                skills.add(skills2[j]);
                                                continue;
                                            }
                                            var list2 = [skills2[j]];
                                            game.expandSkills(list2);
                                            for (var k = 0; k < list2.length; k++) {
                                                var info = lib.skill[list2[k]];
                                                if (!info || !info.enable || info.charlotte || info.limited || info.juexingji || info.hiddenSkill || info.dutySkill || (info.zhuSkill && !player.isZhu2()) || info.groupSkill) continue;
                                                if ((info.enable == 'phaseUse' || (Array.isArray(info.enable) && info.enable.includes('phaseUse'))) ||
                                                    (info.enable == 'chooseToUse' || (Array.isArray(info.enable) && info.enable.includes('chooseToUse')))) {
                                                    if (/*info.init||*/info.onChooseToUse || info.ai && (info.ai.combo || info.ai.notemp || info.ai.neg)) continue;
                                                    var evt = event.getParent(2);
                                                    if (info.init) info.init(player, list2[k]);
                                                    //if (info.onChooseToUse) info.onChooseToUse(evt);
                                                    if (info.filter) {
                                                        try {
                                                            var bool = info.filter(evt, player);
                                                            if (!bool) continue;
                                                        }
                                                        catch (e) {
                                                            continue;
                                                        }
                                                    }
                                                    else if (info.viewAs && typeof info.viewAs != 'function') {
                                                        try {
                                                            if (evt.filterCard && !evt.filterCard(info.viewAs, player, evt)) continue;
                                                            if (info.viewAsFilter && info.viewAsFilter(player) == false) continue;
                                                        }
                                                        catch (e) {
                                                            continue;
                                                        }
                                                    }
                                                    list.push(name);
                                                    if (!map[name]) map[name] = [];
                                                    map[name].push(skills2[j]);
                                                    skills.add(skills2[j]);
                                                    break;
                                                }
                                            }
                                        }
                                        if (list.length > 2) break;
                                    }
                                    if (skills.length) player.chooseControl(skills).set('dialog', ['请选择要发动的技能', [list, 'character']]);
                                    else event.finish();
                                    'step 1'
                                    player.markAuto('minipingjian', [result.control]);
                                    player.addTempSkill(result.control);
                                    player.storage.minipingjian_remove[result.control] = 'phaseUse';
                                },
                                ai: {
                                    order: 12,
                                    result: { player: 1 },
                                },
                            },
                            minipingjian_remove: {
                                group: 'minipingjian_skill',
                                charlotte: true,
                                trigger: { player: ['phaseUseEnd', 'damageEnd', 'phaseJieshuBegin'] },
                                filter(event, player) {
                                    return Object.keys(player.storage.minipingjian_remove).find(function (skill) {
                                        if (event.name != 'damage') return player.storage.minipingjian_remove[skill] == event.name;
                                        return player.storage.minipingjian_remove[skill] == event;
                                    });
                                },
                                direct: true,
                                lastDo: true,
                                priority: -Infinity,
                                content() {
                                    var skills = Object.keys(player.storage.minipingjian_remove).filter(function (skill) {
                                        if (trigger.name != 'damage') return player.storage.minipingjian_remove[skill] == trigger.name;
                                        return player.storage.minipingjian_remove[skill] == trigger;
                                    });
                                    player.removeSkill(skills);
                                    for (var skill of skills) delete player.storage.minipingjian_remove[skill];
                                },
                            },
                            minipingjian_skill: {
                                charlotte: true,
                                trigger: { player: ['useSkill', 'logSkillBegin'] },
                                filter(event, player) {
                                    if (get.info(event.skill).charlotte) return false;
                                    var skill = event.sourceSkill || event.skill;
                                    return player.storage.minipingjian_remove[skill];
                                },
                                direct: true,
                                firstDo: true,
                                priority: Infinity,
                                content() {
                                    var skill = trigger.sourceSkill || trigger.skill;
                                    player.removeSkill(skill);
                                    delete player.storage.minipingjian_remove[skill];
                                },
                            },
                            //貂蝉
                            minirelijian: {
                                onChooseToUse(event) {
                                    if (event.type == 'phase' && !game.online && !event.minirelijian_targets) {
                                        var evtx = event.getParent('phaseUse');
                                        var list = [], player = event.player;
                                        for (var target of game.filterPlayer2()) {
                                            if (target.getHistory('damage', function (evt) {
                                                return evt.card && evt.card.name == 'juedou' && evt.getParent(3).name == 'minirelijian' && evt.getParent(3).player == player;
                                            }).length) list.push(target);
                                        }
                                        event.set('minirelijian_targets', list);
                                    }
                                },
                                audio: 'lijian',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        if (event.minirelijian_targets.includes(target)) return false;
                                        return game.hasPlayer(function (current) {
                                            if (event.minirelijian_targets.includes(current)) return false;
                                            return current != target && current.canUse({ name: 'juedou' }, target);
                                        });
                                    });
                                },
                                filterTarget(card, player, target) {
                                    if (_status.event.minirelijian_targets.includes(target)) return false;
                                    if (ui.selected.targets.length) return target.canUse({ name: 'juedou' }, ui.selected.targets[0]);
                                    return game.hasPlayer(function (current) {
                                        return current.canUse({ name: 'juedou' }, target);
                                    });
                                },
                                selectTarget: 2,
                                targetprompt: ['先出杀', '后出杀'],
                                multitarget: true,
                                filterCard: true,
                                check(card) {
                                    return 10 - get.value(card);
                                },
                                position: 'he',
                                usable: 2,
                                content() {
                                    targets[1].useCard({ name: 'juedou', isCard: true }, 'nowuxie', targets[0], 'noai').animate = false;
                                    game.delay(0.5);
                                },
                                ai: {
                                    order: 8,
                                    expose: 0.4,
                                    threaten: 4.8,
                                    result: {
                                        target(player, target) {
                                            if (!ui.selected.targets.length) return -3;
                                            return get.effect(target, { name: 'juedou' }, ui.selected.targets[0], target);
                                        },
                                    },
                                },
                            },
                            minirebiyue: {
                                audio: 'biyue',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                locked: false,
                                content() {
                                    player.draw(1 + player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'minirelijian';
                                    }).length);
                                },
                            },
                            //何太后
                            minizhendu: {
                                audio: 'zhendu',
                                trigger: { global: 'phaseUseBegin' },
                                filter(event, player) {
                                    return event.player.isIn() && player.countCards('he') && event.player.hasUseTarget({ name: 'jiu' }, null, true);
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    var nono = (Math.abs(get.attitude(player, trigger.player)) < 3);
                                    if (player == trigger.player || get.damageEffect(trigger.player, player, player) <= 0 || !trigger.player.hasUseTarget({ name: 'jiu' }, null, true)) nono = true;
                                    if (trigger.player.hp > 2) nono = true;
                                    if (trigger.player.hp > 1 && player.countCards('h') < 3 && (trigger.player.canUse('sha', player) && !player.countCards('h', 'shan') && trigger.player.countCards('h') >= 3)) nono = true;
                                    var next = player.chooseToDiscard(get.prompt2('minizhendu', trigger.player), 'he');
                                    next.set('ai', function (card) {
                                        if (_status.event.nono) return -1;
                                        return 7 - get.useful(card);
                                    });
                                    next.set('logSkill', ['minizhendu', trigger.player]);
                                    next.set('nono', nono);
                                    next.setHiddenSkill('minizhendu');
                                    'step 1'
                                    if (result.bool) trigger.player.chooseUseTarget({ name: 'jiu' }, true, 'noTargetDelay', 'nodelayx');
                                    else event.finish();
                                    'step 2'
                                    if (result.bool && trigger.player != player) {
                                        trigger.player.damage();
                                        trigger.player.addTempSkill('minizhendu2');
                                        trigger.player.addMark('minizhendu2', 1, false);
                                    }
                                },
                                ai: { expose: 0.3 },
                            },
                            minizhendu2: {
                                mark: true,
                                marktext: '毒',
                                charlotte: true,
                                onremove: true,
                                intro: { content: '计算与其他角色的距离+#' },
                                mod: {
                                    globalFrom(from, to, distance) {
                                        return distance + from.countMark('minizhendu2');
                                    },
                                },
                            },
                            miniqiluan: {
                                group: 'miniqiluan_draw',
                                audio: 'qiluan2',
                                trigger: { global: 'dying' },
                                prompt: '是否发动【戚乱】摸一张牌？',
                                preHidden: true,
                                frequent: true,
                                content() {
                                    player.draw();
                                },
                                subfrequent: ['use'],
                                subSkill: {
                                    draw: {
                                        audio: 'qiluan2',
                                        trigger: { source: 'dieAfter' },
                                        prompt: '是否发动【戚乱】摸两张牌？',
                                        forced: true,
                                        locked: false,
                                        preHidden: true,
                                        content() {
                                            player.draw(2);
                                        },
                                    },
                                },
                            },
                            //孙悟空
                            'mini72bian': {
                                onChooseToUse(event) {
                                    if (event.type == 'phase' && !game.online && !event['mini72bian_type']) {
                                        var evtx = event.getParent('phaseUse');
                                        var list = ['basic', 'trick', 'equip'], player = event.player;
                                        player.getHistory('lose', function (evt) {
                                            var evt2 = evt.getParent();
                                            if (evt2.name == 'useSkill' && evt2.skill == 'mini72bian') list.remove(get.type2(evt.cards2[0]));
                                        });
                                        event.set('mini72bian_type', list);
                                    }
                                },
                                nobracket: true,
                                audio: 'ext:活动武将/audio/skill:true',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he', function (card) {
                                        return event['mini72bian_type'].includes(get.type2(card));
                                    });
                                },
                                filterCard(card, player) {
                                    return _status.event['mini72bian_type'].includes(get.type2(card));
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    if (player.hasSkill('mini72bian_' + get.type2(card))) return -1;
                                    return 5 - get.value(card);
                                },
                                position: 'he',
                                prepare(cards, player) {
                                    player.$throw(cards, 1000);
                                    game.log(player, '将', cards, '置入了弃牌堆');
                                },
                                discard: false,
                                loseTo: 'discardPile',
                                visible: true,
                                content() {
                                    var list = ['basic', 'trick', 'equip'];
                                    var type = list[(list.indexOf(get.type2(cards[0])) + 1) % 3];
                                    var card = get.cardPile2(function (card) {
                                        return get.type2(card) == type;
                                    });
                                    if (card) {
                                        player.gain(card, 'draw');
                                        game.log(player, '获得了一张', '#g' + get.translation(type) + '牌');
                                    }
                                    else {
                                        player.chat('无牌可得了吗？');
                                        game.log('但是牌堆中已经没有', '#g' + get.translation(type) + '牌', '了！');
                                        player.addTempSkill('mini72bian_' + get.type2(cards[0]), 'washCard');
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: { player: 1 },
                                },
                                subSkill: { basic: { charlotte: true }, trick: { charlotte: true }, equip: { charlotte: true } },
                            },
                            miniruyi: {
                                locked: true,
                                audio: 'ext:活动武将/audio/skill:true',
                                derivation: 'miniruyi_jingubang',
                                group: ['miniruyi_jingubang', 'miniruyi_jingubang2'],
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (player == target && get.type(card) == 'equip' && get.subtype(card) == 'equip1') {
                                                if (!target.hasEmptySlot(1)) return;
                                                return 0;
                                            }
                                        },
                                    },
                                },
                            },
                            miniruyi_jingubang: {
                                init(player) {
                                    if (!player.storage.miniruyi_jingubang) player.storage.miniruyi_jingubang = 1;
                                },
                                onremove: true,
                                mod: {
                                    attackRange(player, num) {
                                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return;
                                        if (_status.miniruyiCheck) return num + _status.miniruyiCheck - 1;
                                        return num + player.storage.miniruyi_jingubang - 1;
                                    },
                                },
                                equipSkill: true,
                                audioname2: { Mbaby_sunwukong: 'miniruyi' },
                                trigger: { player: 'phaseBegin' },
                                filter(event, player) {
                                    return player.hasEmptySlot(1) || player.getEquip('miniruyi_jingubang');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var cards = player.getEquips('miniruyi_jingubang');
                                    player.chooseControl('1', '2', '3', '4', 'cancel2').set('prompt', '是否调整' + (cards.length ? get.translation(cards) : '如意金箍棒') + '的攻击范围？').set('choiceList', [
                                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为1 → 你使用【杀】不计入次数限制',
                                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为2 → 你于回合内使用的第一张【杀】造成的伤害+1',
                                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为3 → 你使用【杀】无法被响应',
                                        '将' + (card ? get.translation(card) : '如意金箍棒') + '的攻击范围调整为4 → 你使用【杀】可以额外指定一个目标'
                                    ]).set('ai', function () {
                                        var player = _status.event.player;
                                        if (!player.hasSha()) return '4';
                                        for (var i = 0; i <= 3; i++) {
                                            _status.miniruyiCheck = [2, 1, 3, 4][i];
                                            if (game.hasPlayer(function (current) {
                                                return player.canUse({ name: 'sha' }, current) && get.effect(current, { name: 'sha' }, player, player) > 0;
                                            })) {
                                                delete _status.miniruyiCheck;
                                                return i + 1;
                                            }
                                        }
                                        if (_status.miniruyiCheck) delete _status.miniruyiCheck;
                                        return '4';
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        var num = parseInt(result.control), cards = player.getEquips('miniruyi_jingubang');
                                        player.logSkill('miniruyi_jingubang');
                                        player.storage.miniruyi_jingubang = num;
                                        player.popup(num);
                                        game.log(player, '将', '#g' + (cards.length ? get.translation(cards) : '如意金箍棒'), '的攻击范围调整为', '#y' + num);
                                    }
                                },
                            },
                            miniruyi_jingubang2: {
                                mod: {
                                    selectTarget(card, player, range) {
                                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEmptySlot(1)) return;
                                        var num = player.storage.miniruyi_jingubang;
                                        if (card.name == 'sha' && range[1] != -1 && num == 4) range[1]++;
                                    },
                                },
                                equipSkill: true,
                                audioname2: { Mbaby_sunwukong: 'miniruyi' },
                                trigger: { player: 'useCard' },
                                filter(event, player) {
                                    var num = player.storage.miniruyi_jingubang;
                                    if (event.card.name != 'sha' || !player.hasEnabledSlot(1)) return false;
                                    if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return false;
                                    if (num == 2) return player.getHistory('useCard', function (evt) {
                                        return evt.card.name == 'sha';
                                    }).indexOf(event) == 0 && _status.currentPhase && player == _status.currentPhase;
                                    return num != 4;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    var num = player.storage.miniruyi_jingubang;
                                    switch (num) {
                                        case 1:
                                            trigger.addCount = false;
                                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                                            game.log(trigger.card, '不计入次数');
                                            break;
                                        case 2:
                                            trigger.baseDamage++;
                                            game.log(trigger.card, '造成的伤害+1');
                                            break;
                                        case 3:
                                            trigger.directHit.addArray(game.players);
                                            game.log(trigger.card, '不可被响应');
                                            break;
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!player.getEquip('miniruyi_jingubang') && !player.hasEnabledSlot(1)) return false;
                                        return arg.card.name == 'sha' && ((_status.miniruyiCheck && _status.miniruyiCheck == 3) || player.storage.miniruyi_jingubang == 3);
                                    },
                                },
                            },
                            miniqitian: {
                                unique: true,
                                audio: 'ext:活动武将/audio/skill:true',
                                derivation: ['minihuoyan', 'minijindouyun'],
                                trigger: { player: ['changeHp', 'enterGame'], global: 'phaseBefore' },
                                filter(event, player) {
                                    if (player.hp != 1) return false;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                juexingji: true,
                                forced: true,
                                skillAnimation: true,
                                animationColor: 'fire',
                                content() {
                                    'step 0'
                                    player.awakenSkill('miniqitian');
                                    player.loseMaxHp();
                                    'step 1'
                                    player.addSkills(['minihuoyan', 'minijindouyun']);
                                },
                            },
                            minihuoyan: {
                                locked: true,
                                ai: {
                                    viewHandcard: true,
                                    skillTagFilter(player, arg, target) {
                                        return target != player && !_status.auto;
                                    },
                                },
                            },
                            minijindouyun: {
                                nobracket: true,
                                locked: true,
                                mod: {
                                    globalFrom(from, to, distance) {
                                        return distance - 1;
                                    },
                                    globalTo(from, to, distance) {
                                        return distance + 1;
                                    },
                                },
                            },
                            //大懒猫
                            minizuzhou: {
                                audio: 'ext:活动武将/audio/skill:true',
                                trigger: { global: 'phaseBegin' },
                                check(event, player) {
                                    if (player.hp + player.countCards('hs', { name: 'tao' }) <= 1) return false;
                                    if (event.player == player) return player.countCards('h', { name: ['sha', 'shan'] }) >= 3 && player.countCards('h', { name: 'sha' }) < 3 && player.countCards('h', { name: 'shan' }) < 3;
                                    return get.attitude(player, event.player) < 0 && event.player.countCards('h', { name: 'sha' }) > 2;
                                },
                                logTarget: 'player',
                                content() {
                                    'step 0'
                                    player.loseHp();
                                    'step 1'
                                    player.chooseControl().set('choiceList', [
                                        '令' + get.translation(trigger.player) + '本回合手牌中所有的【杀】视为【闪】',
                                        '令' + get.translation(trigger.player) + '本回合手牌中所有的【闪】视为【杀】',
                                    ]).set('ai', function () {
                                        var player = _status.event.player;
                                        return player == _status.event.target ? 1 : 0;
                                    }).set('target', trigger.player);
                                    'step 2'
                                    trigger.player.addTempSkill('minizuzhou2');
                                    trigger.player.storage.minizuzhou2 = result.index;
                                },
                                ai: { expose: 0.2 },
                            },
                            minizuzhou2: {
                                charlotte: true,
                                onremove: true,
                                mod: {
                                    cardname(card, player, name) {
                                        var list = ['sha', 'shan'];
                                        if (player.storage.minizuzhou2 == 1) list.reverse();
                                        if (card.name == list[0]) return list[1];
                                    },
                                },
                            },
                            minimoyu: {
                                audio: 'ext:活动武将/audio/skill:true',
                                trigger: { player: 'phaseUseBegin' },
                                check(event, player) {
                                    return player.hp + player.countCards('hs', { name: 'tao' }) <= 2;
                                },
                                content() {
                                    player.addTempSkill('minimoyu2');
                                    player.addMark('minimoyu2', 2, false);
                                    player.addTempSkill('minimoyu3', { player: 'minimoyu3After' });
                                    player.addMark('minimoyu3', 2, false);
                                },
                            },
                            minimoyu2: {
                                group: 'zishou2',
                                charlotte: true,
                                onremove: true,
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark('minimoyu2');
                                    },
                                },
                                trigger: { player: 'phaseEnd' },
                                filter(event, player) {
                                    return player.isDamaged();
                                },
                                forced: true,
                                content() {
                                    player.recover();
                                },
                            },
                            minimoyu3: {
                                charlotte: true,
                                onremove: true,
                                trigger: { player: 'phaseBegin' },
                                firstDo: true,
                                direct: true,
                                content() {
                                    player.addTempSkill('minimoyu4');
                                    player.addMark('minimoyu4', 2, false);
                                },
                            },
                            minimoyu4: {
                                charlotte: true,
                                onremove: true,
                                audio: 'minimoyu',
                                trigger: { player: 'phaseDrawBegin2' },
                                filter(event, player) {
                                    return !event.numFixed;
                                },
                                forced: true,
                                content() {
                                    trigger.num += player.countMark('minimoyu4');
                                },
                            },
                            minisanlian: {
                                audio: 'ext:活动武将/audio/skill:true',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h', function (card) {
                                        return lib.skill.minisanlian.filterCard(card, player);
                                    });
                                },
                                filterCard(card, player) {
                                    if (ui.selected.cards.length) {
                                        var cardx = ui.selected.cards[0];
                                        return get.type2(card) == get.type2(cardx);
                                    }
                                    return player.countCards('h', function (cardx) {
                                        return get.type2(card) == get.type2(cardx);
                                    }) >= 3;
                                },
                                selectCard: 3,
                                check(card) {
                                    return 6 - get.value(card);
                                },
                                complexCard: true,
                                content() {
                                    'step 0'
                                    player.draw(player.getDamagedHp());
                                    'step 1'
                                    for (var i of game.filterPlayer().sortBySeat(player)) {
                                        player.line(i);
                                        i.damage();
                                    }
                                    var card = cards[0];
                                    for (var cardx of cards) {
                                        if (get.name(cardx, player) != get.name(card, player)) {
                                            event.finish();
                                            break;
                                        }
                                    }
                                    'step 2'
                                    for (var i of game.filterPlayer().sortBySeat(player)) {
                                        if (i == player) continue;
                                        player.line(i);
                                        player.discardPlayerCard(i, 'he', true);
                                    }
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player) {
                                            if (player.hp + player.countCards('hs', { name: ['tao', 'jiu'] }) < 2) return -1;
                                            return game.countPlayer(function (current) {
                                                return get.sgn(get.damageEffect(current, player, player));
                                            });
                                        },
                                    },
                                },
                            },
                            //王荣
                            miniminsi: {
                                audio: 'minsi',
                                inherit: 'minsi',
                                content() {
                                    player.draw(cards.length * 2).gaintag = ['miniminsi2'];
                                    player.addTempSkill('miniminsi2');
                                },
                            },
                            miniminsi2: {
                                onremove(player) {
                                    player.removeGaintag('miniminsi2');
                                },
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (!card.cards) return;
                                        for (var i of card.cards) {
                                            if (!i.hasGaintag('miniminsi2')) return;
                                        }
                                        return true;
                                    },
                                    ignoredHandcard(card, player) {
                                        if (card.hasGaintag('miniminsi2')) return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == 'phaseDiscard' && card.hasGaintag('miniminsi2')) return false;
                                    },
                                    aiOrder(player, card, num) {
                                        if (get.itemtype(card) == 'card' && card.hasGaintag('miniminsi2')) return num - 0.1;
                                    },
                                },
                            },
                            minijijing: {
                                audio: 'jijing',
                                trigger: { player: 'damageEnd' },
                                frequent: true,
                                content() {
                                    'step 0'
                                    player.judge();
                                    'step 1'
                                    player.chooseToDiscard('是否弃置任意张点数之和不小于' + get.cnNumber(num) + '的牌并回复1点体力？', 'he').set('selectCard', function () {
                                        var num = 0;
                                        for (var i = 0; i < ui.selected.cards.length; i++) {
                                            num += get.number(ui.selected.cards[i]);
                                        }
                                        if (num >= _status.event.num) return ui.selected.cards.length;
                                        return ui.selected.cards.length + 2;
                                    }).set('ai', function (card) {
                                        return 6 - get.value(card);
                                    }).set('num', result.number).set('complexCard', true);
                                    'step 2'
                                    if (result.bool) player.recover();
                                },
                            },
                            minimanwang: {
                                init() {
                                    lib.skill.sppanqin.subSkill.eff.filter = function (event, player) {
                                        return event.card.name == 'nanman' && event.getParent(2).name == 'sppanqin' && player.countMark('spmanwang') < 4 && (player.hasSkill('spmanwang') || player.hasSkill('minimanwang')) && event.cards.length <= event.targets.length;
                                    };
                                },
                                derivation: ['sppanqin', 'minihuoshou'],
                                audio: 'spmanwang',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he') > 0;
                                },
                                filterCard: true,
                                position: 'he',
                                selectCard: [1, Infinity],
                                check(card) {
                                    var player = _status.event.player;
                                    var max = Math.min(player.isDamaged() ? 3 : 2, 4 - player.countMark('spmanwang'));
                                    if (!max && !player.hasSkill('sppanqin')) return 0;
                                    if (max == 0 && ui.selected.length > 0) return 0;
                                    return 7 - ui.selected.cards.length - get.value(card);
                                },
                                content() {
                                    'step 0'
                                    var num = Math.min(cards.length, 4 - player.countMark('spmanwang'));
                                    if (num >= 1) player.addSkill('sppanqin');
                                    if (num >= 2) player.draw();
                                    if (num >= 3) player.recover();
                                    if (num >= 4) {
                                        player.draw(2);
                                        player.removeSkills('sppanqin');
                                    }
                                    'step 1'
                                    player.addTempSkill('minihuoshou', { player: 'phaseBegin' });
                                },
                                ai: {
                                    order: 2,
                                    result: {
                                        player(player, target) {
                                            if (player.getUseValue({ name: 'nanman' }) <= 0) return 0;
                                            if (player.getStat('skill').spmanwang && player.hasSkill('sppanqin')) return 0;
                                            return 1;
                                        },
                                    },
                                },
                            },
                            //银河射手
                            miniliushi: {
                                audio: 'cxliushi',
                                inherit: 'cxliushi',
                                group: 'miniliushi_damage',
                                subSkill: {
                                    damage: {
                                        audio: 'cxliushi',
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return event.card && event.card.name == 'sha';
                                        },
                                        logTarget: 'player',
                                        forced: true,
                                        locked: false,
                                        content() {
                                            trigger.player.addMark('cxliushi2', 1);
                                            trigger.player.addSkill('cxliushi2');
                                        },
                                    },
                                },
                            },
                            //
                            minilulve: {
                                audio: 'lulve',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    var hs = player.countCards('h');
                                    return hs > 0 && game.hasPlayer(function (target) {
                                        var ts = target.countCards('h');
                                        return target != player && ts > 0 && hs >= ts;
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minilulve'), function (card, player, target) {
                                        var hs = player.countCards('h'), ts = target.countCards('h');
                                        return target != player && ts > 0 && hs >= ts;
                                    }).set('ai', function (target) {
                                        var player = _status.event.player, att = get.attitude(player, target);
                                        if (target.isTurnedOver()) return att / 10;
                                        if (!player.hasShan() && target.canUse({ name: 'sha', isCard: true }, player, false) && get.effect(player, { name: 'sha', isCard: true }, target, player) < 0 && player.hp < 4) return 0;
                                        return -att * Math.sqrt(target.countCards('h'));
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minilulve', target);
                                        var str = get.translation(player);
                                        target.chooseControl().set('choiceList', [
                                            '将所有手牌交给' + str + '，然后其将武将牌翻面',
                                            '将武将牌翻面，然后视为对' + str + '使用【杀】',
                                        ]).set('ai', function () {
                                            var player = _status.event.player, target = _status.event.getParent().player;
                                            if (player.isTurnedOver()) return 1;
                                            if (!target.hasShan() && player.canUse({ name: 'sha', isCard: true }, target, false) && get.effect(target, { name: 'sha', isCard: true }, player, player) < 0) return 0;
                                            return Math.random() < 0.5 ? 0 : 1;
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.index == 0) {
                                        target.give(target.getCards('h'), player);
                                        player.turnOver();
                                        event.finish();
                                    }
                                    else target.turnOver();
                                    'step 3'
                                    if (target.canUse({ name: 'sha', isCard: true }, player, false)) target.useCard({ name: 'sha', isCard: true }, player, false);
                                },
                            },
                            //曹节
                            minishouxi: {
                                audio: 'shouxi',
                                trigger: { target: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (event.card.name != 'sha' || !event.player.isIn()) return false;
                                    return get.inpileVCardList(info => {
                                        if (player.getStorage('minishouxi').includes(info[2]) || info[3]) return false;
                                        return ['basic', 'trick', 'delay'].includes(info[0]);
                                    }).length;
                                },
                                async cost(event, trigger, player) {
                                    const target = trigger.player;
                                    const list = get.inpileVCardList(info => {
                                        if (player.getStorage('minishouxi').includes(info[2]) || info[3]) return false;
                                        return ['basic', 'trick', 'delay'].includes(info[0]);
                                    })
                                    const { result: { bool, links } } = await player.chooseButton([get.prompt(event.name.slice(0, -5), target), [list, 'vcard']]).set('ai', button => {
                                        if (_status.event.num > 0) return 0;
                                        return 1 + Math.random();
                                    }).set('num', get.effect(player, trigger.card, target, player));
                                    event.result = {
                                        bool: bool,
                                        cost_data: links,
                                    }
                                },
                                logTarget: 'player',
                                async content(event, trigger, player) {
                                    const target = trigger.player;
                                    const links = event.cost_data, name = links[0][2], str = get.translation(name);
                                    player.markAuto(event.name, [name]);
                                    player.popup(str);
                                    game.log(player, '声明了', '#g【' + str + '】');
                                    const bool = await target.chooseToDiscard('he', (card) => get.name(card) == _status.event.namex).set('ai', card => 10 - get.value(card) * (_status.event.att < 0 ? 1 : 0)).set('att', get.attitude(target, player)).set('namex', name).set('dialog', ['###守玺###弃置一张【' + str + '】，否则此【杀】对' + get.translation(player) + '无效且' + get.translation(player) + '从牌堆中获得一张【' + str + '】', [links, 'vcard']]).forResultBool();
                                    if (bool && player.countGainableCards(target, 'he')) await target.gainPlayerCard(player, 'he', true);
                                    else {
                                        trigger.getParent().excluded.add(player);
                                        const card = get.cardPile2(card => card.name == name);
                                        if (card) await player.gain(card, 'gain2');
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (_status.event.name == 'minishouxi') return;
                                            if (card.name != 'sha' || get.attitude(player, target) > 0) return;
                                            var list = lib.inpile.filter(i => {
                                                if (target.getStorage('minishouxi').includes(i)) return false;
                                                var type = get.type2(i);
                                                return type == 'basic' || type == 'trick';
                                            });
                                            if (!player.countCards('he', cardx => lib.filter.cardDiscardable(cardx, player) && list.includes(cardx.name))) return 0.2;
                                        },
                                    },
                                },
                            },
                            minihuimin: {
                                //写在前面当filter位置[doge]
                                group: 'minihuimin_log',
                                audio: 'huimin',
                                subSkill: {
                                    log: {
                                        trigger: { player: 'phaseJieshuBegin' },
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.countCards('h') <= current.hp;
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            var num = 1, sum = 0;
                                            for (var target of game.filterPlayer()) {
                                                if (target.countCards('h') > target.hp) continue;
                                                sum++;
                                                var att = get.attitude(player, target);
                                                if (att > 0) num++;
                                                if (att < 0) num--;
                                            }
                                            var info = '摸' + get.cnNumber(sum) + '张牌';
                                            var func = function () {
                                                for (var target of game.filterPlayer()) {
                                                    var bool = (target.countCards('h') > target.hp);
                                                    target.prompt('<span class=\"texiaotext\" style=\"color:' + (bool ? '#FF0000' : '#00FF00') + '\">' + (bool ? '×' : '√') + '</span>');
                                                }
                                            };
                                            if (event.player == game.me) func();
                                            else if (event.isOnline()) player.send(func);
                                            if (sum > 1) info += '，然后展示' + get.cnNumber(sum - 1) + '张手牌，然后你选择一名手牌数小于等于体力值的角色，从该角色开始，所有手牌数小于等于体力值的角色依次选择并获得其中一张';
                                            player.chooseBool(get.prompt('minihuimin'), info).set('choice', num >= 0);
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('minihuimin');
                                                var next = game.createEvent('minihuimin');
                                                next.player = player;
                                                next.setContent(lib.skill.minihuimin.content);
                                            }
                                        },
                                    },
                                },
                                content() {
                                    'step 0'
                                    event.list = game.filterPlayer(function (current) {
                                        return current.countCards('h') <= current.hp;
                                    }).sortBySeat();
                                    player.draw(event.list.length);
                                    if (event.list.length == 1) event.finish();
                                    'step 1'
                                    player.chooseTarget(true, function (card, player, target) {
                                        var list = _status.event.list;
                                        return list.includes(target);
                                    }, '惠民：请选择一名角色作为分牌起点').set('ai', function (target) {
                                        var player = _status.event.player;
                                        var list = _status.event.list;
                                        var att = get.attitude(player, target);
                                        var getNum = function (target) {
                                            var num = 0, targets = list.slice(0);
                                            for (var i = 0; i < targets.length; i++) {
                                                if (att > 0) num += (targets.length - i);
                                                if (att < 0) num -= (targets.length - i);
                                            }
                                            return num;
                                        };
                                        return getNum(target);
                                    }).set('list', event.list);
                                    'step 2'
                                    if (result.bool) {
                                        player.line(result.targets, 'green');
                                        var index = event.list.indexOf(result.targets[0]);
                                        if (index < 0) index = 0;
                                        var tmp = event.list.splice(index);
                                        event.list = tmp.concat(event.list);
                                        var yuanzhong = event.list[event.list.length - 1];//掉队的冤种[doge]
                                        game.log(player, '选择了', result.targets, '作为分牌起点'/*+'，',yuanzhong,'被',player,'落下'*/);
                                        yuanzhong.chat(['我成冤种了', '555没我份', '怎能如此对我', '太狠心啦2333'].randomGet());
                                        event.list.remove(yuanzhong);
                                        if (event.list.length > 0) player.chooseCard('h', '选择要分配的手牌', event.list.length, true);
                                        else event.finish();
                                    }
                                    'step 3'
                                    var cards = result.cards;
                                    player.lose(cards, ui.ordering);
                                    event.togain = cards;
                                    if (result.bool && cards.length) {
                                        var dialog = ui.create.dialog('惠民', cards, true);
                                        _status.dieClose.push(dialog);
                                        dialog.videoId = lib.status.videoId++;
                                        event.dialogID = dialog.videoId;
                                        game.addVideo('cardDialog', null, ['惠民', get.cardsInfo(cards), dialog.videoId]);
                                        game.broadcast(function (cards, id) {
                                            var dialog = ui.create.dialog('惠民', cards, true);
                                            _status.dieClose.push(dialog);
                                            dialog.videoId = id;
                                        }, cards, dialog.videoId);
                                    }
                                    else event.finish();
                                    'step 4'
                                    game.delay();
                                    'step 5'
                                    if (event.list.length && event.togain.length) {
                                        event.current = event.list.shift();
                                        var next = event.current.chooseButton(true, function (button) {
                                            return get.value(button.link, _status.event.player);
                                        });
                                        next.set('dialog', event.dialogID);
                                        next.set('closeDialog', false);
                                        next.set('dialogdisplay', true);
                                        next.set('cardFilter', event.togain.slice(0));
                                        next.set('filterButton', function (button) {
                                            return _status.event.cardFilter.includes(button.link);
                                        })
                                    }
                                    else {
                                        for (var i = 0; i < ui.dialogs.length; i++) {
                                            if (ui.dialogs[i].videoId == event.dialogID) {
                                                var dialog = ui.dialogs[i];
                                                dialog.close();
                                                _status.dieClose.remove(dialog);
                                                break;
                                            }
                                        }
                                        if (event.togain.length) {
                                            game.cardsDiscard(event.togain);
                                        }
                                        game.broadcast(function (id) {
                                            var dialog = get.idDialog(id);
                                            if (dialog) {
                                                dialog.close();
                                                _status.dieClose.remove(dialog);
                                            }
                                        }, event.dialogID);
                                        game.addVideo('cardDialog', null, event.dialogID);
                                        event.finish();
                                    }
                                    'step 6'
                                    var card = result.links[0], target = event.current;
                                    if (card) {
                                        target.gain(card, 'gain2');
                                        event.togain.remove(card);
                                    }
                                    var capt = get.translation(target) + '选择了' + get.translation(card);
                                    game.broadcastAll(function (card, id, name, capt) {
                                        var dialog = get.idDialog(id);
                                        if (dialog) {
                                            dialog.content.firstChild.innerHTML = capt;
                                            for (var i = 0; i < dialog.buttons.length; i++) {
                                                if (dialog.buttons[i].link == card) {
                                                    dialog.buttons[i].querySelector('.info').innerHTML = name;
                                                    break;
                                                }
                                            }
                                            game.addVideo('dialogCapt', null, [dialog.videoId, dialog.content.firstChild.innerHTML]);
                                        }
                                    }, card, event.dialogID, function (target) {
                                        if (target._tempTranslate) return target._tempTranslate;
                                        var name = target.name;
                                        if (lib.translate[name + '_ab']) return lib.translate[name + '_ab'];
                                        return get.translation(name);
                                    }(target), capt);
                                    if (event.togain.length) event.goto(5);
                                    else {
                                        for (var i = 0; i < ui.dialogs.length; i++) {
                                            if (ui.dialogs[i].videoId == event.dialogID) {
                                                var dialog = ui.dialogs[i];
                                                dialog.close();
                                                _status.dieClose.remove(dialog);
                                                break;
                                            }
                                        }
                                        if (event.togain.length) {
                                            game.cardsDiscard(event.togain);
                                        }
                                        game.broadcast(function (id) {
                                            var dialog = get.idDialog(id);
                                            if (dialog) {
                                                dialog.close();
                                                _status.dieClose.remove(dialog);
                                            }
                                        }, event.dialogID);
                                        game.addVideo('cardDialog', null, event.dialogID);
                                        event.finish();
                                    }
                                },
                            },
                            //唐姬
                            minikangge: {
                                group: ['minikangge_draw', 'minikangge_dying'],
                                audio: 'kangge',
                                trigger: { player: 'phaseBegin' },
                                filter(event, player) {
                                    return game.countPlayer() > 1;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget('请选择【抗歌】的目标', '其于回合外摸牌后，你摸等量的牌；其进入濒死状态时，你可令其回复体力至1点；其死亡后，你弃置所有牌并失去1点体力', lib.filter.notMe, true).set('ai', function (target) {
                                        return get.attitude(_status.event.player, target) > 0;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minikangge', target);
                                        player.addSkill('minikangge_clear');
                                        player.storage.minikangge = target;
                                        player.markSkill('minikangge');
                                        game.delayx();
                                    }
                                },
                                intro: { content: '已指定$为目标' },
                                subSkill: {
                                    draw: {
                                        audio: 'kangge',
                                        trigger: {
                                            global: ['gainAfter', 'loseAsyncAfter'],
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            if (player.countMark('minikangge_draw') >= 3) return false;
                                            var target = player.storage.minikangge;
                                            return target && target != _status.currentPhase && event.getg(target).length > 0;
                                        },
                                        logTarget: 'player',
                                        content() {
                                            var num = Math.min(3 - player.countMark('minikangge_draw'), trigger.getg(player.storage.minikangge).length);
                                            player.addMark('minikangge_draw', num, false);
                                            player.draw(num);
                                        },
                                    },
                                    clear: {
                                        trigger: { global: 'phaseBeginStart' },
                                        forced: true,
                                        firstDo: true,
                                        popup: false,
                                        charlotte: true,
                                        filter(event, player) {
                                            return player.countMark('minikangge_draw') > 0;
                                        },
                                        content() {
                                            player.removeMark('minikangge_draw', player.countMark('minikangge_draw'), false);
                                        },
                                    },
                                    dying: {
                                        audio: 'kangge',
                                        trigger: { global: 'dying' },
                                        logTarget: 'player',
                                        filter(event, player) {
                                            return event.player == player.storage.minikangge && event.player.hp < 1 && !player.hasSkill('minikangge_temp');
                                        },
                                        check(event, player) {
                                            return get.attitude(player, event.player) > 0;
                                        },
                                        prompt2: '令其将体力值回复至1点',
                                        round: 1,
                                        content() {
                                            trigger.player.recover(1 - trigger.player.hp);
                                        },
                                    },
                                },
                            },
                            minijielie: {
                                audio: 'jielie',
                                trigger: { player: 'damageBegin4' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var target = player.storage.minikangge, str;
                                    if (target) {
                                        event.target = target;
                                        str = '，且令' + get.translation(target) + '从弃牌堆中获得等量的花色牌';
                                    }
                                    else str = '';
                                    player.chooseControl(lib.suit.slice(0), 'cancel2').set('prompt', get.prompt('minijielie')).set('prompt2', '防止伤害并改为失去等量体力' + str).set('ai', function () {
                                        var player = _status.event.player;
                                        var target = player.storage.minikangge;
                                        if (target && get.attitude(player, target) <= 0) return 'cancel2';
                                        return lib.suit.randomGet();
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        event.suit = result.control;
                                        player.logSkill('minijielie');
                                        trigger.cancel();
                                        player.loseHp();
                                        if (!target) event.finish();
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.line(target);
                                    var cards = [];
                                    while (cards.length < trigger.num) {
                                        var card = get.discardPile(function (card) {
                                            return get.suit(card, false) == event.suit && !cards.includes(card);
                                        });
                                        if (card) cards.push(card);
                                        else break;
                                    }
                                    if (cards.length) target.gain(cards, 'gain2');
                                },
                            },
                            //李白
                            minishixian: {
                                derivation: ['minishixian_qiangjinjiu', 'minishixian_jingyesi', 'minishixian_xiakexing', 'minishixian_xinglunan'],
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                frequent: true,
                                async content(event, trigger, player) {
                                    if (player.additionalSkills.minishixian) await player.removeAdditionalSkills('minishixian');
                                    let cards = get.cards(4, true);
                                    await player.showCards(cards, get.translation(player) + '发动了【诗仙】');
                                    const map = { 'heart': 'minishixian_qiangjinjiu', 'diamond': 'minishixian_jingyesi', 'spade': 'minishixian_xiakexing', 'club': 'minishixian_xinglunan' };
                                    const skills = Object.values(map).filter(suit => cards.some(card => map[get.suit(card, false)] == suit));
                                    if (skills.length) await player.addAdditionalSkills('minishixian', skills);
                                    cards = cards.filter(card => cards.some(cardx => cardx != card && get.suit(card, player) == get.suit(cardx, player)));
                                    if (cards.length) {
                                        const { result: { bool } } = await player.chooseBool('诗仙：是否获得' + get.translation(cards) + '？').set('frequentSkill', 'minishixian');
                                        if (bool) player.gain(cards, 'gain2');
                                    }
                                },
                                subSkill: {
                                    //将进酒
                                    qiangjinjiu: {
                                        nobracket: true,
                                        audio: 'ext:活动武将/audio/skill:true',
                                        trigger: { global: 'phaseBegin' },
                                        filter(event, player) {
                                            if (event.player == player) return false;
                                            return player.countCards('h') && event.player.countCards('he');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseToDiscard(get.prompt2('minishixian_qiangjinjiu', trigger.player)).set('ai', function (card) {
                                                var player = _status.event.player;
                                                var target = _status.event.target;
                                                if (get.attitude(player, target) > 0) return 0;
                                                return 6 - get.value(card);
                                            }).set('target', trigger.player).logSkill = ['minishixian_qiangjinjiu', trigger.player];
                                            'step 1'
                                            if (result.bool) {
                                                if (!trigger.player.countCards('e')) event._result = { bool: true, index: 1 };
                                                else player.chooseControl().set('choiceList', [
                                                    '弃置' + get.translation(trigger.player) + '装备区里的所有装备牌',
                                                    '获得' + get.translation(trigger.player) + '手牌中的所有【酒】（若其手牌中没有【酒】则改为获得其一张牌）',
                                                ]).set('ai', () => 0);
                                            }
                                            else event.finish();
                                            'step 2'
                                            if (result.index == 0) {
                                                trigger.player.discard(trigger.player.getCards('e')).discarder = player;
                                                var card = get.cardPile2(card => card.name == 'jiu');
                                                if (card) trigger.player.gain(card, 'gain2');
                                            }
                                            else {
                                                if (trigger.player.countCards('h', { name: 'jiu' })) player.gain(trigger.player.getCards('h', { name: 'jiu' }), trigger.player, 'give');
                                                else player.gainPlayerCard(trigger.player, 'he', true);
                                            }
                                        },
                                    },
                                    //静夜思
                                    jingyesi: {
                                        nobracket: true,
                                        audio: 'ext:活动武将/audio/skill:true',
                                        trigger: { player: ['phaseUseEnd', 'phaseDiscardEnd'] },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            var card = get[trigger.name == 'phaseDiscard' ? 'bottomCards' : 'cards']()[0];
                                            if (trigger.name == 'phaseDiscard') {
                                                player.logSkill('minishixian_jingyesi');
                                                player.gain(card, 'gain2');
                                                event.finish();
                                            }
                                            else {
                                                event.card = card;
                                                player.chooseControl('ok').set('dialog', ['静夜思', [card]]);
                                                player.chooseUseTarget(card, false).logSkill = 'minishixian_jingyesi';
                                            }
                                            'step 1'
                                            if (!result.bool) ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                                            game.updateRoundNumber();
                                        },
                                    },
                                    //侠客行
                                    xiakexing: {
                                        nobracket: true,
                                        audio: 'ext:活动武将/audio/skill:true',
                                        trigger: { player: 'useCard', source: 'damageSource' },
                                        filter(event, player) {
                                            if (event.name == 'useCard') return get.translation(event.card.name).indexOf('剑') != -1 && player.hasUseTarget(get.autoViewAs({ name: 'wanjian' }, []));
                                            return event.card && event.card.name == 'sha' && player.getEquips(1).length && event.player.isIn() && player.canCompare(event.player);
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            if (trigger.name == 'useCard') {
                                                player.logSkill('minishixian_xiakexing');
                                                player.chooseUseTarget(true, { name: 'wanjian' }, []);
                                                event.finish();
                                            }
                                            else player.chooseBool('是否和' + get.translation(trigger.player) + '拼点？', '若你赢，其减1点体力上限；若你没赢，弃置你装备区里的武器牌').set('choice', player.hasCard(function (card) {
                                                return get.value(card) <= 5 || get.number(card) > 10;
                                            }) && (get.attitude(player, trigger.player) <= 0 || trigger.player.countCards('h') >= 4));
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('minishixian_xiakexing', trigger.player);
                                                player.chooseToCompare(trigger.player);
                                            }
                                            else event.finish();
                                            'step 2'
                                            if (result.bool) trigger.player.loseMaxHp();
                                            else {
                                                var cards = player.getEquips(1);
                                                if (cards.length) player.discard(cards);
                                            }
                                        },
                                    },
                                    //行路难
                                    xinglunan: {
                                        nobracket: true,
                                        audio: 'ext:活动武将/audio/skill:true',
                                        trigger: { global: 'useCardAfter' },
                                        filter(event, player) {
                                            if (player == _status.currentPhase || event.card.name != 'sha' || event.player == player) return false;
                                            return event.targets && event.targets.includes(player);
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addTempSkill('minishixian_xingluBuff', { player: 'phaseBegin' });
                                            player.addMark('minishixian_xingluBuff', 1, false);
                                        },
                                    },
                                    xingluBuff: {
                                        nobracket: true,
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '其他角色计算与你的距离+#' },
                                        mod: {
                                            globalTo(from, to, distance) {
                                                return distance + to.countMark('minishixian_xingluBuff');
                                            },
                                        },
                                    },
                                },
                            },
                            //郭图
                            minijigong: {
                                audio: 'jigong',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseControl('一张', '两张', '三张', 'cancel2').set('prompt', get.prompt2('minijigong')).set('ai', () => '三张');
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minijigong');
                                        player.addTempSkill('minijigong2');
                                        player.draw(1 + result.index);
                                    }
                                },
                            },
                            minijigong2: {
                                charlotte: true,
                                mod: {
                                    maxHandcardBase(player) {
                                        if (game.online) return (player.getStat('damage') || 0) + 1;
                                        var num = 0;
                                        player.getHistory('sourceDamage', function (evt) {
                                            num += evt.num;
                                        });
                                        return num + 1;
                                    },
                                },
                                audio: 'jigong',
                                trigger: { player: 'phaseDiscardBegin' },
                                filter(event, player) {
                                    if (player.isHealthy()) return false;
                                    var num = 0;
                                    player.getHistory('sourceDamage', function (evt) {
                                        num += evt.num;
                                    });
                                    if (!num) return false;
                                    var num2 = 0;
                                    player.getHistory('gain', function (evt) {
                                        var evtx = evt.getParent(2);
                                        if (evtx.name == 'minijigong' && evtx.player == player) num2 += evt.cards.length;
                                    });
                                    return num >= num2;
                                },
                                forced: true,
                                content() {
                                    player.recover();
                                },
                            },
                            minishifei: {
                                audio: 'shifei',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                filter(event, player) {
                                    if (!_status.currentPhase || event.minishifei) return false;
                                    if (!event.filterCard({ name: 'shan', isCard: true }, player, event)) return false;
                                    if (event.name != 'chooseToUse' && !lib.filter.cardRespondable({ name: 'shan', isCard: true }, player, event)) return false;
                                    return true;
                                },
                                checkx(event, player) {
                                    if (get.attitude(player, _status.currentPhase) > 0) return true;
                                    var num = (event.shanRequired || 1);
                                    if (player.countCards('hs', { name: 'shan' }) - num > 1) return false;
                                    return game.hasPlayer(function (current) {
                                        if (current == _status.currentPhase) return false;
                                        return _status.currentPhase.countCards('h') + 1 <= current.countCards('h');
                                    });
                                },
                                delay: false,
                                content() {
                                    'step 0'
                                    player.line(_status.currentPhase, 'green');
                                    _status.currentPhase.draw();
                                    'step 1'
                                    if (_status.currentPhase.isMaxHandcard(true)) {
                                        var evt = event.getParent(2);
                                        evt.set('minishifei', true);
                                        evt.goto(0);
                                        event.finish();
                                        return;
                                    }
                                    if (game.hasPlayer(current => current.countCards('he'))) {
                                        player.chooseTarget('选择一名角色弃置其一张牌', true, function (card, player, target) {
                                            return target.countCards('he');
                                        }).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.effect(target, { name: 'guohe_copy2' }, player, player);
                                        });
                                    }
                                    else event._result = { bool: false };
                                    'step 2'
                                    var evt = event.getParent(2);
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'green');
                                        player.discardPlayerCard(target, 'he', true);
                                        evt.result = { bool: true, card: { name: 'shan', isCard: true }, cards: [] };
                                        evt.redo();
                                    }
                                    else {
                                        evt.set('minishifei', true);
                                        evt.goto(0);
                                    }
                                },
                                ai: {
                                    order: 8,
                                    respondShan: true,
                                    result: {
                                        player(player) {
                                            return lib.skill.minishifei.checkx(_status.event, player) ? 1 : 0;
                                        },
                                    },
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondShan') && current < 0) {
                                                if (!player.isMaxHandcard()) return 0;
                                            }
                                        },
                                    },
                                },
                            },
                            //南华老仙
                            minijinghe: {
                                audio: 'jinghe',
                                inherit: 'jinghe',
                                filter(event, player) {
                                    return !player.hasSkill('minijinghe_clear');
                                },
                                content() {
                                    'step 0'
                                    player.when('phaseBegin').then(() => game.countPlayer(current => current.removeAdditionalSkills('minijinghe_' + player.playerid)));
                                    player.showCards(cards, get.translation(player) + '发动了【经合】');
                                    event.skills = lib.skill.minijinghe.derivation.randomGets(4);
                                    player.addTempSkill('minijinghe_clear', { player: 'phaseBegin' });
                                    event.targets.sortBySeat();
                                    event.num = 0;
                                    'step 1'
                                    event.target = targets[num];
                                    event.num++;
                                    event.target.chooseControl(event.skills, 'cancel2').set('choiceList', event.skills.map(function (i) {
                                        return '<div class="skill">【' + get.translation(lib.translate[i + '_ab'] || get.translation(i).slice(0, 2)) + '】</div><div>' + get.skillInfoTranslation(i, player) + '</div>';
                                    })).set('displayIndex', false).set('prompt', '选择获得一个技能');
                                    'step 2'
                                    var skill = result.control;
                                    if (skill != 'cancel2') {
                                        event.skills.remove(skill);
                                        target.addAdditionalSkills('minijinghe_' + player.playerid, skill);
                                        target.popup(skill);
                                        game.log(target, '获得了技能', '#g【' + get.translation(skill) + '】');
                                    }
                                    if (event.num < event.targets.length) event.goto(1);
                                    if (target != game.me && !target.isOnline2()) game.delayx();
                                },
                                ai: {
                                    threaten: 3,
                                    order: 10,
                                    result: { target: 1 },
                                },
                                derivation: ['minileiji', 'minibiyue', 'new_retuxi', 'minimingce', 'minizhiyan', 'nhyinbing', 'nhhuoqi', 'nhguizhu', 'nhxianshou', 'nhlundao', 'nhguanyue', 'nhyanzheng'],
                            },
                            minigongxiu: {
                                audio: 'gongxiu',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.getHistory('useSkill', evt => evt.skill == 'minijinghe').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.list1 = [];
                                    event.list2 = [];
                                    event.addIndex = 0;
                                    var choices = [];
                                    game.countPlayer(function (current) {
                                        if (current.additionalSkills['minijinghe_' + player.playerid]) event.list1.push(current);
                                        else event.list2.push(current);
                                    });
                                    event.list1.sortBySeat();
                                    if (event.list1.length) choices.push('令' + get.translation(event.list1) + (event.list1.length > 1 ? '各' : '') + '摸一张牌');
                                    else event.addIndex++;
                                    event.list2.sortBySeat();
                                    if (event.list2.length) choices.push('令' + get.translation(event.list2) + (event.list2.length > 1 ? '各' : '') + '弃置一张手牌');
                                    player.chooseControl('cancel2').set('choiceList', choices).set('prompt', get.prompt('minigongxiu')).set('', function () {
                                        var evt = _status.event.getParent();
                                        if (evt.list2.filter(function (current) {
                                            return get.attitude(player, current) <= 0 && !current.hasSkillTag('noh');
                                        }).length - evt.list1.length > 1) return 1 - evt.addIndex;
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        if (result.index + event.addIndex == 0) {
                                            player.logSkill('minigongxiu', event.list1);
                                            game.asyncDraw(event.list1);
                                        }
                                        else {
                                            player.logSkill('minigongxiu', event.list2);
                                            for (var i of event.list2) i.chooseToDiscard('h', true);
                                            event.finish();
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    game.delayx();
                                },
                            },
                            //严夫人
                            minichanni: {
                                audio: 'channi',
                                inherit: 'channi',
                                content() {
                                    'step 0'
                                    player.give(cards, target);
                                    player.addTempSkill('minichanni_effect');
                                    'step 1'
                                    if (target.countCards('h') > 0) {
                                        game.broadcastAll(function (num) {
                                            lib.skill.minichanni_backup.selectCard = [1, num];
                                        }, cards.length);
                                        var next = target.chooseToUse();
                                        next.set('openskilldialog', '将至多' + get.cnNumber(cards.length) + '张手牌当做【决斗】使用');
                                        next.set('norestore', true);
                                        next.set('addCount', false);
                                        next.set('_backupevent', 'minichanni_backup');
                                        next.set('custom', {
                                            add: {},
                                            replace: { window() { } }
                                        });
                                        next.backup('minichanni_backup');
                                    }
                                },
                                subSkill: {
                                    backup: {
                                        filterCard(card) {
                                            return get.itemtype(card) == 'card';
                                        },
                                        viewAs: { name: 'juedou' },
                                        position: 'h',
                                        filterTarget: lib.filter.targetEnabled,
                                        check: (card) => get.name(card) == 'sha' ? 7 : 5.5 - get.value(card),
                                        log: false,
                                        precontent() {
                                            delete event.result.skill;
                                        },
                                    },
                                    effect: {
                                        charlotte: true,
                                        trigger: { global: 'damageBegin2' },
                                        filter(event, player) {
                                            if (!player.countCards('h') || !event.card || event.card.name !== 'juedou') return false;
                                            const evtx = event.getParent(2);
                                            if (!evtx || evtx.name !== 'useCard' || evtx.card.name !== 'juedou') return false;
                                            const evt = event.getParent(5);
                                            return evt.skill == 'minichanni' && evt.player == player && evt.targets[0] == event.player;
                                        },
                                        prompt2(event, player) {
                                            return '弃置所有手牌，防止即将对' + get.translation(event.player) + '造成的伤害';
                                        },
                                        content() {
                                            player.discard(player.getCards('h'));
                                            trigger.cancel();
                                        },
                                        group: 'minichanni_draw',
                                    },
                                    draw: {
                                        charlotte: true,
                                        trigger: { global: 'damageSource' },
                                        filter(event, player) {
                                            if (!event.source?.isIn() || !event.card || event.card.name !== 'juedou') return false;
                                            const evtx = event.getParent(2);
                                            if (!evtx || evtx.name !== 'useCard' || evtx.card.name !== 'juedou' || !evtx.cards.length) return false;
                                            const evt = event.getParent(5);
                                            return evt.skill == 'minichanni' && evt.player == player && evt.targets[0] == event.source;
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            trigger.source.draw(trigger.getParent(2).cards.length);
                                        },
                                    },
                                },
                            },
                            mininifu: {
                                audio: 'nifu',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    return player.countCards('h') < 3;
                                },
                                forced: true,
                                content() {
                                    player.drawTo(3);
                                },
                            },
                            //公孙渊
                            minihuaiyi: {
                                audio: 'huaiyi',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h');
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    player.showHandcards(get.translation(player) + '发动了【怀异】');
                                    if (!player.countDiscardableCards(player, 'h')) event.finish();
                                    'step 1'
                                    player.chooseToDiscard('h', [1, Infinity], function (card, player) {
                                        return !ui.selected.cards.some(cardx => get.color(cardx, player) != get.color(card, player));
                                    }, true).set('complexCard', true).set('ai', function (card) {
                                        var player = _status.event.player;
                                        var num = game.countPlayer(current => current.countGainableCards(player, 'he') && get.effect(current, { name: 'shunshou_copy2' }, player, player) > 0);
                                        if (ui.selected.cards.length >= num) return 0;
                                        var suits = {};
                                        for (var i of player.getDiscardableCards(player, 'h')) {
                                            if (!suits[get.suit(i, player)]) suits[get.suit(i, player)] = 1;
                                            else suits[get.suit(i, player)]++;
                                        }
                                        if (!Object.keys(suits).some(suit => suits[suit] < num)) {
                                            return num / (get.value(card) || 0.5);
                                        }
                                        if (suits[get.suit(card, player)] >= num) return (num / suits[get.suit(card, player)]) / (get.value(card) || 0.5);
                                        return 0;
                                    });
                                    'step 2'
                                    if (!result.bool) { event.finish(); return; }
                                    var color = get.color(result.cards[0], player);
                                    var cards = player.getCards('h', card => get.color(card) == color && player.canRecast(card));
                                    if (cards.length) player.recast(cards);
                                    event.num = result.cards.length;
                                    'step 3'
                                    player.chooseTarget('请选择至多' + get.cnNumber(event.num) + '名有牌的其他角色，获得这些角色的各一张牌。', [1, num], function (card, player, target) {
                                        return target != player && target.countGainableCards(player, 'he') > 0;
                                    }).set('ai', function (target) {
                                        return -get.attitude(_status.event.player, target) + 0.5;
                                    });
                                    'step 4'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.line(targets);
                                        player.gainMultiple(targets, 'he');
                                    }
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        player(player, target) {
                                            return game.countPlayer(current => current.countGainableCards(player, 'he') && get.effect(current, { name: 'shunshou_copy2' }, player, player) > 0);
                                        },
                                    },
                                },
                            },
                            //群张辽
                            minimubing: {
                                audio: 'mubing',
                                enable: 'phaseUse',
                                usable: 1,
                                delay: 0,
                                *content(event, map) {
                                    var player = map.player;
                                    var cards = get.cards(4, true);
                                    var dialog = ['募兵：请选择你要获得的牌和弃置的牌'];
                                    dialog.push('<div class="text center">牌堆顶（已选点数和：0）</div>');
                                    dialog.push(cards);
                                    if (player.countCards('h') > 0) {
                                        dialog.push('<div class="text center">手牌（已选点数和：0）</div>');
                                        dialog.push(player.getCards('h'));
                                    }
                                    var result = yield player.chooseButton(dialog).set('filterButton', button => {
                                        return !get.owner(button.link) || lib.filter.cardDiscardable(button.link, _status.event.player);
                                    }).set('ai', button => {
                                        var player = _status.event.player;
                                        if (get.owner(button.link)) {
                                            var sum = _status.event.sum;
                                            var num = 0;
                                            for (var i of ui.selected.buttons) {
                                                if (get.owner(i.link)) num += i.number;
                                            }
                                            if (num >= sum) return 0;
                                            if (button.link.number + num >= sum) return 15 - get.value(button.link);
                                            if (!ui.selected.buttons.some(but => get.owner(but.link))) {
                                                var min = _status.event.min;
                                                if (button.link.number < min && !player.countCards('h', function (card) {
                                                    return card != button.link && button.link.number + card.number > min;
                                                })) return 0;
                                                return button.link.number;
                                            }
                                            return Math.max(5 - get.value(button.link), button.link.number);
                                        }
                                        return get.value(button.link, player);
                                    }).set('sum', cards.reduce((num, card) => num += get.value(card, player) > 0 ? get.number(card, false) : 0, 0)).set('min', cards.find(card => {
                                        return !cards.some(cardx => cardx != card && cardx.number < card.number);
                                    }).number).set('filterOk', () => {
                                        return ui.selected.buttons.reduce((num, but) => num += but.link.number * (get.owner(but.link) ? 1 : -1), 0) >= 0;
                                    }).set('selectButton', () => {
                                        var dialog = get.idDialog(event.videoId);
                                        if (dialog) {
                                            var num1 = 0, num2 = 0;
                                            ui.selected.buttons.forEach(but => {
                                                if (!get.owner(but.link)) num1 += but.link.number;
                                                else num2 += but.link.number;
                                            });
                                            dialog.content.childNodes[1].innerHTML = '<div class="text center">牌堆顶（已选点数和：' + num1 + '）</div>';
                                            if (dialog.content.childNodes[3]) dialog.content.childNodes[3].innerHTML = '<div class="text center">手牌（已选点数和：' + num2 + '）</div>';
                                        }
                                        return [1, Infinity];
                                    });
                                    if (result.bool) {
                                        var gain = result.links.filter(i => cards.includes(i));
                                        var discard = result.links.filter(i => !cards.includes(i));
                                        cards.removeArray(gain);
                                        if (discard.length) player.discard(discard);
                                        if (gain.length) player.gain(gain, 'gain2').gaintag.add('minimubing');
                                    }
                                    if (cards.length) {
                                        player.$throw(cards, 1000);
                                        game.cardsDiscard(cards);
                                        game.log(cards, '被置入了弃牌堆');
                                    }
                                },
                                onremove(player) {
                                    player.removeGaintag('minimubing');
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                            },
                            miniziqu: {
                                audio: 'ziqu',
                                trigger: { source: 'damageBegin2' },
                                filter(event, player) {
                                    return !player.getStorage('miniziqu_round').includes(event.player) && event.player.countCards('he') > 0;
                                },
                                check(event, player) {
                                    var target = event.player;
                                    var eff = get.damageEffect(target, player, player);
                                    if (get.attitude(player, target) > 0) {
                                        if (eff >= 0) return false;
                                        return true;
                                    }
                                    if (eff <= 0) return true;
                                    if (target.hp == 1) return false;
                                    if (event.num > 1) return false;
                                    var cards = target.getCards('he');
                                    for (var i = 0; i < cards.length; i++) {
                                        if (get.number(cards[i]) > 10) return true;
                                    }
                                    return false;
                                },
                                logTarget: 'player',
                                content() {
                                    'step 0'
                                    player.addTempSkill('miniziqu_round', 'roundStart');
                                    player.markAuto('miniziqu_round', [trigger.player]);
                                    trigger.cancel();
                                    if (trigger.player != player) {
                                        trigger.player.chooseCard(true, 'he', function (card, player) {
                                            return !player.countCards('he', function (cardx) {
                                                return cardx.number > card.number;
                                            });
                                        });
                                    }
                                    else event.finish();
                                    'step 1'
                                    if (result.bool) trigger.player.give(result.cards, player);
                                },
                                subSkill: {
                                    round: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '本轮已对$发动过此技能' },
                                    },
                                },
                            },
                            minidiaoling: {
                                audio: 'diaoling',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h', card => card.hasGaintag('minimubing')) && game.countPlayer() > 1;
                                },
                                filterCard(card, player) {
                                    return card.hasGaintag('minimubing');
                                },
                                selectCard: [1, Infinity],
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    var player = _status.event.player;
                                    if (ui.selected.cards.some(cardx => Math.abs(get.number(cardx, player) - get.number(card, player)) <= 1)) return 10 - get.value(card);
                                    return 5 - get.value(card);
                                },
                                complexCard: true,
                                complexSelect: true,
                                discard: false,
                                lose: false,
                                delay: 0,
                                content() {
                                    'step 0'
                                    player.give(cards, target);
                                    'step 1'
                                    var nums = [];
                                    for (var card of cards) nums.add(get.number(card, player));
                                    nums.sort((a, b) => a - b);
                                    if (cards.length > 1 && cards.length == nums.length && nums[nums.length - 1] - nums[0] == nums.length - 1) {
                                        player.chooseTarget('请选择至多' + get.cnNumber(nums.length - 1) + '名有牌的其他角色，获得这些角色的各一张牌。', [1, nums.length - 1], function (card, player, target) {
                                            return target != player && target.countGainableCards(player, 'he') > 0;
                                        }).set('ai', function (target) {
                                            return -get.attitude(_status.event.player, target) + 0.5;
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.line(targets);
                                        player.gainMultiple(targets, 'he');
                                    }
                                },
                                ai: {
                                    order: 8,
                                    result: { target: 1 },
                                },
                            },
                            //SP张郃
                            minizhouxuan: {
                                group: 'minizhouxuan_use',
                                audio: 'spolzhouxuan',
                                trigger: { player: 'phaseDiscardBegin' },
                                filter(event, player) {
                                    return player.countCards('h') > 0 && player.getExpansions('minizhouxuan').length < 5;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCard('h', get.prompt('minizhouxuan'), [1, 5 - player.getExpansions('minizhouxuan').length], '将至多' + get.cnNumber(5 - player.getExpansions('minizhouxuan').length) + '张手牌置于武将牌上').set('ai', function (card) {
                                        if (ui.selected.cards.length >= player.needsToDiscard()) return 6 - get.value(card);
                                        return 100 - get.useful(card);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var cards = result.cards;
                                        player.logSkill('minizhouxuan');
                                        player.addToExpansion(cards, player, 'give').gaintag.add('minizhouxuan');
                                    }
                                },
                                marktext: '旋',
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                subSkill: {
                                    use: {
                                        trigger: { player: ['useCard', 'respond'] },
                                        filter(event, player) {
                                            if (player.getExpansions('minizhouxuan').length) return true;
                                            return event.name != 'respond' && event.cards?.length;
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            if (player.getExpansions('minizhouxuan').length) {
                                                player.logSkill('minizhouxuan');
                                                var bool = (!player.isMaxHandcard(true));
                                                player.draw(bool ? player.getExpansions('minizhouxuan').length : 1);
                                                player.loseToDiscardpile(player.getExpansions('minizhouxuan').randomGets(bool && player.getExpansions('minizhouxuan').length > 1 ? 2 : 1));
                                                event.finish();
                                            }
                                            else player.chooseBool(get.prompt('minizhouxuan'), '令' + get.translation(trigger.cards) + '结算完毕后置于武将牌上，称为“旋”').set('choice', (get.type(trigger.card) != 'equip' || (trigger.card.name == 'baiyin' && player.isDamaged())) && get.type(trigger.card) != 'delay');
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('minizhouxuan');
                                                player.addTempSkill('minizhouxuan_use2');
                                                player.markAuto('minizhouxuan_use2', [trigger.card]);
                                            }
                                        },
                                    },
                                    use2: {
                                        charlotte: true,
                                        onremove: true,
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            return event.cards.filterInD('oej').length && player.getStorage('minizhouxuan_use2').includes(event.card);
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.addToExpansion(trigger.cards.filterInD('oej'), 'gain2').gaintag.add('minizhouxuan');
                                        },
                                    },
                                },
                            },
                            //嫦娥
                            minidaoyao: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(card, player) {
                                    return player.countDiscardableCards(player, 'h');
                                },
                                filterCard: lib.filter.cardDiscardable,
                                check(card) {
                                    return 6 - get.value(card);
                                },
                                usable: 1,
                                content() {
                                    var card = get.cardPile2(card => card.name == 'tao');
                                    if (card) player.gain(card, 'gain2');
                                    player.draw(2 + (card ? 0 : 1));
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                            },
                            minibenyue: {
                                unique: true,
                                derivation: 'miniguanghan',
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    global: ['loseAsyncAfter'],
                                    player: ['recoverEnd', 'gainAfter'],
                                },
                                filter(event, player) {
                                    if (event.name == 'gain' || event.name == 'loseAsync') {
                                        if (!event.getg(player).some(card => card.name == 'tao')) return false;
                                        return player.countCards('h', { name: 'tao' }) >= 3;
                                    }
                                    else {
                                        var num = 0;
                                        game.getAllGlobalHistory('changeHp', evt => {
                                            if (evt.getParent().name == 'recover' && evt.player == player) num += evt.num;
                                        });
                                        return num >= 3;
                                    }
                                },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: 'silver',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minibenyue');
                                    'step 1'
                                    if (player.maxHp < 15) player.gainMaxHp(15 - player.maxHp);
                                    'step 2'
                                    player.addSkills('miniguanghan');
                                },
                            },
                            miniguanghan: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'damageEnd' },
                                filter(event, player) {
                                    if (!event.player.isIn()) return false;
                                    return lib.skill.miniguanghan.logTarget(event, player).length;
                                },
                                logTarget(event, player) {
                                    var target = event.player;
                                    return game.filterPlayer(current => {
                                        if (current != target.getPrevious() && current != target.getNext()) return false;
                                        return current != player;
                                    });
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    event.targets = lib.skill.miniguanghan.logTarget(trigger, player).sortBySeat();
                                    'step 1'
                                    var target = event.targets.shift();
                                    event.target = target;
                                    target.chooseToDiscard('h', '广寒：弃置一张手牌，或失去1点体力').set('ai', card => {
                                        var player = _status.event.player;
                                        if (card.name == 'tao' || card.name == 'jiu') return 0;
                                        if (player.hasSkill('zhaxiang') && player.hp > 1) return 0;
                                        return 6 - get.value(card);
                                    });
                                    'step 2'
                                    if (!result.bool) target.loseHp(trigger.num);
                                    if (event.targets.length) event.goto(1);
                                },
                                ai: { threaten: 5 },
                            },
                            //朱儁
                            minigongjian: {
                                audio: 'gongjian',
                                inherit: 'gongjian',
                                content() {
                                    'step 0'
                                    event.targets = trigger.parent.gongjian_targets.filter(function (target) {
                                        return trigger.targets.includes(target);
                                    });
                                    event.num = 0;
                                    'step 1'
                                    var target = targets[num];
                                    player.discardPlayerCard(target, true, 'he', [1, 2]).set('forceAuto', true);
                                    'step 2'
                                    event.num++;
                                    if (event.num < targets.length) event.goto(1);
                                    else {
                                        var cards = [];
                                        game.getGlobalHistory('cardMove', function (evt) {
                                            if (evt.player && evt.hs && evt.type == 'discard' && evt.getParent(3) == event) {
                                                for (var i of evt.hs) {
                                                    if (get.type(i, evt.player) == 'basic' && get.position(i, true) == 'd') cards.add(i);
                                                }
                                            }
                                        });
                                        if (cards.length) player.gain(cards, 'gain2');
                                    }
                                },
                            },
                            minizjjuxiang: {
                                inherit: 'jsrgjuxiang',
                                checkx(event, player) {
                                    var target = _status.currentPhase;
                                    if (!target || get.attitude(player, target) <= 0) return false;
                                    var evt = event.getParent('phaseDiscard'), evt2 = event.getParent('phaseJieshu');
                                    if (evt?.name == 'phaseDiscard' || evt2 && evt.name == 'phaseJieshu') return false;
                                    if (target.getCardUsable({ name: 'sha' }) >= target.countCards('hs', 'sha')) return false;
                                    if (!target.hasValueTarget({ name: 'sha' })) return false;
                                    return true;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var target = _status.currentPhase;
                                    var cards = trigger.getg(player).filter(i => player.getCards('h').includes(i)).slice();
                                    var str = '弃置任意张此次获得的牌';
                                    if (target?.isIn()) {
                                        event.target = target;
                                        str += '，令' + get.translation(target) + '本回合使用【杀】的次数+X（X为你以此法弃置的花色数）';
                                    }
                                    player.chooseToDiscard(get.prompt('minizjjuxiang'), str, (card, player) => _status.event.cards.includes(card), [1, cards.length]).set('ai', card => {
                                        if (!_status.event.goon) return 0;
                                        var player = _status.event.player, target = _status.currentPhase;
                                        if (ui.selected.cards.some(cardx => get.suit(cardx, player) == get.suit(card, player))) return 0;
                                        var num = target.countCards('hs', card => card.name == 'sha') - target.getCardUsable({ name: 'sha' });
                                        if (ui.selected.cards.length < num) return 7 - get.value(card);
                                        return 0;
                                    }).set('cards', cards).set('complexCard', true).set('goon', lib.skill.minizjjuxiang.checkx(trigger, player)).logSkill = 'minizjjuxiang';
                                    'step 1'
                                    if (result.bool) {
                                        if (target?.isIn()) {
                                            var num = result.cards.reduce((list, card) => list.add(get.suit(card, player)), []).length;
                                            target.addTempSkill('jsrgjuxiang_sha');
                                            target.addMark('jsrgjuxiang_sha', num, false);
                                            var evt = trigger.getParent('phaseUse');
                                            if (evt?.name == 'phaseUse' && !evt.skill) {
                                                evt.player.addTempSkill('jsrgjuxiang_buff', 'phaseUseAfter');
                                                evt.player.addMark('jsrgjuxiang_buff', num, false);
                                            }
                                        }
                                    }
                                },
                            },
                            //吕布
                            miniwushuang: {
                                mod: {
                                    selectTarget(card, player, range) {
                                        if (card.name == 'sha' && range[1] != -1) range[1]++;
                                    },
                                },
                                audio: 'wushuang',
                                audioname: ['Mnian_lvbu', 're_lvbu', 'lvlingqi'],
                                audioname2: { Mmiao_lvlingqi: 'miniwushuang_Mmiao_lvlingqi' },
                                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                                filter(event, player) {
                                    return (event.card.name == 'sha' && event.player == player) || event.card.name == 'juedou';
                                },
                                logTarget(event, player) {
                                    return player == event.player ? event.target : event.player;
                                },
                                forced: true,
                                content() {
                                    const target = lib.skill.miniwushuang.logTarget(trigger, player);
                                    if (trigger.card.name == 'sha') {
                                        const id = target.playerid;
                                        const map = trigger.getParent().customArgs;
                                        if (!map[id]) map[id] = {};
                                        if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                                        else map[id].shanRequired = 2;
                                    }
                                    else {
                                        const id = target.playerid;
                                        const idt = trigger.target.playerid;
                                        const map = trigger.getParent().customArgs;
                                        if (!map[idt]) map[idt] = {};
                                        if (!map[idt].shaReq) map[idt].shaReq = {};
                                        if (!map[idt].shaReq[id]) map[idt].shaReq[id] = 1;
                                        map[idt].shaReq[id]++;
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        //if(player.hasSkill('miniwuchang')&&arg.target.group==player.group) return false;
                                        if (!arg || !arg.card || !arg.target) return false;
                                        if (arg.card.name == 'sha' && arg.target.countCards('hs', { name: 'shan' }) > 1) return false;
                                        if (arg.card.name == 'juedou' && Math.floor(arg.target.countCards('hs', { name: 'sha' }) / 2) > player.countCards('hs', { name: 'sha' })) return false;
                                    },
                                },
                                subSkill: { Mmiao_lvlingqi: { audio: 'ext:活动武将/audio/skill:2' } },
                            },
                            miniwuchang: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { source: 'damageBegin1' },
                                filter(event, player) {
                                    if (event.player.group != player.group) return false;
                                    if (event.getParent().type != 'card' || !['sha', 'juedou'].includes(event.card.name)) return false;
                                    var history = event.player.getHistory('useCard').concat(event.player.getHistory('respond'));
                                    return !history.some(evt => evt.respondTo && evt.respondTo[1] == event.card);
                                },
                                logTarget: 'player',
                                prompt2: (event, player) => '令即将对' + get.translation(event.player) + '造成的伤害+1，然后你变更至其他势力',
                                check: (event, player) => get.attitude(player, event.player) < 0 && get.damageEffect(event.player, player, player) > 0 && !event.player.hasSkillTag('filterDamage', true, { player: player, card: event.card }),
                                content() {
                                    trigger.num++;
                                    player.addTempSkill('miniwuchang_change');
                                    trigger['miniwuchang_' + player.playerid] = trigger.player.group;
                                },
                                group: 'miniwuchang_draw',
                                subSkill: {
                                    change: {
                                        charlotte: true,
                                        trigger: { global: ['damageAfter', 'damageZero', 'damageCancelled'] },
                                        filter(event, player) {
                                            return event['miniwuchang_' + player.playerid];
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            'step 0'
                                            var list = lib.group.slice();
                                            list.removeArray([/*'shen',*/trigger['miniwuchang_' + player.playerid]]);
                                            player.chooseControl(list).set('prompt', '无常：请选择你要变更的势力').set('ai', () => {
                                                var player = _status.event.player;
                                                var aim = _status.event.getTrigger().player;
                                                var list = _status.event.list;
                                                var list2 = list.filter(group => game.hasPlayer(target => target != aim && target.group == group && get.attitude(player, target) < 0));
                                                if (list2.length) {
                                                    list2.sort((a, b) => game.countPlayer(target => target != aim && target.group == b && get.attitude(player, target) < 0) - game.countPlayer(target => target != aim && target.group == a && get.attitude(player, target) < 0));
                                                    return list2[0];
                                                }
                                                return list.randomGet();
                                            }).set('list', list);
                                            'step 1'
                                            if (result.control) {
                                                var group = result.control;
                                                player.popup(group + '2', get.groupnature(group, 'raw'));
                                                player.changeGroup(group);
                                            }
                                        },
                                    },
                                    draw: {
                                        audio: 'miniwuchang',
                                        enable: 'phaseUse',
                                        filterTarget: lib.filter.notMe,
                                        prompt: '令一名其他角色摸一张牌，然后你将势力变更至与其相同并从牌堆中获得一张【杀】',
                                        usable: 1,
                                        content() {
                                            'step 0'
                                            target.draw();
                                            if (target.group != player.group) player.changeGroup(target.group);
                                            'step 1'
                                            var card = get.cardPile2(card => card.name == 'sha');
                                            if (card) player.gain(card, 'gain2');
                                        },
                                        ai: {
                                            order(item, player) {
                                                var bool = player.countCards('hs', card => get.name(card) == 'juedou' && player.hasValueTarget(card));
                                                return get.order({ name: bool ? 'juedou' : 'sha' }, player) + 0.3;
                                            },
                                            result: {
                                                target(player, target) {
                                                    var cards = player.getCards('hs', card => ['sha', 'juedou'].includes(get.name(card)) && player.hasValueTarget(card));
                                                    var att = get.sgn(get.attitude(player, target));
                                                    if (!cards.length) return 1;
                                                    var list = [];
                                                    cards.forEach(card => {
                                                        if (card.name != 'sha' || player.getCardUsable('sha') > 0) {
                                                            var targets = game.filterPlayer(current => player.canUse(card, current) && get.effect(current, card, player, player) > 0 && get.attitude(player, current) < 0);
                                                            if (targets.length) {
                                                                targets.sort((a, b) => get.effect(b, card, player, player) - get.effect(a, card, player, player));
                                                                list.push([targets[0], get.effect(targets[0], card, player, player)]);
                                                            }
                                                        }
                                                    });
                                                    if (!list.length) return 3 * (get.sgn(att + 0.5) + (att > 0 ? 1 : 0));
                                                    list.sort((a, b) => b[1] - a[1]);
                                                    if (list[0][0].group != target.group) return get.sgn(att - 0.5) + (att >= 0 ? 1.5 : 0);
                                                    return 3 * (get.sgn(att + 0.5) + (att > 0 ? 1 : 0)) + (list[0][0] == target ? 1 : 0);
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //孔融
                            minilirang: {
                                audio: 'splirang',
                                trigger: { global: 'phaseBefore', player: ['enterGame', 'phaseZhunbeiBegin'] },
                                filter(event, player) {
                                    if (player.storage.minilirang?.isIn()) return false;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minilirang'), '选择一名其他角色，其摸牌阶段额外摸一张牌，你获得其弃牌阶段弃置的牌', lib.filter.notMe).set('ai', target => get.attitude(_status.event.player, target));
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minilirang', target);
                                        player.storage.minilirang = target;
                                        player.markSkill('minilirang');
                                        player.when({ global: 'die' }).filter((event, player) => event.player == player.storage.minilirang).then(() => {
                                            player.unmarkSkill('minilirang');
                                            delete player.storage.minilirang;
                                        });
                                        player.addExpose(0.3);
                                    }
                                },
                                group: ['minilirang_yingzi', 'minilirang_guzheng'],
                                intro: { content: '已指定$为“礼让”角色' },
                                subSkill: {
                                    yingzi: {
                                        audio: 'splirang',
                                        trigger: { global: 'phaseDrawBegin2' },
                                        filter(event, player) {
                                            var target = player.storage.minilirang;
                                            return target && target == event.player && !event.numFixed;
                                        },
                                        forced: true,
                                        locked: false,
                                        logTarget: 'player',
                                        content() {
                                            trigger.num++;
                                        },
                                    },
                                    guzheng: {
                                        audio: 'splirang',
                                        trigger: { global: 'phaseDiscardEnd' },
                                        filter(event, player) {
                                            var target = player.storage.minilirang;
                                            return target && target == event.player && lib.skill.twlijian.getCards(event).length;
                                        },
                                        forced: true,
                                        locked: false,
                                        logTarget: 'player',
                                        content() {
                                            player.gain(lib.skill.twlijian.getCards(trigger), 'gain2');
                                        },
                                    },
                                },
                            },
                            minizhengyi: {
                                audio: 'spmingshi',
                                trigger: { global: 'damageBegin4' },
                                filter(event, player) {
                                    var target = player.storage.minilirang;
                                    if (!target || !target.isIn()) return false;
                                    var list = event.minizhengyi || [];
                                    var list2 = [player, target];
                                    return list2.includes(event.player) && list2.some(current => event.player != current && !list.includes(current));
                                },
                                direct: true,
                                *content(event, map) {
                                    var player = map.player, trigger = map.trigger;
                                    var target = player.storage.minilirang;
                                    var current = trigger.player == player ? target : player;
                                    var result = yield current.chooseBool('争义：是否代替' + get.translation(trigger.player) + '承受本次伤害并摸一张牌？').set('choice', lib.skill.twgonghuan.check(trigger, current));
                                    if (result.bool) {
                                        current.logSkill('minizhengyi', trigger.player);
                                        game.log(current, '为', trigger.player, '承受了此次伤害');
                                        var list = trigger.minizhengyi ? trigger.minizhengyi.slice() : [];
                                        list.addArray([player, target]);
                                        trigger.cancel();
                                        current.draw();
                                        current.damage(trigger.source ? trigger.source : 'nosource', trigger.nature, trigger.num).set('card', trigger.card).set('cards', trigger.cards).minizhengyi = list;
                                    }
                                },
                            },
                            minixiaowu: {
                                audio: 'xiaowu',
                                inherit: 'xiaowu',
                                contentAfter() {
                                    var targetsx = event.getParent()._xiaowu_targets;
                                    var num1 = targets.length - targetsx.length;
                                    var num2 = num1 - targetsx.length;
                                    if (num1 > 0) player.addMark('shawu', Math.ceil(num1 / 2));
                                    if (num2 < 0) {
                                        player.line(targetsx, 'fire');
                                        for (var i of targetsx) i.damage();
                                    }
                                },
                            },
                            minihuaping: {
                                audio: 'huaping',
                                inherit: 'huaping',
                                content() {
                                    player.awakenSkill('minihuaping');
                                    var skills = trigger.player.getSkills(null, false, false).filter(function (i) {
                                        var info = get.info(i);
                                        return info && !info.charlotte;
                                    });
                                    player.changeSkills(skills, ['minixiaowu']);
                                    var num = player.countMark('shawu');
                                    if (num > 0) {
                                        player.removeMark('shawu', num);
                                        player.draw(num);
                                    }
                                },
                            },
                            //谋袁绍
                            minisbluanji: {
                                audio: 'sbluanji',
                                inherit: 'sbluanji',
                                filter(event, player) {
                                    if (event.name == 'chooseToUse') return player.countCards('hs', card => get.info('minisbluanji').filterCard(card, player)) > 1;
                                    const evt = event.getParent(2), history = player.getHistory('gain', evtx => evtx.getParent(2).name == 'minisbluanji');
                                    return evt.name == 'wanjian' && evt.getParent().player == player && event.player != player && history.reduce((list, evt) => {
                                        list.addArray(evt.cards); return list;
                                    }, []).length < 3;
                                },
                                filterCard(card, player) {
                                    return !player.getStorage('minisbluanji_used').includes(get.color(card));
                                },
                                check(card) {
                                    const player = get.event('player'), eff = get.info('sbluanji').check(card);
                                    if (ui.selected.cards.length && get.color(card) == get.color(ui.selected.cards[0])) return 2.5 * eff;
                                    return eff;
                                },
                                complexCard: true,
                                precontent() {
                                    player.addTempSkill('minisbluanji_used');
                                    player.markAuto('minisbluanji_used', event.result.cards.map(i => get.color(i, player)));
                                },
                                group: 'minisbluanji_discard',
                                subSkill: {
                                    used: { charlotte: true, onremove: true },
                                    discard: {
                                        audio: 'sbluanji',
                                        trigger: { source: 'damageSource' },
                                        filter(event, player) {
                                            return event.card && event.card.name == 'wanjian' && event.player.isIn() && event.player.countCards('he');
                                        },
                                        usable: 3,
                                        prompt2: (event, player) => '弃置' + get.translation(event.player) + '的一张牌',
                                        check: (event, player) => get.effect(event.player, { name: 'guohe_copy2' }, player, player) > 0,
                                        logTarget: 'player',
                                        content() {
                                            player.discardPlayerCard('he', trigger.player, true);
                                        },
                                    },
                                },
                            },
                            minisbxueyi: {
                                audio: 'sbxueyi',
                                inherit: 'sbxueyi',
                                filter(event, player) {
                                    return event.target.group == 'qun';
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + 2 * game.countPlayer(current => current.group == 'qun');
                                    },
                                },
                            },
                            //马腾
                            minixiongzheng: {
                                onremove: true,
                                audio: 'twxiongzheng',
                                trigger: { global: 'roundStart' },
                                direct: true,
                                content() {
                                    'step 0'
                                    var target = player.storage.minixiongzheng_target;
                                    delete player.storage.minixiongzheng_target;
                                    if (!target) { event.goto(4); return; }
                                    event.target = target;
                                    var list = target.getRoundHistory('damage', evt => evt.source, 1).reduce((list, evt) => list.add(evt.source), []).filter(i => i.isIn());
                                    var list2 = game.filterPlayer(i => i != player).removeArray(list);
                                    event.list = list; event.list2 = list2;
                                    var choiceList = [
                                        '视为对任意名上一轮未对' + get.translation(target) + '造成过伤害的角色使用一张【杀】',
                                        '令任意名上一轮对' + get.translation(target) + '造成过伤害的角色摸两张牌'
                                    ];
                                    var choices = [];
                                    if (list2.length) {
                                        choices.push('选项一');
                                        choiceList[0] += '（' + get.translation(list2) + '）';
                                    }
                                    else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                                    if (list.length) {
                                        choices.push('选项二');
                                        choiceList[1] += '（' + get.translation(list) + '）';
                                    }
                                    else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                                    choices.push('cancel2');
                                    player.chooseControl(choices).set('prompt', '雄争：是否选择一项？').set('choiceList', choiceList).set('ai', function () {
                                        var player = _status.event.player;
                                        var list = _status.event.getParent().list, list2 = _status.event.getParent().list2;
                                        var eff = list.map(target => {
                                            if (target == player) return 0;
                                            return get.effect(target, { name: 'sha' }, player, player);
                                        }).reduce((p, c) => p + c, 0), eff2 = list2.map(target => get.effect(target, { name: 'wuzhong' }, player, player)).reduce((p, c) => p + c, 0);
                                        if (_status.event.controls.includes('选项二') && eff2 > eff) return '选项二';
                                        if (eff > 0) return 0;
                                        return 'cancel2';
                                    });
                                    'step 1'
                                    if (result.control == '选项一') {
                                        event.bool = true;
                                        if (event.list2.length) player.chooseTarget('雄争：请选择任意名满足条件的角色，你视为依次对这些角色使用一张杀', [1, Infinity], true, function (card, player, target) {
                                            return player.canUse('sha', target, false, false) && _status.event.getParent().list2.includes(target);
                                        }).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.effect(target, { name: 'sha' }, player, player);
                                        });
                                        else event.finish();
                                    }
                                    else if (result.control == '选项二') {
                                        event.bool = false;
                                        if (event.list.length) player.chooseTarget('雄争：请选择任意名满足条件的角色，这些角色摸两张牌', [1, Infinity], true, function (card, player, target) {
                                            return _status.event.getParent().list.includes(target);
                                        }).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.effect(target, { name: 'wuzhong' }, player, player);
                                        });
                                        else event.finish();
                                    }
                                    else event.goto(3);
                                    'step 2'
                                    result.targets.sortBySeat();
                                    player.logSkill('minixiongzheng_effect', result.targets);
                                    if (event.bool) {
                                        for (var i of result.targets) player.useCard({ name: 'sha', isCard: true }, i, false);
                                    }
                                    else game.asyncDraw(result.targets, 2);
                                    'step 3'
                                    if (!game.hasPlayer(function (current) {
                                        return !lib.skill.minixiongzheng.getTarget(player, current);
                                    })) event.finish();
                                    else game.delayx();
                                    'step 4'
                                    player.chooseTarget(get.prompt('minixiongzheng'), '选择一名上一轮未选择过的角色，称为“雄争”角色', function (card, player, target) {
                                        return !lib.skill.minixiongzheng.getTarget(player, target);
                                    }).set('ai', target => -get.attitude(_status.event.player, target));
                                    'step 5'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minixiongzheng', target);
                                        player.storage.minixiongzheng_target = target;
                                        player.addTempSkill('minixiongzheng_mark', 'roundStart');
                                        target.addTempSkill('minixiongzheng_threaten', 'roundStart');
                                        game.delayx();
                                    }
                                },
                                getTarget(player, target) {
                                    return player.getRoundHistory('useSkill', evt => {
                                        return evt.skill == 'minixiongzheng' && (evt.targets || [evt.target]).includes(target);
                                    }, 1).length;
                                },
                                subSkill: {
                                    effect: { audio: 'twxiongzheng' },
                                    mark: {
                                        intro: {
                                            content: '$参与了〖雄争〗的争斗',
                                            onunmark: true,
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        trigger: { global: 'damage' },
                                        filter(event, player) {
                                            return event.player == player.storage.minixiongzheng_target && get.itemtype(event.source) == 'player';
                                        },
                                        direct: true,
                                        firstDo: true,
                                        content() {
                                            player.markAuto('minixiongzheng_mark', [trigger.source]);
                                        },
                                    },
                                    threaten: {
                                        mark: true,
                                        intro: { content: '本轮〖雄争〗目标' },
                                        ai: { threaten: 10 },
                                    },
                                },
                            },
                            miniluannian: {
                                audio: 'twluannian',
                                global: 'miniluannian_global',
                                unique: true,
                                zhuSkill: true,
                                subSkill: {
                                    global: {
                                        audio: 'twluannian',
                                        enable: 'phaseUse',
                                        usable: 1,
                                        forceaudio: true,
                                        onChooseToUse(event) {
                                            if (!game.online) {
                                                var num = 1;
                                                game.countPlayer2(current => {
                                                    num += current.getRoundHistory('useSkill', evt => evt.skill == 'miniluannian_global').length;
                                                });
                                                event.set('miniluannian_num', num);
                                            }
                                        },
                                        filter(event, player) {
                                            if (!event.miniluannian_num) return false;
                                            return player.group == 'qun' && player.countCards('he') >= event.miniluannian_num && game.hasPlayer(function (current) {
                                                return current.storage.minixiongzheng_target?.isIn() && current != player && current.hasZhuSkill('miniluannian', player)
                                            });
                                        },
                                        filterCard: true,
                                        position: 'he',
                                        prompt() {
                                            var player = _status.event.player;
                                            var num = _status.event.miniluannian_num
                                            var list = game.filterPlayer(function (current) {
                                                return current.hasZhuSkill('miniluannian', player);
                                            }).map(i => i.storage.minixiongzheng_target).sortBySeat();
                                            return '弃置' + get.cnNumber(num) + '张牌，对' + get.translation(list) + (list.length > 1 ? '中的一人' : '') + '造成1点伤害';
                                        },
                                        selectCard() {
                                            return _status.event.miniluannian_num;
                                        },
                                        complexSelect: true,
                                        complexCard: true,
                                        filterTarget(card, player, target) {
                                            return game.filterPlayer(function (current) {
                                                return current.hasZhuSkill('miniluannian', player);
                                            }).map(i => i.storage.minixiongzheng_target).includes(target);
                                        },
                                        selectTarget() {
                                            return game.filterPlayer(function (current) {
                                                return current.hasZhuSkill('miniluannian', _status.event.player);
                                            }).map(i => i.storage.minixiongzheng_target).filter(i => i && i.isIn()).length > 1 ? 1 : -1;
                                        },
                                        check(card) {
                                            return 6 - get.value(card);
                                        },
                                        content() {
                                            target.damage();
                                        },
                                        ai: {
                                            order: 7,
                                            result: {
                                                target(player, target) {
                                                    return get.damageEffect(target, player, target);
                                                }
                                            },
                                            expose: 0.25,
                                        },
                                    },
                                },
                            },
                            minizecai: {
                                audio: 'dczecai',
                                inherit: 'dczecai',
                                derivation: 'minirejizhi',
                                async content(event, trigger, player) {
                                    const targetx = lib.skill.dczecai.getMax();
                                    let str = '令一名角色于本轮内获得〖集智〗';
                                    if (targetx) str += ('；若选择的目标为' + get.translation(targetx) + '，则其获得一个额外的回合');
                                    const { result: { bool, targets } } = await player.chooseTarget(get.prompt('minizecai'), str).set('ai', target => {
                                        const player = get.event('player');
                                        if (target != get.event('targetx')) return 0;
                                        return get.attitude(player, target);
                                    }).set('targetx', targetx);
                                    if (bool) {
                                        const target = targets[0];
                                        player.logSkill('minizecai', target);
                                        player.awakenSkill('minizecai');
                                        target.addAdditionalSkills('minizecai_effect', 'minirejizhi');
                                        target.addTempSkill('minizecai_effect', 'roundStart');
                                        if (target == targetx) {
                                            const evt = trigger;
                                            target.insertPhase();
                                            if (evt.player != target && !evt._finished) {
                                                evt.finish();
                                                evt._triggered = 5;
                                                const evtx = evt.player.insertPhase();
                                                delete evtx.skill;
                                            }
                                        }
                                    }
                                },
                            },
                            minijianjie: {
                                audio: 'xinfu_jianjie',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.phaseNumber <= 1;
                                },
                                forced: true,
                                locked: false,
                                async content(event, trigger, player) {
                                    const { result: { bool, targets } } = await player.chooseTarget('荐杰：选择一名角色获得“龙印”', true).set('ai', target => get.attitude(get.event('player'), target));
                                    if (bool) {
                                        const target = targets[0];
                                        player.line(target, 'fire');
                                        lib.skill.minijianjie.addMark('huoji', player, target);
                                        await game.asyncDelayx();
                                        if (game.hasPlayer(current => current != target)) {
                                            const { result: { bool, targets } } = await player.chooseTarget('荐杰：选择一名角色获得“凤印”', (card, player, target) => {
                                                return target != get.event('target');
                                            }, true).set('ai', target => get.attitude(get.event('player'), target)).set('target', target);
                                            if (bool) {
                                                const targetx = targets[0];
                                                player.line(targetx, 'thunder');
                                                lib.skill.minijianjie.addMark('lianhuan', player, targetx);
                                                await game.asyncDelayx();
                                            }
                                        }
                                    }
                                },
                                group: ['minijianjie_use', 'minijianjie_die'],
                                derivation: ['minijianjie_huoji', 'minijianjie_lianhuan', 'minijianjie_yeyan'],
                                hasMark(mark, player, target) {
                                    if (!target) return player.getStorage('minijianjie_' + mark).length > 0;
                                    return target.getStorage('minijianjie_' + mark).includes(player);
                                },
                                addMark(mark, player, target) {
                                    const storage = target.storage.minijianjie_yeyan;
                                    mark = 'minijianjie_' + mark;
                                    target.addAdditionalSkill(`${mark}_${player.playerid}`, mark);
                                    target.markAuto(mark, [player]);
                                    target.storage.minijianjie_yeyan = storage;
                                    game.log(player, '令', target, '获得了', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                                },
                                removeMark(mark, player, target, log) {
                                    if (lib.skill.minijianjie.hasMark(mark, player, target, log)) {
                                        mark = 'minijianjie_' + mark;
                                        target.removeAdditionalSkill(`${mark}_${player.playerid}`);
                                        target.unmarkAuto(mark, [player]);
                                        if (log) game.log(target, '移去了', player, '给予的', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                                        else game.log(player, '移去了', target, '的', `#g“${mark == 'minijianjie_huoji' ? '龙印' : '凤印'}”`);
                                    }
                                },
                                getBigFire(player) {
                                    if (player.getDiscardableCards(player, 'h').reduce((list, card) => list.add(get.suit(card, player)), []).length < 4) return false;
                                    const targets = game.filterPlayer(target => get.damageEffect(target, player, player, 'fire') && target.hp <= 3 && !target.hasSkillTag('filterDamage', null, { player: player }));
                                    if (!targets.length) return false;
                                    if (targets.length == 1 || targets.some(target => get.attitude(player, target) < 0 && target.identity && target.identity.indexOf('zhu') != -1)) {
                                        let suits = player.getDiscardableCards(player, 'h').reduce((map, card) => {
                                            const suit = get.suit(card, player);
                                            if (!map[suit]) map[suit] = [];
                                            return map;
                                        }, {}), cards = [];
                                        Object.keys(suits).forEach(i => {
                                            suits[i].addArray(player.getDiscardableCards(player, 'h').filter(card => get.suit(card) == i));
                                            cards.add(suits[i].sort((a, b) => get.value(a) - get.value(b))[0]);
                                        });
                                        return true;
                                    }
                                    return false;
                                },
                                subSkill: {
                                    use: {
                                        audio: 'xinfu_jianjie',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            if (player.phaseNumber <= 1) return false;
                                            const skill = lib.skill.minijianjie;
                                            return game.hasPlayer(current => skill.hasMark('huoji', player, current) || skill.hasMark('lianhuan', player, current));
                                        },
                                        filterTarget(card, player, target) {
                                            if (ui.selected.targets.length) return true;
                                            const skill = lib.skill.minijianjie;
                                            return skill.hasMark('huoji', player, target) || skill.hasMark('lianhuan', player, target);
                                        },
                                        selectTarget: 2,
                                        complexSelect: true,
                                        complexTarget: true,
                                        multitarget: true,
                                        prompt: '出牌阶段限一次，你可以移动场上的“龙印”或“凤印”',
                                        targetprompt: ['失去印', '获得印'],
                                        usable: 1,
                                        async content(event, trigger, player) {
                                            const targets = event.targets;
                                            const skill = lib.skill.minijianjie, bool1 = skill.hasMark('huoji', player, targets[0]), bool2 = skill.hasMark('lianhuan', player, targets[0]);
                                            let mark;
                                            if (bool1 && bool2) {
                                                const { result: { control } } = await player.chooseControl('龙印', '凤印').set('prompt', '选择要移动的“印”');
                                                if (control) mark = control;
                                            }
                                            else mark = (bool1 ? '龙印' : '凤印');
                                            if (mark) {
                                                mark = (mark == '龙印' ? 'huoji' : 'lianhuan');
                                                skill.removeMark(mark, player, targets[0]);
                                                skill.addMark(mark, player, targets[1]);
                                                await game.asyncDelayx();
                                            }
                                        },
                                        ai: {
                                            order: 8,
                                            expose: 0.25,
                                            result: {
                                                target(player, target) {
                                                    if (!ui.selected.targets.length) return get.attitude(player, target) < 0 ? -999 : -3;
                                                    return target.countCards('h') + 1;
                                                },
                                            },
                                        },
                                    },
                                    die: {
                                        audio: 'xinfu_jianjie',
                                        trigger: { global: 'die' },
                                        filter(event, player) {
                                            const skill = lib.skill.minijianjie;
                                            return skill.hasMark('huoji', player, event.player) || skill.hasMark('lianhuan', player, event.player);
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        async content(event, trigger, player) {
                                            if (lib.skill.minijianjie.hasMark('huoji', player, trigger.player)) {
                                                const { result: { bool, targets } } = await player.chooseTarget('荐杰：选择一名角色获得“龙印”', true).set('ai', target => get.attitude(get.event('player'), target));
                                                if (bool) {
                                                    const target = targets[0];
                                                    player.line(target, 'fire');
                                                    lib.skill.minijianjie.addMark('huoji', player, target);
                                                    await game.asyncDelayx();
                                                }
                                            }
                                            if (lib.skill.minijianjie.hasMark('lianhuan', player, trigger.player)) {
                                                const { result: { bool, targets } } = await player.chooseTarget('荐杰：选择一名角色获得“凤印”', true).set('ai', target => get.attitude(get.event('player'), target));
                                                if (bool) {
                                                    const target = targets[0];
                                                    player.line(target, 'thunder');
                                                    lib.skill.minijianjie.addMark('lianhuan', player, target);
                                                    await game.asyncDelayx();
                                                }
                                            }
                                        },
                                    },
                                    huoji: {
                                        marktext: '龙',
                                        intro: {
                                            name: '龙印',
                                            content: '<li>①出牌阶段限三次，你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。<br><li>若你同时拥有“凤印”，则你视为拥有技能〖业炎〗。',
                                        },
                                        inherit: 'rehuoji',
                                        audio: false,
                                        viewAsFilter(player) {
                                            const storage = player.getStorage('minijianjie_huoji');
                                            if (!storage.some(source => source.isIn() && source.hasSkill('minijianjie'))) return false;
                                            return player.hasCard(card => get.color(card) == 'red', 'she');
                                        },
                                        usable: 3,
                                        group: ['minijianjie_yeyan', 'minijianjie_viewAs'],
                                    },
                                    viewAs: {
                                        charlotte: true,
                                        inherit: 'minihuoji',
                                        audio: false,
                                        filter(event, player) {
                                            const storage = player.getStorage('minijianjie_huoji');
                                            if (!storage.some(source => source.isIn() && source.hasSkill('minijianjie'))) return false;
                                            return lib.skill.minihuoji.filter(event, player);
                                        },
                                        group: 'minijianjie_yeyan',
                                    },
                                    lianhuan: {
                                        marktext: '凤',
                                        intro: {
                                            name: '凤印',
                                            content: '<li>出牌阶段限三次。你可以将一张♣牌当作【铁索连环】使用或重铸。<br><li>若你同时拥有“龙印”，则你视为拥有技能〖业炎〗。',
                                        },
                                        inherit: 'lianhuan',
                                        charlotte: true,
                                        audio: false,
                                        filter(event, player) {
                                            const storage = player.getStorage('minijianjie_lianhuan');
                                            if (!storage.some(source => {
                                                return source.isIn() && source.hasSkill('minijianjie');
                                            })) return false;
                                            if (!player.hasCard(card => get.suit(card) == 'club', 'she')) return false;
                                            return event.type == 'phase' || event.filterCard(get.autoViewAs({ name: 'tiesuo' }, 'unsure'), player, event);
                                        },
                                        usable: 3,
                                        group: 'minijianjie_yeyan',
                                    },
                                    yeyan: {
                                        inherit: 'yeyan',
                                        audio: false,
                                        filter(event, player) {
                                            if (player.storage.minijianjie_yeyan) return false;
                                            const huoji = player.getStorage('minijianjie_huoji'), lianhuan = player.getStorage('minijianjie_lianhuan');
                                            return huoji.length > 0 && lianhuan.some(source => huoji.includes(source) && source.isIn() && source.hasSkill('minijianjie'));
                                        },
                                        check(card) {
                                            if (!lib.skill.minijianjie.getBigFire(get.event('player'))) return -1;
                                            return 1 / (get.value(card) || 0.5);
                                        },
                                        contentBefore() {
                                            player.awakenSkill('minijianjie_yeyan');
                                            player.addTempSkill('minijianjie_effect', 'minijianjie_yeyanAfter');
                                        },
                                        ai: {
                                            order: 1,
                                            fireAttack: true,
                                            result: {
                                                target(player, target) {
                                                    if (player.hasUnknown()) return 0;
                                                    const att = get.sgn(get.attitude(player, target));
                                                    const targets = game.filterPlayer(target => get.damageEffect(target, player, player, 'fire') && (!lib.skill.minijianjie.getBigFire(player) || (target.hp <= 3 && !target.hasSkillTag('filterDamage', null, { player: player }))));
                                                    if (!targets.includes(target)) return 0;
                                                    if (lib.skill.minijianjie.getBigFire(player)) {
                                                        if (ui.selected.targets.length) return 0;
                                                        if (!(targets.length == 1 || (att < 0 && target.identity && target.identity.indexOf('zhu') != -1))) return 0;
                                                    }
                                                    return att * get.damageEffect(target, player, player, 'fire');
                                                },
                                            },
                                        },
                                    },
                                    effect: {
                                        charlotte: true,
                                        trigger: { player: 'loseHpBefore' },
                                        filter(event, player) {
                                            return event.getParent().name == 'minijianjie_yeyan';
                                        },
                                        firstDo: true,
                                        forced: true,
                                        popup: false,
                                        content() {
                                            trigger.cancel();
                                            const skill = lib.skill.minijianjie, huoji = player.getStorage('minijianjie_huoji').slice(), lianhuan = player.getStorage('minijianjie_lianhuan').slice();
                                            huoji.forEach(source => skill.removeMark('huoji', source, player, true));
                                            lianhuan.forEach(source => skill.removeMark('lianhuan', source, player, true));
                                        },
                                    },
                                },
                            },
                            miniyinshi: {
                                audio: 'xinfu_yinshi',
                                trigger: { player: 'damageBegin4' },
                                filter(event, player) {
                                    const skill = lib.skill.minijianjie;
                                    if (skill.hasMark('huoji', player) && skill.hasMark('lianhuan', player)) return false;
                                    if (!player.hasEmptySlot(2)) return false;
                                    return event.hasNature() || get.type(event.card, 'trick') == 'trick';
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    trigger.cancel();
                                },
                                ai: {
                                    notrick: true,
                                    nofire: true,
                                    nothunder: true,
                                    effect: {
                                        target(card, player, target, current) {
                                            const skill = lib.skill.minijianjie;
                                            if (skill.hasMark('huoji', target) && skill.hasMark('lianhuan', target)) return false;
                                            if (player == target && get.subtype(card) == 'equip2') {
                                                if (get.equipValue(card) <= 8) return 0;
                                            }
                                            if (!target.hasEmptySlot(2)) return;
                                            if (get.tag(card, 'natureDamage')) return 'zerotarget';
                                            if (get.type(card) == 'trick' && get.tag(card, 'damage')) {
                                                return 'zeroplayertarget';
                                            }
                                        },
                                    },
                                },
                            },
                            //邹氏
                            minihuoshui: {
                                audio: 'huoshui',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(target => {
                                        if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                                        return (!player.hasSkill('minihuoshui_0') && !target.hasSkill('fengyin')) || (!player.hasSkill('minihuoshui_1') && target.countCards('h')) || (!player.hasSkill('minihuoshui_2') && target.countDiscardableCards(player, 'e'));
                                    });
                                },
                                usable: 3,
                                chooseButton: {
                                    dialog(event, player) {
                                        var dialog = ui.create.dialog('祸水：选择一名一名其他角色…', 'hidden');
                                        dialog.add([[
                                            ['0', '令其本回合非锁定技失效'],
                                            ['1', '观看其手牌并获得其中一张牌'],
                                            ['2', '弃置其装备区所有牌'],
                                        ], 'textbutton']);
                                        return dialog;
                                    },
                                    filter(button, player) {
                                        if (player.hasSkill('minihuoshui_' + button.link, null, null, false)) return false;
                                        return game.hasPlayer(target => {
                                            if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                                            return (button.link == '0' && !target.hasSkill('fengyin')) || (button.link == '1' && target.countCards('h')) || (button.link == '2' && target.countDiscardableCards(player, 'e'));
                                        });
                                    },
                                    check: () => 1 + Math.random(),
                                    backup(links, player) {
                                        return {
                                            audio: 'huoshui',
                                            num: links[0],
                                            filterTarget(card, player, target) {
                                                if (target == player || player.getStorage('minihuoshui_used').includes(target)) return false;
                                                const num = lib.skill.minihuoshui_backup.num;
                                                return (num == '0' && !target.hasSkill('fengyin')) || (num == '1' && target.countCards('h')) || (num == '2' && target.countDiscardableCards(player, 'e'));
                                            },
                                            async content(event, trigger, player) {
                                                const target = event.target, num = lib.skill.minihuoshui_backup.num;
                                                if (!player.storage.minihuoshui_used) {
                                                    player.when({ global: 'phaseAfter' }).then(() => delete player.storage.minihuoshui_used);
                                                }
                                                player.markAuto('minihuoshui_used', [target]);
                                                player.addTempSkill('minihuoshui_' + num);
                                                switch (num) {
                                                    case '0':
                                                        target.addTempSkill('fengyin');
                                                        break;
                                                    case '1':
                                                        if (!target.countGainableCards(player, 'h')) await player.viewHandcards(target);
                                                        await player.gainPlayerCard(target, 'h', true, 'visible');
                                                        break;
                                                    case '2':
                                                        await target.discard(target.getDiscardableCards(player, 'e')).set('discarder', player);
                                                        break;
                                                }
                                            },
                                            ai: {
                                                result: {
                                                    target(player, target) {
                                                        const num = lib.skill.minihuoshui_backup.num;
                                                        if (num == '1') return -target.countCards('h');
                                                        if (num == '2') return -target.countDiscardableCards(player, 'e');
                                                        return -target.getSkills(null, false, false).filter(skill => !get.is.locked(skill)).length - 1;
                                                    },
                                                },
                                            },
                                        }
                                    },
                                    prompt(links) {
                                        return '祸水：' + [
                                            ['令一名角色本回合非锁定技失效'],
                                            ['观看一名角色的手牌并获得其中一张牌'],
                                            ['弃置一名角色装备区所有牌']
                                        ][parseInt(links[0])];
                                    },
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    backup: {},
                                    '0': { charlotte: true },
                                    '1': { charlotte: true },
                                    '2': { charlotte: true },
                                },
                            },
                            miniqingcheng: {
                                audio: 'qingcheng',
                                inherit: 'reqingcheng',
                                filter(event, player) {
                                    return game.hasPlayer(target => lib.skill.miniqingcheng.filterTarget(null, player, target));
                                },
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('h') <= player.countCards('h') + player.getDamagedHp();
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player, target) {
                                            if (target.countCards('h')) return -Math.max(get.value(target.getCards('h'), player) - get.value(player.getCards('h'), player), 0);
                                            return 0;
                                        },
                                    },
                                },
                            },
                            //王允
                            minilianji: {
                                inherit: 'xinlianji',
                                filterTarget(card, player, target) {
                                    const cardx = new lib.element.VCard({ name: 'sha', isCard: true });
                                    if (!ui.selected.targets.length) return target != player && game.hasPlayer(current => target.canUse(cardx, current, false));
                                    return ui.selected.targets[0].canUse(cardx, target, false);
                                },
                                filterCard: false,
                                async content(event, trigger, player) {
                                    const targets = event.targets, sha = new lib.element.VCard({ name: 'sha', isCard: true });
                                    let card = get.cardPile2(card => get.subtype(card) == 'equip1' && targets[0].hasUseTarget(card));
                                    if (card) {
                                        if (card.name == 'qinggang' && !lib.inpile.includes('qibaodao')) {
                                            card.remove();
                                            card = game.createCard('qibaodao', card.suit, card.number);
                                        }
                                        await targets[0].chooseUseTarget(card, true, 'nopopup', 'nothrow');
                                    }
                                    else {
                                        player.chat('没有装备牌了吗');
                                        game.log('但是牌堆里已经没有装备牌了！');
                                    }
                                    if (targets[0].canUse(sha, targets[1], false)) await targets[0].useCard(sha, targets[1], false);
                                    const cards = targets[0].getEquips(1);
                                    if (cards.length && game.hasPlayer(target => target != targets[0])) {
                                        const { result } = await player.chooseTarget('是否将' + get.translation(cards) + '交给一名其他角色？', (card, player, target) => {
                                            return target != get.event('target');
                                        }).set('ai', target => {
                                            const card = _status.event.getParent().cards;
                                            if (get.attitude(get.event('player'), get.event('target')) > 0) return false;
                                            return (target.hasSkillTag('nogain') ? 0 : get.attitude(get.event('player'), target)) * Math.max(0.1, target.getUseValue(cards[0]));
                                        }).set('target', targets[0]).set('cards', cards);
                                        if (result.bool) await result.targets[0].gain(cards, targets[0], 'give').set('giver', player);
                                    }
                                },
                            },
                            minimoucheng: {
                                audio: 'moucheng',
                                inherit: 'xinmoucheng',
                                trigger: { player: 'phaseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer2(current => {
                                        return current.getAllHistory('sourceDamage', function (evt) {
                                            if (!evt.card || evt.card.name != 'sha' || evt.getParent().type != 'card') return false;
                                            var evt2 = evt.getParent(3);
                                            return evt2?.name == 'minilianji' && evt2.player == player;
                                        }).length > 0;
                                    });
                                },
                                content() {
                                    player.awakenSkill('minimoucheng');
                                    player.addSkills('xinjingong');
                                },
                            },
                            //小闪
                            minishanshan: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { target: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (event.player == event.target) return false;
                                    if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                                    return player.hasShan() || _status.connectMode;
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const { result: { bool } } = await player.chooseToRespond(get.prompt('minishanshan'), (card, player) => {
                                        return get.name(card) == 'shan';
                                    }).set('prompt2', '打出一张【闪】令' + get.translation(trigger.card) + '无效，然后你摸一张牌').set('ai', card => {
                                        const trigger = get.event().getTrigger();
                                        return -get.effect(player, trigger.card, trigger.target, player);
                                    }).set('logSkill', 'minishanshan');
                                    if (bool) {
                                        trigger.getParent().excluded.add(player);
                                        await player.draw();
                                    }
                                },
                                group: 'minishanshan_qingguo',
                                subSkill: {
                                    qingguo: {
                                        audio: 'minishanshan',
                                        inherit: 'reqingguo',
                                        mod: {
                                            aiValue(player, card, num) {
                                                if (get.name(card) != 'shan' && get.type(card) != 'equip') return;
                                                var cards = player.getCards('hs', card => {
                                                    return get.name(card) == 'shan' || get.type(card) == 'equip';
                                                });
                                                cards.sort((a, b) => (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2));
                                                var geti = function () {
                                                    if (cards.includes(card)) return cards.indexOf(card);
                                                    return cards.length;
                                                };
                                                if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                                return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                                            },
                                            aiUseful() {
                                                return lib.skill.minishanshan.subSkill.qingguo.mod.aiValue.apply(this, arguments);
                                            },
                                        },
                                        filterCard(card) {
                                            return get.type(card) == 'equip';
                                        },
                                        viewAsFilter(player) {
                                            if (!player.countCards('hes', { type: 'equip' })) return false;
                                        },
                                        prompt: '将一张装备牌当作【闪】使用或打出',
                                        ai: {
                                            order: 0.001,
                                            respondShan: true,
                                            skillTagFilter(player) {
                                                if (!player.countCards('hes', { type: 'equip' })) return false;
                                            },
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.tag(card, 'respondShan') && current < 0) return 0.7;
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            minianshi: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'roundStart' },
                                forced: true,
                                async content(event, trigger, player) {
                                    const num = Array.from({ length: 5 }).map((_, i) => i + 1).filter(num => !player.getStorage('minianshi_effect').includes(num)).randomGet();
                                    if (!num) return;
                                    player.addTempSkill('minianshi_effect', 'roundStart');
                                    player.markAuto('minianshi_effect', [num]);
                                    if (num == 2) {
                                        player.when({ global: 'roundStart' })
                                            .filter(evt => evt != trigger)
                                            .assign({ firstDo: true, priority: 114514 })
                                            .then(() => {
                                                player.removeSkill('minianshi_effect');
                                                const targets = game.filterPlayer(target => {
                                                    return !target.getRoundHistory('useCard', null, 1).slice().concat(target.getRoundHistory('respond', null, 1)).some(evt => {
                                                        return evt.card.name == 'shan';
                                                    }) && !target.getRoundHistory('lose', evt => {
                                                        return evt.type == 'discard' && evt.cards2 && evt.cards2.some(card => get.name(card, target) == 'shan' || get.name(card, false) == 'shan');
                                                    }, 1).length;
                                                }).sortBySeat();
                                                if (targets.length) {
                                                    player.logSkill('minianshi_effect', targets);
                                                    for (const target of targets) target.damage(1, 'thunder');
                                                }
                                            });
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        intro: {
                                            markcount: () => 0,
                                            content(storage, player) {
                                                const list = [
                                                    '一名角色使用或打出【杀】时，其弃置所有手牌',
                                                    '下一轮开始时，所有未于本轮使用、打出或弃置过【闪】的角色各受到你对其造成的1点雷属性伤害',
                                                    '一名角色的装备区的牌数发生变化后，其弃置所有装备牌',
                                                    '一名角色使用或打出【桃】或【酒】后，其本回合无法使用或打出手牌',
                                                    '一名角色使用单目标锦囊牌指定目标时，你摸一张牌',
                                                ];
                                                const nums = Array.from({ length: 5 }).map((_, i) => i + 1).filter(num => storage.includes(num));
                                                let str = '';
                                                for (const i of nums) {
                                                    if (!player.isUnderControl(true) && !storage.includes('showed_' + parseFloat(i))) continue;
                                                    str += '<li>';
                                                    str += list[i - 1];
                                                    str += '<br>';
                                                }
                                                if (str == '') return '这是小闪的秘密哦';
                                                return str.slice(0, -4);
                                            },
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        audio: 'minianshi',
                                        trigger: { global: ['loseAfter', 'equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter', 'useCardToPlayer', 'useCard', 'respond'] },
                                        filter(event, player) {
                                            const storage = player.getStorage('minianshi_effect');
                                            if (event.name == 'useCard' || event.name == 'respond') {
                                                if (storage.includes(1) && event.card.name == 'sha' && event.player.countCards('h')) return true;
                                                if (storage.includes(4) && (event.card.name == 'tao' || event.card.name == 'jiu')) return true;
                                                return false;
                                            }
                                            if (event.name == 'useCardToPlayer') {
                                                if (!storage.includes(5) || get.type2(event.card) != 'trick') return false;
                                                const info = get.info(event.card);
                                                return info && !info.notarget && (info.toself || info.singleCard || !info.selectTarget || info.selectTarget == 1);
                                            }
                                            if (!storage.includes(3)) return false;
                                            if (event.name == 'equip') {
                                                if (!event.player.countCards('e')) return false;
                                                const evt = event.getl(event.player);
                                                return !evt || evt.cards.length != 1;
                                            }
                                            return game.hasPlayer(target => {
                                                if (!target.countCards('e')) return false;
                                                const evt = event.getl(target);
                                                return evt?.es?.length;
                                            });
                                        },
                                        logTarget(event, player) {
                                            if (event.name == 'useCard' || event.name == 'respond' || event.name == 'useCardToPlayer' || event.name == 'equip') return event.player;
                                            return game.filterPlayer(target => {
                                                if (!target.countCards('e')) return false;
                                                const evt = event.getl(target);
                                                return evt?.es?.length;
                                            }).sortBySeat();
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            const storage = player.getStorage('minianshi_effect');
                                            if (trigger.name == 'useCard' || trigger.name == 'respond') {
                                                if (trigger.card.name == 'sha' && trigger.player.countCards('h')) {
                                                    player.markAuto('minianshi_effect', ['showed_1']);
                                                    trigger.player.discard(trigger.player.getCards('h'));
                                                }
                                                if (trigger.card.name == 'tao' || trigger.card.name == 'jiu') {
                                                    player.markAuto('minianshi_effect', ['showed_4']);
                                                    trigger.player.addTempSkill('minianshi_ban');
                                                }
                                            }
                                            else if (trigger.name == 'useCardToPlayer') {
                                                player.markAuto('minianshi_effect', ['showed_5']);
                                                player.draw();
                                            }
                                            else {
                                                player.markAuto('minianshi_effect', ['showed_3']);
                                                let targets = lib.skill.minianshi.subSkill.effect.logTarget(trigger, player);
                                                if (!Array.isArray(targets)) targets = [targets];
                                                for (const target of targets) target.discard(target.getCards('e'));
                                            }
                                        },
                                    },
                                    ban: {
                                        mod: {
                                            cardEnabled2(card) {
                                                if (get.position(card) == 'h') return false;
                                            },
                                        },
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '不能使用或打出手牌' },
                                    },
                                },
                            },
                            //张鲁
                            miniyishe: {
                                audio: 'yishe',
                                inherit: 'yishe',
                                filter: () => true,
                                frequent: true,
                            },
                            minibushi: {
                                audio: 'bushi',
                                inherit: 'bushi',
                                async content(event, trigger, player) {
                                    let sum = trigger.num;
                                    while (sum && player.getExpansions('yishe').length && player.hasSkill('minibushi')) {
                                        sum--;
                                        const { result: { bool, links } } = await player.chooseCardButton('布施：是否' + (trigger.player != player ? ('令' + get.translation(trigger.player)) : '') + '获得一张“米”？', player.getExpansions('yishe')).set('ai', button => {
                                            const att = get.attitude(get.event('player'), get.event().getTrigger().player);
                                            return get.value(button.link) * get.sgn(get.sgn(att) - 0.5);
                                        });
                                        if (bool) {
                                            player.logSkill('minibushi', trigger.player);
                                            await player.give(links, trigger.player);
                                        }
                                        else break;
                                    }
                                },
                                ai: { combo: 'miniyishe' },
                            },
                            minimidao: {
                                audio: 'midao',
                                inherit: 'midao',
                                async content(event, trigger, player) {
                                    const { result: { bool, links } } = await player.chooseButton([
                                        get.translation(trigger.player) + '的' + (trigger.judgestr || '') + '判定为' + get.translation(trigger.player.judging[0]) + '，' + get.prompt('minimidao'),
                                        player.getExpansions('yishe'), 'hidden',
                                    ]).set('filterButton', button => {
                                        const player = get.event('player'), card = button.link;
                                        const mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                        if (mod2 != 'unchanged') return mod2;
                                        const mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                                        if (mod != 'unchanged') return mod;
                                        return true;
                                    }).set('ai', button => {
                                        const card = button.link, trigger = get.event().getTrigger();
                                        const player = get.event('player'), judging = get.event('judging');
                                        const result = trigger.judge(card) - trigger.judge(judging) + 0.00001;
                                        const attitude = get.attitude(player, trigger.player);
                                        return result * attitude;
                                    }).set('judging', trigger.player.judging[0]);
                                    if (bool) {
                                        event.forceDie = true;
                                        await player.respond(links, 'minimidao', 'highlight', 'noOrdering');
                                        if (trigger.player.judging[0].clone) {
                                            trigger.player.judging[0].clone.classList.remove('thrownhighlight');
                                            game.broadcast(card => {
                                                if (card.clone) card.clone.classList.remove('thrownhighlight');
                                            }, trigger.player.judging[0]);
                                            game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                                        }
                                        await game.cardsDiscard(trigger.player.judging[0]);
                                        trigger.player.judging[0] = links[0];
                                        trigger.orderingCards.addArray(links);
                                        game.log(trigger.player, '的判定牌改为', links[0]);
                                        await game.asyncDelay(2);
                                        await player.draw();
                                    }
                                },
                                ai: {
                                    combo: 'miniyishe',
                                    rejudge: true,
                                    tag: { rejudge: 0.6 },
                                },
                            },
                            //张宁
                            minitianze: {
                                audio: 'tianze',
                                inherit: 'tianze',
                                trigger: { global: 'useCardAfter' },
                                filter(event, player) {
                                    return player != event.player && event.player.isIn() && get.color(event.card) == 'black' && event.player.hasHistory('lose', evt => {
                                        return evt?.hs?.length && evt.getParent() == event;
                                    }) && event.player.isPhaseUsing() && player.hasCard(card => {
                                        if (_status.connectMode && get.position(card) == 'h') return true;
                                        return get.color(card, player) == 'black';
                                    }, 'he') && !player.hasSkill('minitianze_block');
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseToDiscard('he', (card, player) => {
                                        return get.color(card, player) == 'black';
                                    }, get.prompt('minitianze', trigger.player), '弃置一张黑色牌并对其造成1点伤害').set('ai', card => {
                                        if (!get.event().goon) return 0;
                                        return 8 - get.value(card);
                                    }).set('goon', get.damageEffect(trigger.player, player, player) > 0).set('logSkill', ['minitianze', trigger.player]).forResult();
                                },
                                popup: false,
                                async content(event, trigger, player) {
                                    player.addTempSkill('minitianze_block');
                                    if (get.mode() != 'identity' || player.identity != 'nei') player.addExpose(0.2);
                                    await trigger.player.damage();
                                    await game.asyncDelayx();
                                },
                                group: 'minitianze_draw',
                            },
                            minidifa: {
                                audio: 'difa',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hasCard(card => get.info('minidifa').filterCard(card, player), 'h');
                                },
                                filterCard(card, player) {
                                    return get.color(card) == 'red' && player.canRecast(card);
                                },
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                position: 'h',
                                usable: 1,
                                discard: false,
                                lose: false,
                                delay: 0,
                                async content(event, trigger, player) {
                                    await player.recast(event.cards);
                                    const list = lib.inpile.filter(name => get.type2(name) == 'trick');
                                    if (!list.length) return;
                                    const { result: { bool, links } } = await player.chooseButton(['地法：选择获得一张锦囊牌', [list, 'vcard']], true).set('ai', button => {
                                        if (!get.cardPile2(card => card.name == button.link[2])) return 0;
                                        return get.event('player').getUseValue({ name: button.link[2] });
                                    });
                                    if (bool) {
                                        const card = get.cardPile2(card => card.name == links[0][2]);
                                        if (card) await player.gain(card, 'gain2');
                                        else {
                                            player.chat('无牌可得？！');
                                            game.log('但是牌堆中已经没有', '#y【' + get.translation(links[0][2]) + '】', '了！');
                                        }
                                    }
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        player(player) {
                                            return lib.inpile.some(name => get.type2(name) == 'trick' && player.getUseValue({ name: name }) > 0);
                                        },
                                    },
                                },
                            },
                            minicixiao: {
                                audio: 'cixiao',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(target => {
                                        return target != player && !target.hasSkill('minipanshi', null, false, false);
                                    });
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const { result: { bool, targets } } = await player.chooseTarget(get.prompt('minicixiao'), (card, player, target) => {
                                        return target != player && !target.hasSkill('minipanshi', null, false, false);
                                    }).set('ai', target => {
                                        var player = _status.event.player;
                                        var att = -get.attitude(player, target);
                                        return att * target.countCards('h');
                                    }).set('prompt2', '令一名没有“义子”标记的其他角色获得“义子”标记');
                                    if (bool) {
                                        const source = targets[0], card = new lib.element.VCard({ name: 'sha' });
                                        player.logSkill('minicixiao', source);
                                        await source.addSkills('minipanshi');
                                        if (source.hasUseTarget(card, true) && player.countCards('h')) {
                                            const { result: { bool, cards, targets } } = await player.chooseCardTarget({
                                                prompt: '是否交给' + get.translation(source) + '一张手牌并令其视为对其攻击范围内你选择的另一名角色使用一张【杀】？',
                                                filterCard: true,
                                                position: 'h',
                                                filterTarget(cardx, player, target) {
                                                    const source = get.event('source'), card = new lib.element.VCard({ name: 'sha' });
                                                    return source.canUse(card, target, true);
                                                },
                                                ai1(card) {
                                                    return 7.5 - get.value(card);
                                                },
                                                ai2(target) {
                                                    const player = get.event('player'), source = get.event('source'), card = new lib.element.VCard({ name: 'sha' });
                                                    return get.effect(target, card, source, player);
                                                },
                                            }).set('source', source);
                                            if (bool) {
                                                const target = targets[0];
                                                await player.give(cards, source);
                                                await source.useCard(card, target, false);
                                            }
                                        }
                                    }
                                },
                                derivation: 'minipanshi',
                            },
                            minipanshi: {
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.countCards('h') > 0 && game.hasPlayer(current => {
                                        return current != player && current.hasSkill('minicixiao');
                                    });
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    var targets = game.filterPlayer(function (current) {
                                        return current != player && current.hasSkill('minicixiao');
                                    });
                                    if (targets.length == 1) {
                                        event.target = targets[0];
                                        player.chooseCard('h', true, '叛弑：将一张手牌交给' + get.translation(targets));
                                    }
                                    else player.chooseCardTarget({
                                        prompt: '叛弑：将一张手牌交给' + get.translation(targets) + '中的一名角色',
                                        filterCard: true,
                                        position: 'h',
                                        targets: targets,
                                        forced: true,
                                        filterTarget(card, player, target) {
                                            return _status.event.targets.includes(target);
                                        },
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        if (!target) target = result.targets[0];
                                        player.line(target);
                                        player.give(result.cards, target);
                                    }
                                },
                                mark: true,
                                marktext: '子',
                                intro: {
                                    name: '义子',
                                    content: '我是儿子',
                                },
                                group: 'minipanshi_damage',
                                subSkill: {
                                    damage: {
                                        trigger: { source: 'damageBegin1' },
                                        filter(event, player) {
                                            return player.isPhaseUsing() && event.card && event.card.name == 'sha' && event.player.hasSkill('minicixiao');
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        content() {
                                            trigger.num++;
                                            player.removeSkills('minipanshi');
                                            var evt = event.getParent('phaseUse');
                                            if (evt?.player == player) evt.skipped = true;
                                        },
                                    },
                                },
                            },
                            minidushi: {
                                audio: 'dushi',
                                global: 'minidushi_buff',
                                trigger: { player: 'dyingAfter' },
                                forced: true,
                                forceDie: true,
                                async content(event, trigger, player) {
                                    if (player.isAlive()) {
                                        await player.removeSkills('minidushi');
                                    }
                                    if (game.hasPlayer(target => target != player)) {
                                        const { result: { bool, targets } } = await player.chooseTarget('请选择【毒逝】的目标', '令一名其他角色获得技能【毒逝】', true, lib.filter.notMe).set('ai', target => {
                                            return -get.attitude(_status.event.player, target);
                                        }).set('forceDie', true);
                                        if (bool) {
                                            const target = targets[0];
                                            player.line(target);
                                            target.markSkill('minidushi');
                                            await target.addSkills('minidushi');
                                        }
                                    }
                                },
                                intro: { content: '您已经获得弘农王的诅咒' },
                                subSkill: {
                                    buff: {
                                        mod: {
                                            cardSavable(card, player, target) {
                                                if (card.name == 'tao' && target != player && target.hasSkill('minidushi')) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            miniheqia: {
                                audio: 'heqia',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(current => current.countCards(current == player ? 'he' : 'h') > 0);
                                },
                                filterCard: true,
                                position: 'he',
                                selectCard() {
                                    if (ui.selected.targets.length && !ui.selected.targets[0].countCards('h')) return [1, Infinity];
                                    return [0, Infinity];
                                },
                                filterTarget(card, player, target) {
                                    if (player == target) return false;
                                    if (!ui.selected.cards.length) return target.countCards('h') > 0;
                                    return true;
                                },
                                check(card) {
                                    const player = get.event('player');
                                    if (!!game.hasPlayer(function (current) {
                                        return current != player && get.attitude(player, current) <= 0 && current.countCards('h') > 0;
                                    }) || ui.selected.cards.length) return 0 - get.value(card);
                                    return 1 / Math.max(1, get.value(card));
                                },
                                usable: 1,
                                complexCard: true,
                                discard: false,
                                lose: false,
                                delay: 0,
                                content() {
                                    'step 0'
                                    player.addTempSkill('miniheqia_add');
                                    'step 1'
                                    if (cards.length) {
                                        player.give(cards, target);
                                        event.source = target;
                                        event.num = cards.length;
                                        event.goto(4);
                                    }
                                    'step 2'
                                    var he = target.getCards('he');
                                    if (he.length > 0) {
                                        if (he.length > 1) target.chooseCard('he', true, [1, Infinity], '选择交给' + get.translation(player) + '任意张牌').set('ai', (card) => -get.value(card));
                                        else event._result = { bool: true, cards: he };
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (result.bool) {
                                        event.source = player;
                                        target.give(result.cards, player);
                                        event.num = result.cards.length;
                                    }
                                    else event.finish();
                                    'step 4'
                                    if (source?.isIn() && source.countCards('h') > 0) {
                                        var list = [];
                                        for (var name of lib.inpile) {
                                            if (get.type(name) != 'basic') continue;
                                            if (source.hasUseTarget({ name: name }, false)) list.push(['基本', '', name]);
                                            if (name == 'sha') {
                                                for (var nature of lib.inpile_nature) {
                                                    if (source.hasUseTarget({ name: name, nature: nature }, false)) list.push(['基本', '', name, nature]);
                                                }
                                            }
                                        }
                                        if (list.length) {
                                            source.chooseButton(['是否将一张手牌当做一种基本牌使用？', [list, 'vcard']]).set('ai', (button) => _status.event.player.getUseValue({ name: button.link[2], nature: button.link[3] }, false));
                                        }
                                        else event.finish();
                                    }
                                    else event.finish();
                                    'step 5'
                                    if (result.bool) {
                                        var card = { name: result.links[0][2], nature: result.links[0][3] };
                                        game.broadcastAll(card => {
                                            lib.skill.heqia_backup.viewAs = card;
                                        }, card);
                                        var next = source.chooseToUse();
                                        next.set('openskilldialog', '将一张手牌当做' + get.translation(card) + '使用');
                                        next.set('norestore', true);
                                        next.set('addCount', false);
                                        next.set('_backupevent', 'heqia_backup');
                                        next.set('custom', {
                                            add: {},
                                            replace: { window() { } }
                                        });
                                        next.backup('heqia_backup');
                                    }
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            return (get.attitude(player, target) - 0.1) * (ui.selected.cards.length ? 1 : -1);
                                        },
                                    },
                                },
                                subSkill: {
                                    add: {
                                        charlotte: true,
                                        trigger: { global: 'useCard2' },
                                        filter(event, player) {
                                            var evt = event.getParent(2);
                                            if (evt.name != 'miniheqia' || evt.player != player || !event.targets || evt.num <= event.targets.length) return false;
                                            var card = event.card, info = get.info(card);
                                            if (info.allowMultiple == false) return false;
                                            if (event.targets && !info.multitarget) {
                                                if (game.hasPlayer(function (current) {
                                                    return !event.targets.includes(current) && lib.filter.targetEnabled2(card, event.player, current);
                                                })) return true;
                                            }
                                            return false;
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            var num = trigger.getParent(2).num - trigger.targets.length;
                                            var prompt2 = '是否为' + get.translation(trigger.card) + '增加至多' + get.cnNumber(num) + '个目标？';
                                            trigger.player.chooseTarget(prompt2, [1, num], function (card, player, target) {
                                                var player = _status.event.player;
                                                return !_status.event.targets.includes(target) && lib.filter.targetEnabled2(_status.event.card, player, target);
                                            }).set('ai', function (target) {
                                                var trigger = _status.event.getTrigger();
                                                var player = _status.event.player;
                                                return get.effect(target, trigger.card, player, player);
                                            }).set('card', trigger.card).set('targets', trigger.targets);
                                            'step 1'
                                            if (result.bool) {
                                                trigger.player.line(result.targets);
                                                game.log(result.targets, '也成为了', trigger.card, '的目标')
                                                trigger.targets.addArray(result.targets);
                                            }
                                        },
                                    },
                                },
                            },
                            //李采薇
                            miniqibie: {
                                audio: 'qibie',
                                inherit: 'qibie',
                                filter(event, player) {
                                    return player.hasCard(card => _status.connectMode || lib.filter.cardDiscardable(card, player), 'h');
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseToDiscard(get.prompt('miniqibie'), 'h', [1, Infinity]).set('ai', lib.skill.zhiheng.check).set('logSkill', 'miniqibie').forResult();
                                },
                                popup: false,
                                *content(event, map) {
                                    const player = map.player;
                                    yield player.recover();
                                    yield player.draw(event.cards.length + 1);
                                },
                            },
                            //黄祖
                            minixiaojuan: {
                                audio: 'dcxiaojuan',
                                inherit: 'dcxiaojuan',
                                filter(event, player) {
                                    return event.targets.length == 1 && player != event.target && event.target.countCards('h');
                                },
                                check(event, player) {
                                    var target = event.target;
                                    if (get.attitude(player, target) >= 0) return false;
                                    if (get.color(event.card) == 'none') return true;
                                    return target.countCards('h');
                                },
                                content() {
                                    'step 0'
                                    var target = trigger.target;
                                    event.target = target;
                                    var num = Math.ceil(target.countCards('h') / 2);
                                    if (num > 0) player.discardPlayerCard(target, 'h', num, true);
                                    else event.finish();
                                    'step 1'
                                    var suit = get.suit(trigger.card);
                                    if (result.bool && lib.suit.includes(suit) && player.countCards('h') > 1) {
                                        var bool = false;
                                        for (var i of result.cards) {
                                            if (get.suit(i, target) == suit) {
                                                bool = true;
                                                break;
                                            }
                                        }
                                        if (!bool) event.finish();
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (player.countCards('h') > 0) player.chooseToDiscard('h', 1, true);
                                },
                            },
                            //white tigger
                            minizhidao: {
                                audio: 'zhidao',
                                inherit: 'zhidao',
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (num > 0 && !player.hasSkill('minizhidao_buff') && !get.tag(card, 'damage') && (!lib.filter.targetEnabled(card, player, player) || get.effect(player, card, player) <= 0)) return num + 10;
                                    },
                                },
                                filter(event, player) {
                                    if (event._notrigger.includes(event.player)) return false;
                                    return player.isPhaseUsing() && event.player.isIn() && event.player.countCards('hej') > 0 && event.player != player && !player.hasSkill('minizhidao_buff');
                                },
                                logTarget: 'player',
                                async content(event, trigger, player) {
                                    const target = trigger.player;
                                    let num = 0;
                                    if (target.countCards('h')) num++;
                                    if (target.countCards('e')) num++;
                                    if (target.countCards('j')) num++;
                                    if (num) await player.gainPlayerCard(target, num, 'hej', true).set('filterButton', button => {
                                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                                            if (get.position(button.link) == get.position(ui.selected.buttons[i].link)) return false;
                                        }
                                        return true;
                                    });
                                    player.addTempSkill('minizhidao_buff');
                                    player.markAuto('minizhidao_buff', [target]);
                                },
                                subSkill: {
                                    buff: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: {
                                            content: '本回合不能对$使用牌',
                                        },
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (player.getStorage('minizhidao_buff').includes(target)) return false;
                                            },
                                        }
                                    }
                                }
                            },
                            minybhijili: {
                                audio: 'jili',
                                inherit: 'jili',
                                async content(event, trigger, player) {
                                    trigger.getParent().targets.add(player);
                                    trigger.player.line(player, 'green');
                                    player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent() && game.hasPlayer(current => current.hasHistory('damage', evt => evt.card && evt.card == trigger.card))).then(() => {
                                        player.draw();
                                    })
                                },
                            },
                            //界坤姐
                            minirejiuchi: {
                                audio: 'oljiuchi',
                                inherit: 'oljiuchi',
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                position: 'hes',
                                viewAsFilter(player) {
                                    return player.hasCard(card => get.color(card) == 'black', 'hes');
                                },
                                prompt() {
                                    if (get.event().name == 'chooseToUse') return '将一张黑色牌当酒使用';
                                    return get.prompt('minirejiuchi');
                                },
                                prompt2(event, player) {
                                    return '摸一张牌并令【崩坏】本回合失效';
                                },
                                filter(event, player) {
                                    if (event.name == 'chooseToUse') return player.hasCard(card => get.color(card) == 'black', 'hes')
                                    return event.card && event.card.name == 'sha' && event.getParent(2).jiu == true;
                                },
                                forced: false,
                                content() {
                                    player.draw();
                                    if (!player.hasSkill('minirejiuchi_air', null, null, false)) player.addTempSkill('minirejiuchi_air');
                                },
                                subSkill: {
                                    air: {
                                        charlotte: true,
                                    }
                                }
                            },
                            miniroulin: {
                                audio: 'roulin',
                                inherit: 'roulin',
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    if (player.hasSkill('minirebenghuai_all', null, null, false)) return true;
                                    if (player == event.player) {
                                        return event.target.hasSex('female');
                                    }
                                    return event.player.hasSex('female');
                                },
                                async content(event, trigger, player) {
                                    const id = (player == trigger.player ? trigger.target : player).playerid;
                                    const map = trigger.getParent().customArgs;
                                    if (!map[id]) map[id] = {};
                                    if (typeof map[id].shanRequired == 'number') {
                                        map[id].shanRequired++;
                                    } else {
                                        map[id].shanRequired = 2;
                                    }
                                    player.when({ global: 'useCardAfter' }).filter(evt => evt == trigger.getParent() && !game.hasPlayer(current => current.hasHistory('damage', evt => evt.card && evt.card == trigger.card))).then(() => {
                                        let card = get.cardPile2(card => get.color(card) == 'black')
                                        if (card) player.gain(card, 'draw');
                                    })
                                },
                                ai: {
                                    halfneg: true,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag === 'directHit_ai') return;
                                        if (arg.card.name != 'sha' || (!arg.target.hasSex('female') && !(player.hasSkill('minirebenghuai_all', null, null, false))) || arg.target.countCards('h', 'shan') > 1) return false;
                                    },
                                },
                            },
                            minirebenghuai: {
                                audio: 'benghuai',
                                inherit: 'minibenghuai',
                                filter(event, player) {
                                    return !player.isMinHp() && !player.hasSkill('minirejiuchi_air') && !player.hasSkill('rejiuchi_air') && !player.hasSkill('oljiuchi_air');
                                },
                                group: 'minirebenghuai_buff',
                                subSkill: {
                                    buff: {
                                        trigger: {
                                            player: 'phaseBegin',
                                        },
                                        filter(event, player) {
                                            return player.isMinHp();
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            player.addTempSkill('minirebenghuai_all');
                                        },
                                    },
                                    all: {
                                        charlotte: true,
                                        mark: true,
                                        intro: {
                                            content: '本回合〖肉林〗对所有角色生效',
                                        }
                                    }
                                }
                            },
                            //郭汜
                            minitanbei: {
                                audio: 'xinfu_tanbei',
                                inherit: 'xinfu_tanbei',
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    let result;
                                    const goon = target.countCards('hej');
                                    if (goon) result = await target.chooseControl().set('choiceList', ['令' + get.translation(player) + '获得你区域内的一张牌，然后其本回合内不能再对你使用牌。', '令' + get.translation(player) + '本回合内对你使用牌没有次数与距离限制。']).set('ai', () => {
                                        var list = [0, 1];
                                        return list.randomGet();
                                    }).forResult();
                                    else result = { index: 1 };
                                    player.addTempSkill('tanbei_effect3');
                                    if (result.index == 0) {
                                        await player.gainPlayerCard(target, 'hej', true);
                                        target.addTempSkill('tanbei_effect2');
                                    } else {
                                        target.addTempSkill('tanbei_effect1');
                                    }
                                },
                            },
                            minisidao: {
                                audio: 'xinfu_sidao',
                                trigger: {
                                    player: 'useCardAfter',
                                },
                                filter(event, player) {
                                    if (player.hasSkill('minisidao_sidaoy')) return false;
                                    if (!event.targets || !event.targets.length || !event.isPhaseUsing(player)) return false;
                                    const history = player.getHistory('useCard');
                                    const index = history.indexOf(event) - 1;
                                    if (index < 0) return false;
                                    const evt = history[index];
                                    if (!evt || !evt.targets || !evt.targets.length || !evt.isPhaseUsing(player)) return false;
                                    return event.targets.some(current => evt.targets.includes(current) && current != player && current.countGainableCards(player, 'hej'));
                                },
                                async cost(event, trigger, player) {
                                    const targets = player.getLastUsed(1).targets;
                                    event.result = await player.chooseTarget(get.prompt2(event.name.slice(0, -5)), (card, player, target) => {
                                        return get.event('targets').includes(target);
                                    }).set('targets', game.filterPlayer(current => {
                                        return current != player && targets.includes(current) && trigger.targets.includes(current) && current.countGainableCards(player, 'hej') > 0;
                                    })).set('ai', target => {
                                        const player = get.player();
                                        let att = get.attitude(player, target);
                                        if (att < 0) att = -Math.sqrt(-att);
                                        else att = Math.sqrt(att);
                                        return att * lib.card.shunshou.ai.result.target(player, target);
                                    }).forResult();
                                },
                                async content(event, trigger, player) {
                                    player.addTempSkill('minisidao_sidaoy');
                                    await player.gainPlayerCard(event.targets[0], 'hej', true);
                                },
                                subSkill: {
                                    sidaoy: { charlotte: true },
                                }
                            },
                            //老八
                            minixingluan: {
                                audio: 'xinfu_xingluan',
                                usable: 1,
                                trigger: {
                                    player: 'useCardAfter',
                                },
                                filter(event, player) {
                                    return player.isPhaseUsing() && event.targets && event.targets.length == 1;
                                },
                                async content(event, trigger, player) {
                                    const cards = []
                                    while (cards.length < 2) {
                                        const card = get.cardPile2(card => {
                                            return !cards.includes(card) && get.number(card) == 6;
                                        });
                                        if (!card) break;
                                        cards.push(card);
                                    }
                                    if (!cards.length) await player.draw(6);
                                    else {
                                        const links = await player.chooseButton(['兴乱：选择获得其中一张', cards], true).set('ai', button => {
                                            return get.value(button.link, get.player());
                                        }).forResultLinks();
                                        await player.gain(links, 'gain2');
                                    }
                                },
                            },
                            //皇甫嵩
                            minijuxia: {
                                trigger: { player: 'compareFixing', target: 'compareFixing' },
                                filter(event, player) {
                                    if (event['num' + (event.player == player ? 1 : 2)] != 1) return false;
                                    return !event.iwhile || event.player != player;
                                },
                                forced: true,
                                content() {
                                    trigger.forceWinner = player;
                                },
                                ai: {
                                    forceWin: true,
                                    skillTagFilter(player, _, arg) {
                                        return arg?.card && get.number(arg.card, false) == 1;
                                    },
                                },
                            },
                            miniranshang: {
                                audio: 'ranshang',
                                inherit: 'ranshang',
                                group: 'miniranshang_effect',
                                subSkill: {
                                    effect: {
                                        audio: 'ranshang',
                                        inherit: 'ranshang2',
                                        content() {
                                            const num = player.countMark('ranshang');
                                            player.loseHp(num);
                                            if (num >= 2) {
                                                player.loseMaxHp(2);
                                                player.draw(num);
                                            }
                                        },
                                    },
                                },
                            },
                            // 伏完
                            minimoukui: {
                                audio: 'dcmoukui',
                                trigger: {
                                    player: 'useCardToPlayered',
                                    target: 'useCardToTargeted',
                                },
                                filter(event, player) {
                                    return event.card?.name == 'sha';
                                },
                                async cost(event, trigger, player) {
                                    const target = get.info(event.name.slice(0, -5)).logTarget(trigger, player);
                                    const { result: { bool, links } } = await player.chooseButton([
                                        get.prompt(event.name.slice(0, -5)),
                                        [
                                            [
                                                ['draw', '摸一张牌'],
                                                ['discard', `弃置${get.translation(target)}的一张牌`],
                                            ],
                                            'textbutton',
                                        ],
                                    ]).set('filterButton', button => {
                                        const { link } = button, { player, target } = get.event();
                                        if (link == ' discard' && !target.countDiscardableCards(player, 'he')) return false;
                                        return true;
                                    }).set('ai', button => {
                                        const { link } = button, { player, target } = get.event();
                                        if (link == 'discard' && get.effect(target, { name: 'guohe_copy2' }, player) <= 0) return 0;
                                        return 1;
                                    }).set('selectButton', [1, 2]).set('target', target);
                                    event.result = {
                                        bool: bool,
                                        cost_data: links,
                                    }
                                },
                                logTarget: (event, player) => player == event.player ? event.target : event.player,
                                async content(event, trigger, player) {
                                    const target = get.info(event.name).logTarget(trigger, player);
                                    const { cost_data: choices } = event;
                                    if (choices.includes('draw')) {
                                        game.log(player, '选择了', '#y选项一');
                                        await player.draw();
                                    }
                                    if (choices.includes('discard')) {
                                        game.log(player, '选择了', '#y选项二');
                                        if (target.countDiscardableCards(player, 'he')) await player.discardPlayerCard(target, true, 'he').set('boolline', true);
                                    }
                                    if (choices.length >= 2) {
                                        player.addTempSkill(event.name + '_conseq');
                                        player.markAuto(event.name + '_conseq', [trigger.card]);
                                    }
                                    else {
                                        player.addTempSkill(event.name + '_effect');
                                        player.markAuto(event.name + '_effect', [[target, choices[0]]]);
                                        const evt = trigger.getParent();
                                        if (!evt[event.name + '_effect']) evt[event.name + '_effect'] = true;
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        trigger: {
                                            global: 'useCardAfter',
                                        },
                                        filter(event, player) {
                                            if (!game.hasPlayer(current => current.hasHistory('damage', evt => evt.card == event.card))) return false;
                                            return event.minimoukui_effect;
                                        },
                                        forced: true,
                                        popup: false,
                                        async content(event, trigger, player) {
                                            const storage = player.getStorage(event.name);
                                            for (const [target, choice] of storage) {
                                                if (choice == 'draw') await player.draw();
                                                else if (target.isIn() && target.countDiscardableCards(player, 'he')) await player.discardPlayerCard(target, true, 'he').set('boolline', true);
                                            }
                                            player.removeSkill(event.name);
                                        },
                                    },
                                    conseq: {
                                        charlotte: true,
                                        onremove: true,
                                        trigger: {
                                            global: ['shaMiss', 'useCardToExcluded', 'eventNeutralized', 'shaCancelled'],
                                        },
                                        forced: true,
                                        popup: false,
                                        filter(event, player, name) {
                                            const { card, target } = event;
                                            if (!card) return false;
                                            const cards = player.getStorage('minimoukui_conseq');
                                            if (!cards.includes(card)) return false;
                                            return player.countDiscardableCards(target, 'he');
                                        },
                                        async content(event, trigger, player) {
                                            await game.delayx();
                                            await trigger.target.discardPlayerCard(player, true, 'he').set('boolline', true);
                                        },
                                    }
                                }
                            },
                            // 董翓
                            minijiaoxia: {
                                audio: 'dcjiaoxia',
                                mod: {
                                    cardUsableTarget(card, player, target) {
                                        if (!player.isPhaseUsing()) return;
                                        if (card.name == 'sha' && !player.getStorage('dcjiaoxia_mark').includes(target)) return true;
                                    },
                                    targetInRange(card, player, target) {
                                        if (!player.isPhaseUsing()) return;
                                        if (card.name == 'sha' && !player.getStorage('dcjiaoxia_mark').includes(target)) return true;
                                    },
                                },
                                locked: false,
                                enable: 'phaseUse',
                                viewAs: {
                                    name: 'sha',
                                },
                                viewAsFilter(player) {
                                    return player.countCards('hs');
                                },
                                filterCard: true,
                                position: 'hs',
                                prompt: '将一张手牌当做【杀】使用',
                                check(card) {
                                    if (get.player().hasUseTarget(card)) return 1;
                                    return 6 - get.value(card);
                                },
                                precontent() {
                                    player.addTempSkill('minijiaoxia_effect');
                                },
                                group: 'dcjiaoxia_load',
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        trigger: {
                                            player: 'useCardAfter',
                                        },
                                        filter(event, player) {
                                            return event.skill == 'minijiaoxia' && event.cards?.length == 1 && player.hasUseTarget(get.copy(event.cards[0])) && player.getHistory('sourceDamage', evt => evt.card == event.card).length && player.hasUseTarget(event.cards[0]);
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseUseTarget(trigger.cards[0], get.prompt(event.name.slice(0, -5)), false, false).set('prompt2', `使用${get.translation(trigger.cards[0])}`).set('logSkill', event.name.slice(0, -5)).forResult();
                                        },
                                        popup: false,
                                        content() { },
                                    }
                                },
                            },
                            minihumei: {
                                audio: 'dchumei',
                                inherit: 'dchumei',
                                usable(skill, player) {
                                    return get.event()?.dchumei_num;
                                },
                                filter(event, player) {
                                    if (typeof event.dchumei_num != 'number') return false;
                                    return game.hasPlayer(target => lib.skill.minihumei.filterTarget(null, player, target));
                                },
                                filterTarget(card, player, target) {
                                    const list = player.getStorage('minihumei_used');
                                    if (!list.includes('draw')) return true;
                                    if (!list.includes('give') && target.countCards('he')) return true;
                                    if (!list.includes('recover') && target.isDamaged()) return true;
                                    return false;
                                },
                                async content(event, trigger, player) {
                                    const { target } = event, str = get.translation(target);
                                    const { result: { bool, links } } = await player.chooseButton([
                                        '狐魅：请选择一项',
                                        [
                                            [
                                                ['draw', '令' + str + '摸一张牌'],
                                                ['give', '令' + str + '交给你一张牌'],
                                                ['recover', '令' + str + '回复1点体力'],
                                            ].filter(list => {
                                                if (player.getStorage('minihumei_used').includes(list[0])) return false;
                                                if (list[0] == 'give' && !target.countCards('he')) return false;
                                                if (list[0] == 'recover' && target.isHealthy()) return false;
                                                return true;
                                            }),
                                            'textbutton',
                                        ],
                                    ], true).set('filterButton', button => {
                                        const { player, target } = get.event();
                                        if (player.getStorage('minihumei_used').includes(button.link)) return false;
                                        if (button.link == 'give' && !target.countCards('he')) return false;
                                        if (button.link == 'recover' && target.isHealthy()) return false;
                                        return true;
                                    }).set('ai', button => {
                                        const { player, target } = get.event();
                                        switch (button.link) {
                                            case 'draw': {
                                                return get.effect(target, { name: 'draw' }, player, player);
                                            }
                                            case 'give': {
                                                return get.effect(target, { name: 'shunshou_copy2' }, player, player);
                                            }
                                            case 'recover': {
                                                return get.recoverEffect(target, player, player);
                                            }
                                        }
                                        return 0;
                                    }).set('target', target);
                                    if (bool) {
                                        player.addTempSkill(event.name + '_used');
                                        player.markAuto(event.name + '_used', links);
                                        if (links[0] == 'draw') await target.draw();
                                        else if (links[0] == 'give') await target.chooseToGive(player, 'he', true);
                                        else await target.recover();
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target(player, target) {
                                            const list = player.getStorage('minihumei_used');
                                            if (!list.includes('draw')) return 1;
                                            if (!list.includes('give')) return -1;
                                            if (!list.includes('recover')) return 1;
                                        },
                                    },
                                },
                                subSkill: {
                                    used: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                            },
                            //管宁
                            minidunshi: {
                                Mbaby_characterlist: true,
                                hiddenCard(player, name) {
                                    return player.storage.minidunshi?.includes(name) && !player.getStat('skill').minidunshi;
                                },
                                init(player, skill) {
                                    player.storage[skill] = player.storage[skill] || ['sha', 'shan', 'tao', 'jiu'];
                                    player.markSkill(skill);
                                },
                                audio: 'dunshi',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                usable: 1,
                                mark: true,
                                intro: {
                                    content(storage, player) {
                                        if (!storage?.length) return '已无可用牌';
                                        return '剩余可用牌：' + get.translation(storage);
                                    },
                                },
                                filter(event, player) {
                                    if (event.type == 'wuxie') return false;
                                    var storage = player.storage.minidunshi;
                                    return storage?.some(i => event.filterCard({ name: i, isCard: true }, player, event));
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [], storage = player.storage.minidunshi;
                                        for (var i of storage) list.push(['基本', '', i]);
                                        return ui.create.dialog('遁世', [list, 'vcard'], 'hidden');
                                    },
                                    filter(button, player) {
                                        var evt = _status.event.getParent();
                                        return evt.filterCard({ name: button.link[2], isCard: true }, player, evt);
                                    },
                                    check(button) {
                                        var card = { name: button.link[2] }, player = _status.event.player;
                                        if (_status.event.getParent().type != 'phase') return 1;
                                        if (card.name == 'jiu') return 0;
                                        if (card.name == 'sha' && player.hasSkill('jiu')) return 0;
                                        return player.getUseValue(card, null, true);
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: 'dunshi',
                                            filterCard: () => false,
                                            popname: true,
                                            viewAs: {
                                                name: links[0][2],
                                                isCard: true,
                                            },
                                            selectCard: -1,
                                            precontent() {
                                                player.addTempSkill('minidunshi_damage');
                                                player.storage.minidunshi_damage = event.result.card.name;
                                            },
                                        }
                                    },
                                    prompt(links, player) {
                                        return '###遁世###<div class="text center">请选择【' + get.translation(links[0][2]) + '】的目标</div>';
                                    },
                                },
                                ai: {
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag, arg) {
                                        var storage = player.storage.minidunshi;
                                        if (!storage?.length) return false;
                                        if (player.getStat('skill').minidunshi) return false;
                                        switch (tag) {
                                            case 'respondSha': return (_status.event.type != 'phase' || (player == game.me || player.isUnderControl() || player.isOnline())) && storage.includes('sha');
                                            case 'respondShan': return storage.includes('shan');
                                            case 'save':
                                                if (arg == player && storage.includes('jiu')) return true;
                                                return storage.includes('tao');
                                        }
                                    },
                                    order: 2,
                                    result: {
                                        player(player) {
                                            if (_status.event.type == 'dying') return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                initList() {
                                    var list, skills = [], banned = [];
                                    list = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(i => lib.character[i]);
                                    for (var i of list) {
                                        for (var j of lib.character[i][3]) {
                                            var skill = lib.skill[j];
                                            if (!skill || skill.zhuSkill || banned.includes(j)) continue;
                                            if (skill.ai && (skill.ai.combo || skill.ai.notemp || skill.ai.neg)) continue;
                                            var info = get.translation(j);
                                            for (var ix = 0; ix < info.length; ix++) {
                                                if (/仁|义|礼|智|信/.test(info[ix]) == true) {
                                                    if (/游戏开始时/.test(info[ix]) && !/一轮游戏开始时/.test(info[ix])) continue;
                                                    skills.add(j);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    _status.minidunshi_list = skills;
                                },
                                subSkill: {
                                    backup: { audio: 'dunshi' },
                                    damage: {
                                        charlotte: true,
                                        onremove: true,
                                        audio: 'dunshi',
                                        trigger: { global: 'damageBegin2' },
                                        filter(event, player) {
                                            return event.source == _status.currentPhase;
                                        },
                                        forced: true,
                                        logTarget: 'source',
                                        async content(event, trigger, player) {
                                            const cardname = player.storage[event.name], { source: target } = trigger;
                                            player.removeSkill(event.name);
                                            const list = [
                                                `防止即将对${get.translation(trigger.player)}造成的伤害，并令${get.translation(target)}获得一个技能名中包含“仁/义/礼/智/信”的技能`,
                                                `从〖遁世〗中删除【${get.translation(cardname)}】`,
                                                '减1点体力上限，然后摸剩余选项数的牌',
                                            ]
                                            const next = player.chooseButton([
                                                '遁世：请选择两项',
                                                [list.map((item, i) => {
                                                    return [i, item];
                                                }), 'textbutton']
                                            ]);
                                            next.set('forced', true);
                                            next.set('selectButton', 2);
                                            next.set('ai', button => {
                                                const player = get.player();
                                                switch (button.link) {
                                                    case 0:
                                                        if (get.attitude(player, _status.currentPhase) > 0) return 3;
                                                        return 0;
                                                    case 1:
                                                        return 1;
                                                    case 2:
                                                        let num = player.storage.minidunshi;
                                                        for (const i of ui.selected.buttons) {
                                                            if (i.link == 1) num++;
                                                        }
                                                        if (num > 0 && player.isDamaged()) return 2;
                                                        return 0;
                                                }
                                            });
                                            const links = await next.forResultLinks();
                                            if (!links?.length) return;
                                            links.sort();
                                            for (const i of links) {
                                                game.log(player, '选择了', '#g【遁世】', '的', '#y选项' + get.cnNumber(i + 1, true));
                                            }
                                            const storage = player.storage.minidunshi;
                                            if (links.includes(0)) {
                                                trigger.cancel();
                                                if (!_status.minidunshi_list) lib.skill.minidunshi.initList();
                                                const list = _status.minidunshi_list.filter(i => !target.hasSkill(i, null, null, false)).randomGets(3);
                                                if (list.length) {
                                                    event.videoId = lib.status.videoId++;
                                                    var func = function (skills, id, target) {
                                                        var dialog = ui.create.dialog('forcebutton');
                                                        dialog.videoId = id;
                                                        dialog.add('令' + get.translation(target) + '获得一个技能');
                                                        for (var i = 0; i < skills.length; i++) {
                                                            dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">【' + get.translation(skills[i]) + '】</div><div>' + lib.translate[skills[i] + '_info'] + '</div></div>');
                                                        }
                                                        dialog.addText(' <br> ');
                                                    }
                                                    if (player.isOnline()) player.send(func, list, event.videoId, target);
                                                    else if (player == game.me) func(list, event.videoId, target);
                                                    const control = await player.chooseControl(list).set('ai', function () {
                                                        var controls = _status.event.controls;
                                                        if (controls.includes('cslilu')) return 'cslilu';
                                                        return controls[0];
                                                    }).forResultControl();
                                                    game.broadcastAll('closeDialog', event.videoId);
                                                    if (control) await target.addSkills(control);
                                                }
                                            }
                                            if (links.includes(1)) {
                                                storage.remove(cardname);
                                                player.markSkill('minidunshi');
                                            }
                                            if (links.includes(2)) {
                                                await player.loseMaxHp();
                                                if (4 - storage.length > 0) await player.draw(storage.length);
                                            }
                                        },
                                    },
                                },
                            },
                            //韩遂
                            mininiluan: {
                                audio: 'niluan',
                                enable: ['chooseToUse', 'chooseToRespond'],
                                filter(event, player) {
                                    return player.hasCard(lib.skill.mininiluan.filterCard, 'hes');
                                },
                                viewAs: { name: 'sha' },
                                check(card) {
                                    return 5 - get.value(card);
                                },
                                filterCard: { color: 'black' },
                                position: 'hes',
                                group: 'mininiluan_clear',
                                prompt: '将一张黑色牌当作【杀】使用或打出',
                                ai: {
                                    respondSha: true,
                                    skillTagFilter(player) {
                                        return player.hasCard(card => {
                                            if (_status.connectMode && get.position(card) === 'h') return true;
                                            return get.color(card) === lib.skill.mininiluan.filterCard.color;
                                        }, 'hes');
                                    },
                                },
                                subSkill: {
                                    clear: {
                                        audio: 'niluan',
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            if (event.card.name !== 'sha') return false;
                                            return event.addCount !== false && !player.hasHistory('sourceDamage', evt => evt.card === event.card);
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            trigger.addCount = false;
                                            if (player.stat[player.stat.length - 1].card.sha > 0) player.stat[player.stat.length - 1].card.sha--;
                                            game.log(trigger.card, '不计入次数限制');
                                        },
                                    },
                                },
                            },
                            //蹋顿 怎么是这版本
                            miniluanzhan: {
                                audio: 'luanzhan',
                                trigger: { player: 'useCardToPlayered', source: 'damageSource' },
                                forced: true,
                                locked: false,
                                filter(event, player) {
                                    if (event.name == 'damage') return true;
                                    if (!event.isFirstTarget || (event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('miniluanzhan')) return false;
                                    const info = get.info(event.card);
                                    if (info.allowMultiple == false || info.multitarget) return false;
                                    return event.targets.length < player.countMark('miniluanzhan');
                                },
                                content() {
                                    if (trigger.name == 'damage') player.addMark(event.name, 1, false);
                                    else player.removeMark(event.name, Math.ceil(player.countMark(event.name) / 2), false);
                                },
                                intro: { content: 'mark' },
                                ai: { notemp: true },
                                group: 'miniluanzhan_add',
                                subSkill: {
                                    add: {
                                        audio: 'luanzhan',
                                        trigger: { player: 'useCard2' },
                                        filter(event, player) {
                                            if ((event.card.name != 'sha' && (get.color(event.card) != 'black' || get.type(event.card) != 'trick')) || !player.countMark('miniluanzhan')) return false;
                                            const info = get.info(event.card);
                                            if (info.allowMultiple == false) return false;
                                            if (event.targets && !info.multitarget) {
                                                return game.hasPlayer(current => {
                                                    return !event.targets.includes(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                                                })
                                            }
                                            return false;
                                        },
                                        async cost(event, trigger, player) {
                                            const num = player.countMark('miniluanzhan');
                                            const { card, targets } = trigger;
                                            const prompt2 = '为' + get.translation(card) + '增加至多' + get.cnNumber(num) + '个目标';
                                            event.result = await player.chooseTarget(get.prompt("reluanzhan"), (card, player, target) => {
                                                const { card: card1, targets } = get.event();
                                                if (targets.includes(target)) return false;
                                                return lib.filter.targetEnabled2(card1, get.player(), target) && lib.filter.targetInRange(card1, get.player(), target);
                                            }, [1, num]).set('prompt2', prompt2).set("ai", target => {
                                                const trigger = get.event().getTrigger();
                                                const player = get.player();
                                                return get.effect(target, trigger.card, player, player);
                                            }).set('card', card).set('targets', targets).forResult();
                                        },
                                        content() {
                                            if (!event.isMine() && !event.isOnline()) game.delayx();
                                            trigger.targets.addArray(event.targets);
                                        },
                                    }
                                }
                            },
                            //高览
                            minixizhen: {
                                audio: 'xizhen',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && (player.canUse('sha', current, false) || player.canUse('juedou', current, false));
                                    })
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minixizhen'), '视为对一名角色使用【杀】或【决斗】', function (card, player, target) {
                                        return target != player && (player.canUse('sha', target, false) || player.canUse('juedou', target, false));
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        var eff1 = 0, eff2 = 0;
                                        if (player.canUse('sha', target, false)) eff1 = get.effect(target, { name: 'sha' }, player, player);
                                        if (player.canUse('juedou', target, false)) eff2 = get.effect(target, { name: 'juedou' }, player, player);
                                        var effx = Math.max(eff1, eff2);
                                        if (effx <= 0) return 0;
                                        if (target.isHealthy()) effx *= 3;
                                        if (get.attitude(player, target) > 0) effx *= 1.6;
                                        return effx;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minixizhen', target);
                                        var list = [];
                                        if (player.canUse('sha', target, false)) list.push('sha');
                                        if (player.canUse('juedou', target, false)) list.push('juedou');
                                        if (list.length == 1) event._result = { control: list[0] };
                                        else player.chooseControl(list).set('prompt', '视为对' + get.translation(target) + '使用…').set('ai', function () {
                                            var player = _status.event.player, target = _status.event.getParent().target;
                                            var eff1 = get.effect(target, { name: 'sha' }, player, player), eff2 = get.effect(target, { name: 'juedou' }, player, player);
                                            return eff1 > eff2 ? 0 : 1;
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.useCard({ name: result.control, isCard: true }, target, false);
                                    'step 3'
                                    if (target.isIn()) {
                                        player.storage.minixizhen_effect = target;
                                        player.addTempSkill('minixizhen_effect', 'phaseUseAfter');
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        audio: 'xizhen',
                                        trigger: { global: ['useCard', 'respond'] },
                                        filter(event, player) {
                                            return Array.isArray(event.respondTo) && event.respondTo[0] == player && player.storage.minixizhen_effect?.isIn();
                                        },
                                        forced: true,
                                        logTarget(event, player) {
                                            return player.storage.minixizhen_effect;
                                        },
                                        content() {
                                            player.storage.minixizhen_effect.recover();
                                            player.draw(2);
                                        },
                                        mark: 'character',
                                        intro: { content: '已指定$为目标' },
                                    },
                                },
                            },
                            minizhenliang: {
                                inherit: 'nzry_zhenliang',
                                drawNum: 2,
                                intro: {
                                    content(storage, player) {
                                        if (storage) return '你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”类别相同，则你可以令一名角色摸两张牌。';
                                        return '出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。';
                                    },
                                },
                                trigger: { global: ['useCardAfter', 'respondAfter'] },
                                filter(event, player) {
                                    const cards = player.getExpansions('nzry_mingren');
                                    if (!cards.length) return false;
                                    if (event.name === 'chooseToUse') {
                                        if (player.storage.minizhenliang || player.hasSkill('minizhenliang_used', null, null, false)) return false;
                                        const color = get.color(cards[0]);
                                        if (!player.hasCard(card => get.color(card) === color && lib.filter.cardDiscardable(card, player))) return false;
                                        return game.hasPlayer(current => player.inRange(current));
                                    } else {
                                        if (_status.currentPhase === player || !player.storage.minizhenliang) return false;
                                        return get.type2(event.card) === get.type2(cards[0]);
                                    }
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget(get.prompt('minizhenliang')).set('ai', target => {
                                        const player = get.player();
                                        return get.effect(target, { name: 'draw' }, player, player);
                                    }).set('prompt2', `令一名角色摸两张牌`).forResult();
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            miniyouqi: {
                                audio: 'dcyouqi',
                                trigger: { global: 'loseAfter' },
                                filter(event, player) {
                                    if (event.getParent(3).name.indexOf('dcyinlu_') !== 0 || player == event.player) return false;
                                    return true;
                                },
                                forced: true,
                                content() {
                                    player.gain(trigger.cards.filterInD('d'), 'gain2');
                                },
                            },
                            //界袁术
                            miniyongsi: {
                                audio: 'yongsi',
                                trigger: { player: ['phaseDrawBegin2', 'phaseDiscardBegin', 'phaseEnd'] },
                                forced: true,
                                filter(event, player) {
                                    if (event.name == 'phaseDraw') return !event.numFixed;
                                    if (event.name == 'phaseDiscard') return player.countCards('he');
                                    return player.getHistory('sourceDamage').reduce((num, evt) => num + evt.num, 0) <= 1;
                                },
                                async content(event, trigger, player) {
                                    const num = game.countGroup();
                                    if (trigger.name == 'phaseDraw') trigger.num += num;
                                    else if (trigger.name == 'phaseDiscard') await player.chooseToDiscard(num, 'he', true);
                                    else await player.draw(num);
                                },
                            },
                            minireweidi: {
                                audio: 'weidi',
                                getCards(event) {
                                    const cards = [];
                                    game.getGlobalHistory('cardMove', evt => {
                                        if (evt.name == 'cardsDiscard' && evt.getParent('phaseDiscard') == event) cards.addArray(evt.cards.filterInD('d'));
                                    });
                                    game.countPlayer2(current => {
                                        current.getHistory('lose', evt => {
                                            if (evt.type != 'discard' || evt.getParent('phaseDiscard') != event) return;
                                            cards.addArray(evt.cards.filterInD('d'));
                                        })
                                    });
                                    return cards;
                                },
                                preHidden: true,
                                trigger: { player: 'phaseDiscardEnd' },
                                filter(event, player) {
                                    return get.info('minireweidi').getCards(event).length;
                                },
                                async cost(event, trigger, player) {
                                    const cards = get.info(event.skill).getCards(trigger);
                                    const list = cards.map(card => get.color(card)).toUniqued();
                                    const dialog = ui.create.dialog();
                                    dialog.addText('伪帝：请选择一张颜色');
                                    dialog.addAuto(cards);
                                    const control = await player.chooseControl(list, 'cancel2').set('dialog', dialog).set('ai', () => {
                                        const { player, cards, controls } = get.event();
                                        if (!game.hasPlayer(current => current != player && get.attitude(player, current) > 0)) return 'cancel2';
                                        const map = {}, list = [];
                                        for (const color of controls.remove('cancel2')) {
                                            if (typeof map[color] != 'number') map[color] = 0;
                                            map[color] += cards.filter(card => get.color(card) == color).length;
                                        } for (let i in map) {
                                            if (map[i] > 0) list.push([i, map[i]]);
                                        }
                                        list.sort((a, b) => b[1] - a[1]);
                                        return list[0][0];
                                    }).set('cards', cards).forResultControl();
                                    if (control == 'cancel2') return;
                                    const give = cards.filter(card => get.color(card) == control);
                                    const targets = await player.chooseTarget(lib.filter.notMe, get.prompt(event.skill), `选择一名其他角色交给其${get.translation(give)}`).set('ai', target => {
                                        const { player, give } = get.event();
                                        return get.attitude(player, target) * get.value(give, target) * (target.hasSkillTag('nogain') ? 0.1 : 1);
                                    }).set('give', give).setHiddenSkill(event.skill).forResultTargets();
                                    event.result = {
                                        bool: targets?.length,
                                        targets: targets,
                                        cost_data: give,
                                    }
                                },
                                async content(event, trigger, player) {
                                    const { targets: [target], cost_data: cards } = event;
                                    await target.gain(cards, 'gain2').set('giver', player);
                                    const color = get.color(cards[0]);
                                    if (target.group != 'qun' || !target.hasCard(card => get.color(card) != color, 'he')) return;
                                    const num = cards.length;
                                    await target.chooseToGive(player, 'he', card => get.color(card) != get.event('color'), num, true).set('color', color);
                                },
                            },
                            //蔡邕
                            minibizhuan: {
                                audio: 'rebizhuan',
                                inherit: 'rebizhuan',
                                trigger: {
                                    player: 'useCardAfter',
                                    target: 'useCardToTargeted',
                                },
                                filter(event, player) {
                                    if (event.name != 'useCard' && event.player == event.target) return false;
                                    const num = 4 + Math.min(player.countMark('minitongbo'), game.countPlayer());
                                    if (player.countExpansions('minibizhuan') >= num) return false;
                                    return get.color(event.card) == 'black';
                                },
                                content() {
                                    player.addToExpansion(get.cards(), 'gain2').gaintag.add(event.name);
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countExpansions('minibizhuan');
                                    },
                                },
                            },
                            minitongbo: {
                                audio: 'retongbo',
                                trigger: { player: 'phaseDrawAfter' },
                                filter(event, player) {
                                    return player.countExpansions('minibizhuan') && player.countCards('h');
                                },
                                async cost(event, trigger, player) {
                                    const next = player.chooseToMove('通博：是否交换“书”和手牌？');
                                    next.set('list', [
                                        [get.translation(player) + '（你）的“书”', player.getExpansions('minibizhuan')],
                                        ['你的牌', player.getCards('he')],
                                    ]);
                                    next.set('filterMove', (from, to) => {
                                        return typeof to != 'number';
                                    });
                                    next.set('processAI', (list) => {
                                        let player = get.player(),
                                            cards = list[0][1].concat(list[1][1]),
                                            cards2 = [];
                                        cards.sort((a, b) => {
                                            return get.useful(a) - get.useful(b);
                                        });
                                        cards2 = cards.splice(0, player.getExpansions('minibizhuan').length);
                                        return [cards2, cards];
                                    });
                                    const { result: { moved } } = await next;
                                    event.result = {
                                        bool: moved?.[0]?.some(card => player.getCards('he').includes(card)),
                                        cost_data: moved,
                                    };
                                },
                                async content(event, trigger, player) {
                                    const { cost_data: moved } = event;
                                    const pushs = moved[0], gains = moved[1];
                                    pushs.removeArray(player.getExpansions('minibizhuan'));
                                    gains.removeArray(player.getCards('he'));
                                    if (!pushs.length || pushs.length != gains.length) return;
                                    const next = player.addToExpansion(pushs, 'give', player);
                                    next.gaintag.add('minibizhuan');
                                    await next;
                                    await player.gain(gains, 'gain2');
                                    const expansions = player.getExpansions('minibizhuan');
                                    if (expansions.length < 4) return;
                                    if (_status.connectMode) game.broadcastAll(() => {
                                        _status.noclearcountdown = true;
                                    });
                                    const given_map = {};
                                    event.given_map = given_map;
                                    let result;
                                    while (Object.values(given_map).flat().length < 4) {
                                        if (expansions.length > 1) {
                                            result = await player.chooseCardButton('通博：请选择要分配的牌', true, expansions, [1, expansions.length]).set('ai', button => {
                                                const { player, goon } = get.event();
                                                if (!goon) return 0;
                                                if (ui.selected.buttons.length) return 0;
                                                return get.value(button.link);
                                            }).set('goon', game.hasPlayer(current => current != player && get.attitude(player, current) > 0)).forResult();
                                        } else if (expansions.length === 1) result = { bool: true, links: expansions.slice(0) };
                                        else return;
                                        if (!result.bool) return;
                                        const toGive = result.links;
                                        result = await player.chooseTarget(`选择一名角色获得${get.translation(toGive)}`, expansions.length === 1, lib.filter.notMe).set('ai', target => {
                                            const { player, toEnemy } = get.event();
                                            const att = get.attitude(player, target);
                                            if (toEnemy) return -att;
                                            else if (att > 0) return att / (1 + target.countCards('h'));
                                            else return att / 100;
                                        }).set('toEnemy', get.value(toGive[0], player, 'raw') < 0).forResult();
                                        if (result.bool) {
                                            expansions.removeArray(toGive);
                                            if (result.targets.length) {
                                                const id = result.targets[0].playerid;
                                                if (!given_map[id]) given_map[id] = [];
                                                given_map[id].addArray(toGive);
                                            }
                                            if (!expansions.length) break;
                                        }
                                    }
                                    if (_status.connectMode) game.broadcastAll(() => {
                                        delete _status.noclearcountdown;
                                        game.stopCountChoose();
                                    });
                                    const gain_list = [];
                                    for (const i in given_map) {
                                        const source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, 'green');
                                        gain_list.push([source, given_map[i]]);
                                        game.log(source, '获得了', given_map[i]);
                                    }
                                    if (gain_list.length) {
                                        await game.loseAsync({
                                            gain_list,
                                            giver: player,
                                            animate: 'gain2',
                                        }).setContent('gaincardMultiple');
                                        await player.recover();
                                        player.addMark(event.name, 1, false);
                                    }
                                },
                                marktext: '博',
                                intro: {
                                    content(storage, player) {
                                        const num = 4 + Math.min(storage, game.countPlayer());
                                        return '“书”的上限+' + num;
                                    },
                                },
                                ai: { combo: 'minibizhuan' },
                            },
                            //神
                            miniwuqian: {
                                derivation: 'wushuang',
                                audio: 'ol_wuqian',
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    if (!_status.currentPhase || player != _status.currentPhase) return false;
                                    if (!['sha', 'juedou'].includes(event.card.name) || !event.isFirstTarget) return false;
                                    return player.getHistory('useCard', function (evt) {
                                        return (evt.card.name == 'sha' || evt.card.name == 'juedou');
                                    }).indexOf(event.getParent()) == 0;
                                },
                                forced: true,
                                logTarget: 'targets',
                                content() {
                                    for (var target of trigger.targets) {
                                        target.addTempSkill('qinggang2');
                                        target.storage.qinggang2.add(trigger.card);
                                        if (trigger.card.name == 'sha') {
                                            var id = target.playerid;
                                            var map = trigger.getParent().customArgs;
                                            if (!map[id]) map[id] = {};
                                            if (typeof map[id].shanRequired == 'number') map[id].shanRequired++;
                                            else map[id].shanRequired = 2;
                                        }
                                        else {
                                            var id = target.playerid;
                                            var idt = target.playerid;
                                            var map = trigger.getParent().customArgs;
                                            if (!map[idt]) map[idt] = {};
                                            if (!map[idt].shaReq) map[idt].shaReq = {};
                                            if (!map[idt].shaReq[id]) map[idt].shaReq[id] = 1;
                                            map[idt].shaReq[id]++;
                                        }
                                    }
                                },
                                ai: {
                                    unequip_ai: true,
                                    skillTagfilter(player, tag, arg) {
                                        if (arg?.card && !player.getHistory('useCard', function (evt) {
                                            return (evt.card.name == 'sha' || evt.card.name == 'juedou');
                                        }).length && ['sha', 'juedou'].includes(arg.card.name)) return true;
                                        return false;
                                    },
                                },
                            },
                            minishenfen: {
                                unique: true,
                                mark: true,
                                limited: true,
                                audio: 'ol_shenfen',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hp > 3;
                                },
                                skillAnimation: true,
                                animationColor: 'metal',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minishenfen');
                                    player.loseHp(3);
                                    event.delay = false;
                                    event.targets = game.filterPlayer();
                                    event.targets.remove(player);
                                    event.targets.sort(lib.sort.seat);
                                    player.line(event.targets, 'green');
                                    event.targets2 = event.targets.slice(0);
                                    event.targets3 = event.targets.slice(0);
                                    'step 1'
                                    if (event.targets2.length) {
                                        event.targets2.shift().damage('nocard');
                                        event.redo();
                                    }
                                    'step 2'
                                    if (event.targets.length) {
                                        event.current = event.targets.shift()
                                        if (event.current.countCards('e')) event.delay = true;
                                        event.current.discard(event.current.getCards('e')).delay = false;
                                    }
                                    'step 3'
                                    if (event.delay) game.delay(0.5);
                                    event.delay = false;
                                    if (event.targets.length) event.goto(2);
                                    'step 4'
                                    if (event.targets3.length) {
                                        var target = event.targets3.shift();
                                        target.chooseToDiscard(4, 'h', true).delay = false;
                                        if (target.countCards('h')) event.delay = true;
                                    }
                                    'step 5'
                                    if (event.delay) game.delay(0.5);
                                    event.delay = false;
                                    if (event.targets3.length) event.goto(4);
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        player(player) {
                                            if (player.hp < 5 || player.hasUnknown()) return 0;
                                            return game.countPlayer(function (current) {
                                                if (current != player) {
                                                    return get.sgn(get.damageEffect(current, player, player));
                                                }
                                            });
                                        },
                                    },
                                },
                            },
                            minishelie: {
                                audio: 'shelie',
                                inherit: 'shelie',
                                forced: true,
                            },
                            minigongxin: {
                                audio: 'gongxin',
                                audioname: ['re_lvmeng'],
                                trigger: { player: 'useCardToPlayered', target: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (event.player == event.target || event.targets.length != 1) return false;
                                    return (player == event.player ? event.target : event.player).countCards('h');
                                },
                                logTarget(event, player) {
                                    return player == event.player ? event.target : event.player;
                                },
                                check(event, player) {
                                    return get.attitude(player, player == event.player ? event.target : event.player) <= 0;
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    var target = (player == trigger.player ? trigger.target : trigger.player);
                                    event.target = target;
                                    event.videoId = lib.status.videoId++;
                                    var cards = target.getCards('h');
                                    if (player.isOnline2()) {
                                        player.send(function (cards, id) {
                                            ui.create.dialog('攻心', cards).videoId = id;
                                        }, cards, event.videoId);
                                    }
                                    event.dialog = ui.create.dialog('攻心', cards);
                                    event.dialog.videoId = event.videoId;
                                    if (!event.isMine()) {
                                        event.dialog.style.display = 'none';
                                    }
                                    player.chooseButton().set('filterButton', function (button) {
                                        return get.color(button.link) == 'red';
                                    }).set('dialog', event.videoId).set('ai', function (button) {
                                        return get.value(button.link);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        event.card = result.links[0];
                                        var func = function (card, id) {
                                            var dialog = get.idDialog(id);
                                            if (dialog) {
                                                for (var i = 0; i < dialog.buttons.length; i++) {
                                                    if (dialog.buttons[i].link == card) {
                                                        dialog.buttons[i].classList.add('selectedx');
                                                    }
                                                    else {
                                                        dialog.buttons[i].classList.add('unselectable');
                                                    }
                                                }
                                            }
                                        }
                                        if (player.isOnline2()) {
                                            player.send(func, event.card, event.videoId);
                                        }
                                        else if (event.isMine()) {
                                            func(event.card, event.videoId);
                                        }
                                        player.chooseControl('获得此牌', '置于牌堆顶');
                                    }
                                    else {
                                        if (player.isOnline2()) {
                                            player.send('closeDialog', event.videoId);
                                        }
                                        event.dialog.close();
                                        event.finish();
                                    }
                                    'step 2'
                                    if (player.isOnline2()) {
                                        player.send('closeDialog', event.videoId);
                                    }
                                    event.dialog.close();
                                    var card = event.card;
                                    if (result.control == '置于牌堆顶') {
                                        player.showCards(card, '置于牌堆顶');
                                        target.lose(card, ui.cardPile, 'insert', 'visible');
                                        game.log(player, '将', event.card, '置于牌堆顶');
                                    }
                                    else player.gain(card, target, 'give');
                                },
                                ai: { expose: 0.25 },
                            },
                            minikuangfeng: {
                                audio: 'kuangfeng',
                                trigger: { player: 'phaseUseEnd' },
                                filter(event, player) {
                                    return player.getExpansions('qixing').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var num = Math.min(game.countPlayer(), player.getExpansions('qixing').length);
                                    player.chooseTarget(get.prompt2('minikuangfeng'), [1, num]).set('ai', target => {
                                        var player = _status.event.player;
                                        return get.damageEffect(target, player, player);
                                    }).set('animate', false);
                                    'step 1'
                                    if (result.bool) {
                                        var targets = event.targets = result.targets.sortBySeat();
                                        player.chooseButton(['请选择要移去的“星”', player.getExpansions('qixing')], targets.length, true).set('ai', button => -get.value(button.link));
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        player.logSkill(event.name, targets);
                                        player.loseToDiscardpile(result.links);
                                    }
                                    else event.finish();
                                    'step 3'
                                    for (var i of targets) i.damage();
                                },
                                ai: { combo: 'qixing' },
                            },
                            minidawu: {
                                audio: 'dawu',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return player.getExpansions('qixing').length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseButton([get.prompt('minidawu'), player.getExpansions('qixing')]).set('ai', button => {
                                        var player = _status.event.player;
                                        if (!game.hasPlayer(current => get.attitude(current, player) < 0)) return 0;
                                        return 1 / Math.max(0.01, get.value(button.link));
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minidawu');
                                        player.loseToDiscardpile(result.links);
                                        player.addTempSkill('minidawu_damage', { player: 'phaseBegin' });
                                    }
                                },
                                ai: { combo: 'qixing' },
                                subSkill: {
                                    damage: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '受到的非属性伤害-1' },
                                        trigger: { player: 'damageBegin3' },
                                        filter(event) {
                                            return event.num > 0 && !event.nature;
                                        },
                                        forced: true,
                                        content() {
                                            trigger.num--;
                                        },
                                        ai: {
                                            effect: {
                                                target(card, player, target) {
                                                    if (player.hasSkillTag('jueqing', false, target)) return;
                                                    if (get.nature(card)) return;
                                                    var num = get.tag(card, 'damage');
                                                    if (num) {
                                                        if (num > 1) return 0.5;
                                                        return 0;
                                                    }
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            miniguixin: {
                                audio: 'guixin',
                                trigger: { player: 'damageEnd' },
                                check(event, player) {
                                    if (player.isTurnedOver() || event.num > 1 || (game.countPlayer() - 1 < 5 && game.countPlayer(function (current) {
                                        return get.attitude(player, current) <= 0 && current.countGainableCards(player, 'hej') > 0;
                                    }) >= game.countPlayer(function (currentx) {
                                        return get.attitude(player, currentx) > 0 && currentx.countGainableCards(player, 'hej') > 0;
                                    }))) return true;
                                    var num = game.countPlayer(function (current) {
                                        if (current.countCards('he') && current != player && get.attitude(player, current) <= 0) return true;
                                        if (current.countCards('j') && current != player && get.attitude(player, current) > 0) return true;
                                    });
                                    return num >= 2;
                                },
                                content() {
                                    'step 0'
                                    var targets = game.filterPlayer();
                                    targets.remove(player);
                                    targets.sort(lib.sort.seat);
                                    event.targets = targets;
                                    event.count = trigger.num;
                                    'step 1'
                                    event.count--;
                                    event.num = 0;
                                    event.numx = 0;
                                    player.line(targets, 'green');
                                    player.chooseControl('手牌区', '装备区', '判定区').set('ai', function () {
                                        if (game.hasPlayer(function (current) {
                                            return current.countCards('j') && current != player && get.attitude(player, current) > 0;
                                        })) return 2;
                                        return Math.floor(Math.random() * 3);
                                    }).set('prompt', '请选择优先获得的区域');
                                    'step 2'
                                    event.range = {
                                        手牌区: ['h', 'e', 'j'],
                                        装备区: ['e', 'h', 'j'],
                                        判定区: ['j', 'h', 'e'],
                                    }[result.control || '手牌区'];
                                    'step 3'
                                    if (num < event.targets.length) {
                                        var target = event.targets[num];
                                        var range = event.range;
                                        for (var i = 0; i < range.length; i++) {
                                            var cards = target.getCards(range[i]);
                                            if (cards.length) {
                                                var card = cards.randomGet();
                                                event.numx++;
                                                player.gain(card, target, 'giveAuto', 'bySelf');
                                                break;
                                            }
                                        }
                                        event.num++;
                                    }
                                    'step 4'
                                    if (num < event.targets.length) event.goto(3);
                                    'step 5'
                                    if (event.numx > 4 && !player.isTurnedOver()) player.turnOver();
                                    'step 6'
                                    if (event.count > 0 && player.hasSkill('miniguixin')) player.chooseBool(get.prompt2('new_guixin')).ai = function () {
                                        return lib.skill.miniguixin.check({ num: event.count }, player);
                                    };
                                    else event.finish();
                                    'step 7'
                                    if (event.count && result.bool) event.goto(1);
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    threaten(player, target) {
                                        if (target.hp == 1) return 2.5;
                                        return 1;
                                    },
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, 'damage')) {
                                                if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                if (target.hp == 1) return 0.8;
                                                if (target.isTurnedOver()) return [0, 3];
                                                var num = game.countPlayer(function (current) {
                                                    if (current.countCards('he') && current != player && get.attitude(player, current) <= 0) {
                                                        return true;
                                                    }
                                                    if (current.countCards('j') && current != player && get.attitude(player, current) > 0) {
                                                        return true;
                                                    }
                                                });
                                                if (num > 2) return [0, 1];
                                                if (num == 2) return [0.5, 1];
                                            }
                                        },
                                    },
                                },
                            },
                            miniwushen: {
                                mod: {
                                    cardnature(card) {
                                        if (get.suit(card) == 'heart' && get.name(card) == 'sha') return false;
                                    },
                                    targetInRange(card) {
                                        if (get.suit(card) == 'heart' && get.name(card) == 'sha') return true;
                                    },
                                },
                                group: 'miniwushen_wusheng',
                                audio: 'wushen',
                                trigger: { source: 'damageBegin1' },
                                forced: true,
                                locked: false,
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && get.suit(event.card) == 'heart';
                                },
                                content() {
                                    trigger.num++;
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondSha') && current < 0) return 0.6
                                        },
                                    },
                                    directHit_ai: true,
                                    skillTagfilter(player, tag, arg) {
                                        return arg.card.name == 'sha' && get.suit(arg.card) == 'heart';
                                    },
                                },
                                subSkill: {
                                    wusheng: {
                                        audio: 'wushen',
                                        enable: ['chooseToRespond', 'chooseToUse'],
                                        filterCard(card, player) {
                                            return get.suit(card) == 'heart';
                                        },
                                        position: 'hs',
                                        viewAs: { name: 'sha' },
                                        viewAsFilter(player) {
                                            if (!player.countCards('hs', { suit: 'heart' })) return false;
                                            return true;
                                        },
                                        prompt: '将一张红桃手牌当作杀使用或打出',
                                        check(card) {
                                            var val = get.value(card);
                                            if (_status.event.name == 'chooseToRespond') return 1 / Math.max(0.1, val);
                                            return 8 - val;
                                        },
                                        ai: {
                                            respondSha: true,
                                            skillTagFilter(player) {
                                                if (!player.countCards('hs', { suit: 'heart' })) return false;
                                                return true;
                                            },
                                        },
                                    },
                                },
                            },
                            miniwuhun: {
                                audio: 'wuhun2',
                                group: ['miniwuhun_mark', 'miniwuhun_die'],
                                trigger: { player: 'damageEnd' },
                                filter(event, player) {
                                    return event.source && event.source.isIn();
                                },
                                forced: true,
                                logTarget: 'source',
                                content() {
                                    trigger.source.addMark('miniwuhun_mark', trigger.num);
                                },
                                subSkill: {
                                    die: {
                                        audio: 'wuhun2',
                                        skillAnimation: true,
                                        animationColor: 'soil',
                                        trigger: { player: ['die', 'dyingAfter'] },
                                        filter(event, player) {
                                            if (event.name == 'dying' && !player.isIn()) return false;
                                            return game.hasPlayer(current => current != player && current.hasMark('miniwuhun_mark'));
                                        },
                                        forced: true,
                                        forceDie: true,
                                        content() {
                                            'step 0'
                                            var num = game.findPlayer(target => target != player && !game.hasPlayer(current => current != player && current.countMark('miniwuhun_mark') < target.countMark('miniwuhun_mark'))).countMark('miniwuhun_mark');
                                            player.chooseTarget('请选择【武魂】的目标', function (card, player, target) {
                                                return target != player && target.countMark('miniwuhun_mark') == _status.event.num;
                                            }).set('ai', function (target) {
                                                return -get.attitude(_status.event.player, target);
                                            }, true).set('forceDie', true).set('num', num);
                                            'step 1'
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                event.target = target;
                                                player.line(target, { color: [255, 255, 0] });
                                                game.delay(2);
                                            }
                                            'step 2'
                                            target.judge(card => ['tao', 'taoyuan'].includes(card.name) ? 10 : -10);
                                            'step 3'
                                            if (!result.bool) target.loseHp(5);
                                        },
                                    },
                                    mark: {
                                        marktext: '魇',
                                        intro: {
                                            name: '梦魇',
                                            content: 'mark',
                                        },
                                    },
                                },
                                ai: {
                                    threaten: 0.01,
                                    notemp: true,
                                },
                            },
                            miniyeyan: {
                                audio: 'yeyan',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('miniyeyan'), lib.filter.notMe).set('ai', target => {
                                        var player = _status.event.player;
                                        return get.damageEffect(target, player, player);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniyeyan', result.targets[0]);
                                        result.targets[0].damage('fire');
                                    }
                                },
                            },
                            miniqinyin: {
                                audio: 'qinyin',
                                trigger: { player: 'phaseDiscardEnd' },
                                filter(event, player) {
                                    return player.getHistory('lose', function (evt) {
                                        return evt.type == 'discard' && evt.getParent('phaseDiscard') == event;
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    event.forceDie = true;
                                    var list = ['失去体力', '回复体力', '摸牌', 'cancel2'];
                                    player.chooseControl(list).set('ai', function () {
                                        var player = _status.event.player;
                                        var list = [
                                            game.filterPlayer().reduce((sum, target) => sum + get.effect(target, { name: 'losehp' }, player, player), 0),
                                            player.getUseValue({ name: 'taoyuan' }),
                                            player.getUseValue({ name: 'wugu' }),
                                            0,
                                        ];
                                        var num = list.slice().sort((a, b) => b - a)[0];
                                        return _status.event.controls[list.indexOf(num)];
                                    }).set('prompt', get.prompt2('miniqinyin'));
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('miniqinyin');
                                        if (result.control == '失去体力') game.playAudio('skill', 'qinyin2');
                                        else game.playAudio('skill', 'qinyin1');
                                        if (result.control == '摸牌') game.asyncDraw(game.filterPlayer());
                                        else {
                                            game.filterPlayer().forEach(target => target[result.control == '失去体力' ? 'loseHp' : 'recover']());
                                            event.finish();
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    game.delayx();
                                },
                                ai: { expose: 0.2 },
                            },
                            minilongnu: {
                                audio: 'nzry_longnu',
                                trigger: { player: 'phaseUseBegin' },
                                forced: true,
                                content() {
                                    'step 0'
                                    var list = [
                                        '失去1点体力并摸两张牌，本回合你的红色手牌均视为火杀且无距离限制',
                                        '减1点体力上限，本回合你的黑色手牌均视为雷杀且无使用次数限制'
                                    ];
                                    player.chooseControl().set('choiceList', list).set('ai', function () {
                                        if (player.countCards() <= 3 && player.maxHp - player.hp <= 1) return 0;
                                        return 1;
                                    });
                                    'step 1'
                                    if (result.index == 0) {
                                        player.loseHp();
                                        player.draw(2);
                                        player.addTempSkill('minilongnu_1');
                                    }
                                    else {
                                        player.loseMaxHp();
                                        player.addTempSkill('minilongnu_2');
                                    }
                                },
                                subSkill: {
                                    '1': {
                                        mod: {
                                            cardname(card, player) {
                                                if (get.color(card) == 'red') return 'sha';
                                            },
                                            cardnature(card, player) {
                                                if (get.color(card) == 'red') return 'fire';
                                            },
                                            targetInRange(card) {
                                                if (card.name == 'sha' && card.hasNature('fire')) return true;
                                            },
                                        },
                                        ai: {
                                            respondSha: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.tag(card, 'respondSha') && current < 0) return 0.6
                                                },
                                            },
                                        },
                                    },
                                    '2': {
                                        mod: {
                                            cardname(card, player) {
                                                if (get.color(card) == 'black') return 'sha';
                                            },
                                            cardnature(card, player) {
                                                if (get.color(card) == 'black') return 'thunder';
                                            },
                                            cardUsable(card, player) {
                                                if (card.name == 'sha' && card.hasNature('thunder')) return Infinity;
                                            },
                                        },
                                        ai: {
                                            respondSha: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.tag(card, 'respondSha') && current < 0) return 0.6
                                                },
                                            },
                                        },
                                    },
                                },
                                ai: {
                                    fireAttack: true,
                                    halfneg: true,
                                },
                            },
                            minijieying: {
                                audio: 'nzry_jieying',
                                locked: true,
                                global: 'minijieying_all',
                                group: ['minijieying_1', 'minijieying_2', 'minijieying_3'],
                                subSkill: {
                                    '1': {
                                        audio: 'nzry_jieying',
                                        trigger: { player: ['linkBefore', 'enterGame'], global: 'phaseBefore' },
                                        forced: true,
                                        filter(event, player) {
                                            if (event.name == 'link') return player.isLinked();
                                            return (event.name != 'phase' || game.phaseNumber == 0) && !player.isLinked();
                                        },
                                        content() {
                                            if (trigger.name != 'link') player.link(true);
                                            else trigger.cancel();
                                        },
                                    },
                                    '2': {
                                        trigger: { player: 'phaseJieshuBegin' },
                                        direct: true,
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current != player && !current.isLinked();
                                            });
                                        },
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('minijieying'), '横置一名其他角色', function (card, player, target) {
                                                return target != player && !target.isLinked();
                                            }).ai = function (target) {
                                                return 1 + Math.random();
                                            };
                                            'step 1'
                                            if (result.bool) {
                                                player.logSkill('minijieying', result.targets[0]);
                                                result.targets[0].link(true);
                                            }
                                            else event.finish();
                                        },
                                    },
                                    '3': {
                                        audio: 'nzry_jieying',
                                        trigger: { player: 'damageBegin2' },
                                        forced: true,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    all: {
                                        mod: {
                                            maxHandcard(player, num) {
                                                if (player.isLinked()) return num + 2 * game.countPlayer(function (current) {
                                                    return current.hasSkill('minijieying');
                                                });
                                            },
                                        },
                                    },
                                },
                                ai: {
                                    effect: {
                                        target(card) {
                                            if (card.name == 'tiesuo') return 'zeroplayertarget';
                                        },
                                    },
                                },
                            },
                            miniduorui: {
                                audio: 'drlt_duorui',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards('h');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('miniduorui'), function (card, player, target) {
                                        if (player == target) return false;
                                        return target.countCards('h');
                                    }).set('ai', function (target) {
                                        return -get.attitude(player, target) * (target.getDamagedHp() + 1);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniduorui', result.targets[0]);
                                        player.gainPlayerCard(result.targets[0], 'h', true, 'visible');
                                        result.targets[0].addTempSkill('miniduorui_target');
                                    }
                                    else event.finish();
                                    'step 2'
                                    player.popup(get.translation(get.color(result.cards[0])));
                                    player.addTempSkill('miniduorui_' + get.color(result.cards[0]));
                                },
                                subSkill: {
                                    target: { charlotte: true },
                                    red: {
                                        audio: 'drlt_duorui',
                                        trigger: { player: 'useCard' },
                                        forced: true,
                                        filter(event, player) {
                                            return event.card && get.color(event.card) == 'red';
                                        },
                                        content() {
                                            trigger.directHit.addArray(game.filterPlayer(function (current) {
                                                return current.hasSkill('miniduorui_target');
                                            }));
                                        },
                                        ai: {
                                            directHit_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                return arg.target.hasSkill('miniduorui_target') && get.color(arg.card) == 'red';
                                            },
                                        },
                                    },
                                    black: {
                                        audio: 'drlt_duorui',
                                        trigger: { player: 'useCard' },
                                        forced: true,
                                        filter(event, player) {
                                            return event.card && get.color(event.card) == 'black';
                                        },
                                        content() {
                                            trigger.directHit.addArray(game.filterPlayer(function (current) {
                                                return current.hasSkill('miniduorui_target');
                                            }));
                                        },
                                        ai: {
                                            directHit_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                return arg.target.hasSkill('miniduorui_target') && get.color(arg.card) == 'black';
                                            },
                                        },
                                    },
                                },
                            },
                            minizhiti: {
                                mod: {
                                    cardUsable(card, player, num) {
                                        if (card.name == 'sha' && game.countPlayer(function (current) {
                                            return current.isDamaged();
                                        }) > 2) return num + 1;
                                    },
                                },
                                audio: 'drlt_zhiti',
                                trigger: { player: 'phaseDrawBegin2' },
                                forced: true,
                                filter(event, player) {
                                    return game.countPlayer(function (current) {
                                        return current.isDamaged();
                                    }) > 1;
                                },
                                content() {
                                    trigger.num++;
                                },
                            },
                            //劝退
                            miniquantui: {
                                marktext: '学',
                                intro: { content: 'mark', name2: '学' },
                                audio: 'ext:活动武将/audio/skill:true',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    game.addGlobalSkill('miniquantui_remove');
                                    player.chooseTarget(get.prompt2('miniquantui'), [1, 2], lib.filter.notMe).set('ai', function (target) {
                                        return !target.hasMark('miniquantui') && -get.attitude(player, target);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('miniquantui', targets);
                                        for (var i of targets) i.addMark('miniquantui', 1);
                                    }
                                },
                                ai: {
                                    threaten: 4.5,
                                    expose: 0.25,
                                },
                                subSkill: {
                                    remove: {
                                        charlotte: true,
                                        trigger: { player: 'phaseBegin' },
                                        filter(event, player) {
                                            return player.hasMark('miniquantui') && game.hasPlayer(function (current) {
                                                return current.hasSkill('miniquantui');
                                            });
                                        },
                                        forced: true,
                                        content() {
                                            'step 0'
                                            player.removeMark('miniquantui', player.countMark('miniquantui'));
                                            'step 1'
                                            player.chooseControl().set('choiceList', [
                                                '本回合不能对其他角色使用牌',
                                                '失去1点体力',
                                            ]).set('ai', function () {
                                                if ((player.countCards('h') < player.getHandcardLimit()) || player.hp <= 2) return 0;
                                                return 1;
                                            });
                                            'step 2'
                                            if (result.index == 0) player.addTempSkill('miniquantui_block');
                                            else player.loseHp();
                                        },
                                    },
                                    block: {
                                        mark: true,
                                        intro: { content: '不能对其他角色使用牌' },
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (player != target) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            minishehu: {
                                trigger: { player: 'useCardToPlayer' },
                                filter(event, player) {
                                    return event.card.name == 'sha' && event.target.hasMark('miniquantui') && event.target.countCards('h');
                                },
                                forced: true,
                                logTarget: 'target',
                                content() {
                                    player.discardPlayerCard('h', true, trigger.target);
                                },
                                ai: {
                                    unequip_ai: true,
                                    combo: 'miniquantui',
                                    skillTagFilter(player, tag, arg) {
                                        if (arg?.name == 'sha' && arg.target && arg.target.hasMark('miniquantui')) return true;
                                        return false;
                                    },
                                },
                            },
                            minidingli: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'logSkill' },
                                filter(event, player) {
                                    return event.skill == 'miniquantui_remove' && event.player != player;
                                },
                                check(event, player) {
                                    if (event.player.hp >= player.hp && player.isHealthy()) return false;
                                    return true;
                                },
                                round: 1,
                                logTarget: 'player',
                                content() {
                                    if (trigger.player.hp >= player.hp) player.recover();
                                    else player.draw(Math.min(2, player.hp - trigger.player.hp));
                                },
                                ai: { combo: 'miniquantui' },
                            },
                            minirenjie: {
                                unique: true,
                                group: 'minirenjie_lose',
                                audio: 'renjie2',
                                trigger: { player: ['enterGame', 'damageEnd'], global: 'phaseBefore' },
                                filter(event, player) {
                                    if (event.num == 'damage') return event.num > 0;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                notemp: true,
                                forced: true,
                                content() {
                                    player.addMark('minirenjie', trigger.num || 1);
                                },
                                marktext: '忍',
                                intro: { name: '忍', content: 'mark' },
                                subSkill: {
                                    lose: {
                                        audio: 'renjie2',
                                        trigger: { player: 'loseAfter' },
                                        filter(event, player) {
                                            if (event.type != 'discard' || !event.cards2) return false;
                                            var evt = event.getParent('phaseDiscard');
                                            return evt?.name == 'phaseDiscard' && evt.player == player;
                                        },
                                        forced: true,
                                        content() {
                                            player.addMark('minirenjie', trigger.cards2.length);
                                        },
                                    },
                                },
                            },
                            minijilve: {
                                unique: true,
                                audio: 'jilue',
                                derivation: ['minijilve_guicai', 'minijilve_fangzhu', 'minijilve_wansha', 'minijilve_jizhi'],
                                group: ['minijilve_guicai', 'minijilve_fangzhu', 'minijilve_wansha', 'minijilve_jizhi'],
                                trigger: { player: ['useSkill', 'logSkillBegin'] },
                                filter(event, player) {
                                    if (!lib.skill.minijilve.derivation.includes(event.skill)) return false;
                                    return player.getHistory('useSkill', evt => lib.skill.minijilve.derivation.includes(evt.skill)).length == 1;
                                },
                                frequent: true,
                                content() {
                                    player.draw();
                                },
                                subSkill: {
                                    guicai: {
                                        audio: 'jilue_guicai',
                                        trigger: { global: 'judge' },
                                        filter(event, player) {
                                            return player.countCards('hes') && player.hasMark('minirenjie');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseCard(get.prompt2('minijilve_guicai'), 'hes', function (card) {
                                                var player = _status.event.player;
                                                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                                if (mod2 != 'unchanged') return mod2;
                                                var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                                                if (mod != 'unchanged') return mod;
                                                return true;
                                            }).set('ai', function (card) {
                                                var trigger = _status.event.getTrigger();
                                                var player = _status.event.player;
                                                var judging = _status.event.judging;
                                                var result = trigger.judge(card) - trigger.judge(judging);
                                                var attitude = get.attitude(player, trigger.player);
                                                if (attitude == 0) {
                                                    if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                                    if (get.suit(card, player) == 'club') return 8;
                                                    return 0;
                                                }
                                                if (attitude > 0) {
                                                    if (result == 0) {
                                                        if (player.isDamaged() && get.suit(card, player) == 'heart') return 10;
                                                        if (get.suit(card, player) == 'club') return 8;
                                                        return 0;
                                                    }
                                                    return result - get.value(card) / 2;
                                                }
                                                else {
                                                    if (result == 0) {
                                                        if (player.isDamaged() && get.suit(card) == 'heart') return 10;
                                                        if (get.suit(card) == 'club') return 8;
                                                        return 0;
                                                    }
                                                    return -result - get.value(card) / 2;
                                                }
                                            }).set('judging', trigger.player.judging[0]);
                                            'step 1'
                                            if (result.bool) player.respond(result.cards, 'highlight', 'minijilve_guicai', 'noOrdering');
                                            else event.finish();
                                            'step 2'
                                            if (result.bool) {
                                                player.removeMark('minirenjie', 1);
                                                if (trigger.player.judging[0].clone) {
                                                    trigger.player.judging[0].clone.delete();
                                                    game.addVideo('deletenode', player, get.cardsInfo([trigger.player.judging[0].clone]));
                                                }
                                                game.cardsDiscard(trigger.player.judging[0]);
                                                trigger.player.judging[0] = result.cards[0];
                                                trigger.orderingCards.addArray(result.cards);
                                                game.log(trigger.player, '的判定牌改为', result.cards[0]);
                                                game.delay(2);
                                                event.card = result.cards[0];
                                            }
                                            else event.finish();
                                            'step 3'
                                            if (get.suit(card, player) == 'heart') player.recover();
                                            if (get.suit(card, player) == 'club') player.draw(2);
                                        },
                                        ai: {
                                            rejudge: true,
                                            tag: { rejudge: 1 },
                                        },
                                    },
                                    fangzhu: {
                                        audio: 'jilue_fangzhu',
                                        trigger: { player: 'damageEnd' },
                                        filter(event, player) {
                                            return player.hasMark('minirenjie');
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt2('minijilve_fangzhu'), lib.filter.notMe).ai = function (target) {
                                                if (target.hasSkillTag('noturn')) return 0;
                                                if (target.isTurnedOver()) return get.attitude(player, target);
                                                return -get.attitude(player, target);
                                            }
                                            'step 1'
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                player.logSkill('minijilve_fangzhu', target);
                                                player.removeMark('minirenjie', 1);
                                                target.turnOver();
                                                target.draw();
                                            }
                                        },
                                        ai: {
                                            maixie: true,
                                            maixie_hp: true,
                                            effect: {
                                                target(card, player, target) {
                                                    if (get.tag(card, 'damage')) {
                                                        if (player.hasSkillTag('jueqing', false, target)) return [1, -2];
                                                        if (target.hp <= 1) return;
                                                        if (!target.hasFriend()) return;
                                                        var hastarget = false;
                                                        var turnfriend = false;
                                                        var players = game.filterPlayer();
                                                        for (var i = 0; i < players.length; i++) {
                                                            if (get.attitude(target, players[i]) < 0 && !players[i].isTurnedOver()) {
                                                                hastarget = true;
                                                            }
                                                            if (get.attitude(target, players[i]) > 0 && players[i].isTurnedOver()) {
                                                                hastarget = true;
                                                                turnfriend = true;
                                                            }
                                                        }
                                                        if (get.attitude(player, target) > 0 && !hastarget) return;
                                                        if (turnfriend || target.hp == target.maxHp) return [0.5, 1];
                                                        if (target.hp > 1) return [1, 0.5];
                                                    }
                                                },
                                            },
                                        },
                                    },
                                    wansha: {
                                        audio: 'jilue_wansha',
                                        trigger: { global: 'dying' },
                                        filter(event, player) {
                                            if (!_status.currentPhase || player.hasSkill('minijilve_miniwansha')) return false;
                                            return player.hasMark('minirenjie') && player == _status.currentPhase;
                                        },
                                        check(event, player) {
                                            return get.attitude(player, event.player) < 0;
                                        },
                                        logTarget: 'player',
                                        content() {
                                            player.removeMark('minirenjie', 1);
                                            player.addTempSkill('minijilve_miniwansha', ['phaseBefore', 'phaseChange', 'phaseAfter']);
                                            game.log(player, '获得了', '#g【完杀】', '效果');
                                        },
                                    },
                                    miniwansha: {
                                        charlotte: true,
                                        global: 'minijilve_miniwanshax',
                                        mark: true,
                                        marktext: '杀',
                                        intro: { content: () => lib.translate.miniwansha_info },
                                    },
                                    miniwanshax: {
                                        mod: {
                                            cardSavable(card, player) {
                                                if (!_status.currentPhase || !_status.currentPhase.hasSkill('minijilve_miniwansha')) return;
                                                if (player != _status.currentPhase && card.name == 'tao') return false;
                                            },
                                            cardEnabled(card, player) {
                                                if (!_status.currentPhase || !_status.currentPhase.hasSkill('minijilve_miniwansha')) return;
                                                if (player != _status.currentPhase && card.name == 'tao') return false;
                                            },
                                        },
                                    },
                                    jizhi: {
                                        audio: 'jilue_jizhi',
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            return get.type2(event.card) == 'trick' && event.card.isCard && player.hasMark('minirenjie');
                                        },
                                        content() {
                                            'step 0'
                                            player.removeMark('minirenjie', 1);
                                            player.draw();
                                            'step 1'
                                            var card = result[0];
                                            event.card = card;
                                            if (['basic', 'trick', 'equip'].includes(get.type2(card))) {
                                                if (['basic', 'trick'].includes(get.type2(card))) {
                                                    player.addTempSkill('minirejizhi_' + get.type2(card));
                                                    player.addMark('minirejizhi_' + get.type2(card), 1, false);
                                                    event.finish();
                                                }
                                                else player.chooseTarget('集智：是否将' + get.translation(card) + '置入一名其他角色的装备栏？', function (card, player, target) {
                                                    return target != player && target.canEquip(_status.event.card);
                                                }).set('card', card).set('ai', function (target) {
                                                    var player = _status.event.player;
                                                    var card = _status.event.card;
                                                    if ((player.canEquip(_status.event.card) || get.equipValue(_status.event.card, target) < 0) && get.equipValue(card) > 0) return 0;
                                                    return get.attitude(player, target);
                                                });
                                            }
                                            else event.finish();
                                            'step 2'
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                player.line(target);
                                                player.$give(card, target, false);
                                                game.delay(0.5);
                                                target.equip(card);
                                            }
                                        },
                                    },
                                },
                            },
                            minijuejing: {
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + 3;
                                    },
                                },
                                audio: 'xinjuejing',
                                inherit: 'xinjuejing',
                            },
                            minilonghun: {
                                audio: 'relonghun',
                                inherit: 'relonghun',
                                group: ['minilonghun_num', 'minilonghun_gain'],
                                subSkill: {
                                    num: {
                                        charlotte: true,
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            return event.skill == 'minilonghun' && ['sha', 'tao'].includes(event.card.name) && event.cards?.length == 2;
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            trigger.baseDamage++;
                                            player.draw();
                                        },
                                    },
                                    gain: {
                                        charlotte: true,
                                        trigger: { player: ['useCardAfter', 'respondAfter'] },
                                        autodelay(event) {
                                            return event.name == 'respond' ? 0.5 : false;
                                        },
                                        filter(event, player) {
                                            return event.skill == 'minilonghun' && ['shan', 'wuxie'].includes(event.card.name) && event.cards?.length == 2 && _status.currentPhase && _status.currentPhase != player && _status.currentPhase.countGainableCards(player, 'he');
                                        },
                                        logTarget: () => _status.currentPhase,
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.line(_status.currentPhase, 'green');
                                            player.gainPlayerCard(_status.currentPhase, 'he', true);
                                        },
                                    },
                                },
                            },
                            minipoxi: {
                                audio: 'drlt_poxi',
                                enable: 'phaseUse',
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards('h');
                                },
                                usable: 1,
                                content() {
                                    'step 0'
                                    var chooseButton;
                                    event.list1 = [];
                                    event.list2 = [];
                                    if (player.countCards('h')) chooseButton = player.chooseButton(3, ['你的手牌', player.getCards('h'), get.translation(target.name) + '的手牌', target.getCards('h')]);
                                    else chooseButton = player.chooseButton(3, [get.translation(target.name) + '的手牌', target.getCards('h')]);
                                    chooseButton.set('target', target);
                                    chooseButton.set('ai', function (button) {
                                        var player = _status.event.player;
                                        var target = _status.event.target;
                                        var ps = [];
                                        var ts = [];
                                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                                            var card = ui.selected.buttons[i].link;
                                            if (target.getCards('h').includes(card)) ts.push(card);
                                            else ps.push(card);
                                        }
                                        var card = button.link;
                                        var owner = get.owner(card);
                                        var val = get.value(card) || 1;
                                        if (owner == target) {
                                            if (ts.length > 1) return 0;
                                            if (ts.length == 0 || player.hp > 3) return val;
                                            return 2 * val;
                                        }
                                        return 7 - val;
                                    });
                                    chooseButton.set('filterButton', function (button) {
                                        for (var i = 0; i < ui.selected.buttons.length; i++) {
                                            if (get.suit(button.link) == get.suit(ui.selected.buttons[i].link)) return false;
                                        };
                                        return true;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var list = result.links;
                                        for (var i = 0; i < list.length; i++) {
                                            if (get.owner(list[i]) == player) event.list1.push(list[i]);
                                            else event.list2.push(list[i]);
                                        }
                                        if (event.list1.length && event.list2.length) {
                                            game.loseAsync({
                                                lose_list: [
                                                    [player, event.list1],
                                                    [target, event.list2]
                                                ],
                                                discarder: player,
                                            }).setContent('discardMultiple');
                                        }
                                        else if (event.list2.length) target.discard(event.list2).discarder = player;
                                        else player.discard(event.list1);
                                    };
                                    'step 2'
                                    if (event.list1.length + event.list2.length != 3) return;
                                    if (event.list1.length == 0) player.loseMaxHp();
                                    if (event.list1.length == 2) {
                                        player.recover();
                                        player.draw();
                                    }
                                    if (event.list1.length == 3) player.draw(3);
                                },
                                ai: {
                                    order: 13,
                                    result: { target: -1 },
                                },
                            },
                            minishenwei: {
                                global: 'minishenwei_damage',
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(current => !current.hasMark('minishenwei'));
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var num = (player.hp == 1 ? [1, 2] : 1);
                                    player.chooseTarget(get.prompt2('minishenwei'), function (card, player, target) {
                                        return !target.hasMark('minishenwei');
                                    }, num).set('ai', function (target) {
                                        var player = _status.event.player, num = 2;
                                        if (target == player) num = 1;
                                        return (get.attitude(player, target) - 4) * num;
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var targets = result.targets.slice().sortBySeat();
                                        player.logSkill('minishenwei', targets);
                                        targets.forEach(target => target.addMark('minishenwei', 1));
                                    }
                                },
                                marktext: '卫',
                                intro: { name2: '卫', content: 'mark' },
                                ai: {
                                    expose: 0.25,
                                    threaten: 4.8,
                                },
                                subSkill: {
                                    damage: {
                                        trigger: { player: 'damageBegin4' },
                                        filter(event, player) {
                                            return player.hasMark('minishenwei') && game.hasPlayer(function (current) {
                                                return current.hasSkill('minishenwei');
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            player.chooseTarget(get.prompt('minishenwei'), '将伤害转移给一名拥有〖神卫〗的角色', function (card, player, target) {
                                                return target.hasSkill('minishenwei');
                                            }).set('ai', function (target) {
                                                var player = _status.event.player, att = get.attitude(player, target);
                                                if (att > 0 && player.hp > 1 && target.hp <= 1) return 0;
                                                return -att + 114514;
                                            });
                                            'step 1'
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                player.logSkill('minishenwei', target);
                                                player.removeMark('minishenwei', player.countMark('minishenwei'));
                                                event.trigger('removeShenWei');
                                                trigger.player = target;
                                            }
                                        },
                                    },
                                },
                            },
                            minielai: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'removeShenWei' },
                                filter(event, player) {
                                    return player.isDamaged() || game.hasPlayer(function (current) {
                                        return current != player && player.inRange(current);
                                    });
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    if (!game.hasPlayer(function (current) {
                                        return current != player && player.inRange(current);
                                    })) result.index = 0;
                                    else if (player.isHealthy()) result.index = 1;
                                    else player.chooseControl().set('choiceList', [
                                        '回复1点体力',
                                        '对攻击范围内的一名其他角色造成1点伤害'
                                    ]).set('ai', function () {
                                        var num = 3;
                                        if (player.hasSkill('minikuangxi') && game.hasPlayer(function (current) {
                                            return current.hasMark('minishenwei');
                                        })) num--;
                                        if (player.hp >= num && game.hasPlayer(function (current) {
                                            return current != player && get.damageEffect(current, player, player) > 0;
                                        })) return 1;
                                        return 0;
                                    });
                                    'step 1'
                                    if (result.index == 0) {
                                        player.recover();
                                        event.finish();
                                    }
                                    else player.chooseTarget('请选择【恶来】的目标', '对一名攻击范围内的一名其他角色造成1点伤害', true, function (card, player, target) {
                                        return target != player && player.inRange(target);
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.damageEffect(target, player, player) + 114514;
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        target.damage();
                                    }
                                },
                                ai: { combo: 'minishenwei' },
                            },
                            minikuangxi: {
                                trigger: { source: 'damageBegin1' },
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current.hasMark('minishenwei');
                                    });
                                },
                                forced: true,
                                content() {
                                    trigger.num++;
                                },
                                ai: { combo: 'minishenwei' },
                            },
                            minijishi: {
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + 3;
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                group: ['minijishi_recover', 'minijishi_lose'],
                                marktext: '药',
                                intro: { name2: '药', content: 'mark' },
                                trigger: { global: 'phaseBefore', player: 'enterGame' },
                                filter(event, player) {
                                    if (player.countMark('minijishi') >= 3) return false;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player.addMark('minijishi', Math.min(3, 3 - player.countMark('minijishi')));
                                },
                                ai: { threaten: 10 },
                                subSkill: {
                                    recover: {
                                        audio: 'minijishi',
                                        trigger: { global: 'dying' },
                                        filter(event, player) {
                                            return event.player.hp <= 0 && player.hasMark('minijishi');
                                        },
                                        prompt2(event, player) {
                                            return '令' + get.translation(event.player) + '回复体力至1点';
                                        },
                                        logTarget: 'player',
                                        check(event, player) {
                                            return get.recoverEffect(event.player, player, player) > 0;
                                        },
                                        content() {
                                            player.removeMark('minijishi', 1);
                                            trigger.player.recover(1 - trigger.player.hp);
                                        },
                                    },
                                    lose: {
                                        audio: 'minijishi',
                                        trigger: {
                                            player: 'loseAfter',
                                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                        },
                                        filter(event, player) {
                                            var bool = false;
                                            if (event.name == 'gain' && player == event.player) return false;
                                            var evt = event.getl(player);
                                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                                            for (var i of evt.cards2) {
                                                if (get.color(i, player) == 'red' && i.original == 'h') bool = true;
                                            }
                                            if (!bool) return false;
                                            return player != _status.currentPhase && player.countMark('minijishi') < 3;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            var num = 0, evt = trigger.getl(player);
                                            for (var i of evt.cards2) {
                                                if (get.color(i, player) == 'red' && i.original == 'h' && num < 3 - player.countMark('minijishi')) num++;
                                            }
                                            player.addMark('minijishi', num);
                                        },
                                    },
                                },
                            },
                            minitaoxian: {
                                group: 'minitaoxian_use',
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'chooseToUse',
                                filterCard(card) {
                                    return get.suit(card) == 'heart';
                                },
                                viewAs: { name: 'tao' },
                                viewAsFilter(player) {
                                    if (!player.countCards('hes', { suit: 'heart' })) return false;
                                    return true;
                                },
                                position: 'hes',
                                prompt: '将一张红桃牌当作桃使用',
                                check(card) {
                                    if (_status.event.type == 'dying') return 1 / Math.max(0.1, get.value(card));
                                    return 8 - get.value(card);
                                },
                                ai: { threaten: 10 },
                                subSkill: {
                                    use: {
                                        audio: 'minitaoxian',
                                        trigger: { global: 'useCard' },
                                        filter(event, player) {
                                            return event.player != player && event.card.name == 'tao';
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            minishenzhen: {
                                audio: 'ext:活动武将/audio/skill:true',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.hasMark('minijishi');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var map = {};
                                    var list = [];
                                    for (var i = 1; i <= player.countMark('minijishi'); i++) {
                                        var cn = get.cnNumber(i, true);
                                        map[cn] = i;
                                        list.push(cn);
                                    }
                                    list.push('cancel2');
                                    event.map = map;
                                    player.chooseControl(list).set('prompt', get.prompt2('minishenzhen')).set('ai', function () {
                                        var player = _status.event.player;
                                        var num = Math.min(player.countMark('minijishi'), Math.max(game.countPlayer(function (current) {
                                            return get.attitude(player, current) > 0 && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                                        }), game.countPlayer(function (current) {
                                            return get.attitude(player, current) < 0;
                                        })));
                                        if (num > 0) return get.cnNumber(num, true);
                                        return 'cancel2';
                                    });
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minishenzhen');
                                        var num = event.map[result.control] || 1;
                                        event.num = num;
                                        player.removeMark('minijishi', num);
                                        player.chooseControl('回血', '扣血').set('prompt', '请选择一种效果').set('ai', function (card) {
                                            if (game.countPlayer(function (current) {
                                                return get.attitude(player, current) > 0 && current.isDamaged() && get.recoverEffect(current, player, player) > 0;
                                            }) >= game.countPlayer(function (current) {
                                                return get.attitude(player, current) < 0;
                                            })) return '回血';
                                            return '扣血';
                                        });
                                    }
                                    else event.finish();
                                    'step 2'
                                    event.control = result.control;
                                    switch (result.control) {
                                        case '回血':
                                            player.chooseTarget('请选择回复体力的目标', [1, Math.min(num, game.countPlayer(function (current) {
                                                return current.isDamaged();
                                            }))], true, function (card, player, target) {
                                                return target.isDamaged();
                                            }).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return get.recoverEffect(target, player, player);
                                            });
                                            break;
                                        case '扣血':
                                            player.chooseTarget('请选择失去体力的目标', [1, Math.min(num, game.countPlayer())], true).set('ai', function (target) {
                                                var player = _status.event.player;
                                                return -get.attitude(player, target);
                                            });
                                            break;
                                    }
                                    'step 3'
                                    if (result.bool) {
                                        result.targets.sortBySeat();
                                        player.line(result.targets);
                                        game.log(player, '选择了', result.targets);
                                        if (event.control == '回血') for (var i of result.targets) i.recover();
                                        else for (var i of result.targets) i.loseHp();
                                    }
                                },
                                ai: {
                                    threaten: 10,
                                    combo: 'minijishi',
                                },
                            },
                            minigjtianyi: {
                                audio: 'stianyi',
                                derivation: 'minizuoxing',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: 'gray',
                                filter(event, player) {
                                    return !game.hasPlayer(function (current) {
                                        return !current.getAllHistory('damage').length;
                                    });
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('minigjtianyi');
                                    player.gainMaxHp(2);
                                    player.recover();
                                    'step 1'
                                    player.chooseTarget(true, '令一名角色获得技能【佐幸】').set('ai', function (target) {
                                        return get.attitude(_status.event.player, target);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target, 'green');
                                        target.storage.minizuoxing = player;
                                        target.addSkills('minizuoxing');
                                    }
                                },
                            },
                            minizuoxing: {
                                audio: 'zuoxing',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    var target = player.storage.minizuoxing;
                                    return player.hasSkill('minizuoxing') && target && target.isIn() && target.maxHp > 1;
                                },
                                check(event, player) {
                                    var target = player.storage.minizuoxing;
                                    if (get.attitude(player, target) <= 0) return true;
                                    return target.maxHp > 3 && !player.hasJudge('lebu');
                                },
                                prompt(event, player) {
                                    return get.prompt('minizuoxing') + '（令' + get.translation(player.storage.minizuoxing) + '减少1点体力上限，' + get.translation(player.storage.minizuoxing) + '当前体力上限：' + player.storage.minizuoxing.maxHp + '）';
                                },
                                content() {
                                    player.line(player.storage.minizuoxing, 'fire');
                                    player.storage.minizuoxing.loseMaxHp();
                                    player.addTempSkill('minizuoxing_effect');
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        audio: 'zuoxing',
                                        enable: 'phaseUse',
                                        filter(event, player) {
                                            if (player.hasSkill('minizuoxing_used', null, null, false)) return false;
                                            for (var i of lib.inpile) {
                                                if (get.type(i) == 'trick' && event.filterCard({ name: i, isCard: true }, player, event)) return true;
                                            }
                                            return false;
                                        },
                                        chooseButton: {
                                            dialog(event, player) {
                                                var list = [];
                                                for (var i of lib.inpile) {
                                                    if (get.type(i) == 'trick' && event.filterCard({ name: i, isCard: true }, player, event)) list.push(['锦囊', '', i]);
                                                }
                                                return ui.create.dialog('佐幸', [list, 'vcard']);
                                            },
                                            check(button) {
                                                return _status.event.player.getUseValue({ name: button.link[2], isCard: true });
                                            },
                                            backup(links, player) {
                                                return {
                                                    audio: 'zuoxing',
                                                    viewAs: {
                                                        name: links[0][2],
                                                        isCard: true,
                                                    },
                                                    filterCard: () => false,
                                                    selectCard: -1,
                                                    popname: true,
                                                    precontent() {
                                                        player.addTempSkill('minizuoxing_used', 'phaseUseEnd');
                                                    },
                                                }
                                            },
                                            prompt(links, player) {
                                                return '请选择' + get.translation(links[0][2]) + '的目标';
                                            },
                                        },
                                        ai: {
                                            order: 1,
                                            result: { player: 1 },
                                        },
                                    },
                                    used: { charlotte: true },
                                },
                            },
                            minihuishi: {
                                audio: 'sghuishi',
                                enable: 'phaseUse',
                                limited: true,
                                skillAnimation: true,
                                animationColor: 'water',
                                filterTarget: true,
                                selectTarget() {
                                    var player = _status.event.player;
                                    for (var target of game.filterPlayer()) {
                                        var list = target.getSkills(null, false, false).filter(function (skill) {
                                            if (target.awakenedSkills.includes(skill)) return false;
                                            return lib.skill[skill]?.juexingji;
                                        });
                                        var bool1 = (!list.length && player.maxHp >= 3);
                                        var bool2 = (list.length && player.maxHp >= game.players.length);
                                        target.prompt((bool1 ? '可摸牌' : '') + ((bool1 && bool2) ? '<br>' : '') + (bool2 ? '可觉醒' : ''));
                                    }
                                    return 1;
                                },
                                content() {
                                    'step 0'
                                    player.awakenSkill('minihuishi');
                                    var list = target.getSkills(null, false, false).filter(function (skill) {
                                        if (target.awakenedSkills.includes(skill)) return false;
                                        return lib.skill[skill]?.juexingji;
                                    });
                                    if (!list.length && player.maxHp >= 3) {
                                        target.draw(4);
                                        event.goto(2);
                                        return;
                                    }
                                    if (list.length && player.maxHp >= game.players.length) {
                                        if (list.length == 1) event._result = { control: list[0] };
                                        else player.chooseControl(list).set('prompt', '选择一个觉醒技，令' + get.translation(target) + '可无视条件发动该技能');
                                    }
                                    else event.goto(2);
                                    'step 1'
                                    target.storage.minihuishi_mark = result.control;
                                    target.markSkill('minihuishi_mark');
                                    var info = lib.skill[result.control];
                                    if (info.filter && !info.charlotte && !info.minihuishi_filter) {
                                        info.minihuishi_filter = info.filter;
                                        info.filter = function (event, player) {
                                            if (player.storage.minihuishi_mark) return true;
                                            return this.minihuishi_filter.apply(this, arguments);
                                        };
                                    }
                                    'step 2'
                                    player.loseMaxHp(2);
                                },
                                subSkill: { mark: { intro: { content: '发动【$】时无视条件' } } },
                                ai: {
                                    order: 0.1,
                                    expose: 0.2,
                                    result: {
                                        target(player, target) {
                                            if (player.maxHp < 5) return 0;
                                            var list = target.getSkills(null, false, false).filter(function (skill) {
                                                return lib.skill[skill]?.juexingji;
                                            });
                                            if (list.length && player.maxHp >= game.players.length) return 10 * list.length;
                                            if (target.hasJudge('lebu') || target.hasSkillTag('nogain')) return 0;
                                            if (!list.length && player.maxHp >= 3) return 4;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            minishenfu: {
                                audio: 'shenfu',
                                trigger: { player: ['phaseEnd', 'phaseAfter'] },
                                filter(event, player, name) {
                                    if (name == 'phaseEnd') return true;
                                    return player.getHistory('useSkill', function (evt) {
                                        return evt.skill == 'minishenfu';
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    if (event.triggername == 'phaseAfter') {
                                        player.logSkill('minishenfu');
                                        player.draw(Math.min(5, player.getHistory('useSkill', function (evt) {
                                            return evt.skill == 'minishenfu';
                                        }).length - 1));
                                        event.finish();
                                        return;
                                    }
                                    event.targets = [];
                                    event.goto(player.countCards('h') % 2 == 1 ? 1 : 4);
                                    'step 1'
                                    player.chooseTarget(get.prompt('minishenfu'), '对一名其他角色造成1点雷属性伤害', function (card, player, target) {
                                        return target != player && !_status.event.getParent().targets.includes(target);
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return get.damageEffect(target, player, player, 'thunder') * (target.hp == 1 ? 2 : 1);
                                    });
                                    'step 2'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        targets.push(target);
                                        player.logSkill('minishenfu', target, 'thunder');
                                        target.damage('thunder');
                                    }
                                    else event.finish();
                                    'step 3'
                                    if (target.isDead()) event.goto(1);
                                    else event.finish();
                                    'step 4'
                                    if (!game.hasPlayer(function (target) {
                                        return !event.targets.includes(target);
                                    })) { event.finish(); return; }
                                    player.chooseTarget(get.prompt('minishenfu'), '令一名角色摸一张牌或弃置其一张手牌', function (card, player, target) {
                                        return !_status.event.getParent().targets.includes(target);
                                    }).set('ai', function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        var delta = target.hp - target.countCards('h');
                                        if (Math.abs(delta) == 1 && get.sgn(delta) == get.sgn(att)) return 3 * Math.abs(att);
                                        if (att > 0 || target.countCards('h') > 0) return Math.abs(att);
                                        return 0;
                                    });
                                    'step 5'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minishenfu', target, 'wood');
                                        targets.push(target);
                                        if (target.countCards('h') == 0) event._result = { index: 0 };
                                        else player.chooseControl('摸一张牌', '弃置卡牌').set('prompt', '选择一项令' + get.translation(target) + '执行…').set('goon', get.attitude(player, target) > 0 ? 0 : 1).set('ai', () => _status.event.goon);
                                    }
                                    else event.finish();
                                    'step 6'
                                    if (result.index == 0) target.draw();
                                    else player.discardPlayerCard(target, 'he', true);
                                    'step 7'
                                    if (target.hp == target.countCards('h')) event.goto(4);
                                },
                                ai: { expose: 0.25 },
                            },
                            miniqixian: {
                                mod: {
                                    maxHandcardBase(player, num) {
                                        return 7;
                                    },
                                },
                                trigger: { player: 'phaseUseEnd' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCard(get.prompt('miniqixian'), '将一张牌移出游戏，于回合结束时归还手牌中', 'he').set('ai', function (card) {
                                        var player = _status.event.player;
                                        if (player.countCards('h') % 2 == 0 && get.position(card) == 'h' && game.hasPlayer(function (target) {
                                            return get.damageEffect(target, player, player, 'thunder') > 0;
                                        })) return 15;
                                        if (get.position(card) == 'h' && player.needsToDiscard()) return 10;
                                        if (get.position(card) == 'e' && get.value(card) <= 0) return 5;
                                        return (get.position(card) == 'h' ? 2 : 1) * -get.value(card);
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('miniqixian');
                                        player.addTempSkill('miniqixian2', { player: 'miniqixian2After' });
                                        player.addToExpansion(result.cards, player, 'give').gaintag.add('miniqixian2');
                                    }
                                },
                            },
                            miniqixian2: {
                                charlotte: true,
                                trigger: { player: 'phaseAfter' },
                                forced: true,
                                content() {
                                    player.gain(player.getExpansions('miniqixian2'), 'gain2');
                                },
                                intro: {
                                    content: 'expansion',
                                    markcount: 'expansion',
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                            },
                            minifeifu: {
                                mod: {
                                    aiValue(player, card, num) {
                                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                                        var cards = player.getCards('hs', function (card) {
                                            return get.name(card) == 'shan' || get.color(card) == 'black';
                                        });
                                        cards.sort(function (a, b) {
                                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                                        });
                                        var geti = function () {
                                            if (cards.includes(card)) {
                                                return cards.indexOf(card);
                                            }
                                            return cards.length;
                                        };
                                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                                    },
                                    aiUseful() {
                                        return lib.skill.minifeifu.mod.aiValue.apply(this, arguments);
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: ['chooseToRespond', 'chooseToUse'],
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                locked: false,
                                position: 'hes',
                                viewAs: { name: 'shan' },
                                viewAsFilter(player) {
                                    if (!player.countCards('hes', { color: 'black' })) return false;
                                },
                                prompt: '将一张黑色牌当作【闪】使用或打出',
                                check: () => 1,
                                ai: {
                                    order: 2,
                                    respondShan: true,
                                    skillTagFilter(player) {
                                        if (!player.countCards('hes', { color: 'black' })) return false;
                                    },
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                                        },
                                    },
                                },
                            },
                            //神二乔
                            minishuangshu: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                frequent: true,
                                content() {
                                    var cards = get.cards(2), bool1 = false, bool2 = false;
                                    game.cardsGotoOrdering(cards);
                                    player.showCards(cards, get.translation(player) + '发动了【双姝】');
                                    for (var i of cards) {
                                        if (get.suit(i, false) == 'diamond') bool1 = true;
                                        if (get.suit(i, false) == 'heart') bool2 = true;
                                    }
                                    if (bool1) {
                                        game.log(player, '强化了技能', '#g【娉婷】');
                                        player.addTempSkill('minishuangshu_pingting');
                                        player.addMark('minishuangshu_pingting', 1, false);
                                    }
                                    if (bool2) {
                                        game.log(player, '强化了技能', '#g【移筝】');
                                        player.addTempSkill('minishuangshu_yizheng');
                                        player.addMark('minishuangshu_yizheng', 1, false);
                                    }
                                    if (!bool1 && !bool2) player.gain(cards, 'gain2');
                                    else game.cardsDiscard(cards);
                                },
                                subSkill: {
                                    pingting: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '婷',
                                        intro: { content: '本回合发动【双姝】可多选择#项' },
                                    },
                                    yizheng: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '筝',
                                        intro: { content: '本回合发动【移筝】可多选择#项' },
                                    },
                                },
                            },
                            minipingting: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseUseBegin' },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseButton([
                                        '###' + get.prompt('minipingting') + '###' + '选择并于本阶段获得下列至多' + get.cnNumber(Math.min(4, 2 + player.countMark('minishuangshu_pingting'))) + '项效果', [[
                                            ['distance', '本阶段使用的第一张牌无距离限制'],
                                            ['return', '本阶段使用第二张牌指定目标后获得此牌'],
                                            ['draw', '本阶段使用的第三张牌结算完成后摸两张牌'],
                                            ['reuse', '本阶段使用的第四张牌额外结算一次'],
                                        ], 'textbutton']
                                    ]).set('ai', function (button) {
                                        var player = _status.event.player;
                                        var num = player.countCards('hs', function (card) {
                                            return player.hasUseTarget(card) && player.getUseValue(card) > 0;
                                        });
                                        switch (button.link) {
                                            case 'distance': {
                                                if (game.hasPlayer(function (target) {
                                                    return player.hasCard('hs', function (card) {
                                                        return player.canUse(card, target, false) && player.canUse(card, target) && get.effect(target, card, player, player) > 0;
                                                    });
                                                })) return 1;
                                                return 0.5;
                                                break;
                                            }
                                            case 'return': {
                                                if (num >= 2) return 2;
                                                return 0.6;
                                                break;
                                            }
                                            case 'draw': {
                                                if (num >= 3) return 4;
                                                return 0.7;
                                                break;
                                            }
                                            case 'reuse': {
                                                if (num >= 4) return 3;
                                                return 0.8;
                                                break;
                                            }
                                        }
                                    }).set('selectButton', [1, player.hasSkill('minishuangshu_pingting') ? 3 : 2]);
                                    'step 1'
                                    if (result.bool) {
                                        player.logSkill('minipingting');
                                        for (var i of result.links) player.addTempSkill('minipingting_' + i, { player: 'phaseUseAfter' });
                                    }
                                },
                                subSkill: {
                                    distance: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: '①',
                                        intro: { content: '本阶段使用的第一张牌无距离限制' },
                                        //为适配联机进行的代码退化[doge]
                                        mod: {
                                            targetInRange(card, player, target) {
                                                //if(game.online){
                                                if (!player.storage.minipingting_distance) return true;
                                                //}
                                                /*
                                                else{
                                                var evt=_status.event.getParent('phaseUse');
                                                if(evt?.name=='phaseUse'&&!player.getHistory('useCard',function(evt2){
                                                return evt2.getParent('phaseUse')==evt;
                                                }).length) return true;
                                                }
                                                */
                                            },
                                        },
                                        trigger: { player: 'useCard1' },
                                        filter(event, player) {
                                            return !player.storage.minipingting_distance/*&&player.isOnline()*/;
                                        },
                                        direct: true,
                                        firstDo: true,
                                        content() {
                                            player.storage.minipingting_distance = true;
                                        },
                                    },
                                    return: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: '②',
                                        intro: { content: '本阶段使用第二张牌指定目标后获得此牌' },
                                        audio: 'minipingting',
                                        trigger: { player: 'useCardToPlayered' },
                                        filter(event, player) {
                                            if (!event.isFirstTarget) return false;
                                            var evt = event.getParent('phaseUse');
                                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                                return evt2.getParent('phaseUse') == evt;
                                            }).indexOf(event.getParent()) == 1 && event.cards?.filterInD().length;
                                        },
                                        forced: true,
                                        content() {
                                            player.gain(trigger.cards.filterInD(), 'gain2');
                                        },
                                        ai: {
                                            result: {
                                                player(card, player, target) {
                                                    var evt = _status.event.getParent('phaseUse');
                                                    if (['equip', 'delay'].includes(get.type(card)) && evt?.player == player && player.getHistory('useCard', function (evt2) {
                                                        return evt2.getParent('phaseUse') == evt;
                                                    }).length == 1) return 0.3;
                                                },
                                            },
                                        },
                                    },
                                    draw: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: '③',
                                        intro: { content: '本阶段使用的第三张牌结算完成后摸两张牌' },
                                        audio: 'minipingting',
                                        trigger: { player: 'useCardAfter' },
                                        filter(event, player) {
                                            var evt = event.getParent('phaseUse');
                                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                                return evt2.getParent('phaseUse') == evt;
                                            }).indexOf(event) == 2;
                                        },
                                        forced: true,
                                        content() {
                                            player.draw(2);
                                        },
                                    },
                                    reuse: {
                                        //group:'minipingting_buff',
                                        charlotte: true,
                                        mark: true,
                                        marktext: '④',
                                        intro: { content: '本阶段使用的第四张牌额外结算一次' },
                                        audio: 'minipingting',
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            var evt = event.getParent('phaseUse');
                                            return evt?.player == player && player.getHistory('useCard', function (evt2) {
                                                return evt2.getParent('phaseUse') == evt;
                                            }).indexOf(event) == 3 && event.targets/*&&!event.reuse_buff*/;
                                        },
                                        forced: true,
                                        content() {
                                            //trigger.reuse_buff=player;
                                            trigger.effectCount++;
                                            game.log(trigger.card, '额外结算一次');
                                        },
                                        ai: {
                                            result: {
                                                player(card, player, target) {
                                                    var evt = _status.event.getParent('phaseUse');
                                                    if (card.name == 'tiesuo' && evt?.player == player && player.getHistory('useCard', function (evt2) {
                                                        return evt2.getParent('phaseUse') == evt;
                                                    }).length == 3) return 'zerotarget';
                                                },
                                            },
                                        },
                                    },
                                    /*
                                    buff:{
                                    charlotte:true,
                                    trigger:{global:'useCardToTargeted'},
                                    filter:function(event,player){
                                    return event.parent.reuse_buff==player&&event.targets.length==event.parent.triggeredTargets4.length;
                                    },
                                    direct:true,
                                    lastDo:true,
                                    content:function(){
                                    trigger.getParent().targets=trigger.getParent().targets.concat(trigger.targets);
                                    trigger.getParent().triggeredTargets4=trigger.getParent().triggeredTargets4.concat(trigger.targets);
                                    },
                                    },
                                    */
                                },
                            },
                            miniyizheng: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseUseEnd' },
                                filter(event, player) {
                                    return game.hasPlayer(target => {
                                        return target.hasVCard(card => lib.skill.miniyizheng.filterCardx(card, player), 'e');
                                    });
                                },
                                check(event, player) {
                                    return game.hasPlayer(target => {
                                        return target.hasVCard(card => lib.skill.miniyizheng.filterCardx(card, player, true), 'e');
                                    });
                                },
                                filterCardx(card, player = get.event('player'), ai) {
                                    if (!Array.from({ length: 3 }).map((_, i) => i).includes(lib.skill.miniyizheng.filterType(card))) return false;
                                    return player.canMoveCard(ai || null, true, card);
                                },
                                filterType(card) {
                                    if (get.type(card) != 'equip' || !get.subtype(card)) return -1;
                                    const num = parseInt(get.subtype(card).slice(5));
                                    return [3, 4].includes(num) ? 0 : num;
                                },
                                async content(event, trigger, player) {
                                    let moveCard = [], moveType = [], filter = (card, player) => {
                                        if (moveCard.some(cardx => lib.skill.miniyizheng.filterType(cardx) == lib.skill.miniyizheng.filterType(card))) return false;
                                        return lib.skill.miniyizheng.filterCardx(card, player);
                                    }, limit = Math.min(3, 1 + player.countMark('minishuangshu_yizheng'));
                                    while (moveCard.length < limit && game.hasPlayer(target => target.hasVCard(card => filter(card, target), 'e'))) {
                                        const forced = (!moveCard.length);
                                        const { result: { card } } = await player.moveCard(filter, 'nojudge')
                                            .set('prompt', '移筝：' + (forced ? '请' : '是否') + '移动场上的一张牌' + (forced ? '' : '？')).set('forced', forced)
                                            .set('prompt2', '还可移动' + get.cnNumber(limit - moveCard.length) + '张' + (moveType.length ? ('非' + get.translation(moveType)) : '') + '牌');
                                        if (card) {
                                            moveCard.push(card);
                                            moveType.push(get.subtype(card));
                                        }
                                        else break;
                                    }
                                    switch (moveCard.length) {
                                        case 1: await player.recover(); break;
                                        case 2: player.addTempSkill('miniyizheng_draw', { player: 'phaseBegin' }); break;
                                    }
                                },
                                subSkill: {
                                    draw: {
                                        charlotte: true,
                                        mark: true,
                                        intro: { content: '失去一张牌后，摸一张牌' },
                                        audio: 'miniyizheng',
                                        trigger: {
                                            player: 'loseAfter',
                                            global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                        },
                                        filter(event, player) {
                                            var evt = event.getl(player);
                                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                                            return true;
                                        },
                                        forced: true,
                                        content() {
                                            player.draw(trigger.getl(player).cards2.length);
                                        },
                                    },
                                },
                            },
                            //神貂蝉
                            minimeihun: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseJieshuBegin', target: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (event.name != 'phaseJieshu' && game.getGlobalHistory('useCard', function (evt) {
                                        return evt.card.name == 'sha' && evt.targets.includes(player);
                                    }).indexOf(event.getParent()) != 0) return false;
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards('he');
                                    });
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt2('minimeihun'), function (card, player, target) {
                                        return target != player && target.countCards('he');
                                    }).set('ai', function (target) {
                                        var player = _status.event.player;
                                        return -get.sgn(get.attitude(player, target)) * target.countCards('he');
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill('minimeihun', target);
                                        event.target = target;
                                        player.chooseControl(lib.suit.slice(0).reverse()).set('prompt', '请声明一个花色').set('ai', function () {
                                            var target = _status.event.target, cards = target.getCards('he');
                                            var suits = lib.suit.slice(0);
                                            suits.sort(function (a, b) {
                                                var num = function (suit) {
                                                    return cards.filter(function (card) {
                                                        return get.suit(card) == suit;
                                                    }).length;
                                                };
                                                return num(b) - num(a);
                                            });
                                            return suits[0];
                                        }).set('target', target);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var suit = result.control;
                                    player.chat(get.translation(suit + 2));
                                    game.log(player, '选择了', '#y' + get.translation(suit + 2));
                                    if (target.countCards('he', { suit: suit })) player.gain(target.getCards('he', { suit: suit }), target, 'giveAuto');
                                    else if (target.countCards('h')) player.gainPlayerCard(target, true, 'h', 'visible');
                                },
                            },
                            minihuoxin: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        return lib.skill.minihuoxin.filterTarget(null, player, target);
                                    }) && player.countCards('he');
                                },
                                filterTarget(card, player, target) {
                                    if (!ui.selected.targets.length) {
                                        return game.hasPlayer(function (current) {
                                            return current != target && target.canCompare(current);
                                        });
                                    }
                                    return ui.selected.targets[0].canCompare(target);
                                },
                                selectTarget: 2,
                                multitarget: true,
                                multiline: true,
                                targetprompt: ['发起人', '拼点目标'],
                                filterCard: true,
                                check(card) {
                                    return 1 / (get.value(card) || 0.5);
                                },
                                position: 'he',
                                usable: 1,
                                content() {
                                    'step 0'
                                    event.list = [];
                                    targets[0].chooseToCompare(targets[1]);
                                    'step 1'
                                    for (var target of targets) {
                                        if (result.winner !== target) event.list.push(target);
                                    }
                                    event.list.sortBySeat();
                                    var suits = lib.suit.slice(0).reverse();
                                    suits.push('cancel2');
                                    player.chooseControl(suits).set('prompt', get.translation(event.list) + '拼点没赢，是否声明一个花色令其进行选择？').set('ai', function () {
                                        var currents = _status.event.list, cards = [];
                                        for (var i of currents) cards.addArray(i.getCards('he'));
                                        var suits = lib.suit.slice(0);
                                        suits.sort(function (a, b) {
                                            var num = function (suit) {
                                                return cards.filter(function (card) {
                                                    return get.suit(card) == suit;
                                                }).length;
                                            };
                                            return num(b) - num(a);
                                        });
                                        return suits[0];
                                    }).set('list', event.list);
                                    'step 2'
                                    var suit = result.control;
                                    if (suit != 'cancel2') {
                                        player.chat(get.translation(suit + 2));
                                        game.log(player, '选择了', '#y' + get.translation(suit + 2));
                                        event.suit = suit;
                                    }
                                    else event.finish();
                                    'step 3'
                                    var target = event.list.shift();
                                    event.target = target;
                                    player.line(target);
                                    if (!target.countCards('he', { suit: event.suit })) event._result = { index: 1 };
                                    else target.chooseControl().set('choiceList', [
                                        '交给' + get.translation(player) + '所有的' + get.translation(event.suit) + '牌',
                                        '不能使用或打出' + get.translation(event.suit) + '牌直到你的下个回合结束'
                                    ]).set('ai', () => 1);
                                    'step 4'
                                    if (result.index == 0) player.gain(target.getCards('he', { suit: event.suit }), target, 'giveAuto');
                                    else {
                                        target.addTempSkill('minihuoxin_use', { player: 'phaseEnd' });
                                        target.markAuto('minihuoxin_use', [event.suit]);
                                    }
                                    'step 5'
                                    if (event.list.length) event.goto(3);
                                },
                                ai: {
                                    order: 12,
                                    result: {
                                        target(player, target) {
                                            return -target.countCards('h');
                                        },
                                    },
                                },
                                subSkill: {
                                    use: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { name: '魅惑', content: '不能使用或打出$花色的牌' },
                                        mod: {
                                            cardEnabled2(card, player) {
                                                if (player.getStorage('minihuoxin_use').includes(get.suit(card))) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            //神太
                            minidulie: {
                                audio: 'dulie',
                                inherit: 'dulie',
                                filter(event, player) {
                                    return event.card.name == 'sha';
                                },
                                group: 'minidulie_dying',
                                subSkill: {
                                    dying: {
                                        audio: 'tspowei2',
                                        trigger: { player: 'dying' },
                                        filter(event, player) {
                                            return !player.storage.minidulie_dying;
                                        },
                                        skillAnimation: true,
                                        animationColor: 'fire',
                                        direct: true,
                                        content() {
                                            player.storage.minidulie_dying = true;
                                            var num = game.countPlayer(current => current.hasMark('minidulie'));
                                            if (num) {
                                                player.logSkill('minidulie_dying');
                                                player.recover(num - player.hp);
                                            }
                                        },
                                    },
                                },
                            },
                            minichongwei: {
                                audio: 'tspowei3',
                                forced: true,
                                group: ['minichongwei_init', 'minichongwei_move', 'minichongwei_use', 'minichongwei_remove'],
                                subSkill: {
                                    remove: {
                                        audio: 'tspowei3',
                                        trigger: { global: 'damageEnd' },
                                        filter(event, player) {
                                            return event.player && event.player.isIn() && event.player.hasMark('minidulie');
                                        },
                                        forced: true,
                                        logTarget: 'player',
                                        content() {
                                            trigger.player.removeMark('minidulie', trigger.player.countMark('minidulie'));
                                        },
                                    },
                                    use: {
                                        audio: 'tspowei3',
                                        trigger: { global: 'phaseBegin' },
                                        filter(event, player) {
                                            return event.player != player && event.player.hasMark('minidulie') && (player.countCards('h') > 0 || player.hp >= event.player.hp && event.player.countCards('h') > 0);
                                        },
                                        direct: true,
                                        content() {
                                            'step 0'
                                            var list = [], target = trigger.player, choiceList = [
                                                '弃置一张牌并对其造成1点伤害',
                                                '获得其一张手牌',
                                            ];
                                            event.target = target;
                                            if (player.hasCard(function (card) {
                                                return lib.filter.cardDiscardable(card, player, 'minichongwei_use');
                                            }, 'h')) list.push('选项一');
                                            else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + '</span>';
                                            if (player.hp >= target.hp && target.countCards('h') > 0) list.push('选项二');
                                            else choiceList[1] = '<span style="opacity:0.5">' + choiceList[1] + '</span>';
                                            player.chooseControl(list, 'cancel2').set('prompt', get.prompt('minichongwei', target)).set('choiceList', choiceList).set('ai', function () {
                                                var evt = _status.event.getParent();
                                                if (evt.player.hasCard(function (card) {
                                                    return lib.filter.cardDiscardable(card, evt.player, 'minichongwei_use') && get.value(card, evt.player) < 7;
                                                }, 'h') && get.damageEffect(evt.target, evt.player, evt.player) > 0) return '选项一';
                                                if (evt.player.hp >= evt.target.hp && evt.target.countCards('h') > 0 && get.attitude(evt.player, evt.target) <= 0 && !evt.target.hasSkillTag('noh')) return '选项二';
                                                return 'cancel2';
                                            });
                                            'step 1'
                                            if (result.control != 'cancel2') {
                                                if (result.control == '选项二') {
                                                    player.logSkill('minichongwei_use', target);
                                                    player.gainPlayerCard(target, 'h', true);
                                                    event.goto(3);
                                                }
                                            }
                                            else event.finish();
                                            'step 2'
                                            player.chooseToDiscard('h', true).logSkill = ['minichongwei_use', target];
                                            target.damage();
                                            'step 3'
                                            player.addTempSkill('tspowei_inRange');
                                        },
                                        ai: { expose: 0.2 },
                                    },
                                    init: {
                                        audio: 'tspowei3',
                                        trigger: { global: 'phaseBefore', player: 'enterGame' },
                                        filter(event, player) {
                                            if (!lib.skill.minichongwei.subSkill.init.logTarget(event, player).length) return false;
                                            return event.name != 'phase' || game.phaseNumber == 0;
                                        },
                                        logTarget(event, player) {
                                            return game.filterPlayer((current) => current != player && !current.hasMark('minidulie'));
                                        },
                                        forced: true,
                                        content() {
                                            var list = game.filterPlayer((current) => current != player && !current.hasMark('minidulie')).sortBySeat();
                                            for (var i of list) i.addMark('minidulie', 1, false);
                                        },
                                    },
                                    move: {
                                        audio: 'tspowei3',
                                        trigger: { player: 'phaseBegin' },
                                        filter(event, player) {
                                            return game.hasPlayer((current) => current != player && current.hasMark('minidulie'));
                                        },
                                        forced: true,
                                        content() {
                                            var list = game.filterPlayer((current) => current != player && current.hasMark('minidulie')).sortBySeat();
                                            var map = {};
                                            for (var i of list) {
                                                var num = i.countMark('minidulie');
                                                i.removeMark('minidulie', num);
                                                map[i.playerid] = num;
                                            }
                                            for (var i of list) {
                                                var next = i.next;
                                                if (next == player) next = next.next;
                                                next.addMark('minidulie', map[i.playerid]);
                                            }
                                        },
                                    },
                                },
                            },
                            minipowei: {
                                unique: true,
                                derivation: 'minishenzhu',
                                audio: 'tspowei1',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    return !game.hasPlayer(current => current.hasMark('minidulie'));
                                },
                                forced: true,
                                skillAnimation: true,
                                animationColor: 'metal',
                                content() {
                                    'step 0'
                                    player.awakenSkill('minipowei');
                                    player.addSkills('minishenzhu');
                                    'step 1'
                                    var num = 0;
                                    game.countPlayer2(current => {
                                        num += current.getRoundHistory('useSkill', evt => evt.skill == 'minichongwei_remove').length;
                                    });
                                    if (num) player.draw(num);
                                },
                            },
                            minishenzhu: {
                                audio: 'shenzhu',
                                inherit: 'shenzhu',
                                group: 'minishenzhu_wusheng',
                                subSkill: {
                                    wusheng: {
                                        audio: 'shenzhu',
                                        trigger: { player: 'phaseBegin' },
                                        forced: true,
                                        content() {
                                            var card = get.cardPile(card => card.name == 'sha');
                                            if (card) player.gain(card, 'gain2');
                                        },
                                    },
                                },
                            },
                            //女娲
                            minibutian: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    source: 'damageSource',
                                    global: ['roundStart', 'phaseBefore'],
                                    player: ['damageEnd', 'changeHp', 'gainMaxHpEnd', 'loseMaxHpEnd', 'enterGame'],
                                },
                                filter(event, player, name) {
                                    var num = Math.floor(player.getDamagedHp() / 5);
                                    if (name == 'damageEnd') return num > 0;
                                    if (name == 'roundStart') return game.roundNumber > 1 && num > 0;
                                    if (name == 'damageSource') return event.player != player && player.isDamaged() && num > 0;
                                    if (name == 'phaseBefore' && game.phaseNumber > 0) return false;
                                    return player.isHealthy();
                                },
                                forced: true,
                                content() {
                                    var num = Math.floor(player.getDamagedHp() / 5);
                                    var name = event.triggername;
                                    if (name == 'damageSource') player.recover(num);
                                    else if (name == 'damageEnd' || name == 'roundStart') player.loseHp(num);
                                    else {
                                        player.$fullscreenpop('补天', 'fire');
                                        var targets = game.filterPlayer(current => current != player).sortBySeat();
                                        if (targets.length) {
                                            targets.forEach(target => {
                                                player.line(target);
                                                target.die();
                                            });
                                        }
                                    }
                                },
                            },
                            minilianshi: {
                                mod: { maxHandcardBase: (player, num) => 5 },
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    player: ['useCard', 'respond', 'loseAfter'],
                                    global: ['loseAsyncAfter'],
                                },
                                filter(event, player) {
                                    if (event.name.indexOf('lose') == 0) return event.type == 'discard' && event.getl(player).cards2.filter(card => get.position(card, true) == 'd' && !player.getStorage('minilianshi').includes(get.suit(card, player))).length > 0;
                                    return event.cards?.some(card => !player.getStorage('minilianshi').includes(get.suit(card, player)) && lib.suit.includes(get.suit(card, player)));
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    var cards;
                                    if (trigger.name.indexOf('lose') == 0) cards = trigger.getl(player).cards2.filter(card => get.position(card, true) == 'd');
                                    else cards = trigger.cards;
                                    event.cards = cards;
                                    var suits = cards.reduce((list, card) => list.add(get.suit(card, player)), []);
                                    suits = suits.filter(suit => !player.getStorage('minilianshi').includes(suit));
                                    player.markAuto('minilianshi', suits);
                                    player.storage.minilianshi.sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                                    player.addTip('minilianshi', get.translation('minilianshi') + player.getStorage('minilianshi').reduce((str, suit) => str + get.translation(suit), ""));
                                    'step 1'
                                    if (player.getStorage('minilianshi').length >= 4) {
                                        player.draw();
                                        if (player.isDamaged()) player.recover(get.number(cards[cards.length - 1], player));
                                        player.unmarkSkill('minilianshi');
                                        delete player.storage.minilianshi;
                                        player.removeTip('minilianshi');
                                    }
                                },
                                intro: {
                                    onunmark: true,
                                    content: '已记录花色：$',
                                },
                                onremove(player, skill) {
                                    player.removeTip(skill);
                                    delete player.storage[skill];
                                },
                            },
                            minituantu: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('h') && event.minituantu;
                                },
                                onChooseToUse(event) {
                                    if (!game.online && !event.minituantu) event.set('minituantu', ui.discardPile.childElementCount);
                                },
                                usable: 1,
                                content() {
                                    var names = player.getCards('h').reduce((list, card) => list.add(get.name(card)), []);
                                    var cards = [];
                                    names.forEach(name => {
                                        var card = get.discardPile(card => !cards.includes(card) && card.name == name);
                                        if (card) cards.push(card);
                                    });
                                    if (cards.length) player.gain(cards, 'gain2');
                                    else player.chat('无牌可得？！');
                                },
                                ai: {
                                    order(item, player) {
                                        var names = player.getCards('h').reduce((list, card) => list.add(get.name(card)), []);
                                        var cards = [];
                                        names.forEach(name => {
                                            var card = get.discardPile(card => !cards.includes(card) && card.name == name);
                                            if (card) cards.push(card);
                                        });
                                        return cards.length;
                                    },
                                    result: { player: 1 },
                                },
                            },
                            minitunxing: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    global: 'phaseBefore',
                                    player: ['enterGame', 'logSkill'],
                                },
                                filter(event, player) {
                                    if (event.name == 'logSkill' && event.skill != 'minimengli') return false;
                                    return event.name != 'phase' || game.phaseNumber == 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    if (player.additionalSkills.minitunxing && player.additionalSkills.minitunxing.length) await player.removeAdditionalSkills('minitunxing');
                                    const list = ((!_status.connectMode && lib.config.extension_活动武将_PingJianName) ? lib.config.extension_活动武将_PingJianName : lib.skill.minipingjian.getList()).filter(name => {
                                        if (!lib.character[name]) return false;
                                        return lib.character[name][4] && lib.character[name][4].includes('zhu');
                                    }).randomGets(3);
                                    if (!list.length) return;
                                    const { result: { bool, links } } = await player.chooseButton(['###吞星：请选择获得一张武将牌###<div class="text center">获得此武将牌上的所有主公技和觉醒技外的技能</div>', [list, 'character']], true).set('ai', button => 1 + Math.random());
                                    if (bool) {
                                        const name = links[0], skills = get.character(name, 3).filter(skill => {
                                            const info = get.info(skill);
                                            return !info || (!info.zhuSkill && !info.juexingji);
                                        });
                                        if (skills.length) await player.addAdditionalSkills('minitunxing', skills);
                                    }
                                },
                                derivation: 'minitunxing_faq',
                                onremove(player) {
                                    if (player.additionalSkills.minitunxing && player.additionalSkills.minitunxing.length) player.removeAdditionalSkills('minitunxing');
                                },
                            },
                            minimengli: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'changeHp' },
                                filter(event, player) {
                                    return get.sgn(player.hp - 3.5) != get.sgn(player.hp - 3.5 - event.num);
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const name = ('Mbaby_tunxingmengli' + (player.hp > 3 ? 'x' : ''));
                                    player.changeSkin('minimengli', name);
                                    await player.draw();
                                },
                            },
                            //神左慈
                            minihuanshu: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    global: ['roundStart', 'loseAfter'],
                                    player: ['damageEnd', 'phaseUseBegin'],
                                },
                                filter(event, player) {
                                    if (event.name == 'lose') return event.HuanShuDestroy;
                                    return event.name != 'phaseUse' || player.countCards('h', card => card.minihuanshu && !card.minihuanhua);
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    if (trigger.name == 'lose') await player.draw(trigger.cards.length);
                                    else if (trigger.name == 'phaseUse') {
                                        const cards = player.getCards('h', card => card.minihuanshu && !card.minihuanhua);
                                        for (const card of cards) {
                                            const card2 = lib.card.list.filter(cardx => {
                                                if (card.suit == cardx[0] && card.number == cardx[1] && card.name == cardx[2] && card.nature == cardx[3]) return false;
                                                return card.suit == cardx[0];
                                            }).randomGet();
                                            if (!card2) continue;
                                            game.addVideo('skill', player, ['minihuanshu', [false, get.cardInfo(card)]]);
                                            game.broadcastAll((card, card2) => {
                                                card.init([card2[0], card2[1], card2[2], card2[3]]);
                                            }, card, card2);
                                        }
                                    }
                                    else await lib.skill.minihuanshu.GainContent(2, (trigger.num || 1), player);
                                },
                                init() {
                                    game.broadcastAll(() => {
                                        /*神左慈幻术卡牌颜色*/
                                        lib.init.sheet([
                                            '.card.minihuanshu-glow:before{',
                                            'opacity:0.2;',
                                            'box-shadow:rgba(0,0,0,0.2) 0 0 0 1px,rgb(255,109,12) 0 0 5px,rgb(255,0,0) 0 0 10px;',
                                            'background-color:#0000FF;',
                                            '-webkit-filter:blur(5px);',
                                            'filter:blur(5px);',
                                            '}'
                                        ].join(''));
                                        /*神左慈幻化卡牌颜色*/
                                        lib.init.sheet([
                                            '.card.minihuanhua-glow:before{',
                                            'opacity:0.2;',
                                            'box-shadow:rgba(0,0,0,0.2) 0 0 0 1px,rgb(255,109,12) 0 0 5px,rgb(255,0,0) 0 0 10px;',
                                            'background-color:yellow;',
                                            '-webkit-filter:blur(5px);',
                                            'filter:blur(5px);',
                                            '}'
                                        ].join(''));
                                    });
                                },
                                async GainContent(length, num, player) {
                                    game.addGlobalSkill('minihuanshu_gain');
                                    while (num > 0 && player.hasSkill('minihuanshu')) {
                                        num--;
                                        let gains = [], count = 0;
                                        const sum = Math.min(length, player.maxHp * 2 - player.countCards('h', card => card.minihuanshu));
                                        if (sum > 0) {
                                            while (sum - count > 0) {
                                                count++;
                                                const cardy = lib.card.list.randomGet();
                                                if (cardy) gains.push(game.createCard2(cardy[2], cardy[0], cardy[1], cardy[3]));
                                                else break;
                                            }
                                            if (gains.length) {
                                                game.broadcastAll(cards => {
                                                    for (const card of cards) {
                                                        card.minihuanshu = true;
                                                        card.classList.add('minihuanshu-glow');
                                                    }
                                                }, gains);
                                                await player.gain(gains, 'draw');
                                                game.log(player, '获得了', '#y' + get.cnNumber(gains.length) + '张', '#g“幻化”牌');
                                            }
                                        }
                                        if (length - gains.length > 0) await player.draw(length - gains.length);
                                    }
                                },
                                derivation: 'minihuanshu_faq',
                                subSkill: {
                                    gain: {
                                        charlotte: true,
                                        mod: {
                                            ignoredHandcard(card, player) {
                                                if (card.minihuanshu) return true;
                                            },
                                            cardDiscardable(card, player, name) {
                                                if (name == 'phaseDiscard' && card.minihuanshu) return false;
                                            },
                                        },
                                        trigger: { player: 'gainAfter', global: 'loseAsyncAfter' },
                                        filter(event, player) {
                                            if (player.hasSkill('minihuanshu', null, false, false)) return false;
                                            return event.getg(player).some(card => card.minihuanshu);
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        forceDie: true,
                                        content() {
                                            const cards = trigger.getg(player).filter(card => card.minihuanshu);
                                            game.log(cards, '被销毁了');
                                            player.lose(cards, ui.special).set('HuanShuDestroy', true);
                                        },
                                    },
                                },
                            },
                            minihuanhua: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                onChooseToUse(event) {
                                    if (!game.online && event.type == 'phase' && !event.minihuanhua_count) {
                                        const player = event.player;
                                        event.set('minihuanhua_count', [
                                            player.getHistory('useSkill', evt => evt.skill == 'minihuanhua').length, player.getCards('h', card => card.minihuanshu && !card.minihuanhua),
                                            player.getCards('h', card => (player.countMark('minihuanjing_effect') || !card.minihuanshu) && !card.hasGaintag('minihuanhua_tag'))
                                        ]);
                                    }
                                },
                                filter(event, player) {
                                    const count = event.minihuanhua_count;
                                    return count[0] < 2 + player.countMark('minihuanjing_effect') && count[1].length && count[2].length;
                                },
                                filterCard(card, player) {
                                    return (get.event('minihuanhua_count')[1 + ui.selected.cards.length] || []).includes(card);
                                },
                                selectCard: 2,
                                check(card) {
                                    if (ui.selected.cards.length && ui.selected.cards[0].suit == card.suit) return 5 + get.useful(card) * get.value(card);
                                    return get.useful(card) * get.value(card);
                                },
                                complexCard: true,
                                position: 'h',
                                lose: false,
                                discard: false,
                                delay: false,
                                async content(event, trigger, player) {
                                    const cards = event.cards, suit = cards[0].suit;
                                    player.addGaintag([cards[1]], 'minihuanhua_tag');
                                    game.addVideo('skill', player, ['minihuanhua', [false, get.cardInfo(cards[0])]]);
                                    game.broadcastAll(cards => {
                                        cards[0].minihuanhua = true;
                                        cards[0].init([cards[1].suit, cards[1].number, cards[1].name, cards[1].nature]);
                                        cards[0].classList.remove('minihuanshu-glow');
                                        cards[0].classList.add('minihuanhua-glow');
                                    }, cards);
                                    if (suit == cards[1].suit) await lib.skill.minihuanshu.GainContent(1, 1, player);
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                                subSkill: { tag: {} },
                            },
                            minihuanjing: {
                                unique: true,
                                limited: true,
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                async content(event, trigger, player) {
                                    const num = Math.max(1, player.getDamagedHp() * 2);
                                    player.awakenSkill('minihuanjing');
                                    await lib.skill.minihuanshu.GainContent(num, 1, player);
                                    player.addTempSkill('minihuanjing_effect');
                                    player.addMark('minihuanjing_effect', num, false);
                                },
                                ai: {
                                    order: 10,
                                    result: { player: 1 },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: '境',
                                        intro: { content: '<li>本回合可额外发动#次【幻化】<br><li>本回合发动【幻化】可选择“幻术”牌为转化目标卡牌' },
                                    },
                                },
                            },
                            //神邓艾
                            minixianjin: {
                                init(player) {
                                    var num = game.getAllGlobalHistory('changeHp', evt => {
                                        return evt.getParent().name == 'damage' && (evt.getParent().player == player || (evt.getParent().source && evt.getParent().source == player));
                                    }).concat(game.getAllGlobalHistory('changeHp', evt => {
                                        return evt.getParent().name == 'damage' && evt.getParent().player == player && evt.getParent().source && evt.getParent().source == player;
                                    })).length;
                                    if (num) player.addMark('minixianjin', num, false);
                                },
                                onremove: true,
                                audio: 'dcxianjin',
                                trigger: {
                                    player: 'damageEnd',
                                    source: 'damageSource',
                                },
                                filter(event, player) {
                                    return player.countMark('minixianjin') % 2 == 0;
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    var tags = ['dctuoyu_fengtian', 'dctuoyu_qingqu', 'dctuoyu_junshan'];
                                    tags.removeArray(player.getStorage('dctuoyu'));
                                    if (!tags.length) {
                                        player.draw(3);
                                        event.finish();
                                    }
                                    else if (tags.length == 1) {
                                        event._result = { control: tags[0] };
                                    }
                                    else player.chooseControl(tags).set('prompt', '险峻：选择激活一个副区域标签');
                                    'step 1'
                                    var control = result.control;
                                    game.log(player, '激活了副区域', '#y' + get.translation(control));
                                    player.markAuto('dctuoyu', [control]);
                                    player.popup(get.translation(control + '_tag'));
                                    player.draw(player.getStorage('dctuoyu').length)
                                },
                                group: 'minixianjin_mark',
                                intro: { content: '已造成或受到#次伤害' },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        trigger: {
                                            player: 'damageEnd',
                                            source: 'damageSource',
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        content() {
                                            player.addMark('minixianjin', 1, false);
                                        },
                                    },
                                },
                            },
                            //神陆逊
                            minicuike: {
                                audio: 'nzry_cuike',
                                trigger: { player: 'phaseUseBegin' },
                                async cost(event, trigger, player) {
                                    let result = await player.chooseTarget(get.prompt('minicuike'), ['横置一名角色并弃置其区域内的一张牌', '对一名角色造成1点伤害'][player.countMark('nzry_junlve') % 2]).set('ai', target => {
                                        const player = get.event('player');
                                        if (player.countMark('nzry_junlve') % 2 == 1) return get.damageEffect(target, player, player);
                                        return (target.isLinked() ? 0 : get.effect(target, { name: 'tiesuo' }, player, player)) + get.effect(target, { name: 'guohe' }, player, player);
                                    }).forResult();
                                    if (!result.bool && player.countMark('nzry_junlve') > game.countPlayer()) result.bool = true;
                                    event.result = result;
                                },
                                popup: false,
                                async content(event, trigger, player) {
                                    let logged = true;
                                    if ((event.targets || []).length) {
                                        const target = event.targets[0];
                                        await player.logSkill('minicuike', target);
                                        if (player.countMark('nzry_junlve') % 2 == 1) await target.damage();
                                        else {
                                            await target.link(true);
                                            await player.discardPlayerCard(target, 'hej', true);
                                        }
                                    }
                                    else logged = false;
                                    if (player.countMark('nzry_junlve') > game.countPlayer()) {
                                        const result = await player.chooseTarget('摧克：是否对任意名其他角色各造成1点伤害？', lib.filter.notMe, [1, Infinity]).set('ai', target => {
                                            const player = get.event('player');
                                            if (player.countMark('nzry_junlve') % 2 == 1) return get.damageEffect(target, player, player);
                                        }).forResult();
                                        if (result.bool) {
                                            const targets = result.targets.sortBySeat();
                                            if (logged) player.line(targets, 'fire');
                                            else await player.logSkill('minicuike', targets);
                                            player.removeMark('nzry_junlve', player.countMark('nzry_junlve'));
                                            for (const i of targets) await i.damage();
                                        }
                                    }
                                },
                            },
                            //神庞统
                            minilunce: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'roundStart' },
                                filter(event, player) {
                                    return game.hasPlayer(target => lib.skill.minilunce.derivation.some(i => !target.hasSkill(i)));
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const result = await player.chooseTarget(get.prompt(event.name), (card, player, target) => {
                                        return lib.skill.minilunce.derivation.some(i => !target.hasSkill(i));
                                    }, '选择一名角色并为其分配一个计策').set('ai', target => 1 + Math.random()).forResult();
                                    if (result.bool) {
                                        const target = result.targets[0];
                                        player.logSkill(event.name, target);
                                        const list = lib.skill.minilunce.derivation.filter(i => !target.hasSkill(i));
                                        let choice;
                                        if (list.length == 1) choice = { control: list[0] };
                                        else choice = await player.chooseControl(list).set('choiceList', (() => {
                                            return list.map(i => '<div class="skill">【' + lib.translate[i] + '】</div><div>' + lib.translate[i + '_info'] + '</div>');
                                        })()).set('prompt', '论策：为' + get.translation(target) + '分配一个计策').set('ai', () => {
                                            return get.event().controls.randomGet();
                                        }).set('displayIndex', false).forResult();
                                        if (choice.control) {
                                            const control = choice.control;
                                            player.popup(control);
                                            player.line(target);
                                            target.storage[control] = player;
                                            target.addSkill(control);
                                            game.log(player, '为', target, '分配了', '#y' + get.translation(control));
                                        }
                                    }
                                },
                                derivation: ['minilunce_上策', 'minilunce_中策', 'minilunce_下策'],
                                subSkill: {
                                    '上策': {
                                        charlotte: true,
                                        onremove: true,
                                        silent: true,
                                        nopop: true,
                                        trigger: { player: 'phaseUseBegin' },
                                        async content(event, trigger, player) {
                                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                                            player.removeSkill(skill);
                                            const result = await player.chooseToUse(function (card, player, event) {
                                                if (get.name(card) != 'sha') return false;
                                                return lib.filter.filterCard.apply(this, arguments);
                                            }, '###上策：是否执行' + str + '的计策？###对一名角色使用一张无距离限制的【杀】').set('addCount', false).set('targetRequired', true).set('complexSelect', true).set('filterTarget', lib.filter.targetEnabled).forResult();
                                            if (source.isIn()) {
                                                const bool = Boolean(result.bool);
                                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                                game.log(source, '的上策执行', bool ? '#g成功' : '#y失败');
                                                source.getHistory('custom').push({ 'minilunce_上策': [bool, player] });
                                            }
                                        },
                                        mark: true,
                                        intro: { content: '<li>由$向你传授的上策<br><li>出牌阶段开始时，你可以对一名角色使用一张无距离限制的【杀】。' },
                                    },
                                    '中策': {
                                        charlotte: true,
                                        onremove: true,
                                        silent: true,
                                        nopop: true,
                                        trigger: { player: ['phaseEnd', 'useCardToPlayered'] },
                                        filter(event, player) {
                                            return event.name == 'phase' || (event.card.name == 'sha' && player.getHistory('useCard', evt => {
                                                return evt.card.name == 'sha';
                                            }).indexOf(event.getParent()) == 0);
                                        },
                                        async content(event, trigger, player) {
                                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                                            player.removeSkill(skill);
                                            if (source.isIn()) {
                                                const bool = Boolean(trigger.name !== 'phase');
                                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                                game.log(source, '的中策执行', bool ? '#g成功' : '#y失败');
                                                source.getHistory('custom').push({ 'minilunce_中策': [bool, player] });
                                                if (bool) {
                                                    source.line(player);
                                                    await source.gainPlayerCard(player, 'he', true);
                                                }
                                            }
                                        },
                                        mark: true,
                                        intro: { content: `<li>由$向你传授的中策<br><li>当你于回合内首次使用【杀】指定目标后，$获得你一张牌，直到你的回合结束。` },
                                    },
                                    '下策': {
                                        charlotte: true,
                                        onremove: true,
                                        silent: true,
                                        nopop: true,
                                        trigger: { player: 'phaseEnd' },
                                        async content(event, trigger, player) {
                                            const skill = event.name, source = player.storage[skill], str = get.translation(source);
                                            player.removeSkill(skill);
                                            if (source.isIn()) {
                                                const bool = !player.hasHistory('sourceDamage', evt => evt.isPhaseUsing(player) && evt.card?.name == 'sha');
                                                source.popup(bool ? '洗具' : '杯具', bool ? 'wood' : 'fire');
                                                game.log(source, '的下策执行', bool ? '#g成功' : '#y失败');
                                                source.getHistory('custom').push({ 'minilunce_下策': [bool, player] });
                                                if (bool) {
                                                    if (source != player) {
                                                        const bool = await source.chooseToGive(player, [1, 3], 'he').forResultBool();
                                                        if (bool) await player.recover();
                                                    }
                                                    else if (player.isDamaged()) {
                                                        const bool = await player.chooseBool('是否回复1点体力').forResultBool();
                                                        if (bool) await player.recover();
                                                    }
                                                }
                                            }
                                        },
                                        mark: true,
                                        intro: { content: '<li>由$向你传授的下策<br><li>回合结束时，若你本回合未于出牌阶段使用【杀】造成过伤害，则$可以交给你至多三张牌并令你回复1点体力。' },
                                    },
                                },
                            },
                            minilanhai: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    return lib.skill.minilunce.derivation.some(effect => {
                                        return player.getHistory('custom', evt => {
                                            return evt[effect];
                                        }).length;
                                    });
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const bool = player.hasHistory('custom', evt => {
                                        return lib.skill.minilunce.derivation.some(effect => {
                                            return evt[effect] && evt[effect][0];
                                        });
                                    });
                                    const history = player.getRoundHistory('custom', evt => {
                                        return lib.skill.minilunce.derivation.some(effect => {
                                            return evt[effect] && evt[effect][0];
                                        });
                                    });
                                    if (bool) {
                                        await player.draw(Math.min(3, history.length));
                                        const targets = game.filterPlayer(current => {
                                            return lib.skill.minilunce.derivation.some(i => !current.hasSkill(i));
                                        });
                                        if (!targets.length) return;
                                        await player.useSkill('minilunce');
                                    }
                                    else {
                                        if (player.countMark('minilanhai') < 3) {
                                            player.addMark('minilanhai', 1, false);
                                            await player.gainMaxHp();
                                        }
                                        await player.recover();
                                    }
                                },
                            },
                            //精卫
                            minitianhai: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: ['useCard', 'respond'] },
                                filter(event, player) {
                                    const { card, player: target } = event, number = get.number(card);
                                    if (typeof number !== 'number') return false;
                                    const storage = player.getStorage('minitianhai'), bool = !storage.includes(number);
                                    if (player == target) return bool && player.hasHistory('lose', evt => evt.getParent() == event && evt.hs?.length);
                                    if (bool) return false;
                                    if (number >= 10 && !target.hasCard(card => lib.filter.cardDiscardable(card, target, 'minitianhai'), 'he')) return false;
                                    return true;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const { card, player: target } = trigger, number = get.number(card);
                                    if (player == target) player.markAuto(event.name, [number]);
                                    else {
                                        if (number <= 4) {
                                            target.addSkill(event.name + '_damage');
                                            target.addMark(event.name + '_damage', 1, false);
                                            game.log(target, '下一次受到的伤害', '#g+1');
                                        }
                                        else if (number >= 10) {
                                            const num = target.getCards('he').filter(card => lib.filter.cardDiscardable(card, target, 'minitianhai')).reduce((sum, card) => sum + get.number(card), 0);
                                            if (num <= number) await target.discard(target.getCards('he'));
                                            else await target.chooseToDiscard(`弃置任意张点数之和不小于${number}的牌`, 'he', true).set('selectCard', function () {
                                                let num = 0;
                                                for (let i = 0; i < ui.selected.cards.length; i++) {
                                                    num += get.number(ui.selected.cards[i]);
                                                }
                                                if (num >= _status.event.num) return ui.selected.cards.length;
                                                return ui.selected.cards.length + 2;
                                            }).set('ai', card => {
                                                return 6 - get.value(card);
                                            }).set('num', number).set('complexCard', true);
                                        }
                                        else await player.draw();
                                    }
                                },
                                onremove: true,
                                intro: {
                                    content: '已记录点数：$',
                                },
                                subSkill: {
                                    damage: {
                                        trigger: { player: 'damageBegin3' },
                                        forced: true,
                                        charlotte: true,
                                        onremove: true,
                                        content() {
                                            trigger.num += player.countMark(event.name);
                                            player.removeSkill(event.name);
                                        },
                                        intro: { content: '下次受到伤害时，此伤害+#' },
                                    }
                                }
                            },
                            minihaiku: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: ['gainAfter', 'loseAsyncAfter'] },
                                filter(event, player, name, target) {
                                    if (player.getStorage('minitianhai').length != 13) return false;
                                    return target?.isIn();
                                },
                                getIndex(event, player) {
                                    const evt = event.getParent('phaseDraw');
                                    if (evt?.name == 'phaseDraw') return false;
                                    return game.filterPlayer(current => {
                                        if (evt?.player == current || player == current) return false;
                                        return event.getg(current).some(card => get.owner(card) == current && lib.filter.cardDiscardable(card, current, 'minihaiku'));
                                    }).sortBySeat();
                                },
                                logTarget: (event, player, triggername, target) => target,
                                forced: true,
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    let cards = trigger.getg(target).filter(card => get.owner(card) == target && lib.filter.cardDiscardable(card, target, 'minihaiku'));
                                    if (cards.length) await target.discard(cards);
                                    cards = cards.filterInD('d');
                                    if (cards.length) await player.gain(cards, 'gain2');
                                },
                                ai: { combo: 'minitianhai' },
                            },
                            //喵
                            //核心逗猫
                            minidoumao: {
                                audio: 'ext:活动武将/audio/skill:true',
                                trigger: { player: ['phaseBegin', 'phaseEnd'] },
                                filter(event, player) {
                                    return player.countCards('he');
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    if (event.triggername == 'phaseEnd') {
                                        player.logSkill('minidoumao');
                                        player.chooseToDiscard(true);
                                        event.finish();
                                    }
                                    else {
                                        player.chooseCardTarget({
                                            prompt: get.prompt('minidoumao'),
                                            prompt2: '弃置一张牌，失去【逗猫】并令一名其他角色获得【逗猫】，然后其摸一张牌',
                                            //filterTarget:function(card,player,target){
                                            //return !target.hasSkill('minidoumao');
                                            //},
                                            filterTarget: lib.filter.notMe,
                                            filterCard: lib.filter.cardDiscardable,
                                            position: 'he',
                                            ai1(card) {
                                                return 7 - get.value(card);
                                            },
                                            ai2(target) {
                                                var player = _status.event.player;
                                                var att = get.attitude(player, target);
                                                //集智
                                                if (target.hasSkill('minimiaojizhi')) return 10 * (-get.sgn(att));
                                                //枪舞
                                                if (player.hasSkill('minimiaoqiangwu')) {
                                                    player._minimiaoqiangwu_check = true;
                                                    var cards = player.getCards('hs', function (card) {
                                                        return card.name == 'sha' && player.canUse(card, target);
                                                    });
                                                    if (cards.length > 1) {
                                                        if (att >= 0) return 0;
                                                        var sum = 0;
                                                        for (var card of cards) sum += get.effect(target, card, player, player);
                                                        if (sum <= 0) return 0;
                                                        else {
                                                            while (sum < 1 || sum > 10) {
                                                                if (sum < 1) sum = sum * 10;
                                                                if (sum > 10) sum = sum / 10;
                                                            }
                                                            return sum;
                                                        }
                                                    }
                                                    return 0;
                                                }
                                                if (player._minimiaoqiangwu_check) delete player._minimiaoqiangwu_check;
                                                //顺位传递
                                                var players = game.filterPlayer(function (current) {
                                                    if (current.hasSkill('minimiaojizhi') || current.hasSkill('minimiaoqiangwu')) return false;
                                                    return current != player && !current.isTurnedOver() && get.attitude(player, current) > 0 && get.attitude(current, player) > 0;
                                                }).sortBySeat(player);
                                                if (players.length) return target == players[0] ? (att * (target.getSkills().some(skill => skill.indexOf('minimiao') == 0) ? 0.5 : 1)) : -1;
                                                //普通传递
                                                return get.sgn(att) + att / 114514;
                                            },
                                        });
                                    }
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minidoumao', target);
                                        player.discard(result.cards);
                                        player.removeSkills('minidoumao');
                                        target.addSkills('minidoumao');
                                    }
                                    else event.finish();
                                    'step 2'
                                    target.draw();
                                },
                                mark: true,
                                marktext: '猫',
                                intro: { content: '嘿！有只猫在你身边欸！' },
                            },
                            //喵蔡文姬
                            minimiaobeige: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'damageEnd' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && event.source && event.source.isIn() && event.player.isIn() && player.countCards('he');
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    'step 0'
                                    player.chooseToDiscard('he', get.prompt2('minimiaobeige', trigger.player)).set('ai', function (card) {
                                        var player = _status.event.player;
                                        var target = _status.event.list[0];
                                        var source = _status.event.list[1];
                                        var att1 = get.attitude(player, target);
                                        var att2 = get.attitude(player, source);
                                        switch (get.suit(card, player)) {
                                            case 'heart': case 'diamond':
                                                if (att1 > 0) return 10 - get.value(card);
                                                return 0;
                                                break;
                                            case 'club':
                                                if (att2 < 0) return (7 - get.value(card)) * (source.countCards('he') ? 1 : 0);
                                                return 0;
                                                break;
                                            case 'spade':
                                                if (att2 > 0 && source.isTurnedOver()) return 20 - get.value(card);
                                                if (att2 < 0 && !source.isTurnedOver()) return 10 - get.value(card);
                                                return 0;
                                                break;
                                        }
                                    }).setHiddenSkill('minimiaobeige').set('list', [trigger.player, trigger.source]).logSkill = 'minimiaobeige';
                                    'step 1'
                                    if (result.bool) {
                                        switch (get.suit(result.cards[0], player)) {
                                            case 'heart':
                                                player.line(trigger.player);
                                                trigger.player.recover();
                                                break;
                                            case 'diamond':
                                                player.line(trigger.player);
                                                trigger.player.draw(2);
                                                break;
                                            case 'club':
                                                player.line(trigger.source);
                                                trigger.source.chooseToDiscard('he', 2, true);
                                                break;
                                            case 'spade':
                                                player.line(trigger.source);
                                                trigger.source.turnOver();
                                                break;
                                        }
                                        if (player.hasSkill('minidoumao')) { event.finish(); return; }
                                        player.chooseButton([
                                            '悲歌：是否额外选择一个效果执行',
                                            [[
                                                ['heart', '令' + get.translation(trigger.player) + '回复1点体力'],
                                                ['diamond', '令' + get.translation(trigger.player) + '摸两张牌'],
                                                ['club', '令' + get.translation(trigger.source) + '弃置两张牌'],
                                                ['spade', '令' + get.translation(trigger.source) + '将武将牌翻面']
                                            ].filter(list => list[0] != get.suit(result.cards[0], player)), 'textbutton']
                                        ]).set('ai', function (button) {
                                            var player = _status.event.player;
                                            var target = _status.event.list[0];
                                            var source = _status.event.list[1];
                                            var att1 = get.attitude(player, target);
                                            var att2 = get.attitude(player, source);
                                            switch (button.link) {
                                                case 'heart':
                                                    if (att1 > 0) return 3;
                                                    return 0;
                                                    break;
                                                case 'diamond':
                                                    if (att1 > 0) return 2;
                                                    return 0;
                                                    break;
                                                case 'club':
                                                    if (att2 < 0) return 1;
                                                    return 0;
                                                    break;
                                                case 'spade':
                                                    if (att2 > 0 && source.isTurnedOver()) return 5;
                                                    if (att2 < 0 && !source.isTurnedOver()) return 4;
                                                    return 0;
                                                    break;
                                            }
                                        }).set('list', [trigger.player, trigger.source]);
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        if (result.links.includes('heart')) {
                                            player.line(trigger.player);
                                            trigger.player.recover();
                                        }
                                        if (result.links.includes('diamond')) {
                                            player.line(trigger.player);
                                            trigger.player.draw(2);
                                        }
                                        if (result.links.includes('club')) {
                                            player.line(trigger.source);
                                            trigger.source.chooseToDiscard('he', 2, true);
                                        }
                                        if (result.links.includes('spade')) {
                                            player.line(trigger.source);
                                            trigger.source.turnOver();
                                        }
                                    }
                                },
                                ai: { expose: 0.25 },
                            },
                            minimiaoduanchang: {
                                group: 'duanchang',
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'dying' },
                                filter(event, player) {
                                    if (player.hasSkill('minidoumao')) return false;
                                    return event.getParent().name == 'damage' && event.source && event.source.countCards('he');
                                },
                                forced: true,
                                logTarget: 'source',
                                content() {
                                    trigger.source.chooseToDiscard('he', true, 2);
                                },
                            },
                            //喵貂蝉
                            minimiaolijian: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return game.countPlayer(current => current != player) > 1;
                                },
                                filterCard: true,
                                selectCard() {
                                    const player = get.event('player'), goon = (!player.hasSkill('minidoumao'));
                                    return [goon ? 1 : 2, Infinity];
                                },
                                position: 'he',
                                filterTarget: lib.filter.notMe,
                                selectTarget() {
                                    const player = get.event('player'), goon = (!player.hasSkill('minidoumao'));
                                    return ui.selected.cards.length + (goon ? 1 : 0);
                                },
                                filterOk() {
                                    const player = get.event('player'), goon = (!player.hasSkill('minidoumao'));
                                    return ui.selected.targets.length == ui.selected.cards.length + (goon ? 1 : 0);
                                },
                                check(card) {
                                    let player = get.owner(card), targets = lib.skill.minimiaolijian.selectTargetAi(_status.event, player);
                                    if (ui.selected.cards.length < targets - 1) {
                                        if (player.hasSkill('sbbiyue')) return 4 * targets - get.value(card);
                                        return 6 + targets - get.value(card);
                                    }
                                    return 0;
                                },
                                multiline: true,
                                usable: 1,
                                content() {
                                    var targetx = targets.slice().sortBySeat(target)[1];
                                    var card = { name: 'juedou', isCard: true };
                                    if (target.canUse(card, targetx)) target.useCard(card, targetx);
                                },
                                ai: {
                                    threaten: 3,
                                    order: 7,
                                    result: {
                                        player(player, target) {
                                            let targets = _status.event.getTempCache('minimiaolijian', 'targets');
                                            if (Array.isArray(targets)) {
                                                for (let arr of targets) {
                                                    if (target === arr[0] && !arr[2]) return 1;
                                                }
                                            }
                                            return 0;
                                        },
                                        target(player, target) {
                                            let targets = _status.event.getTempCache('minimiaolijian', 'targets');
                                            if (Array.isArray(targets)) {
                                                for (let arr of targets) {
                                                    if (target === arr[0]) {
                                                        if (arr[1] * arr[2] < 0) return get.sgn(arr[2]);
                                                        return arr[1];
                                                    }
                                                }
                                            }
                                            return 0;
                                        },
                                    },
                                },
                                selectTargetAi(event, player) {
                                    let cache = _status.event.getTempCache('minimiaolijian', 'targets');
                                    if (Array.isArray(cache)) return cache.length;
                                    let targets = [], cards = [0], sbbiyue = player.hasSkill('sbbiyue') ? Math.max(0, 3 - game.countPlayer2(current => {
                                        return current.getHistory('damage').length > 0;
                                    })) : 0, alter = [null, 1, 1], temp;
                                    for (let i of game.players) {
                                        if (player === i) continue;
                                        let vplayer = ui.create.player(i);
                                        temp = get.effect(i, new lib.element.VCard({ name: 'juedou', isCard: true }), vplayer, i);
                                        vplayer.remove();
                                        if (temp) {
                                            let att = get.attitude(event.player, i);
                                            if (!att && sbbiyue || att * temp > 0) targets.push([i, temp, att]);
                                            else if (!alter[2]) continue;
                                            else if (!att || att > 0 && temp > -15 && i.hp > 2 || att < 0 && temp < 15) alter = [i, temp, att];
                                        }
                                    }
                                    targets.sort((a, b) => {
                                        if (Boolean(a[2]) !== Boolean(b[2])) return Math.abs(b[2]) - Math.abs(a[2]);
                                        return Math.abs(b[1]) - Math.abs(a[1]);
                                    });
                                    if (targets.length < 2 && alter[0]) targets.push(alter);
                                    targets = targets.slice(0, 1 + player.countCards('he', card => {
                                        if (lib.filter.cardDiscardable(card, player, 'minimiaolijian')) {
                                            cards.push(get.value(card));
                                            return true;
                                        }
                                        return false;
                                    }));
                                    cards.sort((a, b) => a - b);
                                    for (let i = 0; i < targets.length; i++) {
                                        if (Math.abs(targets[i][1]) < cards[i] / (1 + sbbiyue)) {
                                            targets.splice(i, targets.length - i);
                                            break;
                                        }
                                    }
                                    if (targets.length < 2) {
                                        event.putTempCache('minimiaolijian', 'targets', []);
                                        return 0;
                                    }
                                    event.putTempCache('minimiaolijian', 'targets', targets);
                                    return targets.length;
                                },
                            },
                            minimiaobiyue: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseJieshuBegin' },
                                forced: true,
                                content() {
                                    player.draw(Math.min(5, game.countPlayer2(function (current) {
                                        return current.getHistory('damage').length > 0;
                                    }) + (player.hasSkill('minidoumao') ? 1 : 2)));
                                },
                            },
                            //喵蔡夫人
                            minimiaoqieting: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    return event.player != player;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    var list = ['摸一张牌'], target = trigger.player, str = get.translation(target);
                                    event.target = target;
                                    if (target.hasSkill('minidoumao') && target.countCards('h') > 0) list.push('观看' + str + '的两张手牌并获得其中一张');
                                    if (!target.hasSkill('minidoumao') && target.countCards('e', function (card) {
                                        return player.canEquip(card);
                                    }) > 0) list.push('将' + str + '装备区内的一张牌移动至自己的装备区');
                                    player.chooseControl('cancel2').set('choiceList', list).set('prompt', get.prompt('minimiaoqieting', target)).set('ai', function () {
                                        var evt = _status.event.getParent();
                                        var player = evt.player, target = evt.target;
                                        var list = _status.event.choiceList;
                                        if (get.attitude(player, target) > 0 || list.length == 1) return 0;
                                        if (target.hasSkill('minidoumao')) return 1;
                                        var val = (target.hasSkillTag('noe') ? 6 : 0);
                                        if (target.countCards('e', function (card) {
                                            return player.canEquip(card) && get.value(card, target) > val && get.effect(player, card, player, player) > 0;
                                        }) > 0) return 1;
                                        return 0;
                                    }).set('list', list);
                                    'step 1'
                                    if (result.control != 'cancel2') {
                                        player.logSkill('minimiaoqieting', target);
                                        if (result.index == 0) {
                                            player.draw();
                                            event.finish();
                                        }
                                        else if (target.hasSkill('minidoumao')) {
                                            player.choosePlayerCard(target, 'h', 2, true);
                                            player.addExpose(0.2);
                                            event.goto(3);
                                        }
                                        else {
                                            player.addExpose(0.1);
                                            player.choosePlayerCard(target, 'e', true).set('filterButton', function (button) {
                                                return _status.event.player.canEquip(button.link);
                                            }).set('ai', function (button) {
                                                var player = _status.event.player;
                                                return get.effect(player, button.link, player, player);
                                            });
                                        }
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        var card = result.cards[0];
                                        target.$give(card, player, false);
                                        game.delay(0.5);
                                        player.equip(card);
                                    }
                                    event.finish();
                                    'step 3'
                                    if (result.bool) player.chooseButton(['选择获得一张牌', result.cards], true);
                                    else event.finish();
                                    'step 4'
                                    if (result.bool) {
                                        var card = result.links[0];
                                        if (lib.filter.canBeGained(card, player, target)) player.gain(card, target, 'giveAuto', 'bySelf');
                                        else game.log('但', card, '不能被', player, '获得！');
                                    }
                                },
                            },
                            minimiaoxianzhou: {
                                unique: true,
                                limited: true,
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.countCards('he') > 0;
                                },
                                filterCard: true,
                                selectCard: [1, Infinity],
                                check(card) {
                                    var player = _status.event.player;
                                    if (ui.selected.cards.length >= player.hp) return 0;
                                    return 7 - get.value(card);
                                },
                                filterTarget: lib.filter.notMe,
                                discard: false,
                                lose: false,
                                delay: false,
                                skillAnimation: true,
                                animationColor: 'gray',
                                content() {
                                    'step 0'
                                    player.addSkill('minimiaoxianzhou_restore');
                                    player.awakenSkill('minimiaoxianzhou');
                                    player.give(cards, target);
                                    'step 1'
                                    var list = game.filterPlayer(function (current) {
                                        return target.inRange(current);
                                    });
                                    if (list.length) {
                                        var max = Math.min(list.length, cards.length);
                                        target.chooseTarget([1, max], '献州：对至多' + get.cnNumber(max) + '名范围内的角色各造成1点伤害，或点“取消”令' + get.translation(player) + '回复' + cards.length + '点体力', function (card, player, target) {
                                            return _status.event.list.includes(target);
                                        }).set('list', list).set('ai', function (target) {
                                            var player = _status.event.player;
                                            return get.damageEffect(target, player, player);
                                        });
                                    }
                                    else event._result = { bool: false };
                                    'step 2'
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        target.line(targets, 'green');
                                        for (var i of targets) i.damage('nocard', target);
                                    }
                                    else player.recover(cards.length);
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        target: 1,
                                        player(player) {
                                            var bool = true, players = game.filterPlayer();
                                            for (var i = 0; i < players.length; i++) {
                                                if (players[i] != player && get.attitude(player, players[i]) > 2 && get.attitude(players[i], player) > 2) {
                                                    bool = false; break;
                                                }
                                            }
                                            if (bool) return -10;
                                            if (player.hp == 1) return 1;
                                            return -10;
                                        }
                                    },
                                },
                                subSkill: {
                                    restore: {
                                        audio: 'minimiaoxianzhou',
                                        trigger: { global: 'logSkill' },
                                        filter(event, player) {
                                            if (event.skill != 'minidoumao' || !event.targets) return false;
                                            return event.targets[0] == player;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.restoreSkill('minimiaoxianzhou');
                                            player.removeSkill('minimiaoxianzhou_restore');
                                        },
                                    },
                                },
                            },
                            //喵张星彩
                            minimiaoshenxian: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: ['loseAfter', 'loseAsyncAfter'] },
                                filter(event, player) {
                                    if (event.type != 'discard' || event.getlx === false) return false;
                                    if (event.name == 'lose' && event.player == player) return false;
                                    var cards = event.cards2.slice(0);
                                    var evt = event.getl(player);
                                    if (evt?.cards?.length) cards.removeArray(evt.cards);
                                    return cards.filter(function (card) {
                                        var type = get.type(card, null, event.hs && event.hs.includes(card) ? event.player : false);
                                        if (!player.hasSkill('minidoumao')) return type != 'equip';
                                        return type == 'basic';
                                    }).length;
                                },
                                usable: 1,
                                frequent: true,
                                content() {
                                    'step 0'
                                    if (trigger.delay == false) game.delay();
                                    'step 1'
                                    player.draw();
                                },
                            },
                            minimiaoqiangwu: {
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (player._minimiaoqiangwu_check) return;
                                        if (card.name == 'sha' && !target.hasSkill('minidoumao')) return true;
                                    },
                                    cardUsableTarget(card, player, target) {
                                        if (card.name == 'sha' && target.hasSkill('minidoumao')) return Infinity;
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { source: 'damageSource' },
                                filter(event, player) {
                                    return event.card && event.card.name == 'sha' && player.hasSkill('minidoumao');
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player.draw();
                                },
                            },
                            //喵祝融
                            minimiaojuxiang: {
                                group: 'juxiang1',
                                audio: 'ext:活动武将/audio/skill:2',
                                preHidden: ['juxiang1', 'minimiaojuxiang'],
                                trigger: { player: 'useCard', source: 'damageSource', global: ['useCardAfter', 'loseAfter'] },
                                filter(event, player, name) {
                                    if (event.name != 'lose' && (!event.card || event.card.name != 'nanman')) return false;
                                    if (name == 'useCard') return game.hasPlayer(function (current) {
                                        return current != player && current.hasSkill('minidoumao');
                                    });
                                    if (name == 'useCardAfter') return event.cards.filterInD().length && event.player != player;
                                    if (event.name == 'damage') return !event.player.hasSkill('minidoumao');
                                    if (event.type != 'discard' || event.getlx === false) return false;
                                    var cards = event.cards2.slice(0);
                                    var evt = event.getl(player);
                                    if (evt?.cards?.length) cards.removeArray(evt.cards);
                                    return cards.filter(function (card) {
                                        return card.name == 'nanman' && get.position(card, true) == 'd';
                                    }).length;
                                },
                                forced: true,
                                content() {
                                    'step 0'
                                    var name = event.triggername;
                                    if (trigger.name == 'damage') player.draw();
                                    else if (trigger.name == 'lose') {
                                        var cards = trigger.cards2.slice(0);
                                        var evt = trigger.getl(player);
                                        if (evt?.cards?.length) cards.removeArray(evt.cards);
                                        player.gain(cards.filter(function (card) {
                                            return card.name == 'nanman' && get.position(card, true) == 'd';
                                        }), 'gain2');
                                    }
                                    else if (name == 'useCardAfter' && trigger.cards.filterInD().length) player.gain(trigger.cards.filterInD(), 'gain2');
                                    else trigger.directHit.addArray(game.filterPlayer(function (current) {
                                        return current != player && current.hasSkill('minidoumao');
                                    }));
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        return arg?.card && arg.card.name == 'nanman' && arg.target && arg.target != player && arg.target.hasSkill('minidoumao');
                                    },
                                    effect: {
                                        target(card) {
                                            if (card.name == 'nanman') return [0, 1];
                                        },
                                    },
                                },
                            },
                            minimiaolieren: {
                                group: ['minirelieren', 'minimiaolieren_gain'],
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseUseBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        return player.canCompare(target);
                                    }) && player.getHistory('useSkill', function (evt) {
                                        return evt.targets && evt.skill == 'minidoumao';
                                    }).length;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseTarget(get.prompt('minimiaolieren'), '对一名角色发动【烈刃①】', function (card, player, target) {
                                        return player.canCompare(target);
                                    }).set('ai', function (target) {
                                        return -get.attitude(player, target) * target.countCards('e') / target.countCards('h');
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill('minimiaolieren', target);
                                        player.chooseToCompare(target).clear = false;
                                    }
                                    else event.finish();
                                    'step 2'
                                    if (result.bool) {
                                        if (target.countGainableCards(player, 'he')) player.gainPlayerCard(target, true, 'he');
                                        ui.clear();
                                    }
                                },
                                ai: { expose: 0.25 },
                                subSkill: {
                                    gain: {
                                        trigger: { player: 'chooseToCompareAfter' },
                                        filter(event, player) {
                                            if (!['minimiaolieren', 'minirelieren'].includes(event.getParent().name)) return false;
                                            return get.position(event.card2, true) == 'o';
                                        },
                                        direct: true,
                                        content() {
                                            player.gain(trigger.card2, 'gain2');
                                        },
                                    },
                                },
                            },
                            minimiaochangbiao: {
                                audio: 'changbiao',
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (card.minimiaochangbiao) return true;
                                    },
                                    selectTarget(card, player, num) {
                                        if (player.hasSkill('minidoumao') && card.minimiaochangbiao && num[1] != -1) num[1]++;
                                    },
                                },
                                enable: 'phaseUse',
                                usable: 1,
                                position: 'hs',
                                viewAs: {
                                    name: 'sha',
                                    minimiaochangbiao: true,
                                },
                                locked: false,
                                filter(event, player) {
                                    return player.countCards('hs') > 0;
                                },
                                filterCard: true,
                                selectCard: [1, Infinity],
                                position: 'hs',
                                check(card) {
                                    var player = _status.event.player;
                                    if (ui.selected.cards.length) {
                                        var list = game.filterPlayer(function (current) {
                                            return current != player && player.canUse('sha', current, false) && get.effect(current, { name: 'sha' }, player, player) > 0;
                                        }).sort(function (a, b) {
                                            return get.effect(b, { name: 'sha' }, player, player) - get.effect(a, { name: 'sha' }, player, player);
                                        });
                                        if (!list.length) return 0;
                                        var target = list[0];
                                        if (target.mayHaveShan() && !player.hasSkillTag('directHit_ai', true, {
                                            target: target,
                                            card: card,
                                        }, true)) return 0;
                                        return 6.5 - get.value(card);
                                    }
                                    return 6.3 - get.value(card);
                                },
                                onuse(result, player) {
                                    player.addTempSkill('minimiaochangbiao_draw');
                                },
                                subSkill: {
                                    draw: {
                                        trigger: { player: 'phaseUseEnd' },
                                        forced: true,
                                        charlotte: true,
                                        filter(event, player) {
                                            return player.getHistory('sourceDamage', function (evxt) {
                                                var evt = evxt.getParent();
                                                return evt?.name == 'sha' && evt.skill == 'minimiaochangbiao' && evt.getParent('phaseUse') == event;
                                            }).length > 0;
                                        },
                                        content() {
                                            var num = 0;
                                            player.getHistory('sourceDamage', function (evxt) {
                                                var evt = evxt.getParent();
                                                if (evt?.name == 'sha' && evt.skill == 'minimiaochangbiao' && evt.getParent('phaseUse') == trigger) num += evt.cards.length;
                                            });
                                            player.draw(num);
                                        },
                                    },
                                },
                                ai: {
                                    order(item, player) {
                                        return get.order({ name: 'sha' }, player) + 0.3 * (Math.min(player.getCardUsable('sha'), player.countCards('hs', 'sha') + player.hasCard(function (card) {
                                            return card.name != 'sha' && get.value(card, player) < 6.3;
                                        }, 'hs') ? 1 : 0) > 1 ? -1 : 1);
                                    },
                                },
                            },
                            //喵黄月英
                            minimiaojizhi: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'useCard' },
                                filter(event, player) {
                                    if (get.type2(event.card) != 'trick') return false;
                                    return event.player == player || (!player.hasSkill('minidoumao') && !player.hasSkill('minimiaojizhi_used'));
                                },
                                frequent: true,
                                content() {
                                    player.draw();
                                    if (trigger.player != player) player.addTempSkill('minimiaojizhi_used');
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            minimiaoqicai: {
                                mod: {
                                    targetInRange(card, player, target, now) {
                                        var type = get.type2(card);
                                        if (type == 'trick' || type == 'delay') return true;
                                    },
                                    canBeDiscarded(card) {
                                        if (get.position(card) == 'e' && get.subtype(card) == 'equip2') return false;
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'logSkill' },
                                filter(event, player) {
                                    if (event.skill != 'minidoumao' || !event.targets) return false;
                                    return event.targets[0] != player;
                                },
                                forced: true,
                                content() {
                                    var card = get.cardPile2(function (card) {
                                        return get.type2(card) == 'trick';
                                    });
                                    if (card) player.gain(card, 'gain2');
                                },
                            },
                            minimiaoguose: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'sbguose',
                                usable: 4,
                                content() {
                                    'step 0'
                                    if (target.hasJudge('lebu')) target.discard(target.getJudge('lebu'));
                                    else player.useCard({ name: 'lebu' }, target, cards).audio = false;
                                    'step 1'
                                    player.draw(target.hasSkill('minidoumao') ? 2 : 1);
                                    if (target.hasSkill('minidoumao')) player.chooseToDiscard(true, 'he', '国色：请弃置一张牌');
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            var num = (target.hasSkill('minidoumao') ? 2 : 1);
                                            if (target.hasJudge('lebu')) return -get.effect(target, { name: 'lebu' }, player, target) * num;
                                            return get.effect(target, { name: 'lebu' }, player, target) * num;
                                        },
                                    },
                                },
                            },
                            minimiaoliuli: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { target: 'useCardToTarget' },
                                filter(event, player) {
                                    if (event.card.name != 'sha') return false;
                                    if (!player.countCards('he')) return false;
                                    return game.hasPlayer(function (current) {
                                        return player.inRange(current) && current != event.player && current != player && lib.filter.targetEnabled(event.card, event.player, current);
                                    });
                                },
                                direct: true,
                                preHidden: true,
                                content() {
                                    "step 0"
                                    player.chooseCardTarget({
                                        position: 'he',
                                        filterCard: lib.filter.cardDiscardable,
                                        filterTarget(card, player, target) {
                                            var trigger = _status.event;
                                            if (player.inRange(target) && target != trigger.source) {
                                                if (lib.filter.targetEnabled(trigger.card, trigger.source, target)) return true;
                                            }
                                            return false;
                                        },
                                        selectTarget() {
                                            return _status.event.player.hasSkill('minidoumao') ? 1 : [1, 2];
                                        },
                                        complexSelect: true,
                                        ai1(card) {
                                            return get.unuseful(card) + 9;
                                        },
                                        ai2(target) {
                                            var player = _status.event.player;
                                            var att = get.attitude(player, target);
                                            if (player.countCards('h', 'shan')) return -att;
                                            if (!ui.selected.targets.length) {
                                                if (att < 5) return 6 - att;
                                                if (hp == 1 && !player.countCards('h', 'shan')) return 10 - att;
                                                if (player.hp == 2 && !player.countCards('h', 'shan')) return 8 - att;
                                            }
                                            return -1;
                                        },
                                        prompt: get.prompt2('minimiaoliuli'),
                                        source: trigger.player,
                                        card: trigger.card,
                                    }).setHiddenSkill('minimiaoliuli');
                                    "step 1"
                                    if (result.bool) {
                                        var targets = result.targets.sortBySeat();
                                        player.logSkill('minimiaoliuli', targets);
                                        player.discard(result.cards);
                                        var evt = trigger.getParent();
                                        evt.triggeredTargets2.remove(player);
                                        evt.targets.remove(player);
                                        evt.targets.addArray(targets);
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (target.countCards('he') == 0) return;
                                            if (card.name != 'sha') return;
                                            var min = 1;
                                            var friend = get.attitude(player, target) > 0;
                                            var vcard = { name: 'shacopy', nature: card.nature, suit: card.suit };
                                            var players = game.filterPlayer();
                                            for (var i = 0; i < players.length; i++) {
                                                if (player != players[i] && get.attitude(target, players[i]) < 0 && target.canUse(card, players[i])) {
                                                    if (!friend) return 0;
                                                    if (get.effect(players[i], vcard, player, player) > 0) {
                                                        if (!player.canUse(card, players[0])) return [0, 0.1];
                                                        min = 0;
                                                    }
                                                }
                                            }
                                            return min;
                                        },
                                    },
                                },
                            },
                            //喵王异
                            minimiaozhenlie: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'zhenlie',
                                content() {
                                    'step 0'
                                    player.loseHp();
                                    trigger.getParent().excluded.add(player);
                                    'step 1'
                                    if (trigger.player[player.hasSkill('minidoumao') ? 'countDiscardableCards' : 'countGainableCards'](player, 'he')) {
                                        player[player.hasSkill('minidoumao') ? 'discardPlayerCard' : 'gainPlayerCard'](trigger.player, 'he', true);
                                    }
                                },
                            },
                            minimiaomiji: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseJieshuBegin' },
                                filter(event, player) {
                                    return game.hasPlayer(function (target) {
                                        if (player.hasSkill('minidoumao') && target != player) return false;
                                        return target.isDamaged();
                                    });
                                },
                                direct: true,
                                frequent: true,
                                content() {
                                    'step 0'
                                    if (player.hasSkill('minidoumao')) player.chooseBool(get.prompt2('minimiaomiji')).set('frequentSkill', 'minimiaomiji');
                                    else {
                                        var targets = game.filterPlayer(function (target) {
                                            if (player.hasSkill('minidoumao') && target != player) return false;
                                            return target.isDamaged();
                                        });
                                        var str = '摸' + get.cnNumber(player.getDamagedHp()) + '张牌';
                                        if (!player.hasSkill('minidoumao')) str = '选择场上的一名受伤的角色，摸等同于其损失体力值的牌（至多五张）';
                                        player.chooseTarget(get.prompt('minimiaomiji'), str + '，然后你可以将等量的牌交给一名其他角色', function (card, player, target) {
                                            if (player.hasSkill('minidoumao') && target != player) return false;
                                            return target.isDamaged();
                                        }).set('ai', function (target) {
                                            return target.getDamagedHp();
                                        });
                                    }
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0] || player;
                                        player.logSkill('minimiaomiji');
                                        player.line(target);
                                        var num = Math.min(5, target.getDamagedHp());
                                        event.num = num;
                                        player.draw(num);
                                    }
                                    else event.finish();
                                    'step 2'
                                    var check = player.countCards('h') - event.num;
                                    player.chooseCardTarget({
                                        selectCard: event.num,
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            var player = _status.event.player;
                                            if (player.maxHp - player.hp == 1 && card.name == 'du') return 30;
                                            var check = _status.event.check;
                                            if (check < 1) return 0;
                                            if (player.hp > 1 && check < 2) return 0;
                                            return get.unuseful(card) + 9;
                                        },
                                        ai2(target) {
                                            var att = get.attitude(_status.event.player, target);
                                            if (ui.selected.cards.length == 1 && ui.selected.cards[0].name == 'du') return 1 - att;
                                            return att - 2;
                                        },
                                        prompt: '秘计：是否将' + get.cnNumber(event.num) + '张手牌交给一名其他角色？',
                                    }).set('check', check);
                                    'step 3'
                                    if (result.bool) {
                                        player.line(result.targets);
                                        player.give(result.cards, result.targets[0]);
                                    }
                                },
                            },
                            //喵春哥
                            minimiaojueqing: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { source: 'damageBefore' },
                                direct: true,
                                content() {
                                    'step 0'
                                    if (!player.hasSkill('minidoumao')) {
                                        player.chooseBool(get.prompt('minimiaojueqing'), '失去' + trigger.num + '点体力，令即将对其造成的伤害翻倍至' + (trigger.num * 2) + '点').set('choice', player.hp > trigger.num && trigger.player.hp > trigger.num && get.attitude(player, trigger.player) < 0);
                                    }
                                    else event.goto(2);
                                    'step 1'
                                    if (result.bool) {
                                        event.logged = true;
                                        player.logSkill('minimiaojueqing');
                                        player.loseHp(trigger.num);
                                        trigger.num *= 2;
                                    }
                                    'step 2'
                                    if (!event.logged) player.logSkill('minimiaojueqing');
                                    trigger.cancel();
                                    trigger.player.loseHp(trigger.num);
                                },
                            },
                            minimiaoshangshi: {
                                group: 'minishangshi',
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'logSkill' },
                                filter(event, player) {
                                    if (event.skill != 'minidoumao' || !event.targets) return false;
                                    return event.player == player || event.targets.includes(player);
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player[(trigger.player == player ? 'gain' : 'lose') + 'MaxHp']();
                                },
                            },
                            //喵甄姬
                            minimiaoluoshen: {
                                inherit: 'miniluoshen',
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: ['phaseZhunbeiBegin', 'phaseEnd'] },
                                filter(event, player) {
                                    return !player.hasSkill('minidoumao') || event.name == 'phaseZhunbei';
                                },
                            },
                            minimiaoqingguo: {
                                mod: {
                                    aiValue(player, card, num) {
                                        if (!player.hasSkill('minidoumao')) return;
                                        if (get.name(card) != 'shan' && get.color(card) != 'black') return;
                                        var cards = player.getCards('hs', function (card) {
                                            return get.name(card) == 'shan' || get.color(card) == 'black';
                                        });
                                        cards.sort(function (a, b) {
                                            return (get.name(b) == 'shan' ? 1 : 2) - (get.name(a) == 'shan' ? 1 : 2);
                                        });
                                        var geti = function () {
                                            if (cards.includes(card)) {
                                                return cards.indexOf(card);
                                            }
                                            return cards.length;
                                        };
                                        if (get.name(card) == 'shan') return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                                    },
                                    aiUseful() {
                                        return lib.skill.minimiaoqingguo.mod.aiValue.apply(this, arguments);
                                    },
                                },
                                locked: false,
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: ['chooseToRespond', 'chooseToUse'],
                                filterCard(card) {
                                    return get.color(card) == 'black';
                                },
                                position: 'hes',
                                viewAs: { name: 'shan' },
                                viewAsFilter(player) {
                                    if (!player.countCards('hes', { color: 'black' })) return false;
                                },
                                prompt: '将一张黑色牌当闪打出',
                                check: () => 1,
                                ai: {
                                    order: 2,
                                    respondShan: true,
                                    skillTagFilter(player) {
                                        if (!player.countCards('hes', { color: 'black' })) return false;
                                    },
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, 'respondShan') && current < 0) return 0.6
                                        },
                                    },
                                },
                                group: 'minimiaoqingguo_jijiu',
                                subSkill: {
                                    jijiu: {
                                        audio: 'minimiaoqingguo',
                                        mod: {
                                            aiValue(player, card, num) {
                                                if (player.hasSkill('minidoumao')) return;
                                                if (get.name(card) != 'tao' && get.name(card) != 'shan') return;
                                                var cards = player.getCards('hs', function (card) {
                                                    return get.name(card) == 'tao' || get.name(card) == 'shan';
                                                });
                                                cards.sort(function (a, b) {
                                                    return (get.name(a) == 'tao' ? 1 : 2) - (get.name(b) == 'tao' ? 1 : 2);
                                                });
                                                var geti = function () {
                                                    if (cards.includes(card)) {
                                                        return cards.indexOf(card);
                                                    }
                                                    return cards.length;
                                                };
                                                return Math.max(num, [6.5, 4, 3, 2][Math.min(geti(), 2)]);
                                            },
                                            aiUseful() {
                                                return lib.skill.minimiaoqingguo_jijiu.mod.aiValue.apply(this, arguments);
                                            },
                                        },
                                        locked: false,
                                        enable: 'chooseToUse',
                                        viewAsFilter(player) {
                                            return !player.hasSkill('minidoumao') && player.countCards('hs', { name: 'shan' }) > 0;
                                        },
                                        filterCard: { name: 'shan' },
                                        viewAs: { name: 'tao' },
                                        prompt: '将一张【闪】当作【桃】使用',
                                        check(card) {
                                            return 15 - get.value(card);
                                        },
                                    },
                                },
                            },
                            //喵孙尚香
                            minimiaojieyin: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'minijieyin',
                                content() {
                                    'step 0'
                                    if (get.position(cards[0]) == 'e') {
                                        player.$give(cards, target);
                                        target.equip(cards[0]);
                                    }
                                    else player.give(cards, target, true);
                                    'step 1'
                                    player.recover();
                                    player.draw();
                                    'step 2'
                                    if (player.hasSkill('minidoumao')) { event.finish(); return; }
                                    player.chooseBool('结姻：是否令' + get.translation(target) + '回复1点体力并摸一张牌？').set('choice', get.attitude(player, target) > 0);
                                    'step 3'
                                    if (result.bool) {
                                        player.line(target);
                                        target.recover();
                                        target.draw();
                                    }
                                },
                            },
                            minimiaoxiaoji: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: {
                                    player: 'loseAfter',
                                    global: ['equipAfter', 'addJudgeAfter', 'gainAfter', 'loseAsyncAfter', 'addToExpansionAfter'],
                                },
                                filter(event, player) {
                                    var evt = event.getl(player);
                                    return evt?.player == player && evt.es && evt.es.length > 0;
                                },
                                frequent: true,
                                content() {
                                    'step 0'
                                    event.count = trigger.getl(player).es.length;
                                    'step 1'
                                    event.count--;
                                    player.draw(2);
                                    if (player.hasSkill('minidoumao')) { event.goto(3); return; }
                                    player.chooseTarget('是否弃置场上的一张牌？', function (card, player, target) {
                                        return target.countDiscardableCards(player, 'ej');
                                    }).set('ai', target => {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        if (att > 0 && (target.countCards('j') > 0 || target.countCards('e', function (card) {
                                            return get.value(card, target) < 0;
                                        }))) return 2;
                                        if (att < 0 && target.countCards('e') > 0 && !target.hasSkillTag('noe')) return -1;
                                        return 0;
                                    });
                                    'step 2'
                                    if (result.bool) player.discardPlayerCard(result.targets[0], 'ej', true);
                                    'step 3'
                                    if (event.count > 0 && player.hasSkill('minimiaoxiaoji')) player.chooseBool('是否再次发动【枭姬】？').set('frequentSkill', 'minimiaoxiaoji');
                                    else event.finish();
                                    'step 4'
                                    if (result.bool) {
                                        player.logSkill('minimiaoxiaoji');
                                        event.goto(1);
                                    }
                                },
                                ai: {
                                    noe: true,
                                    reverseEquip: true,
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.type(card) == 'equip' && !get.cardtag(card, 'gifts')) return [1, 3];
                                        },
                                    },
                                },
                            },
                            //喵小乔
                            minimiaotianxiang: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'damageBegin3' },
                                filter(event, player) {
                                    return player.countCards('h', { suit: 'heart' }) && event.num > 0;
                                },
                                direct: true,
                                content() {
                                    'step 0'
                                    player.chooseCardTarget({
                                        filterCard(card, player) {
                                            return get.suit(card) == 'heart' && lib.filter.cardDiscardable(card, player);
                                        },
                                        filterTarget: lib.filter.notMe,
                                        ai1(card) {
                                            return 10 - get.value(card);
                                        },
                                        ai2(target) {
                                            var player = _status.event.player;
                                            var num = (target.hasSkill('minidoumao') ? 2 : 1);
                                            var att = get.attitude(player, target);
                                            return -att * num;
                                        },
                                        prompt: get.prompt2('minimiaotianxiang')
                                    });
                                    'step 1'
                                    if (result.bool) {
                                        var target = result.targets[0], cards = result.cards;
                                        player.logSkill('minimiaotianxiang', target);
                                        target.gain(cards, player, 'give');
                                        player.addTempSkill('minimiaotianxiang2');
                                        trigger.cancel();
                                        target.damage(trigger.source ? trigger.source : 'nosource', trigger.nature, trigger.num).set('card', trigger.card).set('cards', trigger.cards).minimiaotianxiang2 = [player];
                                    }
                                },
                                ai: {
                                    maixie_defend: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.hasSkillTag('jueqing', false, target)) return;
                                            if (get.tag(card, 'damage') && target.countCards('h') > 1) return 0.7;
                                        },
                                    },
                                    threaten(player, target) {
                                        if (!target.countCards('h')) return 2;
                                    },
                                },
                            },
                            minimiaotianxiang2: {
                                charlotte: true,
                                trigger: { global: ['damageAfter', 'damageCancelled', 'damageZero'] },
                                filter(event, player) {
                                    return event.minimiaotianxiang2 && event.minimiaotianxiang2.includes(player) && event.player.isIn();
                                },
                                direct: true,
                                content() {
                                    player.line(trigger.player);
                                    if (trigger.player.hasSkill('minidoumao')) trigger.player.damage();
                                    else player.discardPlayerCard(trigger.player, 'he', true);
                                },
                            },
                            minimiaohongyan: {
                                mod: {
                                    suit(card, suit) {
                                        if (suit == 'spade') return 'heart';
                                    },
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'judgeEnd' },
                                filter(event, player) {
                                    if (event.player.hasSkill('minidoumao')) return false;
                                    return get.suit(event.result.card, event.player) == 'heart';
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    player.recover();
                                    player.draw();
                                },
                            },
                            //喵607
                            minimiaozhuangrong: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'zhuangrong',
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    await player.loseMaxHp();
                                    if (player.maxHp > player.hp) await player.recover(player.maxHp - player.hp);
                                    await player.drawTo(Math.min(5, player.maxHp));
                                    await player.addSkills(get.info(event.name).derivation);
                                },
                                derivation: ['minillqshenwei', 'miniwushuang'],
                            },
                            minillqshenwei: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'llqshenwei',
                                async content(event, trigger, player) {
                                    const num = player.hasSkill('minidoumao', null, null, false) ? 2 : 3;
                                    trigger.num += num;
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        const numx = player.hasSkill('minidoumao', null, null, false) ? 2 : 1;
                                        return num + numx;
                                    },
                                },
                            },
                            minimiaoguowu: {
                                audio: 'ext:活动武将/audio/skill:2',
                                inherit: 'guowu',
                                async content(event, trigger, player) {
                                    const hs = player.getCards('h'), num = hs.map(card => get.type2(card, player)).toUniqued().length;
                                    await player.showCards(hs, get.translation(player) + '发动了【帼武】');
                                    if (num >= 1) {
                                        const card = get.discardPile(card => get.type(card) == 'trick');
                                        if (card) await player.gain(card, 'gain2');
                                    }
                                    if (num >= 2) player.addTempSkill(event.name + '_effect', 'phaseUseAfter');
                                    if (num >= 3) player.addTempSkill(event.name + '_buff', 'phaseUseAfter');
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        mod: { cardUsable: () => Infinity },
                                    },
                                    buff: {
                                        charlotte: true,
                                        trigger: { player: 'useCard' },
                                        filter(event, player) {
                                            if (event.card.name != 'sha' && get.type(event.card) != 'trick') return false;
                                            return player.getHistory('useCard', evt => evt.isPhaseUsing() && (evt.card.name == 'sha' || get.type(evt.card) == 'trick')).indexOf(event) == 0;
                                        },
                                        prompt2: '令此牌额外结算一次',
                                        async content(event, trigger, player) {
                                            trigger.effectCount++;
                                            game.log(trigger.card, '额外结算一次');
                                        },
                                    }
                                }
                            },
                            //念
                            mininianying: {
                                subSkill: {
                                    Mnian_zhugeliang: { audio: 'ext:活动武将/audio/skill:2' },
                                    Mnian_lvbu: { audio: 'ext:活动武将/audio/skill:2' },
                                    Mnian_zhouyu: { audio: 'ext:活动武将/audio/skill:2' },
                                },
                            },
                            mininianxinghan: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: ['phaseBegin', 'damageBegin4'] },
                                filter(event, player) {
                                    return lib.skill.mininianxinghan.filterGroup(player).length;
                                },
                                usable: 1,
                                //整理棋子给点反应时间，就不自动发动了
                                //frequent:true,
                                async content(event, trigger, player) {
                                    player.addTempSkill('mininianxinghan_timeOut');
                                    let list = [], groups = lib.skill.mininianxinghan.filterGroup(player);
                                    if (!groups.length) {
                                        player.popup('杯具');
                                        game.log('没有势力可进行', '#g定乱', '操作');
                                        return;
                                    }
                                    for (let i = 1; i <= 2; i++) {
                                        for (let k = 0; k < groups.length; k++) {
                                            const group = groups[k];
                                            if (i == 1) {
                                                game.addVideo('skill', player, ['mininianxinghan', [group]]);
                                                if (!lib.card['group_' + group]) game.broadcastAll(group => lib.skill.mininianxinghan.video(group), group);
                                                list.push([get.translation(group + '2'), []]);
                                            }
                                            else {
                                                const groupPuts = lib.skill.mininianxinghan.putResult(4, groups.length);
                                                for (let j = 0; j < groupPuts.length; j++) {
                                                    //if(j==0) list[k][1].addArray(Array.from({length:groups.length}).map(object=>game.createCard('du',' ',' ')));
                                                    list[j][1].addArray(Array.from({ length: groupPuts[j] }).map(object => game.createCard('group_' + group, ' ', ' ')));
                                                }
                                            }
                                        }
                                    }
                                    for (let l of list) l[1].randomSort();
                                    list.push(['垃圾桶（充当空白区）']);
                                    const result = await player.chooseToMove().set('list', list)
                                        .set('prompt', '###定乱：在规定的时间内将一个势力的卡牌整理完毕###<div class="text center">使一个势力的区域只存在此势力的卡牌</div>').set('filterOk', moved => {
                                            const groups = get.event('groups');
                                            return Array.from({ length: groups.length }).map((_, i) => i).filter(i => moved[i].length == 4 && moved[i].every(card => card.name.endsWith(groups[i]))).length == 1;
                                        }).set('processAI', () => {
                                            const player = get.event('player'), group = get.event('groups');
                                            let groups = group.slice();
                                            const finalGroup = groups.sort((a, b) => game.countPlayer(target => target.group == b) - game.countPlayer(target => target.group == a))[0];
                                            let list = Array.from({ length: group.length + 1 }).map(object => []);
                                            for (let i = 0; i < 4; i++) {
                                                list[group.indexOf(finalGroup)].push(game.createCard('group_' + finalGroup, ' ', ' '));
                                            }
                                            return list;
                                        }).set('chooseTime', parseFloat(40 + 10 * Math.max(0, groups.length - 5))).set('groups', groups).forResult();
                                    if (result.bool) {
                                        let resultGroup = Array.from({ length: result.moved.length - 1 }).map((_, i) => i).find(i => result.moved[i].length == 4 && result.moved[i].every(card => card.name.endsWith(groups[i])));
                                        resultGroup = result.moved[resultGroup][0].name.slice('group_'.length);
                                        player.popup('洗具·' + get.translation(resultGroup));
                                        game.log(player, '#g定乱（' + (get.translation(resultGroup + '2') || get.translation(resultGroup)) + '）', '成功');
                                        player.markAuto('mininianxinghan', [resultGroup]);
                                        await player.gainMaxHp();
                                        await player.recover();
                                        const targets = game.filterPlayer(target => target.group == resultGroup);
                                        if (targets.length) {
                                            player.line(targets);
                                            for (const t of targets) await t.changeGroup('shu');
                                        }
                                    }
                                    else {
                                        player.popup('杯具');
                                        game.log(player, '#g定乱', '失败');
                                    }
                                },
                                derivation: 'mininianxinghan_faq',
                                ai: { threaten: 5 },
                                intro: { content: '已“定乱”成功过$势力' },
                                video(group) {
                                    const name = 'group_' + group;
                                    lib.card[name] = { fullskin: true };
                                    lib.translate[name] = get.translation(group) + '势力';
                                    lib.translate[name + '_bg'] = get.translation(group);
                                },
                                //返回由和为num个的maxNum个随机自然数组成的数组
                                putResult(num, maxNum) {
                                    if (typeof maxNum != 'number' || typeof num != 'number') {
                                        console.warn('你是故意找茬的是吧[doge]');
                                        return;
                                    }
                                    let list = [];
                                    for (let i = 0; i < maxNum; i++) {
                                        const put = ((i == maxNum - 1) ? num : get.rand(0, num - (maxNum - i - 1)));
                                        list.push(put);
                                        num -= put;
                                    }
                                    return list.randomSort();
                                },
                                filterGroup(player) {
                                    let groups = (lib.group || []).slice().concat(game.players.slice().concat(game.dead).reduce((list, i) => list.add(i.group), [])).unique();
                                    groups.removeArray(['shu'].concat(player.getStorage('mininianxinghan')));
                                    return groups;
                                },
                                subSkill: {
                                    timeOut: {
                                        trigger: { player: ['chooseToMoveBegin', 'chooseToMoveEnd'] },
                                        filter(event, player) {
                                            if (_status.connectMode || !event.isMine()) return false;
                                            return event.getParent().name == 'mininianxinghan' && event.chooseTime;
                                        },
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        content() {
                                            if (event.triggername.endsWith('End')) {
                                                game.stopCountChoose();
                                                return;
                                            }
                                            const num = parseInt(trigger.chooseTime);
                                            ui.timer.show();
                                            game.countDown(num, function () {
                                                _status.event.result = { bool: false };
                                                ui.click.cancel();
                                                ui.timer.hide();
                                            });
                                        },
                                    },
                                },
                            },
                            mininianliaoyuan: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'chooseToUse',
                                filterCard: () => false,
                                selectCard: -1,
                                check: () => 1,
                                viewAs: { name: 'huogong' },
                                prompt: '出牌阶段限一次，你可以视为使用【火攻】。',
                                usable: 1,
                                ai: { fireAttack: true },
                                mod: {
                                    selectTarget(card, player, num) {
                                        if (card.name == 'huogong' && num[1] != -1) num[1] = Infinity;
                                    },
                                },
                                locked: false,
                            },
                            mininianying_zgl: {
                                audio: 'mininianying_Mnian_zhugeliang',
                                trigger: { player: 'phaseBegin', global: 'phaseEnd' },
                                filter(event, player, name) {
                                    const skills = Object.keys(lib.skill).filter(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(event, player, name));
                                    if (!skills.length) return false;
                                    if (name == 'phaseBegin') return !game.hasPlayer(target => target.group != 'shu');
                                    return game.hasPlayer2(current => {
                                        return current.getHistory('custom', evt => evt.name == 'changeGroup' && evt.originGroup != evt.group && [evt.originGroup, evt.group].includes('shu')).length;
                                    }) || game.getGlobalHistory('everything', evt => evt.name == 'die' && evt.player.group == 'shu').length;
                                },
                                async cost(event, trigger, player) {
                                    const skills = Object.keys(lib.skill).filter(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(trigger, player, name)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                                        .set('prompt', get.prompt('mininianying_zgl')).set('prompt2', '选择一项念影效果执行')
                                        .set('displayIndex', false)
                                        .set('choiceList', skills.map(i => {
                                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                                        })).set('ai', () => get.event('controls').randomGet()).forResult();
                                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                                },
                                async content(event, trigger, player) {
                                    await player.draw(2);
                                    const choice = event.cost_data;
                                    player.popup(choice[1]);
                                    game.log(player, '选择了', '#g' + choice[1]);
                                    await lib.skill[choice[0]].nianyingContent(player);
                                },
                                nianyingSkill: ['奖率三军', '令场上所有与你势力相同的其他角色各摸一张牌，然后依次交给你一张锦囊牌（若其没有锦囊牌则将其本次获得的牌交给你）'],
                                nianyingFilter(event, player, name) {
                                    return game.hasPlayer(target => target != player && target.group == player.group);
                                },
                                async nianyingContent(player) {
                                    const targets = game.filterPlayer(target => target != player && target.group == player.group);
                                    player.line(targets);
                                    let map = {};
                                    for (let i = 0; i < targets.length; i++) {
                                        const result = await targets[i].draw((i != targets.length - 1) ? 'nodelay' : '').forResult();
                                        if (Array.isArray(result)) map[targets[i].playerid] = result;
                                    }
                                    await game.asyncDelay();
                                    for (const target of targets) {
                                        const result = await target.chooseToGive(player, { type: ['trick', 'delay'] }, 'he', true).forResult();
                                        if (!result.bool || !result.cards || !result.cards.length) {
                                            const cards = map[target.playerid].filter(i => get.owner(i) == target);
                                            if (cards.length) await target.give(cards, player);
                                        }
                                    }
                                },
                            },
                            //念吕布
                            mininiantazhen: {
                                init() {
                                    lib.init.sheet([
                                        '.button.character.tazhen {',
                                        'width: 108px !important;',
                                        'height: 150px !important;',
                                        '}'
                                    ].join(''));
                                    lib.init.sheet([
                                        '.button.card.tazhen {',
                                        'width: 108px !important;',
                                        'height: 150px !important;',
                                        '}'
                                    ].join(''));
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: 'phaseBegin' },
                                forced: true,
                                async content(event, trigger, player) {
                                    game.addVideo("skill", player, ['mininiantazhen', []]);
                                    let list = [[], [], []], items = game.filterPlayer(i => i != player).randomGets(3);
                                    let jiu = 2, horse = 1;
                                    while (jiu > 0 && items.length < 9) {
                                        jiu--;
                                        items.push('jiu');
                                    }
                                    while (horse > 0 && items.length < 9) {
                                        horse--;
                                        items.push('horse');
                                    }
                                    while (items.length < 9) {
                                        items.push('sha');
                                    }
                                    items.randomSort();
                                    for (let i = 0; i < 3; i++) {
                                        for (let j = 0; j < 3; j++) {
                                            let item = items.shift();
                                            list[i].push(get.itemtype(item) == 'player' ? `${item.getSeatNum()}|${item.name}|${item.playerid}|${item.getHp()}|${parseFloat(i)}+${parseFloat(j)}` : `${item}|${parseFloat(i)}+${parseFloat(j)}`);
                                        }
                                    }
                                    const func = () => {
                                        const event = get.event();
                                        const controls = [
                                            link => {
                                                const evt = get.event();
                                                if (evt.dialog && evt.dialog.buttons) {
                                                    for (let i = 0; i < evt.dialog.buttons.length; i++) {
                                                        const button = evt.dialog.buttons[i];
                                                        button.classList.remove('selectable');
                                                        button.classList.remove('selected');
                                                        const counterNode = button.querySelector('.caption');
                                                        if (counterNode) counterNode.childNodes[0].innerHTML = ``;
                                                    }
                                                    ui.selected.buttons.length = 0;
                                                    game.check();
                                                }
                                                return;
                                            },
                                        ];
                                        event.controls = [ui.create.control(controls.concat(['清除选择', 'stayleft']))];
                                    };
                                    if (event.isMine()) func();
                                    else if (event.isOnline()) event.player.send(func);
                                    const videoId = lib.status.videoId++;
                                    const dialog = ui.create.dialog(
                                        '踏阵',
                                        '<div class="text center">剩余' + parseFloat(player.getHp() + 1) + '步；攻击力：0；酒：0；当前击败：无</div>',
                                        [list[0], lib.skill.mininiantazhen.tazhen],
                                        [list[1], lib.skill.mininiantazhen.tazhen],
                                        [list[2], lib.skill.mininiantazhen.tazhen],
                                    );
                                    dialog.videoId = videoId;
                                    dialog.classList.add('fullheight');
                                    const result = await player.chooseButton().set('dialog', dialog).set('selectButton', () => {
                                        const kill = get.info('mininiantazhen').kill(ui.selected.buttons.map(i => i.link), get.event().player);
                                        //const dialog = get.idDialog(get.event().videoId);
                                        const dialog = get.event().dialog;
                                        if (dialog) {
                                            const nums = Array.from({ length: 3 }).map((_, i) => i);
                                            const findXY = function (item) {
                                                const nums = item.split('|').reverse()[0].split('+');
                                                return [parseInt(nums[0]), parseInt(nums[1])];
                                            };
                                            const allPosition = ui.selected.buttons.map(but => findXY(but.link));
                                            dialog.content.childNodes[1].innerHTML = '<div class="text center">剩余' + parseFloat(kill[3]) + '步；攻击力：' + parseFloat(kill[0]) + '；酒：' + parseFloat(kill[1]) + '；当前击败：' + (kill[2].length ? get.translation(kill[2].map(i => i[0])) : '无') + '</div>';
                                        }
                                        return [1, 1 + get.event().player.getHp() + ui.selected.buttons.filter(i => i.link.split('|')[0] == 'horse').length * 2];
                                    }).set('filterButton', button => {
                                        if (!get.event().list.slice().flat().includes(button.link)) return false;
                                        if (!ui.selected.buttons.length) return (button.link.split('|').length > 2) === false;
                                        const findXY = function (item) {
                                            const nums = item.split('|').reverse()[0].split('+');
                                            return [parseInt(nums[0]), parseInt(nums[1])];
                                        };
                                        const buttonPosition = findXY(button.link);
                                        const itemPosition = findXY(ui.selected.buttons.slice().reverse()[0].link);
                                        if (Math.abs(buttonPosition[0] - itemPosition[0]) > 1 || Math.abs(buttonPosition[1] - itemPosition[1]) > 1) return false;
                                        if (buttonPosition[0] == itemPosition[0] || buttonPosition[1] == itemPosition[1]) return true;
                                        const dx = buttonPosition[0] - itemPosition[0], dy = buttonPosition[1] - itemPosition[1];
                                        const allPosition = ui.selected.buttons.map(but => findXY(but.link));
                                        return !allPosition.some(p => p[0] == itemPosition[0] + dx && p[1] == itemPosition[1]) || !allPosition.some(p => p[0] == itemPosition[0] && p[1] == itemPosition[1] + dy);
                                    }).set('list', list).set('ai', () => 1 + Math.random()).set('custom', {
                                        add: {
                                            confirm(bool) {
                                                if (bool != true) return;
                                                const event = get.event().parent;
                                                if (event.controls) event.controls.forEach(i => i.close());
                                                if (ui.confirm) ui.confirm.close();
                                                game.uncheck();
                                            },
                                            button() {
                                                if (ui.selected.buttons.length) return;
                                                const event = get.event();
                                                if (event.dialog && event.dialog.buttons) {
                                                    for (let i = 0; i < event.dialog.buttons.length; i++) {
                                                        const button = event.dialog.buttons[i];
                                                        const counterNode = button.querySelector('.caption');
                                                        if (counterNode) counterNode.childNodes[0].innerHTML = ``;
                                                    }
                                                }
                                                if (!ui.selected.buttons.length) {
                                                    const evt = event.parent;
                                                    if (evt.controls) evt.controls[0].classList.add('disabled');
                                                }
                                            },
                                        },
                                        replace: {
                                            button(button) {
                                                const event = get.event();
                                                if (!event.isMine() || ui.selected.buttons.includes(button)) return;
                                                if (!event.filterButton(button)) return;
                                                if (button.classList.contains('selectable') == false) return;
                                                if (ui.selected.buttons.length >= event.selectButton()) return false;
                                                button.classList.add('selected');
                                                ui.selected.buttons.push(button);
                                                let counterNode = button.querySelector('.caption');
                                                const count = ui.selected.buttons.indexOf(button) + 1;
                                                if (counterNode) {
                                                    counterNode = counterNode.childNodes[0];
                                                    counterNode.innerHTML = `第${count}步`;
                                                } else {
                                                    counterNode = ui.create.caption(`<span style="font-size:24px; font-family:xinwei; text-shadow:#FFF 0 0 4px, #FFF 0 0 4px, rgba(74,29,1,1) 0 0 3px;">第${count}步</span>`, button);
                                                    counterNode.style.right = '5px';
                                                    counterNode.style.bottom = '2px';
                                                }
                                                const evt = event.parent;
                                                if (evt.controls) evt.controls[0].classList.remove('disabled');
                                                game.check();
                                            },
                                        },
                                    }).set('filterOk', () => {
                                        return ui.selected.buttons.some(i => i.link.split('|').length > 2)
                                    }).forResult();
                                    game.broadcastAll('closeDialog', videoId);
                                    if (result.bool) {
                                        const kill = get.info('mininiantazhen').kill(result.links.slice(), player);
                                        if (kill[2].length > 0) {
                                            const targets = kill[2].map(i => {
                                                return game.findPlayer2(t => t.playerid == parseInt(i[1]));
                                            }).filter(i => i.isIn()).sortBySeat();
                                            player.line(targets);
                                            player.popup('踏阵成功', 'wood');
                                            game.log(player, '踏阵', '#g成功', '击败了', targets);
                                            const sha = get.cardPile('sha');
                                            if (sha) await player.gain(sha, 'gain2');
                                            player.addTempSkill('mininiantazhen_wushuang', { player: 'phaseBegin' });
                                            await player.addAdditionalSkills('mininiantazhen_wushuang', 'miniwushuang');
                                            const findXY = function (item) {
                                                const nums = item.split('|').reverse()[0].split('+');
                                                return [parseInt(nums[0]), parseInt(nums[1])];
                                            };
                                            const allPosition = result.links.map(but => findXY(but));
                                            const nums = Array.from({ length: 3 }).map((_, i) => i);
                                            if (nums.some(num => !allPosition.some(l => l[1] == num))) {
                                                player.popup('一整列', 'wood');
                                                for (const i of targets) {
                                                    if (i.countCards('h')) await i.chooseToGive(player, 'he', true);
                                                }
                                            }
                                            if (nums.some(num => !allPosition.some(l => l[0] == num))) {
                                                player.popup('一整行', 'wood');
                                                const card = new lib.element.VCard({ name: 'sha' });
                                                const shas = targets.filter(i => player.canUse(card, i, false));
                                                if (shas.length) await player.useCard(card, shas, false);
                                            }
                                            if (!allPosition.some(l => l[0] == 1 && l[1] == 1)) {
                                                player.popup('中心格', 'wood');
                                                player.addTempSkill('mininiantazhen_effect', { player: 'phaseBegin' });
                                                player.markAuto('mininiantazhen_effect', targets);
                                            }
                                            return;
                                        }
                                    }
                                    player.popup('踏阵失败', 'fire');
                                    game.log(player, '踏阵', '#y失败');
                                },
                                derivation: ['miniwushuang', 'mininiantazhen_faq'],
                                subSkill: {
                                    wushuang: {
                                        charlotte: true,
                                    },
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '$不能对你使用【杀】' },
                                        mod: {
                                            targetEnabled(card, player, target) {
                                                if (card.name == 'sha' && target.getStorage('mininiantazhen_effect').includes(player)) return false;
                                            },
                                        },
                                    },
                                },
                                kill(steps, player) {
                                    let attack = 0, jiu = 0, killed = [], rest = player.getHp() + 1;
                                    rest -= steps.length;
                                    for (const step of steps) {
                                        const items = step.split('|');
                                        if (items.length > 2) {
                                            if (attack + jiu >= items[3]) {
                                                killed.push([items[1], items[2]]);
                                            }
                                            jiu = 0;
                                        }
                                        else {
                                            switch (items[0]) {
                                                case 'sha': attack++; break;
                                                case 'horse': rest += 2; break;
                                                case 'jiu': jiu += 2; break;
                                            }
                                        }
                                    }
                                    return [attack, jiu, killed, rest];
                                },
                                tazhen(item, type, position, noclick, node) {
                                    if (item.slice().split('|').length > 2) {
                                        const info = item.split('|'), _item = item, seat = parseInt(info[0]);
                                        item = info[1];
                                        if (node) {
                                            node.classList.add('button');
                                            node.classList.add('character');
                                            node.style.display = '';
                                        }
                                        else node = ui.create.div('.button.character', position);
                                        node._link = item;
                                        node.link = item;
                                        const func = function (node, item) {
                                            const currentPlayer = game.findPlayer(current => current.getSeatNum() == seat);
                                            if (currentPlayer.classList.contains('unseen_show')) node.setBackground('hidden_image', 'character');
                                            else if (item != 'unknown') node.setBackground(item, 'character');
                                            node.classList.add('tazhen');
                                            if (node.node) {
                                                node.node.name.remove();
                                                node.node.hp.remove();
                                                node.node.group.remove();
                                                node.node.intro.remove();
                                                if (node.node.replaceButton) node.node.replaceButton.remove();
                                            }
                                            node.node = {
                                                name: ui.create.div('.name', node),
                                                group: ui.create.div('.identity', node),
                                                intro: ui.create.div('.intro', node),
                                            };
                                            const infoitem = [currentPlayer.sex, currentPlayer.group, `${currentPlayer.hp}/${currentPlayer.maxHp}/${currentPlayer.hujia}`];
                                            node.node.name.innerHTML = get.slimName(item);
                                            if (lib.config.buttoncharacter_style == 'default' || lib.config.buttoncharacter_style == 'simple') {
                                                if (lib.config.buttoncharacter_style == 'simple') node.node.group.style.display = 'none';
                                                node.classList.add('newstyle');
                                                node.node.name.dataset.nature = get.groupnature(get.bordergroup(infoitem));
                                                node.node.group.dataset.nature = get.groupnature(get.bordergroup(infoitem), 'raw');
                                            }
                                            node.node.name.style.top = '8px';
                                            if (node.node.name.querySelectorAll('br').length >= 4) {
                                                node.node.name.classList.add('long');
                                                if (lib.config.buttoncharacter_style == 'old') {
                                                    node.addEventListener('mouseenter', ui.click.buttonnameenter);
                                                    node.addEventListener('mouseleave', ui.click.buttonnameleave);
                                                }
                                            }
                                            node.node.intro.innerHTML = lib.config.intro;
                                            if (!noclick) lib.setIntro(node);
                                            node.node.group.innerHTML = `<div>${get.cnNumber(seat, true)}号</div>`;
                                            node.node.group.style.backgroundColor = get.translation(`${get.bordergroup(infoitem)}Color`);
                                        };
                                        node.refresh = func;
                                        node.refresh(node, item);
                                        node.link = _item;
                                        node.seatNumber = seat;
                                        node._customintro = uiintro => {
                                            uiintro.add(`${get.translation(node._link)}`);
                                        };
                                        return node;
                                    }
                                    else {
                                        const _item = item;
                                        item = ['', '', 'mininiantazhen_' + item.split('|')[0]];
                                        node = ui.create.card(position, 'noclick', noclick);
                                        node.classList.add('button');
                                        node.classList.add('tazhen');
                                        node.init(item);
                                        node.link = _item;
                                        return node;
                                    }
                                },
                            },
                            mininiandoupo: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: ['juedouBefore', 'juedouBegin', 'useCardAfter'] },
                                filter(event, player, name) {
                                    if (event.name == 'juedou') {
                                        const evt = event.getParent();
                                        if (!evt || evt.name != 'useCard' || !(evt.targets || []).includes(event.target)) return false;
                                        return (evt.targets.slice().reverse()[0] !== event.target) === (name === 'juedouBefore');
                                    }
                                    if (event.card.name != 'juedou' || !(event.targets || []).length) return false;
                                    if (!game.getGlobalHistory('everything', evt => {
                                        return evt.name === 'juedou' && evt.getParent() == event && evt.turn !== player;
                                    }).length) return false;
                                    return event.targets.some(target => target.isIn() && target.countGainableCards(player, 'h') > 0);
                                },
                                direct: true,
                                locked: true,
                                async content(event, trigger, player) {
                                    if (event.triggername == 'juedouBefore') {
                                        trigger.cancel();
                                        return;
                                    }
                                    const targets = trigger.name == 'juedou' ? trigger.getParent().targets : trigger.targets.filter(target => {
                                        return target.isIn() && target.countGainableCards(player, 'h') > 0;
                                    });
                                    await player.logSkill('mininiandoupo', targets);
                                    if (trigger.name == 'useCard') {
                                        for (const target of targets) {
                                            await player.gain(target.getGainableCards(player, 'h').randomGets(1), target, 'giveAuto', 'bySelf');
                                        }
                                    }
                                    else {
                                        trigger.setContent(lib.skill.mininiandoupo.juedouContent);
                                    }
                                },
                                mod: {
                                    selectTarget(card, player, range) {
                                        if (card.name == "juedou" && range[1] != -1) range[1] += 2;
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            cardname(card, player) {
                                                const evt = _status.event, storage = player.getStorage('mininiandoupo_effect');
                                                if (evt.name == 'chooseToRespond' && storage.includes(evt.getParent(2))) return 'sha';
                                            },
                                        },
                                    },
                                },
                                async juedouContent(event, trigger, player) {
                                    const targets = event.targets.sortBySeat(player);
                                    if (event.turn == undefined) event.turn = targets[0];
                                    if (typeof event.baseDamage != 'number') event.baseDamage = 1;
                                    if (typeof event.extraDamage != 'number') event.extraDamage = 0;
                                    if (!event.shaReq) event.shaReq = {};
                                    if (typeof event.shaReq[player.playerid] != 'number') event.shaReq[player.playerid] = 1;
                                    for (const target of targets) {
                                        const map = event.getParent().customArgs, id = target.playerid;
                                        if (map && map[id] && map[id].shaReq && map[id].shaReq[id]) {
                                            event.shaReq[target.playerid] = map[id].shaReq[id];
                                        }
                                        else event.shaReq[target.playerid] = 1;
                                        if (target != event.target) {
                                            const myID = player.playerid;
                                            if (map && map[id] && map[id].shaReq && map[id].shaReq[myID]) {
                                                event.shaReq[player.playerid] += (map[id].shaReq[myID] - 1);
                                            }
                                        }
                                    }
                                    event.playerCards = [];
                                    event.targetCards = [];
                                    let stop = false;
                                    const juedous = targets.slice().concat(player);
                                    while (!stop) {
                                        for (const target of juedous) {
                                            if (stop && target == player) break;
                                            event.turn = target;
                                            await event.trigger('juedou');
                                            event.shaRequired = event.shaReq[event.turn.playerid];
                                            while (true) {
                                                if (event.directHit) {
                                                    event._result = { bool: false };
                                                }
                                                else {
                                                    const next = event.turn.chooseToRespond({ name: 'sha' });
                                                    if (event.shaRequired > 1) next.set('prompt2', '共需打出' + event.shaRequired + '张杀');
                                                    next.set('ai', card => {
                                                        let event = _status.event, player = event.splayer, target = event.starget;
                                                        if (player.hasSkillTag('notricksource') || target.hasSkillTag('notrick')) return 0;
                                                        if (event.shaRequired > 1 && player.countCards('h', 'sha') < event.shaRequired) return 0;
                                                        if (event.player === target) {
                                                            if (_status.event.tdamage >= 0 || player.hasSkill('naman')) return -1;
                                                            if (get.attitude(target, player) <= 0 || event.player.hp <= 1 && _status.event.tdamage < _status.event.pdamage) {
                                                                return get.order(card);
                                                            }
                                                            return -1;
                                                        }
                                                        else {
                                                            if (_status.event.pdamage >= 0 || target.hasSkill('naman')) return -1;
                                                            if (get.attitude(player, target) <= 0 || event.player.hp <= 1 && _status.event.tdamage > _status.event.pdamage) {
                                                                return get.order(card);
                                                            }
                                                            return -1;
                                                        }
                                                    });
                                                    next.set('splayer', player);
                                                    next.set('starget', target);
                                                    next.set('pdamage', targets.reduce((sum, i) => {
                                                        return sum + get.damageEffect(player, i, event.turn);
                                                    }, 0));
                                                    next.set('tdamage', get.damageEffect(target, player, event.turn));
                                                    next.set('shaRequired', event.shaRequired);
                                                    next.autochoose = lib.filter.autoRespondSha;
                                                    const result = await next.forResult();
                                                    if (result.bool) {
                                                        event.shaRequired--;
                                                        if (event.turn !== player) {
                                                            if (result.cards) event.targetCards.addArray(result.cards);
                                                            if (event.shaRequired > 0) continue;
                                                            else break;
                                                        }
                                                        else {
                                                            if (result.cards) event.playerCards.addArray(result.cards);
                                                            if (event.shaRequired > 0) continue;
                                                            else break;
                                                        }
                                                    }
                                                    else {
                                                        stop = true;
                                                        if (event.turn !== player) {
                                                            await target.damage(player);
                                                        }
                                                        else {
                                                            for (const target of targets) {
                                                                await player.damage(target);
                                                            }
                                                        }
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    event._result = {};
                                },
                            },
                            mininianying_lb: {
                                audio: 'mininianying_Mnian_lvbu',
                                trigger: {
                                    player: 'damageEnd',
                                    source: 'damageSource',
                                },
                                filter(event, player, name) {
                                    const skills = Object.keys(lib.skill).filter(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(event, player, name));
                                    if (!skills.length) return false;
                                    return player.countMark('mininianying_lb') >= 2;
                                },
                                async cost(event, trigger, player) {
                                    const skills = Object.keys(lib.skill).filter(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(trigger, player, name)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                                        .set('prompt', get.prompt('mininianying_lb')).set('prompt2', '选择一项念影效果执行')
                                        .set('displayIndex', false)
                                        .set('choiceList', skills.map(i => {
                                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                                        })).set('ai', () => get.event('controls').randomGet()).forResult();
                                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                                },
                                usable: 1,
                                async content(event, trigger, player) {
                                    const choice = event.cost_data;
                                    player.popup(choice[1]);
                                    game.log(player, '选择了', '#g' + choice[1]);
                                    await lib.skill[choice[0]].nianyingContent(player);
                                },
                                nianyingSkill: ['斗破千军', '视为使用一张【决斗】，本次【决斗】结算中，你的所有手牌均视为【杀】'],
                                nianyingFilter(event, player, name) {
                                    return player.hasUseTarget(new lib.element.VCard({ name: 'juedou' }), false);
                                },
                                async nianyingContent(player) {
                                    await player.chooseUseTarget(new lib.element.VCard({ name: 'juedou' }), true, false, '###斗破千军###<div class="text center">视为使用一张【决斗】，本次【决斗】结算中，你的所有手牌均视为【杀】</div>').set('oncard', card => {
                                        const evt = _status.event;
                                        evt.player.addTempSkill('mininiandoupo_effect');
                                        evt.player.markAuto('mininiandoupo_effect', [evt]);
                                    });
                                },
                                init(player, skill) {
                                    const num = game.getGlobalHistory('changeHp', evt => {
                                        return evt.getParent().name == 'damage' && (evt.getParent().player == player || (evt.getParent().source && evt.getParent().source == player));
                                    }).concat(game.getGlobalHistory('changeHp', evt => {
                                        return evt.getParent().name == 'damage' && evt.getParent().player == player && evt.getParent().source && evt.getParent().source == player;
                                    })).length;
                                    if (num) player.addMark(skill, num, false);
                                },
                                onremove: true,
                                group: 'mininianying_lb_mark',
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        trigger: {
                                            global: 'phaseBefore',
                                            player: 'damageEnd',
                                            source: 'damageSource',
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        content() {
                                            if (trigger.name == 'phase') delete player.storage.mininianying_lb;
                                            else player.addMark('mininianying_lb', trigger.num, false);
                                        },
                                    },
                                },
                            },
                            //念周瑜
                            mininiansuhui: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { global: 'phaseEnd' },
                                check(event, player) {
                                    return get.attitude(player, event.player) > 0;
                                },
                                round: 1,
                                logTarget: 'player',
                                async content(event, trigger, player) {
                                    await Promise.all(event.next);
                                    event.videoId = lib.status.videoId++;
                                    const switchToAuto = function () {
                                        _status.imchoosing = false;
                                        if (event.dialog) event.dialog.close();
                                        if (event.control) event.control.close();
                                        game.resume();
                                        event._result = { musicList: [0, 0, 0].concat([get.rand(0, 1)].concat([get.rand(0, 1)])) };
                                        return Promise.resolve(event._result);
                                    };
                                    const zhouyu_MusicPlay = function (player) {
                                        const event = _status.event, { promise, resolve } = Promise.withResolvers();
                                        //可以即兴/更换音符的最大次数
                                        event.restNum = 5 + player.countMark('mininianchongzou_effect');
                                        event.resetNum = 1;
                                        //定义初始五音和是否上锁的列表
                                        const musicList = ['宫', '商', '角', '徵', '羽'].map(i => 'zhouyu_' + i);
                                        event.musicList = [];
                                        while (event.musicList.length < 5) {
                                            event.musicList.push(musicList.randomGet());
                                        }
                                        event.musicList_Locked = [];
                                        //如果以自己视角进入流程后AI直接走结果
                                        event.switchToAuto = function () {
                                            _status.imchoosing = false;
                                            event._result = { musicList: [0, 0, 0].concat([get.rand(0, 1)].concat([get.rand(0, 1)])) };
                                            resolve(event._result);
                                            if (event.dialog) event.dialog.close();
                                            if (event.control_replace) event.control_replace.close();
                                            if (event.control_ok) event.control_ok.close();
                                        };
                                        //替换音符，每次替换消耗一次即兴次数
                                        event.control_replace = ui.create.control('即兴', link => {
                                            if (!event.restNum || event.musicList_Locked.length >= 5) return;
                                            event.restNum--;
                                            event.dialog.content.childNodes[0].innerHTML = event.dialog.content.childNodes[0].innerHTML.replace(/还可即兴\d+次/g, '还可即兴' + event.restNum + '次');
                                            for (let i = 0; i < 5; i++) {
                                                const container = event.dialog.itemContainers[i + event.resetNum];
                                                container.classList.remove('selected');
                                                if (!event.musicList_Locked.includes(container)) event.musicList[i] = musicList.randomGet();
                                            }
                                            event.resetNum += 5;
                                            event.musicList_Locked = [];
                                            event.dialog.content.childNodes[1].remove();
                                            event.dialog.addNewRow(...event.musicList.map(item => {
                                                return {
                                                    item: [game.createCard(item, ' ', ' ')], ItemNoclick: true, clickItemContainer
                                                };
                                            }));
                                        });
                                        //获取结果
                                        event.control_ok = ui.create.control('演奏', link => {
                                            event.dialog.close();
                                            event.control_replace.close();
                                            event.control_ok.close();
                                            game.resume();
                                            _status.imchoosing = false;
                                            event._result = { musicList: event.musicList };
                                            resolve(event._result);
                                        });
                                        //点击容器事件的反馈
                                        const clickItemContainer = function (container) {
                                            if (!event.restNum) return;//无法即兴则点击无效
                                            const goon = event.musicList_Locked.includes(container);
                                            event.musicList_Locked[goon ? 'remove' : 'add'](container);
                                            container.classList[goon ? 'remove' : 'add']('selected');
                                        };
                                        //创建dialog
                                        const dialog = event.dialog = ui.create.dialog('forcebutton', 'hidden');
                                        dialog.addNewRow('溯洄：请进行演奏，根据最多的同名音符数执行后续效果<br><div class="text center">还可即兴' + event.restNum + '次，点击音符即可锁定，避免被即兴替换</div>');
                                        dialog.addNewRow(...event.musicList.map(item => {
                                            return {
                                                item: [game.createCard(item, ' ', ' ')], ItemNoclick: true, clickItemContainer
                                            };
                                        }));
                                        dialog.open();
                                        game.pause();
                                        game.countChoose();
                                        return promise;
                                    };
                                    let next;
                                    if (event.isMine()) {
                                        next = zhouyu_MusicPlay(player);
                                    } else if (event.isOnline()) {
                                        const { promise, resolve } = Promise.withResolvers();
                                        event.player.send(zhouyu_MusicPlay, player);
                                        event.player.wait(async result => {
                                            if (result == 'ai') result = await switchToAuto();
                                            resolve(result);
                                        });
                                        game.pause();
                                        next = promise;
                                    } else {
                                        next = switchToAuto();
                                    }
                                    const result = await next;
                                    game.resume();
                                    const target = trigger.player, musicList = result.musicList;
                                    const num = Math.max(...Object.values(musicList.reduce((map, name) => {
                                        if (!map[name]) map[name] = 0;
                                        map[name]++;
                                        return map;
                                    }, {})));
                                    player.chat(num + '个');
                                    game.log(player, '本次', '#g演奏', '共收集', '#y' + num, '个相同音符');
                                    if (num >= 3) {
                                        player.popup('洗具', 'wood');
                                        const level = { '3': 'phaseDiscard', '4': 'phaseUse', '5': 'phaseZhunbei' }[num.toString()], list = trigger.phaseList;
                                        const index = list.find(item => item.startsWith(level));
                                        if (index) {
                                            target.chat('洗具', 'wood');
                                            trigger.num = list.indexOf(index);
                                            trigger._phaseEndTriggered = false;
                                            game.log(target, '回溯至', '#g' + get.translation(level));
                                        }
                                        else {
                                            target.chat('杯具', 'fire');
                                            game.log('但是', target, '本回合没有', '#g' + get.translation(level), '！');
                                        }
                                    }
                                    else {
                                        player.chat('杯具', 'fire');
                                    }
                                    const cards = game.getGlobalHistory('everything', evt => {
                                        return evt.name === 'cardsDiscard' || (evt.name === 'lose' && evt.position === ui.discardPile);
                                    }).map(evt => evt.cards).flat().filterInD('d');
                                    if (cards.length) await target.gain(cards, 'gain2');
                                    target.addTempSkill('mininiansuhui_hand');
                                    const musicList2 = musicList.map((item, i) => [item, i]);
                                    target.addMark('mininiansuhui_hand', musicList2.filter(item => {
                                        return musicList2.some(item2 => item !== item2 && item[0] === item2[0]);
                                    }).length, false);
                                },
                                subSkill: {
                                    hand: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '手牌上限+#' },
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num + player.countMark('mininiansuhui_hand');
                                            },
                                        },
                                    },
                                },
                                derivation: 'mininiansuhui_faq',
                            },
                            mininianchongzou: {
                                audio: 'ext:活动武将/audio/skill:2',
                                trigger: { player: ['useCard', 'respond'] },
                                filter(event, player) {
                                    if (!game.getGlobalHistory('everything', evt => {
                                        if (evt === event) return false;
                                        return evt.player === event.player && ['useCard', 'respond'].includes(evt.name) && evt.card.name === event.card.name;
                                    }).length) return false;
                                    return !game.getGlobalHistory('everything', evt => {
                                        return evt.player === event.player && evt.name === 'mininianchongzou' && get.type2(event.card) === get.type2(evt._trigger.card);
                                    }).length;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const card = get.cardPile(card => get.type2(card) !== get.type2(trigger.card));
                                    if (card) await player.gain(card, 'gain2');
                                    if (!player.storage.mininianchongzou_gain) {
                                        player.when({ global: 'roundStart' }, false)
                                            .then(() => {
                                                const num = player.countMark('mininianchongzou_gain');
                                                delete player.storage.mininianchongzou_gain;
                                                player.addTempSkill('mininianchongzou_effect', 'roundStart');
                                                player.addMark('mininianchongzou_effect', num, false);
                                            })
                                            .finish();
                                    }
                                    player.addMark('mininianchongzou_gain', 1, false);
                                },
                                ai: { combo: 'mininiansuhui' },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: '即兴次数+#' },
                                    },
                                },
                            },
                            mininianying_zy: {
                                audio: 'mininianying_Mnian_zhouyu',
                                trigger: { global: 'phaseEnd' },
                                filter(event, player, name) {
                                    if (!Object.keys(lib.skill).some(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(event, player, name))) return false;
                                    const history = game.getGlobalHistory('everything', evt => evt.player === event.player && ['useCard', 'respond'].includes(evt.name));
                                    const map = history.reduce((map, evt) => {
                                        const { name } = evt.card;
                                        if (!map[name]) map[name] = 0;
                                        map[name]++;
                                        return map;
                                    }, {});
                                    return Object.keys(map).reduce((sum, item) => sum + Math.floor(map[item] / 2), 0) >= 2;
                                },
                                async cost(event, trigger, player) {
                                    const skills = Object.keys(lib.skill).filter(i => get.info(i) && get.info(i).nianyingSkill && get.info(i).nianyingFilter(trigger, player, name)).map(i => [i, get.info(i).nianyingSkill[0], get.info(i).nianyingSkill[1]]);
                                    const result = await player.chooseControl(skills.map(i => i[1]), 'cancel2')
                                        .set('prompt', get.prompt('mininianying_zy')).set('prompt2', '选择一项念影效果执行')
                                        .set('displayIndex', false)
                                        .set('choiceList', skills.map(i => {
                                            return '<div class="skill">' + i[1] + '</div><div>' + i[2] + '</div>';
                                        })).set('ai', () => get.event('controls').randomGet()).forResult();
                                    event.result = { bool: (result.control != 'cancel2'), cost_data: skills.find(i => i[1] == result.control) };
                                },
                                async content(event, trigger, player) {
                                    const choice = event.cost_data;
                                    player.popup(choice[1]);
                                    game.log(player, '选择了', '#g' + choice[1]);
                                    await lib.skill[choice[0]].nianyingContent(player);
                                },
                                nianyingSkill: ['江东双壁', '令至多两名角色各获得1点护甲（至多为5）'],
                                nianyingFilter: () => true,
                                async nianyingContent(player) {
                                    const { result } = await player.chooseTarget(...get.info('mininianying_zy').nianyingSkill, [1, 2]).set('ai', target => {
                                        const player = get.player();
                                        return get.attitude(player, target) / Math.sqrt(Math.min(1, target.hp + target.hujia));
                                    });
                                    if (result?.bool && result.targets?.length) {
                                        const targets = result.targets.sortBySeat();
                                        player.line(targets);
                                        for (const target of targets) await target.changeHujia(1, null, true);
                                    }
                                },
                            },
                            //战
                            //黄忠
                            minifightdingjun: {
                                init(player) {
                                    if (!ui._minifightdingjun) {
                                        game.broadcastAll(() => {
                                            if (!_status._minifightdingjun) _status._minifightdingjun = 0;
                                            _status._minifightdingjun = Math.max(0, _status._minifightdingjun);
                                            if (get.is.phoneLayout()) ui._minifightdingjun = ui.create.div('.touchinfo.left', ui.window);
                                            else ui._minifightdingjun = ui.create.div(ui.gameinfo);
                                            ui._minifightdingjun.innerHTML = '当前士气：' + _status._minifightdingjun;
                                        });
                                    }
                                },
                                audio: 'ext:活动武将/audio/skill:2',
                                placeSkill: true,
                                categories: () => ['战场技'],
                                async updateShiQi(player = _status.event.player, num = 1) {
                                    if (num) {
                                        const next = game.createEvent('minifight_UpdateShiQi');
                                        next.num = num;
                                        next.player = player;
                                        next.setContent(async function (event, trigger, player) {
                                            const num = event.num;
                                            game.broadcastAll(num => {
                                                _status._minifightdingjun += num;
                                                _status._minifightdingjun = Math.max(0, _status._minifightdingjun);
                                                ui._minifightdingjun.innerHTML = '当前士气：' + _status._minifightdingjun;
                                            }, num);
                                            game.log('#y士气', '#g' + (num > 0 ? '增加了' : '下降了') + Math.abs(num) + '点');
                                        });
                                        await next;
                                    }
                                },
                                trigger: { global: ['damageSource', 'minifight_UpdateShiQiAfter'] },
                                filter(event, player) {
                                    return event.name !== 'damage' || (event.source?.isIn() && event.card?.name === 'sha');
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    if (trigger.name === 'damage') get.info(event.name).updateShiQi(player);
                                    else player.draw();
                                },
                                derivation: 'minifightliegong',
                                global: 'minifightdingjun_ai',
                                group: ['minifightdingjun_change', 'minifightdingjun_effect'],
                                subSkill: {
                                    change: {
                                        audio: 'minifightdingjun',
                                        trigger: { global: 'minifight_UpdateShiQiEnd' },
                                        filter(event, player) {
                                            if (!ui._minifightdingjun_dingjunshan) return _status._minifightdingjun >= game.countPlayer();
                                            return _status._minifightdingjun === 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            if (!ui._minifightdingjun_dingjunshan) {
                                                player.$fullscreenpop('定军山战场', 'fire');
                                                game.broadcastAll(() => {
                                                    if (get.is.phoneLayout()) ui._minifightdingjun_dingjunshan = ui.create.div('.touchinfo.left', ui.window);
                                                    else ui._minifightdingjun_dingjunshan = ui.create.div(ui.gameinfo);
                                                    ui._minifightdingjun_dingjunshan.innerHTML = '<br>定军山战场';
                                                });
                                            }
                                            else {
                                                game.broadcastAll(() => ui._minifightdingjun_dingjunshan.remove());
                                            }
                                        },
                                    },
                                    effect: {
                                        audio: 'minifightdingjun',
                                        trigger: { global: 'useCard' },
                                        filter(event, player) {
                                            if (!ui._minifightdingjun_dingjunshan || event.player.hasSkill('miniliegong', null, null, false)) return false;
                                            return _status._minifightdingjun >= 2 && event.player.getHistory('useCard', evt => evt.card.name === 'sha').indexOf(event) === 0;
                                        },
                                        prompt2(event, player) {
                                            return '是否消耗2层士气，令' + get.translation(event.player) + '于' + get.translation(event.card) + '结算中视为拥有【烈弓】？';
                                        },
                                        check(event, player) {
                                            return event.targets.reduce((sum, target) => sum + get.effect(target, event.card, event.player, player), 0) > 0;
                                        },
                                        logTarget: 'player',
                                        async content(event, trigger, player) {
                                            await get.info('minifightdingjun').updateShiQi(player, -2);
                                            await trigger.player.addTempSkills('minifightliegong');
                                            trigger.player.when('useCardAfter').filter(evt => evt === trigger).then(() => player.removeSkills('minifightliegong'));
                                        },
                                    },
                                    ai: {
                                        ai: {
                                            directHit_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                const targets = game.filterPlayer(target => target.hasSkill('minifightdingjun'));
                                                if (!targets.length || _status._minifightdingjun_aiCheck || !_status._minifightdingjun || _status._minifightdingjun < 2) return false;
                                                if (!ui._minifightdingjun_dingjunshan || !arg?.card || !arg?.target || arg.card.name !== 'sha') return false;
                                                const filter = card => !ui.selected.cards.includes(card) && !card.cards?.includes(card);
                                                if (!(arg.target.getHp() >= player.getHp() || arg.target.countCards('h', filter) >= player.countCards('h', filter))) return false;
                                                _status._minifightdingjun_aiCheck = true;
                                                const bool = (() => {
                                                    if (get.effect(arg.target, arg.card, player, player) <= 0) return false;
                                                    if (get.damageEffect(arg.target, player, player) < 0 && targets.some(i => get.attitude(player, i) < 0)) return true;
                                                    if (get.damageEffect(arg.target, player, player) > 0 && targets.some(i => get.attitude(player, i) > 0)) return true;
                                                    return false;
                                                })();
                                                delete _status._minifightdingjun_aiCheck;
                                                return bool;
                                            },
                                        },
                                    },
                                },
                            },
                            minifightliegong: {
                                audio: 'liegong',
                                trigger: { player: 'useCardToTargeted' },
                                filter(event, player) {
                                    if (event.card.name !== 'sha') return false;
                                    return event.target.getHp() >= player.getHp() || event.target.countCards('h') >= player.countCards('h');
                                },
                                forced: true,
                                logTarget: 'target',
                                content() {
                                    const goon1 = trigger.target.getHp() >= player.getHp(), goon2 = trigger.target.countCards('h') >= player.countCards('h');
                                    trigger.getParent().directHit.push(trigger.target);
                                    game.log(trigger.target, '不能响应', trigger.card);
                                    if (goon1 && goon2) {
                                        const id = trigger.target.playerid;
                                        const map = trigger.getParent().customArgs;
                                        if (!map[id]) map[id] = {};
                                        if (typeof map[id].extraDamage !== 'number') map[id].extraDamage = 0;
                                        map[id].extraDamage++;
                                        game.log(trigger.card, '对', trigger.target, '造成的伤害', '#y+1');
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!arg?.card || !arg?.target || arg.card.name !== 'sha') return false;
                                        const filter = card => !ui.selected.cards.includes(card) && !card.cards?.includes(card);
                                        return arg.target.getHp() >= player.getHp() || arg.target.countCards('h', filter) >= player.countCards('h', filter);
                                    },
                                },
                            },
                            minifightlizhan: {
                                audio: 'ext:活动武将/audio/skill:2',
                                enable: 'phaseUse',
                                filter(event, player) {
                                    return player.hasSha('respond') && player.hasUseTarget(new lib.element.VCard({ name: 'sha' }));
                                },
                                async content(event, trigger, player) {
                                    let num = 0;
                                    while (player.hasSha('respond')) {
                                        const result = await player.chooseToRespond('###力斩：请打出任意张【杀】###当前已经打出' + num + '张【杀】', (card, player) => {
                                            return get.name(card) === 'sha';
                                        }).set('ai', () => 1).forResult();
                                        if (result?.bool) num++;
                                        else break;
                                    }
                                    if (!num) return event.finish();
                                    player.addTempSkill('minifightlizhan_effect');
                                    const sha = new lib.element.VCard({ name: 'sha', storage: { minifightlizhan: num } });
                                    const next = player.chooseUseTarget(sha, true, false, '###力斩###<div class="text center">请选择【杀】的目标（需要' + num + '张【闪】响应，伤害基数为' + num + '）</div>');
                                    await next;
                                    if (player.hasHistory('sourceDamage', evt => evt.getParent('chooseUseTarget') === next)) {
                                        const targets = game.filterPlayer(target => {
                                            if (player.hasHistory('useCard', evt => evt.getParent() === next && evt.targets?.includes(target))) return false;
                                            return get.inpileVCardList().some(name => {
                                                return get.tag({ name: name[2] }, 'damage') >= 0.5 && player.canUse(new lib.element.VCard({ name: name[2] }), target, false);
                                            });
                                        });
                                        if (targets.length) {
                                            const result = await player.chooseTarget('力斩：是否再选择另一名角色？', '视为对其使用一张无距离和次数限制的伤害类卡牌', (card, player, target) => {
                                                return get.event().targets.includes(target);
                                            }).set('targets', targets).set('ai', target => {
                                                const player = get.player();
                                                return Math.max(...get.inpileVCardList().filter(name => {
                                                    return get.tag({ name: name[2] }, 'damage') >= 0.5 && player.canUse(new lib.element.VCard({ name: name[2], nature: name[3] }), target, false);
                                                }).map(name => get.effect(target, new lib.element.VCard({ name: name[2], nature: name[3] }), player, player)));
                                            }).set('animate', false).forResult();
                                            if (result?.bool && result.targets?.length) {
                                                const [target] = result.targets;
                                                const links = await player.chooseButton([
                                                    '###力斩###<div class="text center">视为' + get.translation(target) + '对使用一张无距离和次数限制的伤害类卡牌</div>',
                                                    [get.inpileVCardList().filter(name => {
                                                        return get.tag({ name: name[2] }, 'damage') >= 0.5 && player.canUse(new lib.element.VCard({ name: name[2], nature: name[3] }), target, false);
                                                    }), 'vcard'],
                                                ], true).set('ai', button => {
                                                    const { player, target } = get.event(), name = button.link;
                                                    return get.effect(target, new lib.element.VCard({ name: name[2], nature: name[3] }), player, player);
                                                }).set('target', target).forResult('links');
                                                if (links?.length) await player.useCard(new lib.element.VCard({ name: links[0][2], nature: links[0][3] }), target, false);
                                            }
                                        }
                                    }
                                },
                                ai: {
                                    order(item, player) {
                                        return get.order({ name: 'sha' }, player) + 0.5;
                                    },
                                    result: {
                                        player(player) {
                                            return player.hasValueTarget(new lib.element.VCard({ name: 'sha' })) ? 1 : 0;
                                        },
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        trigger: {
                                            player: 'useCard1',
                                            global: 'useCard',
                                        },
                                        filter(event, player, name) {
                                            if (name === 'useCard1') {
                                                return event.card.storage?.minifightlizhan && typeof event.card.storage.minifightlizhan === 'number';
                                            }
                                            return Array.isArray(event.respondTo) && event.respondTo[0] === player && event.respondTo[1].storage?.minifightlizhan && typeof event.respondTo[1].storage.minifightlizhan === 'number';
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            if (event.triggername === 'useCard1') {
                                                trigger.baseDamage += (trigger.card.storage.minifightlizhan - 1);
                                                for (const target of game.filterPlayer(null, null, true)) {
                                                    const id = target.playerid, map = trigger.customArgs;
                                                    if (!map[id]) map[id] = {};
                                                    map[id].shanRequired = trigger.card.storage.minifightlizhan;
                                                }
                                            }
                                            else {
                                                trigger.getParent(2).baseDamage--;
                                            }
                                        },
                                    },
                                },
                            },
                        },
                        dynamicTranslate: {
                            minizhongjian(player) {
                                return '出牌阶段限' + (player.hasSkill('recaishi2') ? '两' : '一') + '次，你可以选择一名本回合内未选择过的角色。你令其获得一项效果：①其下次造成伤害后弃置两张牌，然后你摸一张牌。②其下次受到伤害后摸两张牌，然后你摸一张牌。';
                            },
                            minijiaozhao(player) {
                                return [lib.translate.minijiaozhao_info, lib.translate.minijiaozhao_1_info, lib.translate.minijiaozhao_2_info][player.countMark('minidanxin')];
                            },
                            minipingting(player) {
                                return '出牌阶段开始时，你可以选择以下选项中的至多' + get.cnNumber(2 + player.countMark('minishuangshu_pingting')) + '项：⒈本阶段使用的第一张牌无距离限制。⒉本阶段使用第二张牌指定目标后获得此牌对应的所有实体牌。⒊本阶段使用的第三张牌结算完毕后摸两张牌。⒋本阶段使用的第四张牌额外结算一次。';
                            },
                            miniyizheng(player) {
                                return '出牌阶段结束时，你可以移动场上至多' + get.cnNumber(1 + player.countMark('minishuangshu_yizheng')) + '张装备牌（只能移动武器、防具和坐骑牌，且一次技能结算中每种副类别的装备限移动一次），然后若你于本次技能结算中移动了：一张装备牌，你回复1点体力；两张装备牌，直到你的下回合开始，当你失去一张牌时，摸一张牌。';
                            },
                            minimanwang(player) {
                                var num = 4 - player.countMark('spmanwang');
                                var str = '出牌阶段，你可以弃置任意张牌。然后你依次执行以下选项中的前X项：';
                                var list = [
                                    '⒈获得〖叛侵〗。',
                                    '⒉摸一张牌。',
                                    '⒊回复1点体力。',
                                    '⒋摸两张牌并失去〖叛侵〗。',
                                ];
                                for (var i = 0; i < 4; i++) {
                                    if (i == num) {
                                        str += '<span style="text-decoration: line-through;">';
                                    }
                                    str += list[i];
                                }
                                if (num < 4) str += '</span>';
                                return str + '然后你获得〖祸首〗直到你的下个回合开始。';
                            },
                            miniguixiu(player) {
                                return lib.translate[(player.storage.miniguixiu ? 'miniguixiux' : 'miniguixiu') + '_info'];
                            },
                            miniyanzhu(player) {
                                var bool = player.storage.miniyanzhu;
                                var str = '出牌阶段限一次，你可以令一名其他角色';
                                if (bool) str += '<span style="text-decoration:line-through;">';
                                str += '选择一项：';
                                if (bool) str += '</span>';
                                str += '弃置一张牌并令下一次受到的伤害+1直到其下回合开始';
                                if (bool) str += '<span style="text-decoration:line-through;">';
                                str += '，或将装备区里的所有牌交给你并令你发动〖宴诛〗无法选择此项';
                                if (bool) str += '</span>';
                                return str + '。';
                            },
                            miniyoulong(player) {
                                var storage = player.storage.miniyoulong;
                                var str = '转换技';
                                if (!player.storage.miniyou_luanfeng) str += '，每回合每项各限一次';
                                str += '。';
                                if (!storage) str += '<span class="bluetext">';
                                str += '阴，你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌；';
                                if (!storage) str += '</span>';
                                if (storage) str += '<span class="bluetext">';
                                str += '阳，你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。';
                                if (storage) str += '</span>';
                                return str;
                            },
                            minikeji(player) {
                                let str = '弃牌阶段开始时，';
                                if (player.hasSkill('minisbduojing_keji', null, false, false)) str += '<span style="text-decoration:line-through;">';
                                str += '若你于本回合的出牌阶段内没有过使用或打出过【杀】，则';
                                if (player.hasSkill('minisbduojing_keji', null, false, false)) str += '</span>';
                                str += '你可以跳过此阶段并摸一张牌。';
                                return str;
                            },
                            miniliuma(player) {
                                if (!player.storage.miniliuma_give) return lib.translate.miniliuma_info;
                                return '①出牌阶段结束时，你可以将至多X张手牌置入“流马”区（X为你的体力值，“流马”区至多存在五张牌）。②你可以使用或打出“流马”区的牌。';
                            },
                            minisbqicai(player) {
                                let storage = player.storage.dcsbyingmou, str = '转换技，①游戏开始时，你可以转换此技能状态。②';
                                if (!storage) str += '<span class="bluetext">';
                                str += '阳：每回合限两次，当你使用锦囊牌时，你可以为此牌增加或减少一个目标；';
                                if (!storage) str += '</span>';
                                if (storage) str += '<span class="bluetext">';
                                str += '阴：每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌。';
                                if (storage) str += '</span>';
                                return str;
                            },
                            minidunshi(player) {
                                var info = player.storage.minidunshi;
                                var str = '每回合限一次，你可以视为使用或打出一张';
                                var list = ['sha', 'shan', 'tao', 'jiu'];
                                for (var i of list) {
                                    var strx = '【' + get.translation(i) + '】';
                                    if (!info?.includes(i)) strx = ('<span style="text-decoration:line-through;">' + strx + '</span>');
                                    str += strx;
                                    if (i != 'jiu') str += '/';
                                }
                                str += '，然后当前回合角色于本回合内下一次造成伤害时，你选择两项：⒈防止此伤害。系统从技能名中包含“仁/义/礼/智/信”字样的技能中随机选择三个其未拥有的技能，然后你令当前回合角色获得其中一个技能。⒉从〖遁世〗中删除你本次使用或打出的牌名。⒊减1点体力上限并摸X张牌（X为〖遁世〗的剩余牌名数）。';
                                return str;
                            },
                            minizhenliang(player) {
                                let storage = player.storage.minizhenliang, str = '转换技。';
                                if (!storage) str += '<span class="bluetext">';
                                str += '阳：出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。';
                                if (!storage) str += '</span>';
                                if (storage) str += '<span class="bluetext">';
                                str += '阴：你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”颜色相同，则你可以令一名角色摸两张牌。';
                                if (storage) str += '</span>';
                                return str;
                            },
                        },
                        translate: {
                            extensionsPack: "活动武将搬运",
                            MiNi_wei: '欢乐三国杀·魏国',
                            MiNi_shu: '欢乐三国杀·蜀国',
                            MiNi_wu: '欢乐三国杀·吴国',
                            MiNi_qun: '欢乐三国杀·群雄',
                            MiNi_shen: '欢乐三国杀·神将',
                            MiNi_change: '一样？不一样？',
                            MiNi_shengzhiyifa: '欢乐三国杀·杂谈',
                            MiNi_sbCharacter: '欢乐三国杀·谋攻篇',
                            MiNi_miaoKill: '欢乐三国杀·喵系列',
                            MiNi_nianKill: '欢乐三国杀·念系列',
                            MiNi_fightKill: '欢乐三国杀·战系列',
                            //牌
                            miniyanxiao_card: '言笑',
                            miniyanxiao_card_info: '判定阶段开始时，获得此牌和判定区内的所有牌。',
                            minilingren_basic: ' ',
                            minilingren_trick: ' ',
                            minilingren_equip: ' ',
                            junling: '军令',
                            minijieyue_junling1: '军令一',
                            minijieyue_junling1_info: '执行者对发起者指定的一名角色造成1点伤害。',
                            minijieyue_junling2: '军令二',
                            minijieyue_junling2_info: '执行者随机弃置一张手牌区和装备区的牌。',
                            minijieyue_junling3: '军令三',
                            minijieyue_junling3_info: '执行者本回合不能回复体力。',
                            minijieyue_junling4: '军令四',
                            minijieyue_junling4_info: '执行者本回合不能使用或打出手牌，且本回合非锁定技失效。',
                            //魏
                            Mbaby_caoang: '欢杀曹昂',
                            Mbaby_caopi: '欢杀曹丕',
                            Mbaby_zhenji: '欢杀甄宓',
                            Mbaby_caoren: '欢杀曹仁',
                            Mbaby_dianwei: '欢杀典韦',
                            Mbaby_guojia: '欢杀郭嘉',
                            Mbaby_guohuai: '欢杀郭淮',
                            Mbaby_zhangchunhua: '欢杀张春华',
                            Mbaby_wangyi: '欢杀王异',
                            Mbaby_xiahoudun: '欢杀夏侯惇',
                            Mbaby_xuzhu: '欢杀许诸',
                            Mbaby_zhangliao: '欢杀张辽',
                            Mbaby_zhanghe: '欢杀张郃',
                            Mbaby_yujin: '欢杀于禁',
                            Mbaby_xuhuang: '欢杀徐晃',
                            Mbaby_xunyu: '欢杀荀彧',
                            Mbaby_dengai: '欢杀邓艾',
                            Mbaby_caozhi: '欢杀曹植',
                            Mbaby_sp_caiwenji: 'SP欢杀蔡琰',
                            Mbaby_caoying: '欢杀曹婴',
                            Mbaby_caorui: '欢杀曹叡',
                            Mbaby_xiahouyuan: '欢杀夏侯渊',
                            Mbaby_haozhao: '欢杀郝昭',
                            Mbaby_xizhicai: '欢杀戏志才',
                            Mbaby_xinxianying: '欢杀辛宪英',
                            Mbaby_guohuanghou: '欢杀郭皇后',
                            Mbaby_caozhen: '欢杀曹真',
                            Mbaby_zhongyao: '欢杀钟繇',
                            Mbaby_lidian: '欢杀李典',
                            Mbaby_xunyou: '欢杀荀攸',
                            Mbaby_caoxiu: '欢杀曹休',
                            Mbaby_sp_jiangwei: 'SP欢杀姜维',
                            Mbaby_zhonghui: '欢杀钟会',
                            Mbaby_zhangchangpu: '欢杀张昌蒲',
                            Mbaby_yangxiu: '欢杀杨修',
                            Mbaby_simayi: '欢杀司马懿',
                            Mbaby_dufuren: '欢杀杜夫人',
                            Mbaby_caozhang: '欢杀曹彰',
                            Mbaby_caocao: '欢杀曹操',
                            Mbaby_sp_pangde: 'SP欢杀庞德',
                            Mbaby_wenyang: '欢杀文鸯',
                            Mbaby_xiahoulingnv: '欢杀夏侯令女',
                            Mbaby_chenqun: '欢杀陈群',
                            Mbaby_wangji: '欢杀王基',
                            Mbaby_jsp_guanyu: 'SP欢杀关羽',
                            Mbaby_kuailiangkuaiyue: '欢杀蒯良蒯越',
                            Mbaby_sp_jiaxu: 'SP欢杀贾诩',
                            Mbaby_yinfuren: '欢杀尹夫人',
                            Mbaby_sp_caoren: 'SP欢杀曹仁',
                            Mbaby_guojia: '欢杀郭嘉',
                            Mbaby_caohong: '欢杀曹洪',
                            Mbaby_sb_caocao: '欢杀谋曹操',
                            Mbaby_zhugedan: '欢杀诸葛诞',
                            Mbaby_bianfuren: '欢杀卞夫人',
                            Mbaby_sb_yujin: '欢杀谋于禁',
                            Mbaby_yuejin: '欢杀乐进',
                            Mbaby_jianggan: '欢杀蒋干',
                            Mbaby_chengyu: '欢杀程昱',
                            Mbaby_sb_xuhuang: '欢杀谋徐晃',
                            Mbaby_ruanyu: '欢杀阮瑀',
                            Mbaby_dc_yanghu: '欢杀羊祜',
                            Mbaby_yanrou: '欢杀阎柔',
                            Mbaby_wangshuang: '欢杀王双',
                            Mbaby_chenlin: '欢杀陈琳',
                            Mbaby_liuye: '欢杀刘晔',
                            Mbaby_wenqin: 'OL文钦',
                            Mbaby_wenqin_prefix: 'OL',
                            Mbaby_guanqiujian: '欢杀毌丘俭',
                            Mbaby_guanlu: '欢杀管辂',
                            Mbaby_zhenghun: '欢杀郑浑',
                            Mbaby_chentai: '欢杀陈泰',
                            Mbaby_hanhaoshihuan: '欢杀韩浩史涣',
                            Mbaby_sb_zhenji: '欢杀谋甄宓',
                            Mbaby_simalang: '欢杀司马朗',
                            miniluoshen: '洛神',
                            miniluoshen_info: '准备阶段，你可以进行一次判定并获得判定牌，若判定结果为黑色，你可重复此流程。',
                            minireluoshen: '洛神',
                            minireluoshen_info: '①准备阶段，你可以进行一次判定并获得判定牌，若判定结果为黑色，你可重复此流程。②当你于每轮首次失去〖洛神①〗获得的红色牌后，你可以发动〖洛神①〗。',
                            miniqiaobian: '巧变',
                            miniqiaobian_info: '①你可以弃置一张手牌并跳过自己的一个阶段（准备阶段和结束阶段除外）。若你以此法跳过了摸牌阶段，则你可以获得至多两名其他角色的各一张手牌；若你以此法跳过了出牌阶段，则你可以移动场上的一张牌。②结束阶段，若你本回合至少跳过了三个阶段，则你摸两张牌。',
                            minikangkai: '慷忾',
                            minikangkai_info: '锁定技，每回合限两次。当一名角色成为【杀】的目标后，若你至该角色的距离为1，你摸一张牌。然后你可以交给其一张牌并展示之，若此牌为装备牌，该角色可以使用此牌。',
                            minishangshi: '伤逝',
                            minishangshi_info: '当你的手牌数小于X时，你可以将手牌摸至X张（X为你已损失的体力值且至少为1）。',
                            minijueqing: '绝情',
                            minijueqing_info: '当你即将造成伤害时，你依次执行：①你可以失去1点体力，令此伤害+1；②你可以防止此伤害，改为令受伤角色失去等同于伤害值的体力。',
                            minireshangshi: '伤逝',
                            minireshangshi_info: '①当你的手牌数小于X时，你可以将手牌摸至X张（X为你已损失的体力值且至少为1）。②每回合限一次，当你发动〖伤逝①〗后，你可以弃置任意张手牌，若你以此法弃置了所有手牌，你于下个回合的摸牌阶段额外摸一张牌。',
                            minifangzhu: '放逐',
                            minifangzhu_info: '当你受到伤害后，你可以令一名其他角色将武将牌翻面，然后该角色摸一张牌。',
                            miniqiangxi: '强袭',
                            miniqiangxi_info: '出牌阶段对每名其他角色限一次，你可以失去1点体力并摸一张牌，对你攻击范围内的一名其他角色造成1点伤害；其他角色受到伤害时，你可以弃置一张装备牌并令伤害值+1。',
                            miniyizhong: '毅重',
                            miniyizhong_info: '锁定技，当你的防具栏没有牌且未被废除时，梅花【杀】对你无效。',
                            minijiezi: '截辎',
                            minijiezi_info: '锁定技，每轮限两次，其他角色跳过摸牌阶段后，你摸两张牌。',
                            minijushou: '据守',
                            minijushou_info: '结束阶段，你可以翻面并摸四张牌，然后你可以使用一张装备牌。',
                            minichenqing: '陈情',
                            minichenqing_info: '每回合限一次，当一名角色进入濒死状态时，你可以令另一名角色摸五张牌，然后其弃置四张牌。若其以此法弃置的四张牌花色各不相同，则视为该角色对濒死的角色使用一张【桃】。',
                            minituntian: '屯田',
                            minituntian_info: '当你于回合外失去牌后，你可以进行判定。若判定结果不为♥，则你将此牌置于你的武将牌上，称之为【田】。结束阶段，你可以弃置一张牌并进行〖屯田〗判定。锁定技，你计算与其他角色的距离时-X（X为你武将牌上【田】的数目）。',
                            minijiushi: '酒诗',
                            minijiushi1: '酒诗',
                            minijiushi3: '酒诗',
                            minijiushi_info: '当你需要使用【酒】时，若你的武将牌正面向上，你可以翻面并视为使用一张【酒】。当你受到伤害后，若你的武将牌背面向上，你可以翻面。当你翻面时，你可以获得牌堆中的一张随机锦囊牌。',
                            miniluoying: '落英',
                            miniluoying_discard: '落英',
                            miniluoying_judge: '落英',
                            miniluoying_info: '当其他角色的梅花牌因弃置或判定而进入弃牌堆时，你可以获得之。你的梅花牌不计入手牌上限。',
                            miniquhu: '驱虎',
                            miniquhu_info: '出牌阶段限一次，你可以：①弃置两张牌，对一名其他角色造成1点伤害；②对自己造成1点伤害，然后摸一张牌。',
                            minijieming: '节命',
                            minijieming_info: '当你受到1点伤害后，你可令一名角色将手牌摸至X张（X为其体力上限且至多为4）。',
                            minimingjian: '明鉴',
                            minimingjian2: '明鉴',
                            minimingjian_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色，该角色于其下个回合的手牌上限+1，使用【杀】的次数上限+1。',
                            minixingshuai: '兴衰',
                            minixingshuai_info: '主公技，限定技，当你进入濒死状态时，其他魏势力角色可依次令你回复1点体力，然后这些角色依次受到1点伤害并摸一张牌。',
                            minixingshang: '行殇',
                            minixingshang_info: '当有角色死亡后，你可以获得该角色的所有牌并摸一张牌。',
                            minilingren: '凌人',
                            minilingren_info: '每回合限一次，当你于出牌阶段使用带有「伤害」这一标签的基本牌或普通锦囊牌指定目标后，你可以猜测其中的一个目标的手牌中是否有基本牌，锦囊牌或装备牌。若你至少猜对了：一项，此牌对该角色的伤害+1；两项，你摸两张牌；三项，你获得技能〖奸雄〗和〖行殇〗直到下回合开始。',
                            minifujian: '伏间',
                            minifujian_info: '锁定技，结束阶段，你随机观看一名的其他角色的一张手牌。',
                            minihuchi: '虎痴',
                            minihuchi_info: '结束阶段，若你的手牌数小于2，则你将手牌数补至两张；当你使用的【杀】被抵消后，你获得1枚“痴”；出牌阶段限一次，你可以移去所有“痴”，然后摸等量的牌。',
                            minijingce: '精策',
                            minijingce_info: '锁定技，结束阶段，你摸X张牌（X为你本回合使用牌的花色数+1且至多为3）。',
                            tiandu_xizhicai: '天妒',
                            minichouce: '筹策',
                            minichouce_info: '当你受到1点伤害后，你可以判定，若结果为：黑色，你获得一名角色区域里的一张牌；红色，你选择一名角色，其摸一张牌，若其是〖先辅〗选择的角色，则改为摸两张牌。',
                            minishensu: '神速',
                            minishensu_info: '你可以选择一至三项：1.跳过判定阶段和摸牌阶段；2.跳过出牌阶段；3.跳过弃牌阶段并将武将牌翻面。你每选择一项，视为你对一名其他角色使用一张无距离限制的雷【杀】。',
                            minishebian: '设变',
                            minishebian_info: '当你翻面时，你可以移动场上的一张装备牌，然后回复1点体力。',
                            minizhongjian: '忠鉴',
                            minizhongjian_info: '出牌阶段限一次，你可以选择一名本回合内未选择过的角色。你令其获得一项效果：①其下次造成伤害后弃置两张牌，然后你摸一张牌。②其下次受到伤害后摸两张牌，然后你摸一张牌。',
                            minicaishi: '才识',
                            minicaishi_info: '摸牌阶段结束时，若你此阶段摸的牌：花色相同，本回合你将〖忠鉴〗中『出牌阶段限一次』修改为『出牌阶段限两次』；花色不同，你可以弃置一张牌，然后回复1点体力。',
                            minijiaozhao: '矫诏',
                            minijiaozhao2: '矫诏',
                            minijiaozhao_info: '出牌阶段限一次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（你不是此牌的合法目标）。',
                            minijiaozhao_1: '矫诏·2级',
                            minijiaozhao_1_info: '出牌阶段限两次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（每种类型限一次，且你不是此牌的合法目标）。',
                            minijiaozhao_2: '矫诏·3级',
                            minijiaozhao_2_info: '出牌阶段限三次，你可以展示一张手牌并声明一个基本牌或普通锦囊牌，本阶段你可以将此牌当作你声明的牌使用（每种牌名限一次）。',
                            minidanxin: '殚心',
                            minidanxin_info: '当你受到伤害后，你可以摸一张牌并升级〖矫诏〗。',
                            miniqingjian: '清俭',
                            miniqingjian_info: '每回合限一次，当你于摸牌阶段外获得牌时，你可以展示任意张牌并交给一名其他角色，然后你摸一张牌。',
                            minisidi: '司敌',
                            minisidi_info: '结束阶段，你可以将至多两张非基本牌置于武将牌上，称为“司”。其他角色的出牌阶段开始时，你可以移去一张“司”。若如此做，其本阶段内不能使用或打出与“司”颜色相同的牌。此阶段结束时，若其于此阶段内未使用过：【杀】，你视为对其使用一张【杀】。锦囊牌，你摸两张牌。',
                            minihomo: '活墨',
                            minihomo_info: '每回合限两次，当你需要使用一张基本牌时，你可以将一张黑色非基本牌置于牌堆顶，然后视为使用此基本牌。',
                            minizuoding: '佐定',
                            minizuoding_info: '一名角色于其回合内使用黑桃牌指定目标后，若本回合内没有角色受到过伤害，则你可以令其中一名目标角色摸一张牌',
                            minixunxun: '恂恂',
                            minixunxun_info: '摸牌阶段，你可以观看牌堆顶的四张牌，然后将其中的两张牌置于牌堆顶，并将其余的牌以任意顺序置于牌堆底。结束阶段，你获得牌堆底的两张牌。',
                            minizhengbing: '整兵',
                            minizhengbing_info: '你通过〖突袭〗获得的牌不计入手牌上限；出牌阶段，你可以重铸你通过〖突袭〗获得的牌，若你以此法重铸的牌为你手牌中的最后一张通过〖突袭〗获得的牌，你额外摸一张牌。',
                            miniqice: '奇策',
                            miniqice_info: '出牌阶段限一次，你可以将任意张手牌当作任意一张普通锦囊牌使用。',
                            minizhiyu: '智愚',
                            minizhiyu_info: '当你受到伤害后，你可以摸两张牌并弃置一张牌，然后展示所有手牌，然后若你的手牌的颜色均相同且伤害来源的手牌数大于你的手牌数，你可以令伤害来源将手牌数弃置至与你一致。',
                            miniqingxi: '倾袭',
                            miniqingxi_info: '当你使用【杀】或【决斗】指定目标后，你可以令其选择一项：①弃置X张手牌（X为你攻击范围内的角色数，且当你装备区内有武器牌/没有武器牌时至多为4/2），若如此做，其弃置你的此武器牌；②令此牌的伤害值+1且你进行判定，若结果为红色，则其不能响应此牌；若结果为黑色，你摸两张牌。',
                            minikunfen: '困奋',
                            minikunfen_info: '结束阶段开始时，你可以失去1点体力。若如此做，你摸两张牌，然后可以视为使用一张【火攻】。',
                            minifengliang: '逢亮',
                            minifengliang_info: '觉醒技，当你进入濒死状态时，你减1点体力上限，将体力值回复至3点，然后获得技能〖挑衅〗。',
                            miniquanji: '权计',
                            miniquanji_info: '当你受到1点伤害后，你可以摸两张牌。出牌阶段，你可以将任意张手牌置于武将牌上，称为“权”。你的手牌上限+X（X为武将牌上“权”的数量且X至多为5）。',
                            minijilei: '鸡肋',
                            minijilei_info: '当你受到有来源的伤害后，你可以声明一种牌的类别。若如此做，你从牌堆中获得一张此类型的牌，且伤害来源不能使用、打出或弃置此类别的手牌直到其下个回合开始。',
                            miniyanjiao: '严教',
                            miniyanjiao_info: '出牌阶段限一次，你可以选择一名角色。该角色从牌堆顶亮出三张牌，选择并获得点数之和不大于总点数一半（至少为1）的牌，然后你获得剩余的牌（若你选的角色是自己，则弃置剩余的牌）。',
                            minifankui: '反馈',
                            minifankui_info: '当你受到1点伤害后，你可以进行一次判定，若判定结果为红桃，你获得一名角色的一张牌，否则你获得伤害来源的一张牌。',
                            miniguicai: '鬼才',
                            miniguicai_info: '当一名角色的判定牌生效前，你可以打出一张牌代替之，然后若此牌的花色为：红桃，你回复1点体力；梅花，你摸两张牌。',
                            miniyise: '异色',
                            miniyise_info: '其他角色得到你的牌后，若这些牌中：有红色牌，你可摸一张牌或令其回复1点体力；有黑色牌，你可令其下次受到【杀】造成的伤害时，此伤害+1。',
                            minishunshi: '顺世',
                            minishunshi_info: '准备阶段开始时，或当你受到伤害后，你可将一张牌交给一名其他角色并获得如下效果直到你的回合结束：下个摸牌阶段的额定摸牌数+1，下个出牌阶段使用【杀】的次数上限+1且无视防具，下个弃牌阶段手牌上限+1。',
                            minijiangchi: '将驰',
                            minijiangchi_info: '出牌阶段开始时，你可以选择一项：①摸一张牌，直到你的下个回合开始，受到伤害后摸一张牌。②摸三张牌，然后本回合内不能使用或打出【杀】且手牌上限+2。③本回合使用【杀】无距离限制且可以多使用一张【杀】。',
                            minijianxiong: '奸雄',
                            minijianxiong_info: '当你受到1点伤害后，你可以选择一项：①摸两张牌；②获得对你造成伤害的牌并摸一张牌。',
                            minihujia: '护驾',
                            minihujia_info: '主公技，当你需要使用或打出一张【闪】时，你可以令其他魏势力角色选择是否打出一张【闪】。若有角色响应，则你视为使用或打出了一张【闪】，且该角色可以令你摸一张牌。',
                            minijuesi: '决死',
                            minijuesi_info: '出牌阶段，你可以弃置一张【杀】并选择攻击范围内的一名有牌的其他角色，该角色弃置一张牌，然后若其弃置的牌不是【杀】且你的体力值不大于该角色，你摸两张牌；若其弃置的牌是【杀】，则视为对其使用【决斗】。',
                            minichoujue: '仇决',
                            minichoujue_info: '觉醒技，一名角色的回合结束时，若你的手牌数和体力值相差3或更多，你减1点体力上限并获得技能〖背水〗，然后将〖膂力〗改为“在自己的回合时每回合限两次”。',
                            minibeishui: '背水',
                            minibeishui_info: '觉醒技，准备阶段，若你的手牌数或体力值不大于2，你减1点体力上限并获得技能〖清剿〗，然后将〖膂力〗改为受到伤害后也可以发动。',
                            miniqingjiao: '清剿',
                            miniqingjiao_info: '出牌阶段开始时，你可以弃置所有手牌，然后从牌堆或弃牌堆中随机获得八张牌名各不相同且副类别不同的牌。若如此做，结束阶段，你弃置所有手牌。',
                            miniweilie: '炜烈',
                            miniweilie_info: '每局游戏限X次。出牌阶段，你可以弃置一张牌并令一名角色回复1点体力并摸一张牌（X为你〖浮萍①〗中的记录数+1）。',
                            minifaen: '法恩',
                            minifaen_info: '①当一名角色翻面或者横置后，你可以令其摸一张牌。②当一名横置的角色受到伤害时，你可以弃置一张牌并防止此伤害。',
                            miniqizhi: '奇制',
                            miniqizhi_info: '当你于回合内使用基本牌或锦囊牌指定目标后，你可以弃置不是此牌目标的一名角色的一张牌。若弃置的牌与使用的牌类型相同，你摸一张牌；类型不同，其摸一张牌。',
                            minijinqu: '进趋',
                            minijinqu_info: '你可以跳过弃牌阶段并摸两张牌。若如此做，你将手牌弃置至X张。（X为你于此回合发动过〖奇制〗的次数+1）',
                            minijinghong: '惊鸿',
                            minijinghong_info: '准备阶段，你可以选择至多X名其他角色（X为场上存活人数-1，且X至多为4），然后你依次随机展示这些角色的各一张牌，其若展示的牌为：黑色，你获得此牌，且此牌不计入你的手牌上限；红色，其弃置此牌。',
                            minispluoshen: '洛神',
                            minispluoshen_info: '你可以将一张黑色牌当作【闪】使用或打出。若如此做，每轮限一次，你可以于此牌结算完成后进行一次判定并获得判定牌，若判定结果为黑色，你可以重复此流程。',
                            minispwusheng: '武圣',
                            minispwusheng_info: '①回合开始时，你从牌堆或弃牌堆中获得一张红色牌。②你可以将一张红色牌当作【杀】使用或打出。③你使用的非转化红色【杀】造成的伤害+1，你使用方片【杀】无距离限制。',
                            minidanji: '单骑',
                            minidanji_info: '觉醒技，当你本局游戏使用或打出的牌数不小于5时，或当本局游戏造成不少于6点伤害后，你将体力值回复至上限，然后获得技能〖驭马〗和〖怒斩〗。',
                            mininuzhan: '怒斩',
                            mininuzhan_info: '锁定技，你使用非锦囊牌转化的【杀】不计入次数限制，你使用锦囊牌转化的【杀】造成的伤害+1。',
                            minishenshi: '审时',
                            minishenshi_info: '①出牌阶段限一次，你可以将一张牌交给一名其他角色，然后对其造成1点伤害，若该角色因此死亡，则你可以令一名角色将手牌摸至四张。②其他角色对你造成伤害后，你可以观看该角色的手牌，然后交给其一张牌，其失去此牌后，你将手牌摸至四张。',
                            minijianshu: '间书',
                            minijianshu_info: '出牌阶段限一次，你可以将一张手牌交给一名其他角色，并选择另一名其他角色，你令前者与后者拼点。赢的角色随机交给你一张牌，没赢的角色失去1点体力。若有角色因此死亡，你令你〖间书〗于此阶段发动的次数上限+1。',
                            miniyongdi: '拥嫡',
                            miniyongdi_info: '限定技，出牌阶段，你可以选择一名角色，若其：体力上限最少，其加1点体力上限；体力值最少，其回复1点体力；手牌数最少，其摸X张牌（X为其体力上限且至多为5）。',
                            miniyongbi: '拥嬖',
                            miniyongbi_info: '限定技。出牌阶段，你可以将任意手牌交给一名其他角色，然后将〖媵予〗的发动时机改为“准备阶段和结束阶段开始时”。若这些牌中包含的花色数：大于1，则你与其本局游戏的手牌上限+2；大于2，则当你或其于本局游戏内受到大于1的伤害时，此伤害-1。',
                            miniweikui: '伪溃',
                            miniweikui_info: '出牌阶段限一次，你可以失去1点体力并选择一名有手牌的其他角色，你观看其手牌：若其手牌中没有【闪】，则视为你对其使用【杀】，且本回合你计算与其的距离视为1；若其手牌中有【闪】，你获得其中一张牌并回复1点体力。',
                            minilizhan: '励战',
                            minilizhan_info: '结束阶段，你可以令任意名已受伤的角色摸一张牌，然后你摸X张牌（X为手牌数等于体力值的目标角色数）。',
                            minishenglun: '胜论',
                            minishenglun_info: '出牌阶段限一次，你可以选择至多两名其他角色，然后你依次与目标角色依次比较你与其的：体力、手牌数、已装备武器牌数、已装备防具牌数、已装备坐骑牌数（你对应的数值比其大则获得1枚“胜”标记，否则获得1枚“负”标记）。当你的“胜”/“负”标记数达到10后，你回复1点体力/对一名角色造成1点伤害，然后发动〖遗计〗并失去所有的“胜”/“负”标记。',
                            miniyuanhu: '援护',
                            miniyuanhu_info: '①出牌阶段限两次，你可将一张装备牌置入一名角色的装备区内并摸一张牌，若此牌为：武器牌，你弃置与其距离为1的另一名角色区域的一张牌；防具牌，其摸一张牌；坐骑牌，其回复1点体力。②回合结束时，若你本回合未发动过〖援护①〗，则你从牌堆中获得一张装备牌。',
                            minijuezhu: '决助',
                            minijuezhu_info: '限定技，出牌阶段，你可以选择一名角色并废除一个坐骑栏，令该角色获得〖飞影〗并废除判定区。若如此做，该角色死亡后，你恢复以此法废除的装备栏。',
                            minisbjianxiong: '奸雄',
                            minisbjianxiong_info: '游戏开始时，你可获得至多2枚“治世”标记。当你受到伤害后，你可获得伤害牌，摸2-X张牌（X为你的“治世”标记数），然后你可获得或失去1枚“治世”标记。',
                            minisbqingzheng: '清正',
                            minisbqingzheng_backup: '清正',
                            minisbqingzheng_info: '出牌阶段限一次，你可以弃置3-X种花色的所有手牌（X为你的“治世”标记数）并观看一名有手牌的其他角色的手牌，你弃置其中一种花色的所有牌。若其被弃置的牌数小于你以此法弃置的牌数，你对其造成1点伤害，然后你可获得或失去1枚“治世”标记。',
                            minigongao: '功獒',
                            minigongao_info: '锁定技，一名其他角色进入濒死状态时，你增加1点体力上限，然后回复1点体力。',
                            minijuyi: '举义',
                            minijuyi_info: '限定技，准备阶段，若你的体力上限大于场上的存活角色数，你将手牌数摸至体力上限，然后获得技能〖崩坏〗和〖威重〗。',
                            miniyuejian: '约俭',
                            miniyuejian_info: '你的手牌上限+X（X为你的体力上限）。当你需要使用基本牌时，若你本回合未使用过基本牌，则你可以视为使用之。',
                            minixiayuan: '狭援',
                            minixiayuan_info: '每轮限一次，一名其他角色进入濒死状态时，你可以弃置至多两张牌并令其回复等量的体力。',
                            minijieyue: '节钺',
                            minijieyue_info: '准备阶段，你可以令一名其他角色摸一张牌，然后选择一个军令令其选择是否执行。若其执行，你摸一张牌；若其不执行，你摸三张牌，且其本回合受到的伤害+1。',
                            minixiaoguo: '骁果',
                            minixiaoguo_info: '其他角色的结束阶段，你可以弃置一张牌，令其选择一项：①弃置一张装备牌，令你摸一张牌，直到其下个结束阶段，你对其造成伤害时摸一张牌；②受到你对其造成的1点伤害，直到其下个结束阶段，你对其使用【杀】造成的伤害+1。',
                            miniweicheng: '伪诚',
                            miniweicheng_info: '当牌从你的手牌区移动至其他角色的手牌区后，若你的手牌数小于等于体力值，你可以摸一张牌。',
                            minidaoshu: '盗书',
                            minidaoshu_info: '出牌阶段限一次，你可以选择一个花色并获得一名其他角色的一张手牌。若此牌花色与你选择的相同，则你对其造成1点伤害且你〖盗书〗于此阶段内可使用的次数上限+1，否则你须交给一名其他角色一张手牌。',
                            minishefu: '设伏',
                            minishefu_info: '结束阶段/当你受到伤害后，你可以记录一个当前「伏兵」未记录的基本牌或锦囊牌的名称并将一张牌移出游戏，称为「伏兵」。你的回合外，当有其他角色使用与你记录的「伏兵」牌名相同的手牌时，你可以取消此牌的所有目标，然后移去该「伏兵」，若此时处于使用者的回合内，则其本回合所有技能失效。',
                            minibenyu: '贲育',
                            minibenyu_info: '当你受到有来源造成的伤害后，你可以选择一项：①将手牌摸至与伤害来源相同（至多摸至五张）；②弃置一张手牌，然后对伤害来源造成1点伤害。',
                            minisbduanliang: '断粮',
                            minisbduanliang_tag: 'invisible',
                            minisbduanliang_info: '出牌阶段限两次，你可以摸一张牌并与一名其他角色进行谋弈。若你赢，且你选择的选项为：“围城断粮”，若其判定区没有【兵粮寸断】，你将此牌当作【兵粮寸断】对其使用，否则你获得其一张牌；“擂鼓进军”，你视为对其使用一张【决斗】。',
                            minixingzuo: '兴作',
                            minixingzuo_info: '出牌阶段开始时，你可观看牌堆底的三张牌并用任意张手牌替换其中等量的牌。若如此做，结束阶段，你可令一名有手牌的角色用所有手牌替换牌堆底的三张牌。',
                            minideshao: '德劭',
                            minideshao_info: '每回合限两次，当你成为一名角色使用的黑色牌的目标后，你可以摸一张牌，然后若其手牌数大于你，则你可以弃置其一张牌。',
                            minixiangshu: '襄戍',
                            minixiangshu_info: '限定技，结束阶段，若你本回合内造成过伤害，则你可以令一名已受伤的角色回复X点体力并摸X张牌（X为你本局游戏内造成的伤害值总和且至多为5）。',
                            minizhuilie: '追猎',
                            minizhuilie_info: '锁定技，你使用【杀】无距离限制；当你使用【杀】指定目标后，若其不在你的攻击范围内，此【杀】不计入使用次数限制且你判定。若判定结果为：武器牌或坐骑牌，此【杀】的伤害基数改为X（X为其体力值）；锦囊牌，你获得此牌；基本牌，你失去1点体力。',
                            minisongci: '颂词',
                            minisongci_info: '①每名角色限一次，出牌阶段，你可以选择一名角色。若其手牌数：大于其体力值，其弃置两张牌；不大于其体力值，其摸两张牌。②弃牌阶段结束时，你摸一张牌。',
                            minipoyuan: '破垣',
                            minipoyuan_info: '游戏开始时或准备阶段，若你的装备区内：没有【霹雳车】，则你可以将一张【霹雳车】置入装备区；有【霹雳车】，则你可以弃置一名其他角色至多两张牌。',
                            minipiliche: '霹雳投石车',
                            minipiliche_info: '锁定技。①你计算与其他角色的距离-1，当此牌离开你的装备区时，销毁之。②你于回合内使用基本牌无距离限制，且当你于回合内使用基本牌时，你令此牌的牌面数值+1。③当你于回合外使用或打出基本牌时，你摸一张牌。',
                            minihuiqi: '彗启',
                            minihuiqi_info: '觉醒技。一名角色回合结束后，若你与其他两名角色于此回合成为过牌的目标，你回复1点体力并获得〖偕举〗。',
                            minixieju: '偕举',
                            minixieju_info: '出牌阶段限一次。你可以令任意名本回合成为过牌的目标的角色可以依次将一张黑色牌当作【杀】使用。',
                            minizhenrong: '征荣',
                            minizhenrong_info: '当你对其他角色造成伤害后，你可以将其一张牌置于你的武将牌上，称为“荣”。',
                            minihongju: '鸿举',
                            minihongju_info: '觉醒技，准备阶段，若你武将牌上的“荣”数不小于3且场上有角色死亡，则你可以用任意张手牌替换等量的“荣”，然后获得〖清侧〗。',
                            minibusuan: '卜算',
                            minibusuan_info: '出牌阶段限一次，你可以选择一名角色，然后选择至多两张不同的卡牌名称（限基本牌或锦囊牌）。该角色下次摸牌阶段摸牌时，改为从牌堆或弃牌堆中获得你选择的牌。',
                            minimingjie: '命戒',
                            minimingjie_info: '结束阶段，你可以摸一张牌，若此牌为红色，你可以重复此流程直到摸到黑色牌或摸到第三张牌。然后若你以此法均获得红色牌，则你回复1点体力。',
                            miniqiangzhi: '强峙',
                            miniqiangzhi_info: '出牌阶段限一次，你可以依次你和一名其他角色的共计三张牌。然后若你与其之中有角色未因此失去牌，则另一名角色对该角色造成1点伤害。',
                            minijiuxian: '救陷',
                            minijiuxian_info: '出牌阶段限一次，你可以重铸至多一半手牌（向上取整），然后视为使用一张【决斗】。当此牌对目标角色造成伤害后，你可以令其攻击范围内的一名其他角色回复1点体力。',
                            miniyonglve: '勇略',
                            miniyonglve_info: '判定区有牌的其他角色的判定阶段开始时，你可以弃置其判定区的一张牌或弃置自己一张牌，然后若其在你的攻击范围内，则你摸一张牌；若其不在你的攻击范围内，则你视为对其使用一张无距离限制的【杀】。',
                            minisbluoshen: '洛神',
                            minisbluoshen_info: '当你失去最后的红色手牌后，你可展示牌堆顶的一张牌，然后若此牌为：黑色，你重复此流程且可使用此牌；红色，你获得此牌。',
                            minisbqingguo: '倾国',
                            minisbqingguo_info: '①出牌阶段限两次，你可以将一张红色手牌交给一名其他角色，然后令其交给你一张黑色牌。②当你成为其他角色【杀】或普通锦囊牌的目标时，你可以弃置一张黑色牌，令此牌对你无效。',
                            miniquji: '去疾',
                            miniquji_info: '出牌阶段限一次，你可以重铸X张牌（X为你已损失的体力值+1）并令至多X名角色回复1点体力，然后仍处于受伤状态的目标角色摸一张牌。',
                            //蜀
                            Mbaby_guanyu: '欢杀关羽',
                            Mbaby_zhugeliang: '欢杀诸葛亮',
                            Mbaby_liubei: '欢杀刘备',
                            Mbaby_machao: '欢杀马超',
                            Mbaby_zhurong: '欢杀祝融',
                            Mbaby_zhangfei: '欢杀张飞',
                            Mbaby_zhaoyun: '欢杀赵云',
                            Mbaby_huangzhong: '欢杀黄忠',
                            Mbaby_weiyan: '欢杀魏延',
                            Mbaby_liaohua: '欢杀廖化',
                            Mbaby_pangtong: '欢杀庞统',
                            Mbaby_menghuo: '欢杀孟获',
                            Mbaby_jiangwei: '欢杀姜维',
                            Mbaby_liushan: '欢杀刘禅',
                            Mbaby_fazheng: '欢杀法正',
                            Mbaby_madai: '欢杀马岱',
                            Mbaby_guanping: '欢杀关平',
                            Mbaby_liufeng: '欢杀刘封',
                            Mbaby_wuyi: '欢杀吴懿',
                            Mbaby_guanyinping: '欢杀关银屏',
                            Mbaby_zhangxingcai: '欢杀张星彩',
                            Mbaby_dongyun: '欢杀董允',
                            Mbaby_sp_sunshangxiang: 'SP欢杀孙尚香',
                            Mbaby_xushu: '欢杀徐庶',
                            Mbaby_masu: '欢杀马谡',
                            Mbaby_qinmi: '欢杀秦宓',
                            Mbaby_zhugezhan: '欢杀诸葛瞻',
                            Mbaby_wuxian: '欢杀吴苋',
                            Mbaby_shamoke: '欢杀沙摩柯',
                            Mbaby_xiahoushi: '欢杀夏侯氏',
                            Mbaby_guansuo: '欢杀关索',
                            Mbaby_mayunlu: '欢杀马云騄',
                            Mbaby_wangping: '欢杀王平',
                            Mbaby_jianyong: '欢杀简雍',
                            Mbaby_zhugeguo: '欢杀诸葛果',
                            Mbaby_sp_zhugeliang: '欢杀卧龙',
                            Mbaby_baosanniang: '欢杀鲍三娘',
                            Mbaby_huaman: '欢杀花鬘',
                            Mbaby_zhaoxiang: '欢杀赵襄',
                            Mbaby_xiahouba: '欢杀夏侯霸',
                            Mbaby_yanyan: '欢杀严颜',
                            Mbaby_chendao: '欢杀陈到',
                            Mbaby_liyan: '欢杀李严',
                            Mbaby_liuchen: '欢杀刘谌',
                            Mbaby_yangwan: '欢杀杨婉',
                            Mbaby_huangyueying: '欢杀黄月英',
                            Mbaby_zhoucang: '欢杀周仓',
                            Mbaby_lvkai: '欢杀吕凯',
                            Mbaby_sunqian: '欢杀孙乾',
                            Mbaby_ganfuren: '欢杀甘夫人',
                            Mbaby_liuyong: '欢杀刘永',
                            Mbaby_mizhu: '欢杀糜竺',
                            Mbaby_mifuren: '欢杀糜夫人',
                            Mbaby_wangyue: '欢杀王悦',
                            Mbaby_xf_yiji: '欢杀伊籍',
                            Mbabysp_zhangfei: 'SP欢杀张飞',
                            Mbaby_wangtao: '欢杀王桃',
                            Mbaby_wolongfengchu: '欢杀卧龙凤雏',
                            Mbaby_guanzhang: '欢杀关兴张苞',
                            Mbaby_sb_liubei: '欢杀谋刘备',
                            Mbaby_sb_machao: '欢杀谋马超',
                            Mbaby_sb_huangzhong: '欢杀谋黄忠',
                            Mbaby_sb_zhaoyun: '欢杀谋赵云',
                            Mbaby_zhangyi: '欢杀张嶷',
                            Mbaby_jiangfei: '欢杀蒋琬费祎',
                            Mbaby_sb_sunshangxiang: '欢杀谋孙尚香',
                            Mbaby_sp_xiahoushi: 'SP欢杀夏侯氏',
                            Mbaby_hujinding: '欢杀胡金定',
                            Mbaby_dengzhi: '欢杀邓芝',
                            Mbaby_mazhong: '欢杀马忠',
                            Mbaby_ol_sb_guanyu: '欢杀谋关羽',
                            Mbaby_zongyu: '欢杀宗预',
                            Mbaby_sb_huangyueying: '欢杀谋黄月英',
                            Mbaby_ol_sb_jiangwei: '欢杀谋姜维',
                            Mbaby_leitong: '欢杀雷铜',
                            Mbaby_wulan: '欢杀吴兰',
                            Mbaby_zhaotongzhaoguang: '欢杀赵统赵广',
                            Mbaby_ganfurenmifuren: '欢杀甘夫人糜夫人',
                            miniwusheng: '武圣',
                            miniwusheng_info: '锁定技。①你使用红色【杀】造成的伤害+1。②回合开始时，你从牌堆或弃牌堆中获得一张红色【杀】。',
                            miniguanxing: '观星',
                            miniguanxing_info: '准备阶段，你可以观看牌堆顶的X张牌（场上人数不大于2时X为3，否则X为5）并可以调整这些牌于牌堆顶或牌堆底。若你将所有牌置于牌堆底，则你可以于结束阶段再次发动〖观星〗。',
                            minireguanxing: '观星',
                            minireguanxing_liannu: '诸葛连弩',
                            minireguanxing_zhuge: '诸葛连弩',
                            minireguanxing_info: '①准备阶段和结束阶段，你可以观看牌堆顶的X张牌并可以调整这些牌于牌堆顶或牌堆底，若你的“星”小于X张，你可以将其中一张牌称为“星”置于你的武将牌上。②出牌阶段，你可以获得你武将牌上的所有“星”，若这些牌不小于X张，则你本回合获得如下效果：若你有空置的装备栏，则你视为装备【诸葛连弩】。（X为5，场上人数不大于2时X为3）',
                            minikongcheng: '空城',
                            minikongcheng_info: '锁定技，若你没有手牌，你不能成为【杀】、【决斗】和【顺手牵羊】的目标。',
                            minirende: '仁德',
                            minirende_info: '出牌阶段结束时，你可以令至多两名角色各摸一张牌。',
                            minirerende: '仁德',
                            minirerende_info: '出牌阶段，你可以将至少一张手牌交给其他角色，然后你于此阶段内不能再以此法交给该角色牌，且该角色使用红色【杀】不能指定你为目标直到你的下个回合开始；若你于此阶段内给出的牌首次达到两张，你可以视为使用一张基本牌或普通锦囊牌。',
                            minijijiang: '激将',
                            minijijiang_info: '主公技。①当你需要使用或打出【杀】时，蜀势力角色可以代替你进行此操作，若如此做，你与响应【激将】的角色各摸一张牌。②每回合限一次，你的回合外，一名其他蜀势力角色使用或打出【杀】时，其可以令你摸一张牌。',
                            miniyuma: '驭马',
                            miniyuma_info: '锁定技，你计算与其他角色的距离-1；当你失去装备区中的坐骑牌时，你摸两张牌。',
                            minitieji: '铁骑',
                            minitieji_info: '当你使用【杀】指定目标后，你可以令目标角色本回合非锁定技失效，然后你进行一次判定，若判定结果为：红色，此【杀】强制命中；黑色，你摸两张牌。',
                            minijuxiang: '巨象',
                            minijuxiang_info: '锁定技。①【南蛮入侵】对你无效。②其他角色弃置【南蛮入侵】后，你获得之。③其他角色使用【南蛮入侵】结算完毕后，你获得此牌对应的所有实体牌，若此牌造成伤害，你摸一张牌。',
                            minilieren: '烈刃',
                            minilieren_info: '当你使用【杀】对目标角色造成伤害后，你可以弃置目标角色一张手牌，若此牌点数小于【杀】的点数，你获得此牌。',
                            minirelieren: '烈刃',
                            minirelieren_info: '当你使用【杀】指定目标后，你可以和目标角色进行拼点，然后你获得其的拼点牌。若你赢，你获得其一张牌。',
                            minitishen: '替身',
                            minitishen_info: '你的回合外，当目标角色含有你的【杀】结算完毕后，若你未受到此牌造成的伤害，则你获得此牌。当你使用的【杀】被【闪】抵消后，你本阶段使用的下一张【杀】不可被响应且造成的伤害+1。',
                            miniyajiao: '涯角',
                            miniyajiao_info: '当你于回合外使用或打出一张手牌时，你可以亮出牌堆顶的一张牌，并可以将之交给任意一名角色。当你于回合内发动一次〖龙胆〗后，你于结束阶段摸一张牌。',
                            miniliegong: '烈弓',
                            miniliegong_info: '你的攻击范围无限。当你使用【杀】指定目标后，若目标角色的手牌数不大于你，则该角色不能使用【闪】；若目标角色的体力值不小于你，此【杀】伤害+1。',
                            minikuanggu: '狂骨',
                            minikuanggu_info: '当你对一名角色造成1点伤害后，你可以回复1点体力或摸一张牌',
                            miniqimou: '奇谋',
                            miniqimou_info: '限定技，出牌阶段，你可以失去任意点体力并摸一张牌，本回合你计算与其他角色的距离-X且你可以多使用X张【杀】（X为你失去的体力值）。',
                            minidangxian: '当先',
                            minidangxian_info: '回合开始时，你进行一个额外的出牌阶段并从牌堆中获得一张【杀】。',
                            minifuli: '伏枥',
                            minifuli_info: '限定技，当你处于濒死状态时，你可以将体力回复至X点并将手牌数摸至X张，然后若X大于3，你翻面（X为全场势力数）。',
                            minilianhuan: '连环',
                            minilianhuan_info: '出牌阶段开始时，你可以选择至多两名角色，这些角色重置或横置其武将牌，然后若你也是【连环】的目标角色，则你摸一张牌。',
                            minirelianhuan: '连环',
                            minirelianhuan_info: '①出牌阶段开始时，你可以视为使用【铁索连环】。②你使用【铁索连环】可以额外指定任意名目标，若以此法指定的目标包含你，则你摸一张牌。③当你使用【铁索连环】指定未横置的其他角色后，你随机弃置其一张手牌。',
                            mininiepan: '涅槃',
                            mininiepan_info: '限定技，当你处于濒死状态时，你可以弃置你区域内的所有牌并复原你的武将牌，然后摸三张牌并将体力回复至3点。然后你选择一项：①获得技能〖八阵〗；②获得技能〖火计〗和〖看破〗。',
                            minihuoshou: '祸首',
                            minihuoshou_info: '锁定技，【南蛮入侵】对你无效；当其他角色使用【南蛮入侵】时，你代替其成为此牌的伤害来源并摸一张牌。',
                            minirehuoshou: '祸首',
                            minirehuoshou_info: '锁定技。①【南蛮入侵】对你无效。②当其他角色使用【南蛮入侵】指定第一个目标后，你代替其成为此牌的伤害来源并摸一张牌。③出牌阶段开始时，你随机获得弃牌堆中的一张【南蛮入侵】。④出牌阶段，若你于此阶段使用过【南蛮入侵】，你不能使用【南蛮入侵】。',
                            minizaiqi: '再起',
                            minizaiqi_info: '①摸牌阶段，若你已受伤，则你可以改为亮出牌堆顶的X张牌（X为你已损失的体力值），并回复X点体力（X为其中♥牌的数目）。然后你将这些♥牌置入弃牌堆，并获得其余的牌。②结束阶段，你可以发动一次X为你本回合造成的伤害值的〖再起①〗。',
                            minitiaoxin: '挑衅',
                            minitiaoxin_info: '出牌阶段开始时，你可以弃置一名其他角色至多两张手牌，然后若弃置的牌中含有【杀】，你弃置一张牌。',
                            minizhiji: '志继',
                            minizhiji_info: '觉醒技，准备阶段，若你没有手牌，你须回复1点体力或摸两张牌，然后减1点体力上限，并获得技能〖观星〗。',
                            minifangquan: '放权',
                            minifangquan_info: '你可以跳过你的出牌阶段，然后于此回合结束时选择一名其他角色，其进行一个额外回合。',
                            miniruoyu: '若愚',
                            miniruoyu_info: '主公技，觉醒技。准备阶段，若你的体力值为全场最少，你增加1点体力上限并回复1点体力，然后获得技能〖激将〗。',
                            minirexiangle: '享乐',
                            minirexiangle_info: '锁定技。①当你成为一名角色使用【杀】的目标后，除非该角色弃置一张牌，否则此【杀】对你无效。②一轮游戏开始时，若你上一轮未使用过牌，你可以弃置X张牌并翻面，然后发动〖放权〗（X为你座次的一半，向下取整）。',
                            minirefangquan: '放权',
                            minirefangquan_info: '你可以跳过你的出牌阶段，然后于弃牌阶段开始时选择一名其他角色，你可以交给其任意张牌并令其于本回合结束后进行一个额外回合。',
                            minireruoyu: '若愚',
                            minireruoyu_info: '主公技，觉醒技。准备阶段，若你的体力值为全场最少，你增加1点体力上限并回复1点体力，然后获得技能〖激将〗和〖思蜀〗。',
                            minienyuan: '恩怨',
                            minienyuan_info: '当你获得一名其他角色的牌后，你可以令其摸一张牌；其他角色获得你的牌后，你可以摸一张牌。',
                            minixuanhuo: '眩惑',
                            minixuanhuo_info: '摸牌阶段，你可以选择一名其他角色，除非该角色对你选择的另一名角色使用一张【杀】，否则你获得其一张牌。',
                            minireenyuan: '恩怨',
                            minireenyuan_info: '①当你获得一名其他角色的牌后，你可以令其摸一张牌；其他角色获得你的牌后，你可以摸一张牌。②当你受到1点伤害后，你可以令伤害来源选择一项：1.交给你一张红色手牌，然后若此牌不为红桃牌，你摸一张牌；2.失去1点体力。',
                            minirexuanhuo: '眩惑',
                            minirexuanhuo_info: '摸牌阶段结束时，你可以交给一名其他角色至多两张手牌，然后其选择一项：1.视为对你选择的另一名其他角色使用任意一张【杀】或【决斗】；2.你观看并获得其任意张手牌。',
                            miniqianxi: '潜袭',
                            miniqianxi2: '潜袭',
                            miniqianxi_info: '准备阶段，你可以摸两张牌并弃置其中的一张，然后你令一名与你距离为1的角色于本回合无法使用或打出与你弃置的牌颜色相同的手牌。',
                            minilongyin: '龙吟',
                            minilongyin_info: '当一名角色于其出牌阶段使用【杀】时，你可弃置一张牌令此【杀】不计入出牌阶段使用次数。若此【杀】为红色，则你摸一张牌；若你以此法弃置的牌与此【杀】的花色相同，则你重置〖竭忠〗。',
                            minixiansi: '陷嗣',
                            minixiansi_info: '准备阶段开始时，你可以弃置至多两名其他角色的各一张牌。若你弃置的是装备区里的牌且你在目标角色的攻击范围内，其视为对你使用一张【杀】。结算完成后，若〖陷嗣〗只选择了一名角色，则你摸一张牌。',
                            minibingzheng: '秉正',
                            minibingzheng_info: '出牌阶段结束时，你可以令一名角色弃置一张手牌或摸一张牌。然后若其手牌数等于体力值，你摸一张牌，且你可以交给该角色一张牌。',
                            miniliangzhu: '良助',
                            miniliangzhu_info: '当一名角色于其出牌阶段内回复体力时，你可以选择一项：1、摸一张牌；2、令该角色摸两张牌；3、获得该角色装备区里的武器牌。',
                            minifanxiang: '返乡',
                            minifanxiang_info: '觉醒技，准备阶段开始时，若你已发动过〖良助〗，你加1点体力上限并回复1点体力，失去技能〖良助〗并获得技能〖枭姬〗和〖舞剑〗。',
                            miniwujian: '舞剑',
                            miniwujian_info: '出牌阶段，你可以将装备区中的牌当作【杀】使用（每个装备栏每回合限一次，且该【杀】不计入次数限制）。',
                            minijujian: '举荐',
                            minijujian_info: '准备阶段和结束阶段，你可以弃置一张非基本牌并选择一名角色，令其选择一项：1.摸两张牌；2.回复1点体力；3.将其武将牌翻转至正面朝上并重置之。',
                            minihuxiao: '虎啸',
                            minihuxiao3: '虎啸',
                            minihuxiao_info: '锁定技，当你造成火属性伤害时，你于此回合内对目标角色使用牌没有次数限制。',
                            miniwuji: '武继',
                            miniwuji_info: '觉醒技，结束阶段开始时，若你于此回合内造成过3点或更多伤害，则你加1点体力上限并回复1点体力，然后从场上、牌堆或弃牌堆中获得【青龙偃月刀】。',
                            minisanyao: '散谣',
                            minisanyao_info: '出牌阶段限一次，你可以弃置至多四张牌并对等量的其他角色各造成1点伤害。',
                            minizhuandui: '专对',
                            minizhuandui_info: '当你使用【杀】指定目标/成为【杀】的目标后，你可以与目标角色/此【杀】使用者拼点，若你赢，此杀不能被【闪】响应/对你无效。当你拼点胜利后，你摸一张牌。',
                            minizuilun: '罪论',
                            minizuilun_info: '结束阶段，你可以观看牌堆顶的四张牌，你每满足以下一项便保留一张，然后以任意顺序放回其余的牌：1.你于此回合内造成过伤害；2.你于此回合内未弃置过牌；3.手牌数为全场最少。若均不满足，你选择一名其他角色，与其各失去1点体力。',
                            miniqiangwu: '枪舞',
                            miniqiangwu_info: '出牌阶段，你可以进行判定并获得判定牌。然后直到回合结束，你使用点数小于判定结果的【杀】时不受距离限制，且你使用点数大于判定结果的【杀】时无使用次数限制。',
                            minixiantu: '献图',
                            minixiantu_info: '一名其他角色的出牌阶段开始时，你可以摸两张牌，然后交给其两张牌。若如此做，此阶段结束时，若该角色本阶段未造成过伤害，你失去1点体力。',
                            minifumian: '福绵',
                            minifumian_info: '准备阶段，你可以选择一项：1.摸牌阶段多摸一张牌；2.使用红色牌可以多选择一个目标。若与你上回合选择的选项不同，则该选项数值+1并复原此技能。',
                            minidaiyan: '怠宴',
                            minidaiyan_info: '结束阶段，你可以令一名角色从牌堆中获得一张红桃基本牌，然后若其于上回合未成为过此技能的目标，则你摸一张牌。',
                            minijili: '蒺藜',
                            minijili_info: '当你于一回合内使用或打出第X张牌时，你可以摸X张牌（X为你的攻击范围）。结束阶段，你可以弃置一张牌并摸一张牌。',
                            miniqiaoshi: '樵拾',
                            miniqiaoshi_info: '其他角色的结束阶段，若其手牌数不小于你，你可以与其各摸一张牌。',
                            miniyanyu: '燕语',
                            miniyanyu_info: '出牌阶段，你可以重铸【杀】。回合结束时，若你本回合因〖燕语〗重铸过【杀】，则你可以令一名角色摸一张牌（若该角色不为你则改为摸两张牌）。',
                            minizhengnan: '征南',
                            minizhengnan_info: '当一名角色进入濒死状态时，若你未因其发动过〖征南〗，则你回复[1]点体力并摸[1]张牌，然后获得下列技能中的任意一个：〖武圣〗、〖当先〗和〖制蛮〗（若技能全部拥有则改为摸[3]张牌，若你因自己发动〖征南〗，则本次技能结算中所有[ ]中的数值+1）。',
                            minixiefang: '撷芳',
                            minixiefang_info: '锁定技，你计算与其他角色的距离时-X，你的手牌上限+X（X为女性角色数且X至少为1）。',
                            minifengpo: '凤魄',
                            minifengpo_info: '当你于回合内第一次使用【杀】或【决斗】指定一个目标后，你可以选择一项：1.摸X张牌；2.令此牌的伤害值基数+X。（X为其手牌中红色牌的数量且X至多为4）',
                            minifeijun: '飞军',
                            minifeijun_info: '出牌阶段限一次，你可以弃置一张牌，然后选择一项：⒈令一名其他角色交给你一张牌；⒉令一名其他角色弃置一张装备区的牌。',
                            minibinglve: '兵略',
                            minibinglve_info: '锁定技，当你发动〖飞军〗时，你摸一张牌，若目标角色与你之前指定的目标均不相同，则你再摸X张牌（X为成为过你发动〖飞军〗目标的存活角色数）。',
                            miniqiaoshui: '巧说',
                            miniqiaoshui_info: '①你的锦囊牌不计入手牌上限。②出牌阶段，你可与一名其他角色拼点。若你赢，你使用的下一张基本牌或普通锦囊牌可以增加或减少一个目标；若你没赢，你本回合不能再发动〖巧说②〗。',
                            miniqirang: '祈禳',
                            miniqirang_info: '①当你使用装备牌，你可获得牌堆中的一张锦囊牌。②当你使用锦囊牌指定唯一目标时，你可以为此牌额外指定一个目标。',
                            miniyuhua: '羽化',
                            miniyuhua_info: '锁定技。①你的非基本牌不计入手牌上限。②结束阶段，你观看牌堆顶的两张牌，将其中一张牌置于牌堆顶或牌堆底，然后获得另一张牌。',
                            minibazhen: '八阵',
                            minibazhen_info: '锁定技。①若你的装备区没有防具牌，你视为装备【八卦阵】。②当你的【八卦阵】判定失效时，你摸一张牌。',
                            minihuoji: '火计',
                            minihuoji_info: '①你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。',
                            minixushen: '许身',
                            minixushen2: '许身',
                            minixushen_info: '限定技，当你进入濒死状态后，你可以回复1点体力并获得技能〖镇南〗，然后若你脱离濒死状态且“欢杀关索”不在场，你可令一名其他角色选择是否用“欢杀关索”代替其武将并令其摸三张牌。',
                            minisouying: '薮影',
                            minisouying_info: '每回合限一次，当你对其他角色（或其他角色对你）使用【杀】或普通锦囊牌指定唯一目标后，你可以弃置一张牌。若如此做，你获得此牌对应的所有实体牌（或令此牌对你无效）。',
                            minizhanyuan: '战缘',
                            minizhanyuan_info: '觉醒技，你的回合内，当你因〖蛮嗣〗累计获得超过7张牌后，你可以选择一名其他角色。若如此做，你与其获得技能〖系力〗，然后你失去技能〖蛮嗣〗',
                            minifuhan: '扶汉',
                            minifuhan_info: '限定技，回合开始时，你可以移去所有"梅影"标记并摸等量的牌，然后从欢杀将池中的随机X张存在于武将牌堆的蜀势力武将牌中选择并获得至多两个技能（限定技、觉醒技、隐匿技、使命技、主公技除外）。若此时你是体力值最低的角色，你回复1点体力（X为场上角色数，且X至少为4）。',
                            minibaobian: '豹变',
                            minibaobian_info: '锁定技，当你受到伤害后，你获得以下未获得的第一个技能：〖挑衅〗、〖咆哮〗、〖神速〗。',
                            minijuzhan: '拒战',
                            minijuzhan_info: '当你成为其他角色【杀】的目标后，你可以与其各摸一张牌，然后其本回合内不能再对你使用牌。当你使用【杀】指定一名角色为目标后，你可以获得其一张牌，然后你本回合内不能再对其使用红色【杀】。',
                            miniwanglie: '往烈',
                            miniwanglie2: '往烈',
                            miniwanglie_info: '出牌阶段，你使用牌无距离限制。当你于出牌阶段内使用牌时，你可以令此牌不能被响应，且本回合结束时，你摸等同于此牌造成的伤害数的牌，然后你本回合不能再使用牌。',
                            miniduliang: '督粮',
                            miniduliang2: '督粮',
                            miniduliang_info: '出牌阶段限一次，你可以获得一名其他角色的一张手牌，然后选择一项：1.令其观看牌堆顶的两张牌，然后获得其中的基本牌和装备牌；2.令其于下个摸牌阶段额外摸一张牌，然后交给你一张牌。',
                            minizhanjue: '战绝',
                            minizhanjue_info: '出牌阶段，若你本阶段内因〖战绝〗获得过的牌数小于3，则你可以将所有手牌当做【决斗】使用。此【决斗】使用结算结束后，你摸一张牌，然后所有因此【决斗】受到过伤害的角色也各摸一张牌。若你因此【决斗】受到过伤害，则你可以弃置伤害来源的一张牌。',
                            miniqinwang: '勤王',
                            miniqinwang_info: '主公技。出牌阶段限一次，你可以令所有其他蜀势力角色依次选择是否交给你一张基本牌，然后你可以令选择是的角色摸一张牌（以此法获得的牌本回合不计算在〖战绝〗使用的牌中）。',
                            miniyouyan: '诱言',
                            miniyouyan_info: '①出牌阶段限一次，你可以弃置任意张牌。②出牌阶段/弃牌阶段各限一次，当你的牌因弃置进入弃牌堆后，你可以从牌堆中获得本次弃牌中没有的花色的牌各一张。',
                            minirejizhi: '集智',
                            minirejizhi_info: '当你使用锦囊牌时，你可以摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
                            minireqicai: '奇才',
                            minireqicai_info: '锁定技，你使用锦囊牌无距离限制，你装备区内的武器牌和防具牌不能被其他角色弃置。',
                            minizhongyong: '忠勇',
                            minizhongyong_info: '当你使用的【杀】结算完毕后，你可以将此【杀】或目标角色使用的【闪】交给一名目标角色以外的其他角色，若其中包含：红色牌，获得牌的角色可以对你攻击范围内的角色使用一张【杀】；黑色牌，你与获得牌的角色各摸一张牌。',
                            minidaopu: '刀仆',
                            minidaopu_info: '锁定技，若你的你的武器栏未被废除且装备区中没有武器牌，则你视为装备【青龙偃月刀】；若你的装备区中有【青龙偃月刀】，则你使用红色【杀】造成的伤害+1。',
                            minitunan: '图南',
                            minitunan_info: '出牌阶段限一次，你可以选择至多两名角色，这些角色依次亮出牌堆顶的一张牌并选择一项：使用此牌（无距离限制）；将此牌当作普通【杀】使用。',
                            miniqianya: '谦雅',
                            miniqianya_info: '当你成为锦囊牌的目标后，你可以将任意张手牌交给一名其他角色，然后你从牌堆中获得一张非装备牌。',
                            minishushen: '淑慎',
                            minishushen_info: '①一名角色受到伤害时，你可以失去1点体力并防止此伤害，然后你与其各摸一张牌。②当你回复1点体力后，你可以令一名其他角色摸一张牌。',
                            minihuangsi: '皇思',
                            minihuangsi_info: '限定技，当你处于濒死状态时，你可以将体力值回复至1并弃置所有手牌，然后你可以令一名角色摸X+2张牌（X为你以此法弃置的手牌数）。',
                            minifengxiang: '封乡',
                            minifengxiang_info: '锁定技，当你受到伤害后，你摸一张牌，然后若场上存在手牌中“隙”唯一最多的角色，则其回复1点体力。',
                            miniziyuan: '资援',
                            miniziyuan_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色，若这些牌的点数之和：不小于13，该角色回复1点体力；不大于13，你摸一张牌。',
                            minijugu: '巨贾',
                            minijugu_info: '锁定技。①你的手牌上限+X。②回合开始时，你可以视为对至多X名角色使用【五谷丰登】。（X为你的体力上限）',
                            miniguixiu: '闺秀',
                            miniguixiu_info: '锁定技，每回合限一次，结束阶段，若你的体力值为：奇数，你摸一张牌；偶数，你回复1点体力。',
                            miniguixiux: '闺秀·改',
                            miniguixiux_info: '锁定技，每回合限一次，结束阶段或当你进入濒死状态时，若你的体力值为：奇数，你摸一张牌；偶数，你回复1点体力。',
                            minicunsi: '存嗣',
                            minicunsi_info: '限定技，出牌阶段，你可以令一名其他角色获得技能〖勇决〗，然后修改技能〖闺秀〗，最后你失去所有体力并令其摸X张牌（X为你失去的体力数+1）。',
                            miniyongjue: '勇决',
                            miniyongjue_info: '①其他角色出牌阶段使用的第一张【杀】结算完毕后，你可以获得之。②当你受到有点数的【杀】造成的伤害时，你可以弃置一张点数大于等于此【杀】点数的牌并防止此伤害。',
                            minihuguan: '护关',
                            minihuguan_info: '一名角色于其出牌阶段使用第一张红色牌时，你可以选择一个花色并选择一项：①令其本回合此花色的牌不计入手牌上限；②令其本回合不能弃置此花色的手牌。',
                            minimingluan: '鸣鸾',
                            minimingluan_info: '其他角色的结束阶段，若本回合有角色回复过体力，你可以摸等同于当前回合角色手牌数的牌，然后将手牌弃至五张。',
                            minijijie: '机捷',
                            minijijie_info: '①出牌阶段限一次，你可以观看牌堆底的一张牌，然后将其交给任意一名角色。②每轮限一次，一名角色于其出牌阶段内一次性得到超过一张牌时，你可以发动〖机捷①〗。',
                            minijiyuan: '急援',
                            minijiyuan_info: '①当你交给一名其他角色牌时，你可令该角色摸一张牌。②当一名角色进入濒死时，你可令其摸X张牌并清空〖机捷①〗的发动计数（X为你发动〖机捷①〗的次数）。',
                            minisppaoxiao: '咆哮',
                            minisppaoxiao_info: '锁定技。①你使用【杀】无距离和次数限制。②你使用本回合第一次之后的【杀】造成的伤害+1，使用本回合第二次之后的【杀】无视防具且不可被响应。',
                            minixvhe: '虚吓',
                            minixvhe_info: '锁定技，当你使用【杀】被【闪】抵消后，或你使用或打出【闪】时，你与对方各摸一张牌。',
                            minirewusheng: '武圣',
                            minirewusheng_info: '①回合开始时，你从牌堆或弃牌堆中获得一张红色牌。②你可以将一张红色牌当作【杀】使用或打出。③你使用的红色【杀】造成的伤害+1。',
                            minituodao: '拖刀',
                            minituodao_info: '锁定技，当你使用或打出【闪】时，你令你使用的下一张【杀】的伤害基数+1。',
                            miniyaopei: '摇佩',
                            miniyaopei_info: '其他角色的弃牌阶段结束时，若其本阶段弃置过牌，则你可以弃置一张牌。若此牌与其本阶段弃置的任意牌的花色相同，你回复1点体力并摸两张牌；否则你选择一项：①其摸两张牌，你回复1点体力。②其回复1点体力，你摸两张牌。',
                            miniyoulong: '游龙',
                            miniyoulong_info: '转换技，每回合每项各限一次。阴，你可以废除你的一个装备栏，视为使用一张未以此法使用过的普通锦囊牌；阳，你可以弃置一张非基本牌，视为使用一张未以此法使用过的基本牌。',
                            miniluanfeng: '鸾凤',
                            miniluanfeng_info: '限定技，一名角色进入濒死状态时，若其体力上限不小于你，你可令其回复至3点体力，恢复你与其被废除的装备栏，令其手牌补至6张，取消〖游龙〗的回合限制并重置〖游龙〗使用过的牌名。',
                            minifuhun: '父魂',
                            minifuhun_info: '①你可以将两张手牌当做【杀】使用或打出。②当你于出牌阶段因〖父魂①〗使用的【杀】造成伤害后，你获得技能〖武圣〗和〖咆哮〗直到回合结束。③当你于一回合内不为首次使用使用的【杀】造成伤害后，你获得技能〖武圣〗和〖咆哮〗。',
                            minisbrende: '仁德',
                            minisbrende_info: '①出牌阶段每名角色限一次，你可以将任意张牌交给一名其他角色，然后你获得等量“仁望”标记（至多为10）。②每回合限一次，你可以移去2/3枚“仁望”，视为使用或打出一张基本牌/普通锦囊牌。③出牌阶段开始时，你获得3枚“仁望”。',
                            minisbzhangwu: '章武',
                            minisbzhangwu_info: '限定技，出牌阶段，你可以令所有于本局游戏成为过〖仁德①〗目标的其他角色依次交给你X张牌，然后你回复3点体力，本回合〖仁德〗失效（X为游戏轮数-1，且至多为3）。',
                            minisbjijiang: '激将',
                            minisbjijiang_info: '主公技，出牌阶段结束时，你可以选择一名其他蜀势力角色A和一名在A攻击范围内的角色B。A选择一项：1.视为对B使用一张【杀】；2.下一个出牌阶段开始前，跳过此阶段。',
                            minisbtieji: '铁骑',
                            minisbtieji_info: '①当你使用【杀】指定其他角色为目标后，你可以令目标角色不能响应此【杀】，且其所有非锁定技失效直到回合结束。然后你与其进行谋弈。若你赢，且你选择的选项为：“直取敌营”，则你获得其一张牌；“扰阵疲敌”，你摸两张牌。②当你谋弈成功后，你本回合使用【杀】的次数上限+1，然后你可以弃置一张牌并从牌堆或弃牌堆获得一张【杀】。',
                            minisbliegong: '烈弓',
                            minisbliegong_info: '若你的装备区内没有武器牌，则你手牌区内所有【杀】的属性视为无属性。当你使用牌时或成为其他角色使用牌的目标后，若此牌有花色且你未记录此牌的花色，你记录此牌的花色。当你使用【杀】指定唯一目标后，若〖烈弓〗存在记录花色，则你可亮出并获得牌堆顶的X张牌（X为〖烈弓〗记录过的花色数-1），令此【杀】的伤害值基数+Y（Y为亮出牌中被〖烈弓〗记录过花色的牌的数量），且目标角色不能使用〖烈弓〗记录过花色的牌响应此【杀】。此【杀】使用结算结束后，你清除〖烈弓〗记录的的花色。',
                            minisblongdan: '龙胆',
                            minisblongdan_info: '蓄力技（1/3）。①你可以消耗1点蓄力值，将一张基本牌当作任意基本牌使用或打出，然后你摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。',
                            minisbshilve: '识略',
                            minisbshilve_info: '当你发动〖龙胆〗使用或打出【杀】或【闪】时，你可以和对方进行谋弈。若你赢，且你选择的选项为：“偃旗息鼓”，从牌堆或弃牌堆获得一张非基本牌；“胆壮心雄”，你获得1点蓄力值。',
                            minishizhi: '矢志',
                            minishizhi_info: '锁定技，若当前回合角色为你，则你的【闪】视为【杀】，且当你使用对应的实体牌为一张【闪】的非转化普通杀造成伤害后，你回复1点体力。',
                            minishoucheng: '守成',
                            minishoucheng_info: '每回合限一次，一名角色于回合外失去手牌后，若其手牌数小于其体力值，则你可以令其摸两张牌。',
                            minisbxiaoji: '枭姬',
                            minisbxiaoji_info: '当你失去装备区里的一张牌后，你摸两张牌，然后可以弃置场上的一张牌。',
                            minisbjieyin: '结姻',
                            minisbjieyin_info: '①游戏开始时，你可以选择一名其他角色，你与其各获得1枚“姻”标记，然后令其获得〖结姻〗，最后你将势力变更至与其相同。②出牌阶段限一次，你可以将一张手牌交给一名有“姻”的其他角色或将一张装备牌置入一名有“姻”的其他角色的对应空置装备栏，然后你回复1点体力并摸一张牌。③拥有“姻”标记的角色死亡时，你获得其区域内所有的牌。',
                            minisbfanxiang: '返乡',
                            minisbfanxiang_info: '限定技，出牌阶段，你可以获得场上所有有“姻”标记的其他角色的装备区的牌，然后移去场上的所有“姻”标记并令所有角色失去〖结姻〗，最后你获得技能〖舞剑〗，将势力更换为吴。',
                            minispyanyu: '燕语',
                            minispyanyu_info: '一名角色的出牌阶段开始时，你可以弃置一张牌。若如此做，则此回合出牌阶段内限两次，当一张与你弃置的牌类别相同的其他牌进入弃牌堆后，你可令任意一名角色获得此牌。',
                            miniwuyuan: '武缘',
                            miniwuyuan_info: '出牌阶段限一次。你可将一张【杀】交给一名其他角色，然后你回复1点体力，你与其各摸一张牌。若此【杀】为：红色【杀】，其回复1点体力：黑色，其下回合使用【杀】的次数上限+1；属性【杀】，其改为摸两张牌。',
                            miniweimeng: '危盟',
                            miniweimeng_info: '出牌阶段限一次，你可以获得一名其他角色的至多X张手牌，然后交给其等量的牌（X为你的体力值）。若你给出的牌点数之和：大于得到的牌，则你摸一张牌；小于得到的牌，弃置该角色区域内的一张牌；等于得到的牌，你下一次发动〖危盟〗时的X改为“你的体力值+1”。',
                            minifuman: '抚蛮',
                            minifuman_info: '出牌阶段每名角色限一次。你可以弃置一张牌，令一名其他角色从牌堆中获得一张【杀】。然后其失去此【杀】后，你与其各摸一张牌。此【杀】结算完成后，若此【杀】造成过伤害，你摸一张牌。',
                            miniweilin: '威临',
                            miniweilin_info: '①每回合限一次，你可以将一张牌当作任意【杀】/【酒】/【忠】/【义】使用，且目标角色本回合与此牌颜色相同的手牌均视为【杀】。②当你使用或打出牌后，若此牌为你本局使用或打出的7的倍数张，则你可以获得一张【水淹七军】。',
                            mini_zhong: '忠',
                            mini_zhong_info: '当其他角色受到伤害时，使用此牌，将此伤害转移给自己。',
                            mini_yi: '义',
                            mini_yi_info: '出牌阶段，对一名有手牌的其他角色使用，令其交给你一张牌，然后其获得此【义】对应的实体牌。',
                            miniduoshou: '夺首',
                            miniduoshou_info: '锁定技。①你每回合使用的第一张红色牌无距离限制。②你每回合使用的第一张基本牌不计入使用次数。③你每回合使用的第一张【杀】指定目标后摸两张牌。④你每回合第一次造成伤害后，你获得受伤角色的一张牌。',
                            minichengshang: '承赏',
                            minichengshang_info: '出牌阶段限一次，当你于使用牌后，你可以从牌堆中获得所有与此牌花色点数相同的牌（你以此法获得的牌本回合不计入手牌上限）。若你未以此法获得牌，此技能视为未发动过。',
                            miniliuma: '流马',
                            miniliuma_info: '①出牌阶段结束时，你可以将至多X张手牌置入“流马”区（X为你的体力值，“流马”区至多存在五张牌）。②一轮游戏开始时，若场上仅你拥有【流马】，则你可以令一名其他角色获得不能发动此项的【流马】。③你可以使用或打出“流马”区的牌。',
                            minisbjizhi: '集智',
                            minisbjizhi_info: '锁定技。①当你使用非转化锦囊牌时，你摸一张牌。②你使用锦囊牌无距离限制。',
                            minisbqicai: '奇才',
                            minisbqicai_info: '转换技，①游戏开始时，你可以转换此技能状态。②阳：每回合限两次，当你使用普通锦囊牌时，你可以为此牌增加或减少一个目标；阴：每回合限两次，出牌阶段，你可以弃置一张基本牌，然后从牌堆中获得一张锦囊牌。',
                            miniranji: '燃己',
                            miniranji_info: '限定技，结束阶段。若你本回合使用过牌的阶段数大于等于/小于等于体力值，你可以获得技能〖困奋〗/〖诈降〗（同时满足则都获得）。若如此做，你将手牌数调整至手牌上限并将体力值回复至体力上限，然后你不能回复体力直到你杀死角色。',
                            minikuiji: '溃击',
                            minikuiji_info: '出牌阶段限一次，你可以将一张黑色基本牌当做【兵粮寸断】置于你的判定区，摸两张牌，然后你可以对体力值最多的一名其他角色造成2点伤害。该角色因此进入濒死状态时，你可令一名角色回复1点体力。',
                            minicuorui: '挫锐',
                            minicuorui_info: '出牌阶段开始时，你可以弃置一名你至其的距离不大于1的角色区域里的一张牌，然后你选择一项：1.弃置另一名其他角色装备区里至多两张与此牌颜色相同的牌；2.弃置另一名其他角色的至多两张手牌，然后获得其中与此牌颜色相同的牌。',
                            miniqingren: '青刃',
                            miniqingren_info: '结束阶段，你可以摸X张牌（X为你本回合使用或打出的非虚拟基本牌数）。',
                            minixunbie: '殉别',
                            minixunbie_info: '限定技。当你进入濒死状态时，你可以将此武将牌替换为“甘夫人”或“糜夫人”（不能选择已在场上的武将）。然后回复至1点体力并防止所有伤害直到本回合结束。',
                            //吴
                            Mbaby_bulianshi: '欢杀步练师',
                            Mbaby_chengpu: '欢杀程普',
                            Mbaby_daqiao: '欢杀大乔',
                            Mbaby_ganning: '欢杀甘宁',
                            Mbaby_huanggai: '欢杀黄盖',
                            Mbaby_lusu: '欢杀鲁肃',
                            Mbaby_luxun: '欢杀陆逊',
                            Mbaby_lvmeng: '欢杀吕蒙',
                            Mbaby_sunce: '欢杀孙策',
                            Mbaby_sunluban: '欢杀孙鲁班',
                            Mbaby_sunluyu: '欢杀孙鲁育',
                            Mbaby_sunquan: '欢杀孙权',
                            Mbaby_sunshangxiang: '欢杀孙尚香',
                            Mbaby_taishici: '欢杀太史慈',
                            Mbaby_wuguotai: '欢杀吴国太',
                            Mbaby_xiaoqiao: '欢杀小乔',
                            Mbaby_xusheng: '欢杀徐盛',
                            Mbaby_zhoutai: '欢杀周泰',
                            Mbaby_zhouyu: '欢杀周瑜',
                            Mbaby_zhugejin: '欢杀诸葛瑾',
                            Mbaby_zumao: '欢杀祖茂',
                            Mbabysp_xiaoqiao: 'SP欢杀小乔',
                            Mbaby_zhuzhi: '欢杀朱治',
                            Mbaby_ol_sunjian: '欢杀孙坚',
                            Mbaby_sunliang: '欢杀孙亮',
                            Mbaby_zhangzhang: '欢杀张昭张紘',
                            Mbaby_zhoufei: '欢杀周妃',
                            Mbaby_zhugeke: '欢杀诸葛恪',
                            Mbaby_xushi: '欢杀徐氏',
                            Mbaby_buzhi: '欢杀步骘',
                            Mbaby_lukang: '欢杀陆抗',
                            Mbabysp_daqiao: 'SP欢杀大乔',
                            Mbaby_sunhao: '欢杀孙皓',
                            Mbaby_re_jsp_pangtong: 'SP欢杀庞统',
                            Mbaby_luyusheng: '欢杀陆郁生',
                            Mbaby_zhuhuan: '欢杀朱桓',
                            Mbaby_yanjun: '欢杀严畯',
                            Mbaby_re_sunyi: '欢杀孙翊',
                            Mbaby_zhangxuan: '欢杀张嫙',
                            Mbaby_zhoufang: '欢杀周鲂',
                            Mbaby_luji: '欢杀陆绩',
                            Mbaby_sundeng: '欢杀孙登',
                            Mbaby_panjun: '欢杀潘濬',
                            Mbaby_dingfeng: '欢杀丁奉',
                            Mbaby_xuezong: '欢杀薛综',
                            Mbaby_sb_huanggai: '欢杀谋黄盖',
                            Mbaby_zhangfen: '欢杀张奋',
                            Mbaby_sunxiu: '欢杀孙休',
                            Mbaby_dc_sunru: '欢杀孙茹',
                            Mbaby_yufan: '欢杀虞翻',
                            Mbaby_quancong: '欢杀全琮',
                            Mbaby_re_guyong: '欢杀顾雍',
                            Mbaby_sb_lvmeng: '欢杀谋吕蒙',
                            Mbaby_quanhuijie: '欢杀全惠解',
                            Mbaby_jiangqing: '欢杀蒋钦',
                            Mbaby_lvdai: '欢杀吕岱',
                            Mbaby_heqi: '欢杀贺齐',
                            Mbaby_sunhanhua: '欢杀孙寒华',
                            Mbaby_zhangwen: '欢杀张温',
                            Mbaby_weiwenzhugezhi: '欢杀卫温诸葛直',
                            Mbaby_panzhangmazhong: '欢杀潘璋马忠',
                            Mbaby_kanze: '欢杀阚泽',
                            Mbaby_sb_ganning: '欢杀谋甘宁',
                            Mbaby_chendong: '欢杀陈武董袭',
                            minizhiheng: '制衡',
                            minizhiheng_info: '出牌阶段结束时，你可以弃置任意张手牌并将手牌数补至四张。',
                            minirezhiheng: '制衡',
                            minirezhiheng_info: '出牌阶段限一次，你可以弃置任意张牌并摸等量张牌。若你以此法弃置了全部手牌，则你额外摸一张牌。若本阶段你第一次发动〖制衡〗获得的牌未包含延时锦囊牌，则本阶段你可以额外发动一次〖制衡〗。若本阶段你第二次发动〖制衡〗获得的牌均为基本牌，则本阶段你可以额外发动一次〖制衡〗。',
                            minijiuyuan: '救援',
                            minijiuyuan_info: '主公技。①其他吴势力角色对你使用的【桃】的回复值+1。②其他吴势力角色于其回合内回复体力时，可以改为令你回复1点体力，然后其摸一张牌。',
                            miniqixi: '奇袭',
                            miniqixi_info: '你可以将一张黑色牌当作【过河拆桥】使用。出牌阶段开始时，你可以弃置一名角色区域里的一张牌。',
                            minifenwei: '奋威',
                            minifenwei_info: '限定技，当一名角色使用的锦囊牌指定了至少两名角色为目标时，你可以令此牌对其中任意名角色无效，然后你摸一张牌。当你失去最后的手牌后，你重置〖奋威〗。',
                            miniwanrong: '国色',
                            miniwanrong_info: '当你失去方片牌时，摸一张牌。',
                            miniguose: '婉容',
                            miniguose_info: '出牌阶段限一次，你可以将一张方片花色牌当作【乐不思蜀】使用，或弃置一张方片花色牌并弃置场上的一张【乐不思蜀】。',
                            minizhaxiang: '诈降',
                            minizhaxiang_info: '锁定技，你使用红色【杀】无距离限制且不能被闪避，你使用【杀】的次数上限+1.',
                            minifanjian: '反间',
                            minifanjian_info: '出牌阶段开始时，你可以令一名其他角色摸一张牌，然后你对其造成1点伤害。',
                            minireyingzi: '英姿',
                            minireyingzi_info: '锁定技，摸牌阶段，你额外摸X张牌；你的手牌上限+X。（X为以下条件中你满足的项数：手牌数不小于2、体力值不小于2、装备区里的牌数不小于1）',
                            minirefanjian: '反间',
                            minirefanjian_info: '出牌阶段限一次，你可以声明一个手牌中有的花色并选择一名其他角色，其选择一个花色，若你与其选择的花色：相同，你令其摸一张牌并对其造成1点伤害；不相同，你对一名角色造成1点伤害。',
                            miniqianxun: '谦逊',
                            miniqianxun_info: '锁定技，当你成为锦囊牌的唯一目标时，你摸一张牌，然后可以交给一名其他角色一张手牌。',
                            minireqianxun: '谦逊',
                            minireqianxun2: '谦逊',
                            minireqianxun_info: '当一张锦囊牌对你生效时，你可以将至多X张手牌置于武将牌上（X为你的体力值）。回合结束时，你获得这些牌。',
                            minilianying: '连营',
                            minilianying_info: '当你失去最后的手牌时，你可以摸两张牌，然后可以交给一名其他角色一张手牌。',
                            minitianyi: '天义',
                            minitianyi_info: '出牌阶段开始时，你可以选择一项：①本回合使用【杀】的次数上限+1，且使用【杀】造成伤害后回复1点体力；②摸一张牌，本回合使用【杀】无距离限制且无视目标角色的防具。',
                            miniretianyi: '天义',
                            miniretianyi_info: '①出牌阶段开始时，你可以选择两项：①本回合使用【杀】的次数上限+1；②本回合使用【杀】造成伤害后回复1点体力；③摸一张牌；④本回合使用【杀】无距离限制且无视目标角色的防具。②当你使用【杀】指定目标时，你可以与目标角色拼点，若你赢，你可以为此【杀】额外指定一个目标。',
                            minihanzhan: '酣战',
                            minihanzhan_info: '①当你发起拼点时，或成为拼点的目标时，你可以令对方选择拼点牌的方式改为随机选择一张手牌。②当你拼点结束后，你可以获得其中的【杀】。',
                            minihaoshi: '好施',
                            minihaoshi_info: '摸牌阶段，你可以多摸两张牌，然后若你的手牌数大于5，你须弃置X张手牌或将X张手牌交给一名手牌数最少的其他角色（X为你手牌数的一半，向下取整）。',
                            miniolhaoshi: '好施',
                            miniolhaoshi_info: '①摸牌阶段开始时，你多摸两张牌。②摸牌阶段结束时，若你的手牌数大于5，则你可以将一半手牌（向下取整）交给一名其他角色并获得如下效果直到你下回合开始：当你成为【杀】或普通锦囊牌的目标后，其可以交给你一张手牌。',
                            minidimeng: '缔盟',
                            minidimeng_info: '①出牌阶段限一次，若你没有“盟”标记，你可令两名角色交换手牌并获得X枚“盟”标记（X为这两名角色手牌数之差的绝对值）。②摸牌阶段结束时或回合结束时，你可以弃置任意张牌并移去等量的“盟”标记。',
                            miniganlu: '甘露',
                            miniganlu_info: '锁定技，出牌阶段开始时，你选择一项：①移动场上的一张装备牌；②交换场上装备区中的两张副类别相同的装备牌的位置；③摸一张牌。',
                            minibuyi: '补益',
                            minibuyi_info: '每回合限三次，一名角色进入濒死状态时，你可以展示其一张手牌，若此牌为基本牌，该角色弃置此牌并回复1点体力。',
                            minipojun: '破军',
                            minipojun2: '破军',
                            minipojun_info: '当你使用【杀】指定目标时，你可以将其至多X张牌移出游戏直至回合结束（X为其体力值），然后若其中有：装备牌，你弃置其中的一张；【闪】，你摸一张牌。',
                            minirepojun: '破军',
                            minirepojun_info: '①当你使用【杀】指定目标后，你可以将其至多X张牌移出游戏直至回合结束（X为其体力值），然后若其中有：装备牌，你弃置其中的一张；【闪】，你摸一张牌。②你使用【杀】对手牌数和装备区牌数均不大于你的角色造成的伤害+1。',
                            minirepojunx: '破军',
                            minirepojunx_info: '当你使用【杀】指定目标或成为【杀】的目标后，你可以将对方的至多X张牌置于其武将牌上（X为你的体力上限），然后其于当前回合结束时获得这些牌。',
                            miniyicheng: '疑城',
                            miniyicheng_info: '锁定技，一名角色的武将牌的牌数变化后，若其武将牌上的类别数：为1，其本回合非锁定技失效且不能使用或打出手牌；为2，其本回合受到的伤害+1；为3，你摸三张牌。',
                            minianxu: '安恤',
                            minianxu_info: '出牌阶段开始和结束时，你可以获得一名手牌数最多的其他角色的一张手牌，然后若此牌的花色为黑桃，该角色摸一张牌。',
                            minilihuo: '疠火',
                            minilihuo_info: '当你声明使用普通【杀】时，你可以将此【杀】改为火【杀】。若以此法使用的【杀】造成的伤害大于1，则此【杀】结算后你失去1点体力；你使用火【杀】选择目标后，可以额外指定一个目标。当你于回合内第一次因火【杀】造成伤害后，你摸一张牌。',
                            minichunlao: '醇醪',
                            minichunlao2: '醇醪',
                            minichunlao_info: '结束阶段，若你没有“醇”，你可以将至少一张【杀】置于你的武将牌上，称为“醇”。当一名角色处于濒死状态时，你可以移去一张“醇”，视为该角色使用一张【酒】，然后若此“醇”的颜色为：红色，你回复1点体力；黑色，你摸两张牌。',
                            minizenhui: '谮毁',
                            minizenhui_info: '出牌阶段限一次，当你使用【杀】或普通锦囊牌指定唯一目标时，你可以令其选择一项：①交给你一张牌；②失去1点体力。',
                            minijiaojin: '骄矜',
                            minijiaojin_info: '当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以弃置一张手牌并令此牌对你无效。',
                            minihongyuan: '弘援',
                            minihongyuan_info: '摸牌阶段，你可以令至多两名角色各摸一张牌。',
                            minixingwu: '星舞',
                            minixingwu_info: '出牌阶段限一次，你可以翻面并弃置一张手牌，然后弃置一名角色装备区里的一张牌并对其造成2点伤害（若该角色为女性角色则改为1点）。',
                            miniluoyan: '落雁',
                            miniluoyan_info: '锁定技，当你发动〖星舞〗后，你获得〖天香〗和〖红颜〗直至你的下个出牌阶段开始。',
                            minihuimou: '回眸',
                            minihuimou_info: '当你于回合外使用或打出红桃牌时，或发动〖天香〗弃置红桃牌后，你可以令一名背面朝上的角色翻至正面。',
                            miniyinbing: '引兵',
                            miniyinbing_info: '弃牌阶段开始前，你可以将至少一张非基本牌称作「引兵」牌置于武将牌上。每当你受到【杀】的伤害后，你移去一张「引兵」牌并摸一张牌。',
                            minijuedi: '绝地',
                            minijuedi_info: '锁定技，准备阶段，若你的武将牌上有「引兵」牌，你选择一项：1.移去「引兵」牌，将手牌补至体力上限+1；2.将「引兵」牌交给一名体力值不大于你的其他角色，其回复1点体力并摸等量的牌。',
                            minimeibu: '魅步',
                            minimeibu_info: '其他角色的出牌阶段开始时，你可以弃置一张牌，令该角色于本阶段内拥有〖止息〗，且你获得其因〖止息〗弃置的牌。',
                            minijieyin: '结姻',
                            minijieyin_info: '出牌阶段限一次，你可以选择一名其他角色，交给其一张手牌或将装备区内的一张装备牌置于其装备区，然后你回复1点体力并摸一张牌。若其体力值小于你，你可以令其回复1点体力；若其体力值大于等于你，你可以令其摸一张牌。',
                            minibuqu: '不屈',
                            minibuqu_info: '锁定技。①当你处于濒死状态时，若你的“创”标记数小于4，则你获得1枚“创”并将体力值回复至1点。②你的手牌上限+X（X为你的“创”标记数）。',
                            minirebuqu: '不屈',
                            minirebuqu_info: '锁定技。①当你受到伤害或失去体力时，若你的“创”标记数小于4，则你获得1枚“创”并取消之。②你的手牌上限+X（X为你的“创”标记数）。',
                            miniqingchuang: '清创',
                            miniqingchuang_info: '出牌阶段限一次，你可以弃置一张【桃】或【酒】，然后移去1枚“创”并摸一张牌。',
                            minijiang: '激昂',
                            minijiang_info: '当你使用【杀】或【决斗】时指定目标后，或成为其他角色使用【杀】或【决斗】时指定目标后，你可以摸一张牌。',
                            minihunzi: '魂姿',
                            minihunzi_info: '觉醒技，游戏开始时或当你的体力值发生变化时，若你的体力值为1，你减1点体力上限，然后获得技能〖英姿〗和〖英魂〗。',
                            minihunzi_old: '魂姿',
                            minihunzi_old_info: '觉醒技，准备阶段，若你的体力值为1，你减1点体力上限，然后获得技能〖英姿〗和〖英魂〗。',
                            minizhiba: '制霸',
                            minizhiba2: '制霸',
                            minizhiba_info: '主公技，其他吴势力角色的出牌阶段限一次，其可以交给你一张【杀】或【决斗】。',
                            minikeji: '克己',
                            minikeji_info: '弃牌阶段开始时，若你于本回合的出牌阶段内没有过使用或打出过【杀】，则你可以跳过此阶段并摸一张牌。',
                            miniqinxue: '勤学',
                            miniqinxue_info: '觉醒技，结束阶段，若你的手牌数不小于你的体力值的三倍，则你调整体力上限与体力值一致，失去技能〖克己〗并获得技能〖攻心〗。',
                            minisbduojing: '夺荆',
                            minisbduojing_info: '出牌阶段限两次，你可以与一名其他角色谋弈。若你赢，且你选择的选项为：“休养生息”，获得其一张牌，回复1点体力，然后若X大于0，你摸X张牌并弃置等量的牌（X为你已损失的体力值）；“白衣渡江”，视为对其使用一张不计次数且无视距离和防具的【杀】，且本回合可额外使用一张【杀】，且本回合无视〖克己〗发动条件。',
                            minitianxiang: '天香',
                            minitianxiang2: '天香',
                            minitianxiang_info: '当你即将受到伤害时，你可以弃置一张红桃手牌并将伤害转移给一名其他角色，然后你选择一项：①令其摸一张牌：②令其摸X张牌（X为其损失的体力值）。',
                            minianguo: '安国',
                            minianguo_info: '出牌阶段限一次，你可以选择一名角色，若其手牌数为全场最少，其摸一张牌；体力值为全场最低，回复1点体力；装备区内牌数为全场最少，随机使用一张装备牌。然后若该角色有未执行的效果且你满足条件，你执行之。',
                            miniyinghun: '英魂',
                            miniyinghun_info: '准备阶段开始时，你可令一名其他角色执行一项：1.摸X张牌；2.摸一张牌，然后弃置X张牌（X为你已损失的体力值）。',
                            miniwulie: '武烈',
                            miniwulie_info: '限定技，回合开始时，你可以失去任意点体力并获得Y枚「烈」，然后你可以指定至多Y名其他角色，令这些角色各获得1枚「烈」（Y为你以此法失去的体力值）。有「烈」的角色受到伤害时，其可以移去1枚「烈」，然后防止此伤害。',
                            miniwulie2: '武烈',
                            miniwulie2_info: '移去1枚「烈」，然后防止此伤害',
                            minikuizhu: '溃诛',
                            minikuizhu_info: '弃牌阶段结束后，你可以选择一项：①令至多X名角色各摸一张牌。②对任意名体力值之和不大于X的角色各造成1点伤害。（X为你此阶段弃置的牌数）',
                            minichezheng: '掣政',
                            minichezheng_info: '锁定技，你的出牌阶段内，攻击范围内不包含你的其他角色不能成为你使用【杀】的目标。出牌阶段结束时，你摸X张牌（X为攻击范围内不包含你的其他角色数且X至少为2）。',
                            minilijun: '立军',
                            minilijun_info: '主公技，每个出牌阶段限一次，其他吴势力角色使用【杀】结算后，你摸一张牌，然后你可以令其摸一张牌。',
                            miniguzheng: '固政',
                            miniguzheng_info: '其他角色的弃牌阶段结束时，你可以令其获得本阶段内进入弃牌堆的牌中的一张，然后你获得剩余的牌（若没有剩余的牌则改为摸一张牌）。',
                            miniliangyin: '良姻',
                            miniliangyin_info: '当有牌移至游戏外时，你可以令一名角色摸一张牌；当有牌从游戏外加入任意角色的手牌时，你可以令一名角色弃置一张牌。',
                            miniaocai: '傲才',
                            miniaocai_info: '当你于回合外需要使用或打出一张基本牌时，你可以观看牌堆顶的三张牌（若你没有手牌则改为四张）。若你观看的牌中有此牌，你可以使用打出之。',
                            miniduwu: '黩武',
                            miniduwu_info: '出牌阶段，你可以弃置X张牌对你攻击范围内的一名其他角色造成1点伤害（X为该角色的体力值）。若该角色因此法进入濒死状态且存活，则你于濒死状态结算后摸一张牌，且本回合不能再发动〖黩武〗。',
                            miniwengua: '问卦',
                            miniwengua2: '问卦',
                            miniwengua_info: '{其他角色}/{你}的出牌阶段限一次，{其可以交给你一张牌并展示}/{你可以展示一张牌}，若此牌为锦囊牌，则你加1点体力上限（体力上限至多加至5点）并回复1点体力，你可以将此牌置于牌堆顶或牌堆底，然后{你与其}/{你}从另一端摸一张牌。',
                            minifuzhu: '伏诛',
                            minifuzhu_info: '其他角色的结束阶段，若牌堆剩余牌数不大于你体力上限的十倍，则你可以依次对其使用牌堆中所有的【杀】（不能超过游戏人数），然后洗牌。',
                            minihongde: '弘德',
                            minihongde_info: '当你一次性获得至少两张牌后，你可以令一名其他角色摸一张牌。每回合限两次，当你失去牌后，你可以摸一张牌。',
                            minidingpan: '定叛',
                            minidingpan_info: '出牌阶段限X次，你可以令一名装备区里有牌的角色摸一张牌，然后其选择一项：1.令你弃置其装备区里的一张牌；2.获得其装备区里的所有牌，若如此做，你对其造成1点伤害。（X为场上的存活势力数）',
                            minijueyan: '决堰',
                            minijueyan_info: '出牌阶段限一次，你可以废除一个装备栏，然后根据选择执行对应的效果：①武器栏，本回合内你可以多使用三张【杀】；②防具栏，摸三张牌，本回合手牌上限+3；③2个坐骑栏，回复1点体力，本回合获得技能〖集智〗，且本回合你使用的牌无距离限制。',
                            minihuairou: '怀柔',
                            minihuairou_info: '出牌阶段，你可以将一张你已废除装备栏对应副类别的装备牌置入弃牌堆，然后选择一个基本牌或锦囊牌的牌名从牌堆中或弃牌堆获得之（每种牌名每回合限一次）。',
                            miniyanxiao: '言笑',
                            miniyanxiao_info: '出牌阶段，你可以将一张方片称为“言笑”牌置于一名角色的判定区内。判定区内有“言笑”牌的角色下个判定阶段开始时，其获得判定区里的所有牌，然后其进行一次判定，若判定结果为：红色，其摸一张牌；黑色，其本回合使用【杀】的次数上限+1。',
                            minianxian: '安娴',
                            minianxian_info: '当你不因〖安娴〗使用【杀】指定目标时，你可以令其弃置一张手牌；当你成为【杀】的目标时，你可以弃置一张手牌，令此【杀】对你无效，然后使用者摸一张牌，若你弃置了方片牌，则你视为对此【杀】的使用者使用一张【杀】。',
                            minicanshi: '残蚀',
                            minicanshi2: '残蚀',
                            minicanshi_info: '摸牌阶段开始时，你可以多摸X张牌（X为已受伤的角色数）。若如此做，当你于此回合内使用【杀】时，你弃置一张牌。',
                            minichouhai: '仇海',
                            minichouhai_info: '锁定技，当你受到【杀】造成的伤害时，若你没有牌，则此伤害+1。',
                            miniguolun: '过论',
                            miniguolun_info: '出牌阶段限一次，你可以展示一名其他角色的手牌，然后你可以选择你的一张牌，你与其交换这两张牌。然后若你展示的牌的点数比其展示的牌的点数小，你摸两张牌；若其展示的牌的点数比你展示的牌的点数小，其摸一张牌，你回复1点体力。',
                            minisongsang: '送丧',
                            minisongsang_info: '锁定技，其他角色死亡后，你增加1点体力上限，然后回复1点体力。',
                            minizhente: '贞特',
                            minizhente_info: '当你成为其他角色使用基本牌或普通锦囊牌的目标后，你可令使用者选择一项：1.本回合不能再使用与此牌颜色相同的牌；2.此牌对你无效。 ',
                            minizhiwei: '至微',
                            minizhiwei2: '至微',
                            minizhiwei_info: '游戏开始时/你的回合开始时，若场上没有因此法被选择过的角色存活，则你选择一名其他角色。该角色造成伤害后，你摸一张牌，该角色受到伤害后，你可以交给其一张手牌。你弃牌阶段弃置的牌可以交给该角色。',
                            minifenli: '奋励',
                            minifenli_info: '若你的手牌数/体力值/装备区的牌数为全场最多，你可以跳过判定和摸牌阶段/出牌阶段/弃牌阶段。',
                            minipingkou: '平寇',
                            minipingkou_info: '回合结束时，你可以对至多X名其他角色各造成1点伤害（X为你本回合跳过的阶段数）。若你选择的角色数小于你本回合跳过的阶段数，则你选择其中一名装备区有牌的目标角色，获得其装备区中的一张牌。',
                            miniguanchao: '观潮',
                            miniguanchao_info: '出牌阶段开始时，你可以选择获得一项效果直到回合结束：1.本回合你使用【杀】的额定次数+1，当你使用牌时，若你本回合使用过的所有牌的点数为严格递增，你摸一张牌；2.本回合你计算与其他角色距离-1，当你使用牌时，若你本回合使用过的所有牌的点数为严格递减，你摸一张牌。',
                            minixunxian: '逊贤',
                            minixunxian_info: '每名角色的回合限一次，当你使用或打出的牌进入弃牌堆后，你可以将这些牌交给一名其他角色。',
                            minisyxiongyi: '凶疑',
                            minisyxiongyi_info: '限定技。当你处于濒死状态时，若剩余武将牌堆中：有“欢杀徐氏”，则你可以将体力值回复至3点，并将此武将牌替换为“欢杀徐氏”；没有“欢杀徐氏”，则你可以将体力值回复至1点并获得〖魂姿〗。',
                            minishezang: '奢葬',
                            minishezang_info: '每回合限一次。当你或你回合内的其他角色进入濒死状态时，你可以从牌堆中获得每种花色的牌各一张。',
                            miniyoudi: '诱敌',
                            miniyoudi_info: '结束阶段，你可以令一名其他角色弃置你一张手牌。若弃置的牌：不是【杀】，则你获得其一张牌并摸一张牌；不是黑色牌且你的体力上限小于5，则你增加1点体力上限。',
                            minizhenglun: '整论',
                            minizhenglun_info: '摸牌阶段，若你没有“橘”，你可以少摸一张牌并获得一个“橘”。',
                            minikuangbi: '匡弼',
                            minikuangbi_info: '①出牌阶段限一次，你可以令一名其他角色将至多三张牌置于你的武将牌上，然后你可以令其摸等量张牌。②回合开始时，你获得武将牌上所有的“匡弼”牌。③当你失去手牌中最后一张因〖匡弼②〗获得的牌时，你摸一张牌并回复1点体力。',
                            miniguanwei: '观微',
                            miniguanwei_info: '每回合限一次，一名角色的出牌阶段结束时，若其本阶段使用过重复花色的牌，则你可以弃置一张牌，令该角色摸两张牌并进行一个额外的出牌阶段。',
                            minigongqing: '公清',
                            minigongqing_info: '锁定技，当你受到伤害时，若伤害来源的攻击范围：小于3，此伤害减至1点；大于等于3，你摸一张牌。',
                            miniduanbing: '短兵',
                            miniduanbing_info: '①你使用【杀】可以额外选择一名距离为1的角色为目标。②当你于一回合首次使用【杀】指定与你距离不小于1的角色后，你令其需额外使用一张【闪】响应此【杀】。',
                            minifenxun: '奋迅',
                            minifenxun_info: '①出牌阶段限一次，你可以选择一名其他角色，本回合你计算与其的距离视为1。②回合结束时，你摸X张牌（X为本回合距离你1以内的角色受到过伤害数之和）。',
                            minifunan: '复难',
                            minifunan_info: '其他角色使用或打出牌响应你使用的牌时，你可获得其使用或打出的牌。',
                            minijiexun: '诫训',
                            minijiexun_info: '结束阶段，你可以选择一种花色，然后令一名角色摸等同于场上此花色牌数张牌，然后其弃置X张牌（X为此前〖诫训〗的发动次数）。若其因此法弃置了所有牌，则清空〖诫训〗的发动次数。',
                            minisbkurou: '苦肉',
                            minisbkurou_info: '出牌阶段，你可以失去1点体力，然后你的手牌上限和体力上限+1直到你的下个回合开始，然后当你回复体力后，你重置此技能。',
                            minisbzhaxiang: '诈降',
                            minisbzhaxiang_info: '锁定技。①当你失去1点体力后，你摸三张牌。②回合结束时，你摸X张牌。③你于每回合使用的前X张【杀】无距离限制、不计入次数限制且不可被响应。（X为你已损失体力值的一半，向上取整）',
                            miniwanglu: '望橹',
                            miniwanglu_info: '锁定技。准备阶段，若你的装备区内：有【大攻车】，则你获得一个额外的出牌阶段；没有【大攻车】，则你将一张【大攻车】置入装备区。',
                            miniwanglu_faq: '关于大攻车',
                            miniwanglu_faq_info: '<br><li>花色：♠<br><li>点数：9<br><li>类别：武器<br><li>攻击范围：2<br><li>装备效果：出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。',
                            minixianzhu: '陷筑',
                            minixianzhu_info: '①出牌阶段限一次，你可以弃置一张手牌中的武器牌，然后视为对一名角色使用一张无距离且不计入次数的【杀】。②当你使用【杀】造成伤害后，你可以强化你装备区内的【大攻车】（每张【大攻车】最多被强化五次）。',
                            minixianzhu_faq: '关于强化大攻车',
                            minixianzhu_faq_info: '<br>从以下选项中任选一项：<br><li>⒈通过【大攻车】使用【杀】无视距离和防具；<br><li>⒉通过【大攻车】使用的【杀】可以额外选择1个目标（可叠加）；<br><li>⒊通过【大攻车】使用的【杀】造成伤害后的弃置牌数+1（可叠加）。',
                            minichaixie: '拆械',
                            minichaixie_info: '锁定技。当你的【大攻车】被销毁后，你摸X张牌（X为此【大攻车】被强化过的次数）。',
                            minidagongche: '大攻车',
                            minidagongche_skill: '大攻车',
                            minidagongche_info: '出牌阶段开始时，你可以视为使用一张【杀】，且当此【杀】对目标角色造成伤害后，你弃置其一张牌。若此【大攻车】未被强化，则其他角色无法弃置你装备区内的【大攻车】。当此牌离开你的装备区后，销毁之。',
                            miniyanzhu: '宴诛',
                            miniyanzhu_info: '出牌阶段限一次，你可以令一名其他角色选择一项：弃置一张牌并令下一次受到的伤害+1直到其下回合开始，或将装备区里的所有牌交给你并令你发动〖宴诛〗无法选择此项。',
                            minixingxue: '兴学',
                            minixingxue_info: '结束阶段开始时，你可以令至多X名角色依次摸一张牌并将一张牌置于牌堆顶或交给一名其他目标角色（X为你的体力上限）。',
                            minizhaofu: '诏缚',
                            minizhaofu_info: '主公技，出牌阶段限一次，你可选择至多两名其他角色，这些角色本轮视为在所有吴势力角色的攻击范围内。',
                            minixiecui: '撷翠',
                            minixiecui_info: '一名角色于其回合内第一次使用牌造成伤害时，你可以令此伤害+1。然后若其手牌数大于其体力值，则该角色获得伤害牌且其本回合的手牌上限+1。',
                            minizongxuan: '纵玄',
                            minizongxuan_info: '当你的牌因弃置而进入弃牌堆后，你可以令一名其他角色获得其中的一张，然后你摸一张牌。然后你可将其中的任意张剩余牌置于牌堆顶。',
                            minizhiyan: '直言',
                            minizhiyan_info: '结束阶段开始时，你可令一名角色正面朝上摸一张牌。若此牌不为装备牌，则你摸一张牌。若此牌为装备牌，则其使用此装备牌，然后回复1点体力。',
                            miniyaoming: '邀名',
                            miniyaoming_info: '①每回合每项限两次。当你造成或受到伤害时，你可以：⒈令一名角色摸一张牌；⒉弃置一名其他角色的一张手牌；⒊令一名角色摸两张牌，然后弃置两张牌。②回合结束时，若你本回合未发动过〖邀名①〗，则你可以发动〖邀名①〗。',
                            minishenxing: '慎行',
                            minishenxing_info: '出牌阶段限20次，你可以摸一张牌，然后弃置X张牌（X为你本阶段此前发动此技能的次数，且X至多为2）。然后若你没有可弃置的牌，则本阶段此技能失效。',
                            miniligong: '离宫',
                            miniligong_info: '觉醒技，准备阶段，若〖慧淑〗的中括号内有不小于5的数字，则你加1点体力上限，回复1点体力并失去〖易数〗。系统随机检索四张存在于欢杀将池中的吴势力女性武将牌，然后你选择一项：⒈摸三张牌。⒉失去〖慧淑〗，然后获得这些武将牌上的任意两个技能。',
                            minijianyi: '俭衣',
                            minijianyi_info: '锁定技，其他角色的回合结束时，若弃牌堆中有于本回合内因弃置而进入弃牌堆的武器牌或防具牌，则你获得其中一张。',
                            minishangyi: '尚义',
                            minishangyi_info: '出牌阶段限一次，你可以弃置一张牌并选择一名有手牌的其他角色，你令其观看你的手牌，然后你观看其手牌并选择一项：1.获得其中一张牌；2.与其交换一张手牌。若你以此法获得了其的黑色牌，或你与其交换的两张牌均为红色，你摸一张牌。',
                            miniqinguo: '勤国',
                            miniqinguo_info: '①当你使用的装备牌结算完毕时，你可以视为使用一张【杀】，若此【杀】造成伤害，则你摸一张牌。②当你因使用或失去装备牌导致装备区内牌的数量发生变化后，若你装备区内牌的数量大于等于你的体力值，则你可以回复1点体力。',
                            miniqizhou: '绮冑',
                            miniqizhou_info: '锁定技。若你的装备区的花色数：≥1，〖英姿〗；≥2，〖奇袭〗；≥3，〖旋风〗；≥4：〖短兵〗。',
                            minishanxi: '闪袭',
                            minishanxi_info: '出牌阶段限一次。你可以选择一名攻击范围内不包含你的其他角色，展示你与其的至多X张手牌（X为你的空装备栏数+1）。若这些牌中有【闪】，则你弃置这些【闪】，然后获得对方的一张未展示的牌。',
                            minihuiling: '汇灵',
                            minihuiling_info: '锁定技。当你使用牌时或因弃置而失去牌后，若此牌颜色为弃牌堆中数量较少的颜色，你获得1枚“灵”标记。若弃牌堆中：红色牌数大于黑色牌数，你回复1点体力；黑色牌数大于红色牌数，你可以弃置一名其他角色区域内的一张牌。',
                            minichongxu: '冲虚',
                            minichongxu_info: '限定技。出牌阶段，若“灵”数不小于4，你可以失去〖汇灵〗，增加等同于“灵”数的体力上限（至多增加场上人数的体力上限），然后获得〖踏寂〗和〖清荒〗。',
                            minisongshu: '颂蜀',
                            minisongshu_info: '出牌阶段限一次，你可以和其他角色拼点。若你没赢，你可以与其各摸两张牌；否则此技能视为未发动过。',
                            minisibian: '思辩',
                            minisibian_info: '摸牌阶段，你可以放弃摸牌，改为亮出牌堆顶的四张牌，然后获得其中所有点数最大与点数最小的牌，且可以将剩余的牌交给手牌数最少或最多的角色。',
                            minifuhai: '浮海',
                            minifuhai_info: '出牌阶段限一次。你可以令所有有手牌的其他角色同时展示一张手牌，然后你选择一个方向并摸X张牌（X为该方向上的角色展示的点数连续严格递增或严格递减的牌数，至少为2）。',
                            miniduodao: '夺刀',
                            miniduodao_info: '当你成为【杀】的目标后，你可以弃置一张牌。然后你获得此【杀】使用者装备区里的武器牌（若此【杀】为红色，则改为你获得其区域内一张牌）。',
                            minianjian: '暗箭',
                            minianjian_info: '锁定技，当你使用【杀】指定目标后，若你不在其攻击范围内，则此【杀】无视防具且你选择一项：1. 令其无法响应此【杀】；2. 其受到此【杀】造成的伤害+1。若其因执行此【杀】的效果受到伤害而进入濒死状态，则其不能使用【桃】直到此濒死事件结算结束。',
                            minikuanshi: '宽释',
                            minikuanshi_info: '结束阶段，你可以选择一名角色。直到你的下回合开始，该角色每受到两次伤害后，其回复1点体力。',
                            minisbfenwei: '奋威',
                            minisbfenwei_info: '①出牌阶段限一次，你可以将至多三张牌称为“威”分别置于等量名角色的武将牌上，然后你摸等量牌。②当一名有“威”的角色成为锦囊牌的目标时，你须选择一项：1.令其获得其“威”；2.令其移去“威”，并取消此目标；3.令其移去“威”，其不可响应此牌；4.令其移去“威”，你摸一张牌。',
                            miniduanxie: '断绁',
                            miniduanxie_info: '出牌阶段限一次，你可以令一名其他角色横置（若场上无处于横置状态的角色则改为至多两名），然后你横置。',
                            minifenming: '奋命',
                            minifenming_info: '结束阶段，你可以弃置所有处于横置状态的角色的各一张牌，然后你摸等量张牌。',
                            //群
                            Mbaby_zuoci: '欢杀左慈',
                            Mbaby_gaoshun: '欢杀高顺',
                            Mbaby_caifuren: '欢杀蔡夫人',
                            Mbaby_lijue: '欢杀李傕',
                            Mbaby_xuyou: '欢杀许攸',
                            Mbaby_gongsunzan: '欢杀公孙瓒',
                            Mbaby_pangde: '欢杀庞德',
                            Mbaby_jushou: '欢杀沮授',
                            Mbaby_liru: '欢杀李儒',
                            Mbaby_dongzhuo: '欢杀董卓',
                            Mbaby_zhangjiao: '欢杀张角',
                            Mbaby_huatuo: '欢杀华佗',
                            Mbaby_lvbu: '欢杀吕布',
                            Mbaby_sp_diaochan: 'SP欢杀貂蝉',
                            Mbaby_diaochan: '欢杀貂蝉',
                            Mbaby_huaxiong: '欢杀华雄',
                            Mbaby_yuji: '欢杀于吉',
                            Mbaby_zhangliang: '欢杀张梁',
                            Mbaby_zhangbao: '欢杀张宝',
                            Mbaby_yanwen: '欢杀颜良文丑',
                            Mbaby_caiwenji: '欢杀蔡琰',
                            Mbaby_liubiao: '欢杀刘表',
                            Mbaby_yuanshao: '欢杀袁绍',
                            Mbaby_yuanshu: '欢杀袁术',
                            Mbaby_chengong: '欢杀陈宫',
                            Mbaby_jiaxu: '欢杀贾诩',
                            Mbaby_liuzhang: '欢杀刘璋',
                            Mbaby_panfeng: '欢杀潘凤',
                            Mbaby_sp_machao: 'SP欢杀马超',
                            Mbaby_jsp_huangyueying: '欢杀黄月英',
                            Mbaby_quyi: '欢杀麴义',
                            Mbaby_liuxie: '欢杀刘协',
                            Mbaby_fuhuanghou: '欢杀伏寿',
                            Mbaby_zhangqiying: '欢杀张琪瑛',
                            Mbaby_chunyuqiong: '欢杀淳于琼',
                            Mbaby_beimihu: '欢杀卑弥呼',
                            Mbaby_dongbai: '欢杀董白',
                            Mbaby_zhangji: '欢杀张济',
                            Mbaby_sp_taishici: 'SP欢杀太史慈',
                            Mbaby_xushao: '欢杀许劭',
                            Mbaby_hetaihou: '欢杀何太后',
                            Mbaby_wangrong: '欢杀王荣',
                            Mbaby_sp_menghuo: 'SP欢杀孟获',
                            Mbaby_caoxing: '欢杀曹性',
                            Mbabysp_zhenji: 'SP欢杀甄宓',
                            Mbaby_liangxing: '欢杀梁兴',
                            Mbaby_caojie: '欢杀曹节',
                            Mbaby_tangji: '欢杀唐姬',
                            Mbaby_libai: '欢杀李白',
                            Mbaby_guotufengji: '欢杀郭图逢纪',
                            Mbaby_re_nanhualaoxian: '欢杀南华老仙',
                            Mbaby_yanfuren: '欢杀严夫人',
                            Mbaby_gongsunyuan: '欢杀公孙渊',
                            Mbaby_sp_zhangliao: 'SP欢杀张辽',
                            Mbaby_sp_ol_zhanghe: 'SP欢杀张郃',
                            Mbaby_zhujun: '欢杀朱儁',
                            Mbaby_sp_kongrong: '欢杀孔融',
                            Mbaby_laiyinger: '欢杀来莺儿',
                            Mbaby_sb_yuanshao: '欢杀谋袁绍',
                            Mbaby_tw_mateng: '欢杀马腾',
                            Mbaby_dc_huangchengyan: '欢杀黄承彦',
                            Mbaby_simahui: '欢杀司马徽',
                            Mbaby_zoushi: '欢杀邹氏',
                            Mbaby_wangyun: '欢杀王允',
                            Mbaby_xiaoshan: '欢杀小闪',
                            Mbaby_zhanglu: '欢杀张鲁',
                            Mbaby_zhangning: '欢杀张宁',
                            Mbaby_ol_dingyuan: '欢杀丁原',
                            Mbaby_liubian: '欢杀刘辩',
                            Mbaby_re_pangdegong: '欢杀庞德公',
                            Mbaby_licaiwei: '欢杀李采薇',
                            Mbaby_dc_huangzu: '欢杀黄祖',
                            Mbaby_yanbaihu: '欢杀严虎',
                            Mbaby_guosi: '欢杀郭汜',
                            Mbaby_fanchou: '欢杀樊稠',
                            Mbaby_huangfusong: '欢杀皇甫嵩',
                            Mbaby_wutugu: '欢杀兀突骨',
                            Mbaby_fuwan: '欢杀伏完',
                            Mbaby_dongxie: '欢杀董翓',
                            Mbaby_guanning: '欢杀管宁',
                            Mbaby_re_hansui: '欢杀韩遂',
                            Mbaby_tadun: '欢杀蹋顿',
                            Mbaby_gaolan: '欢杀高览',
                            Mbaby_yl_luzhi: '欢杀卢植',
                            Mbaby_mengjie: '欢杀孟节',
                            Mbaby_caiyong: '欢杀蔡邕',
                            miniweidi: '伪帝',
                            miniweidi_info: '弃牌阶段结束时，你可以将其中一张弃置的牌交给一名其他角色。',
                            minimingce: '明策',
                            minimingce_info: '出牌阶段开始时，你可以令一名其他角色视为对其攻击范围内另一名角色使用一张【杀】。',
                            miniremingce: '明策',
                            miniremingce_info: '出牌阶段开始时，你可以选择一项：1.令一名角色视为对其攻击范围内另一名你指定的角色使用一张【杀】，此【杀】结算后，若此【杀】造成过伤害，你摸两张牌；2.选择一名其他角色，与其各摸一张牌，且其下回合使用【杀】的次数上限+1。',
                            minizhichi: '智迟',
                            minizhichi_info: '锁定技。当你于回合外受到伤害后，直到此回合结束，防止你受到的伤害且所有普通锦囊牌对你无效。',
                            minichenglve: '成略',
                            minichenglve_info: '出牌阶段限一次，你可以摸一张牌，然后弃置一张手牌。若如此做，直到本回合结束，你使用与弃置牌花色相同的牌无距离和次数限制。',
                            miniguhuo: '蛊惑',
                            miniguhuo_info: '锁定技。①你使用【杀】或伤害性锦囊牌结算完毕后，若此牌未造成伤害，你将此牌移出游戏并摸一张牌，然后于当前回合结束获得此牌。②每回合限一次，你使用【杀】或伤害性锦囊牌结算完毕后，若此牌造成伤害，你摸一张牌。',
                            minijijun: '集军',
                            minijijun_info: '锁定技，当你使用【杀】或普通锦囊牌指定唯一目标时，或成为【杀】的目标时，你进行一次判定，若结果为黑色，你将此牌置于武将牌上，称为“兵”。',
                            minifangtong: '方统',
                            minifangtong_info: '结束阶段，你可以选择一项：①弃置一张“兵”，摸一张牌；②弃置两张“兵”，回复1点体力；③弃置三张“兵”，对一名角色造成两点雷属性伤害。',
                            minizhoufu: '咒缚',
                            minizhoufu2: '咒缚',
                            minizhoufu_info: '出牌阶段限一次，你可以用一张牌对一名其他角色施“咒”或移去一名其他角色的“咒”。当有“咒”的角色判定时，将“咒”作为判定牌；一名角色的回合结束时，你令本回合移除过“咒”的角色各失去1点体力。',
                            miniyingbing: '影兵',
                            miniyingbing_info: '锁定技，有“咒”的角色使用与“咒”颜色相同的牌时，你摸一张牌；若这是你第二次因该“咒”摸牌，其移去该“咒”。',
                            miniqieting: '窃听',
                            miniqieting_info: '锁定技，其他角色的结束阶段，若其手牌数大于你，则你摸一张牌。',
                            minireqieting: '窃听',
                            minireqieting_info: '其他角色的回合结束时，若其手牌数大于你，则你摸一张牌，然后若其本回合内未对其他角色造成过伤害，则你可选择一项：①摸一张牌。②观看其两张手牌并获得其中的一张。③将其装备区内的一张牌移动至你的装备区。',
                            minixianzhou: '献州',
                            minixianzhou_info: '限定技，出牌阶段，你可将所有手牌交给一名其他角色，然后其可以对其攻击范围内的至多X名角色各造成1点伤害（X为你以此法给出的牌数）。',
                            minirexianzhou: '献州',
                            minirexianzhou_info: '限定技，出牌阶段，你可将任意张牌交给一名其他角色，然后你回复X点体力并对其攻击范围内的至多X名角色各造成1点伤害（X为你以此法给出的牌数）。',
                            minibiyue: '翩仪',
                            minibiyue_info: '结束阶段，你可以摸一张牌，若你的武将牌已翻面，则改为摸三张牌。',
                            minijianchu: '鞬出',
                            minijianchu_info: '当你使用【杀】指定一名角色为目标后，你可以弃置其一张牌，然后若此牌类型：不为基本牌，你摸一张牌且此【杀】强制命中；为基本牌，你令此【杀】不计入次数限制。',
                            miniyaowu: '耀武',
                            miniyaowu_info: '锁定技，一名角色使用【杀】对你造成伤害时，若此【杀】为红色/黑色，其摸一张牌/你摸一张牌。然后你获得此【杀】对应的所有实体牌。',
                            miniyangwei: '扬威',
                            miniyangwei_info: '当你于出牌阶段使用有颜色的【杀】结算完毕后，你可以于本阶段使用一张与此牌颜色不同的【杀】（无次数限制且不计入次数）。出牌阶段结束后，若你本回合使用【杀】的次数大于2，你回复1点体力。',
                            miniqiaomeng: '趫猛',
                            miniqiaomeng_info: '当你使用【杀】对一名角色造成伤害时，你可以获得该角色区域内的一张牌。若此牌是坐骑牌，此伤害+1。',
                            miniyicong: '义从',
                            miniyicong_info: '锁定技，你计算与其他角色的距离时-X，其他角色计算与你的距离时+Y。（X为你的体力值，Y为你的已损失体力值）',
                            minishendao: '神道',
                            minishendao_info: '你的判定牌生效前，你可以将判定结果改为任意花色。',
                            minixinsheng: '新生',
                            minixinsheng_info: '当你受到伤害后，你可以亮出牌堆顶的三张牌，然后获得其中每种花色的牌各一张。',
                            minixianzhen: '陷阵',
                            minixianzhen_info: '锁定技。你于回合内首次使用【杀】造成伤害时，此伤害+1；你于回合内使用的第一张【杀】被闪避后，你摸一张牌。',
                            minijinjiu: '禁酒',
                            minijinjiu_info: '锁定技。①你的【酒】均视为【杀】且不计入出牌阶段的使用次数。②其他角色使用的【酒】进入弃牌堆后，你获得之。③你的回合内，其他角色不能使用【酒】。',
                            miniluanji: '乱击',
                            miniluanji_info: '你可以将两张与你本回合以此法转化的花色均不相同的手牌当【万箭齐发】使用。若你以此法使用的【万箭齐发】未造成伤害，则你可以在此牌结算完成后摸X张牌。（X为此牌的目标数）',
                            minixueyi: '血裔',
                            minixueyi_info: '主公技，锁定技，游戏开始时，你获得X个“裔”标记（X为场上群势力角色的数目）。出牌阶段/当你处于濒死状态时，你可以移去1枚“裔”标记，然后回复1点体力并摸一张牌。你的手牌上限+Y（Y为你拥有的“裔”标记数的两倍）。',
                            minijiuchi: '酒池',
                            minijiuchi_info: '你可以将一张黑色手牌当作【酒】使用。',
                            minibenghuai: '崩坏',
                            minibenghuai_info: '锁定技，结束阶段，若你的体力不为全场最少，你须减1点体力或体力上限，然后摸一张牌。',
                            miniwansha: '完杀',
                            miniwansha_info: '锁定技，你的回合内，只有你可以使用【桃】。',
                            minirewansha: '完杀',
                            minirewansha_info: '锁定技，你的回合内，只有你可以使用【桃】；出牌阶段开始时，你可令一名体力值大于1的其他角色失去1点体力，本阶段结束时，其回复1点体力。',
                            minimieji: '灭计',
                            minimieji_info: '出牌阶段限一次，你可以将一张黑色牌置于牌堆顶，然后令有一名手牌的其他角色弃置一张锦囊或弃置两张非锦囊牌。',
                            minishibei: '矢北',
                            minishibei_info: '锁定技，当你受到伤害后，若此伤害是你本回合第一次受到的伤害，则你回复1点体力并摸一张牌，否则你失去1点体力。',
                            minijijiu: '急救',
                            minijijiu_info: '你的回合外，你可以将一张红色牌当作【桃】使用，然后你可以弃置一名其他角色的一张手牌。',
                            minireqingnang: '青囊',
                            minireqingnang_info: '出牌阶段限一次，你可以令任意名角色各加1点体力上限并回复1点体力，然后你弃置X张牌（X为目标角色数-1）。若如此做，你的下个回合开始时，这些角色减1点体力上限。',
                            miniqingnang: '青囊',
                            miniqingnang_info: '出牌阶段限一次，你可以令一名角色回复1点体力。',
                            minileiji: '雷击',
                            minileiji_info: '①当你使用或打出一张【闪】或【闪电】时，你可令一名其他角色进行一次判定：若结果为梅花，其受到1点雷属性伤害，然后你回复1点体力；若结果为黑桃，其受到2点雷属性伤害。②你的手牌上限+2。',
                            minihuangtian: '黄天',
                            minihuangtian2: '黄天',
                            minihuangtian4: '黄天',
                            minihuangtian_info: '主公技。①其他群势力角色的出牌阶段限一次，其可以交给你一张【闪】或【闪电】或黑桃手牌。②每回合限一次，你可以获得其他群势力角色使用或打出的【闪】。',
                            minishuangxiong: '双雄',
                            minishuangxiong_info: '摸牌阶段，你可以放弃摸牌，亮出牌堆顶的三张牌并选择获得其中一种颜色的所有牌，本回合你可以将与这些牌颜色不同的一张手牌当作【决斗】使用。当你受到【决斗】造成的伤害后，你可以获得对方于此牌结算过程中打出的所有【杀】。',
                            miniyinlang: '引狼',
                            miniyinlang_info: '出牌阶段结束时，你可以选择场上的一个势力。若如此做，你与场上与你选择势力相同的角色各获得1枚“生”标记。有“生”标记的角色使用牌无法指定没有“生”的角色为目标。',
                            minixiusheng: '休生',
                            minixiusheng_info: '锁定技，准备阶段，你移去场上所有的“生”标记，然后你摸等量的牌。',
                            minihuaibi: '怀璧',
                            minihuaibi_info: '主公技，锁定技，你的手牌上限+X（X场上的“生”标记数）；有“生”标记的角色对你造成伤害后，你摸一张牌。',
                            minikuangfu: '狂斧',
                            minikuangfu_info: '出牌阶段限一次，你可以弃置场上的一张装备牌，然后视为使用一张无对应实体牌的【杀】（无视距离且不计入次数限制）。若此【杀】造成了伤害，你摸两张牌。',
                            minilihun: '离魂',
                            minilihun_info: '出牌阶段限一次，你可以选择一名其他角色，你将武将牌翻面并获得其所有手牌。出牌阶段结束时，你交给其X张牌。（X为该角色的体力值）',
                            minizhuiji: '追击',
                            minizhuiji_info: '锁定技，你计算体力值小于等于你的角色的距离视为1，体力值大于等于你的角色无法响应你对其使用的【杀】。',
                            minishichou: '誓仇',
                            minishichou2: '誓仇',
                            minishichou4: '誓仇',
                            minishichou_info: '①当你使用【杀】指定目标后，你可以选择X+1名角色成为此【杀】的额外目标（X为你已损失的体力值）。②你使用【杀】结算完成后，若此牌未造成伤害，则你从牌堆中获得一张【杀】。③每回合限三次，当你使用【杀】造成1点伤害后，你摸一张牌。',
                            minilijian: '离间',
                            minilijian_info: '每回合限一次，你使用的【杀】或【决斗】可以额外指定一名男性角色为目标。',
                            minijiqiao: '机巧',
                            minijiqiao_info: '出牌阶段开始时，你可以弃置任意张非锦囊牌，然后你亮出牌堆顶两倍数量的牌并获得其中的锦囊牌，若其中没有锦囊牌，则你从牌堆或弃牌堆中获得一张锦囊牌。',
                            minilinglong: '玲珑',
                            minilinglong_info: '锁定技，若你的装备区没有防具牌，你视为装备【八卦阵】；若你的装备区没有坐骑牌，你的手牌上限+1；若你的装备区没有牌，你视为拥有〖集智〗和〖奇才〗。',
                            minilinglong_jizhi: '集智',
                            minilinglong_jizhi_info: '当你使用锦囊牌时，你可以摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
                            minifuqi: '伏骑',
                            minifuqi_info: '锁定技，当你使用牌时，你令所有与你距离不大于2的其他角色不能使用或打出牌响应此牌；当你对其他角色造成伤害后，你令其本回合非锁定技失效。',
                            minijiaozi: '骄恣',
                            minijiaozi_info: '锁定技，当你造成伤害时，若你的手牌数为全场最多，则此伤害+1。',
                            minitianming: '天命',
                            minitianming_info: '当你成为【杀】的目标时，你可以弃置两张牌（不足则全弃，无牌则不弃），然后摸两张牌。然后你可以选择一名角色，令其弃置两张牌（不足则全弃，无牌则不弃），然后摸两张牌。',
                            minimizhao: '密诏',
                            minimizhao_info: '出牌阶段限一次，你可以将任意张手牌交给一名其他角色。若如此做，你令该角色与你指定的另一名有手牌的角色拼点，视为拼点赢的角色对没赢的角色使用一张【杀】。',
                            minibeige: '悲歌',
                            minibeige_info: '当一名角色受到【杀】造成的伤害后，你可以弃置一张牌，然后若此牌为：①红色，其回复1点体力并摸两张牌；②梅花，伤害来源弃置两张牌；③黑桃，伤害来源将武将牌翻面。',
                            minizhuikong: '惴恐',
                            minizhuikong_info: '其他角色的准备阶段，你可以与该角色拼点。若你赢，该角色本回合使用的牌不能指定除该角色外的角色为目标。若你没赢，其本回合至你的距离视为1。',
                            miniqiuyuan: '求援',
                            miniqiuyuan_info: '当你成为【杀】的目标时，你可以令至多三名不为此【杀】的使用者的其他角色选择一项：①交给你一张【闪】；②成为此【杀】的额外目标并弃置一张牌。',
                            minidianhua: '点化',
                            minidianhua_info: '准备阶段或结束阶段，你可以观看牌堆顶的X张牌（X为你的「紫薇」「后土」「玉清」「勾陈」标记数的总和+1），然后你将这些牌以任意顺序放回牌堆顶。',
                            minizhenyi: '真仪',
                            minizhenyi_info: '你可以在以下时机弃置相应的标记来发动以下效果：一名角色的判定牌生效前，你可以弃置一枚「紫薇」，然后将判定结果改为黑桃5或红桃5；你的回合外，你可以弃置一枚「后土」，然后将你的一张手牌当【桃】使用；当你造成伤害时，你可以弃置一枚「玉清」，然后令此伤害+1；当你受到伤害后，你可以弃置一张「勾陈」，然后你从牌堆中随机获得三种类型的牌各一张。',
                            minicangchu: '仓储',
                            minicangchu2: '仓储',
                            minicangchu3: '仓储',
                            minicangchu_info: '锁定技。①游戏开始时，你获得3个“粮”。你的手牌上限+X（X为“粮”数）。②每回合限一次，当你于回合外获得牌时/回复体力后，你获得一个“粮”。③你的“粮”数不能超过存活角色数。',
                            miniliangying: '粮营',
                            miniliangying_info: '弃牌阶段开始时，你可以摸至多X张牌，然后交给等量的角色各一张牌。（X为你的“粮”数）',
                            minishishou: '失守',
                            minishishou_info: '锁定技，当你使用【酒】时或受到火焰伤害后，你移去一个“粮”。',
                            minizongkui: '纵傀',
                            minizongkui_info: '回合开始时，你可以指定一名未拥有“傀”标记的其他角色，令其获得一枚“傀”标记。游戏开始时，你指定一名体力值最少且没有“傀”标记的其他角色，令其获得一枚“傀”标记。',
                            miniguju: '骨疽',
                            minilianzhu: '连诛',
                            minilianzhu_info: '出牌阶段限一次，你可将一张牌交给一名其他角色。若此牌为红色，你摸两张牌或回复1点体力。若此牌为黑色，目标角色选择一项：①弃置两张牌；②令你摸两张牌。',
                            minixiahui: '黠慧',
                            minixiahui_info: '锁定技，①你的黑色牌不计入手牌上限。②当有其他角色获得你的黑色牌后，其于下次扣减体力前不能使用，打出，弃置这些牌。③一名其他角色的回合结束时，若其本回合失去过“黠慧”牌，则其失去1点体力。',
                            minilveming: '掠命',
                            minilveming_info: '出牌阶段限一次，你可以选择一名装备区牌数不大于你的的角色，令其选择一个点数，然后你进行判定：若点数相同，你对其造成2点伤害；若点数不同，则你随机获得其区域内的一张牌。',
                            minitunjun: '屯军',
                            minitunjun_info: '限定技。出牌阶段，你可以选择一名角色，令其随机使用牌堆中的X张装备牌（X为你本局游戏发动过〖掠命〗的次数+1）。',
                            minijixu: '击虚',
                            minijixu_info: '出牌阶段限一次，若你有手牌，你可以令至多四名其他角色猜测你的手牌中是否有【杀】。所有角色猜测结束后，你依次弃置所有猜错的角色的一张牌并视为对其使用一张【杀】，然后你摸X张牌且本回合的手牌上限+X（X为猜对的角色数+1）。',
                            minipingjian: '评荐',
                            minipingjian_use: '评荐',
                            minipingjian_info: '结束阶段开始时/当你受到伤害后/出牌阶段限一次，你可以令系统从欢杀将池中随机检索出三张拥有发动时机为结束阶段开始时/当你受到伤害后/出牌阶段的技能的武将牌。然后你可以选择尝试发动其中一个技能。每个技能每局只能选择一次。',
                            Mbaby_characterlist_append: '<span style="font-family:yuanli">欢杀将池：<br>活动武将扩展页面自定义欢杀将池（未自定义将池/联机模式默认为欢乐三国杀全武将）。</span>',
                            Mbaby_characterlist_faq: '欢杀将池',
                            Mbaby_characterlist_faq_info: '<br>活动武将扩展页面自定义欢杀将池（未自定义将池/联机模式默认为欢乐三国杀全武将）。',
                            minirelijian: '离间',
                            minirelijian_info: '出牌阶段限两次，你可以弃置一张牌并选择两名角色（不能选择本回合因你发动〖离间〗受到伤害的角色），视为一名角色对另一名角色使用一张【决斗】（不可被【无懈可击】响应）。',
                            minirebiyue: '闭月',
                            minirebiyue_info: '结束阶段开始时，你摸X张牌（X为你本回合发动〖离间〗的次数+1）。',
                            minizhendu: '鸩毒',
                            minizhendu2: '鸩毒',
                            minizhendu_info: '一名角色的出牌阶段开始时，你可以弃置一张牌，令该角色视为使用一张【酒】；若该角色不是你，你对其造成1点伤害，且本回合其计算与他人的距离时+1。',
                            miniqiluan: '戚乱',
                            miniqiluan_info: '①一名角色进入濒死状态时，你可以摸一张牌。②当你杀死一名角色后，你摸两张牌。',
                            'mini72bian': '72变',
                            'mini72bian_info': '每回合每种类型限一次，出牌阶段，你可以将一张基本牌/锦囊牌/装备牌置入弃牌堆，然后从牌堆中获得一张锦囊牌/装备牌/基本牌。',
                            miniruyi: '如意',
                            miniruyi_info: '锁定技，若你未装备武器且你的武器栏未被废除，你视为装备【如意金箍棒】。',
                            miniruyi_jingubang: '如意金箍棒',
                            miniruyi_jingubang2: '如意金箍棒',
                            miniruyi_jingubang_info: '回合开始时，你可以将【如意金箍棒】的攻击范围调整至1，2，3，4之间的任意值。当【如意金箍棒】的攻击范围为：1，你使用【杀】不计入次数限制；2，你于回合内使用的第一张【杀】造成的伤害+1；3，你使用【杀】无法被响应；4，你使用【杀】可以额外选择一个目标。',
                            miniqitian: '齐天',
                            miniqitian_info: '觉醒技，游戏开始时或当你的体力值发生变化时，若你的体力值为1，你减1点体力上限，然后获得技能〖火眼〗和〖筋斗云〗。',
                            minihuoyan: '火眼',
                            minihuoyan_info: '锁定技，其他角色的手牌始终对你可见。',
                            minijindouyun: '筋斗云',
                            minijindouyun_info: '锁定技，你计算与其他角色的距离-1；其他角色计算与你的距离+1。',
                            minizuzhou: '诅咒',
                            minizuzhou_info: '一名角色的回合开始时，你可以失去1点体力，然后选择一项：①令其本回合手牌中的所有【杀】视为【闪】；②令其本回合手牌中的所有【闪】视为【杀】。',
                            minimoyu: '摸鱼',
                            minimoyu2: '摸鱼',
                            minimoyu4: '摸鱼',
                            minimoyu_info: '出牌阶段开始时，你可以令本回合手牌上限+2，下回合摸牌阶段额外摸两张牌。若如此做，你本回合不能对其他角色使用牌，且回合结束时回复1点体力。',
                            minisanlian: '三连',
                            minisanlian_info: '出牌阶段，你可以弃置三张类型相同的手牌，然后摸X张牌（X为你已损失的体力值），对所有角色各造成1点伤害，若你弃置的牌名均相同，则你弃置所有其他角色各一张牌。',
                            miniminsi: '敏思',
                            miniminsi2: '敏思',
                            miniminsi_info: '出牌阶段限一次，你可以弃置任意张点数之和为13的牌，然后摸两倍数量的牌。本回合你使用这些牌无距离限制且这些牌本回合不计入手牌上限。',
                            minijijing: '吉境',
                            minijijing_info: '当你受到伤害后，你可以进行一次判定，然后你可以弃置任意张点数之和不小于判定结果点数的牌并回复1点体力。',
                            minimanwang: '蛮王',
                            minimanwang_info: '出牌阶段，你可以弃置任意张牌。然后你依次执行以下选项中的前X项：⒈获得〖叛侵〗。⒉摸一张牌。⒊回复1点体力。⒋摸两张牌并失去〖叛侵〗。然后你获得〖祸首〗直到你的下个回合开始。',
                            miniliushi: '流矢',
                            miniliushi_info: '①出牌阶段，你可以将一张红桃牌置于牌堆顶，视为对一名角色使用一张【杀】（此【杀】无距离限制且不计入使用次数）。②当你使用【杀】造成伤害后，受到伤害的角色获得一个“流”，有“流”的角色手牌上限-X（X为其“流”数）。',
                            minilulve: '掳掠',
                            minilulve_info: '出牌阶段开始时，你可选择一名有手牌且手牌数不大于你的角色。其选择一项：①将所有手牌交给你，然后你将武将牌翻面。②将武将牌翻面，然后其视为对你使用一张【杀】。',
                            minishouxi: '守玺',
                            minishouxi_info: '当你成为【杀】的目标后，你可声明一种本局未因〖守玺〗声明过的基本或锦囊牌牌名，然后除非使用者弃置一张你声明的牌，并获得你的一张牌；否则此【杀】对你无效，且你从剩余牌堆中获得一张牌名与其相同的牌。',
                            minihuimin: '惠民',
                            minihuimin_info: '结束阶段，你可以摸X张牌，然后展示X-1张手牌（X为手牌数小于等于体力值的角色数），然后你选择一名手牌数小于等于体力值的角色，从该角色开始，所有手牌数小于等于体力值的角色依次选择并获得其中一张。',
                            minikangge: '抗歌',
                            minikangge_info: '回合开始时，你选择一名其他角色作为“抗歌”角色（覆盖之前选择的“抗歌”角色）。该角色每次于其回合外获得牌后，你摸等量的牌（每回合至多摸三张）；其进入濒死状态时，你可令其回复体力至1点（每轮限一次）。',
                            minijielie: '节烈',
                            minijielie_info: '当你受到伤害时，你可以防止此伤害并选择一种花色，然后你失去1点体力，令“抗歌”角色从弃牌堆中随机获得X张此花色的牌（X为伤害值）。',
                            minishixian: '诗仙',
                            minishixian_info: '锁定技，回合开始时，你失去因〖诗仙〗获得的技能并亮出牌堆顶的四张牌，然后根据花色获得对应技能：红桃〖静夜思〗；方片〖行路难〗；黑桃〖侠客行〗；梅花〖将进酒〗，然后你可获得其中含有重复花色的牌。',
                            minishixian_qiangjinjiu: '将进酒',
                            minishixian_qiangjinjiu_info: '其他角色的回合开始时，你可以弃置一张手牌，然后选择一项：⒈弃置其装备区里的所有的牌，然后令其从牌堆中获得一张【酒】；⒉获得其手牌中所有【酒】（若其手牌中没有【酒】则改为获得其一张牌）。',
                            minishixian_jingyesi: '静夜思',
                            minishixian_jingyesi_info: '①出牌阶段结束时，你可以观看牌堆顶一张牌，然后你可以使用此牌。②弃牌阶段结束时，你获得牌堆底的一张牌。',
                            minishixian_xiakexing: '侠客行',
                            minishixian_xiakexing_info: '①当你使用了牌名含有“剑”的武器牌时，你视为使用一张【万箭齐发】。②当你使用【杀】造成伤害后，若你的装备区里有武器牌，你可以与受伤角色拼点。若你赢，该角色减1点体力上限；若你没赢，你弃置装备区里的武器牌。',
                            minishixian_xinglunan: '行路难',
                            minishixian_xingluBuff: '行路难',
                            minishixian_xinglunan_info: '其他角色使用目标角色包含你的【杀】结算完毕后，若当前回合角色不为你，则其他角色计算与你的距离时+1直到你的下回合开始。',
                            minijigong: '急攻',
                            minijigong_info: '出牌阶段开始时，你可以摸至多三张牌。若如此做，你本回合的手牌上限基数改为X+1，且弃牌阶段结束时，若X不小于Y，则你回复1点体力。（X为你本回合内造成的伤害值之和，Y为你本回合内因〖急攻〗摸牌而获得的牌的数量总和）',
                            minishifei: '饰非',
                            minishifei_info: '当你需要使用或打出【闪】时，你可以令当前回合角色摸一张牌。然后若其手牌数不为全场唯一最多，则你弃置一名角色的一张牌，视为你使用或打出了一张【闪】。',
                            minigongxiu: '共修',
                            minigongxiu_info: '结束阶段，若你本回合内发动过〖经合〗，则你选择一项：①令所有本回合内成为过〖经合〗目标的角色各摸一张牌；②令所有本回合内未成为过〖经合〗目标的角色各弃置一张手牌。',
                            minijinghe: '经合',
                            minijinghe_info: '出牌阶段限一次，你可以展示四张牌名各不相同的牌并选择等量的角色。系统从“写满技能的天书”中随机选择等量的技能，然后这些角色依次选择获得其中的一个。',
                            minichanni: '谗逆',
                            minichanni_info: '出牌阶段限一次，你可将任意张手牌交给一名其他角色，然后其可以将等量的手牌当做【决斗】使用。其因此【决斗】造成伤害后摸X张牌（X为此【决斗】对应的实体牌数）。其因此【决斗】受到伤害时，你可以弃置所有手牌并防止此伤害。',
                            mininifu: '匿伏',
                            mininifu_info: '锁定技，一名角色的回合结束时，你将手牌摸至三张。',
                            minihuaiyi: '怀异',
                            minihuaiyi_info: '出牌阶段限一次，你可以展示所有手牌，然后弃置任意张颜色相同的手牌，并重铸剩余此颜色的手牌，然后你可以获得至多X名角色的各一张牌（X为你本次弃置的牌数）。',
                            minimubing: '募兵',
                            minimubing_info: '出牌阶段限一次，你可以观看牌堆顶的四张牌，然后你可以弃置任意张手牌，获得任意张展示的牌（你弃置的牌点数和不得小于你获得的牌的点数之和），将其余牌置入弃牌堆。',
                            miniziqu: '资取',
                            miniziqu_info: '每名角色每轮限一次，你对其他角色造成伤害时，你可防止此伤害，令其将其的一张点数最大的牌交给你。',
                            minidiaoling: '调令',
                            minidiaoling_info: '出牌阶段，你可以将任意张因〖募兵〗获得的牌交给一名其他角色，若以此法给出的牌数大于1且这些牌的点数连续，你可以获得场上至多X名角色的各一张手牌（X为你本次交出的〖募兵〗牌数-1）。',
                            minizhouxuan: '周旋',
                            minizhouxuan_info: '①弃牌阶段开始时，你可将任意张手牌称为“旋”置于武将牌上（你至多拥有五张“旋”）。②当你使用或打出一张牌时，你摸一张牌，然后移去一张“旋”（若你的手牌不是场上唯一最多则改为摸X张牌，然后移去两张“旋”）。③当你使用牌时，若你没有“旋”，你可令此牌结算完毕后将此牌对应的所有实体牌称为“旋”置于武将牌上。',
                            minidaoyao: '捣药',
                            minidaoyao_info: '出牌阶段限一次，你可以弃置一张手牌，然后从牌堆中获得一张【桃】并摸两张牌（若牌堆中没有【桃】则改为摸三张牌）。',
                            minibenyue: '奔月',
                            minibenyue_info: '觉醒技。当你得到【桃】后，若你的手牌中有三张【桃】，或当你回复体力后，若你本局游戏累计回复至少3点体力。则你将体力上限增加至15点并获得技能〖广寒〗。',
                            miniguanghan: '广寒',
                            miniguanghan_info: '锁定技。一名角色受到伤害后，该角色的非你上家和非你下家依次选择一项：①弃置一张牌；②失去等量的体力。',
                            minigongjian: '攻坚',
                            minigongjian_info: '每回合限一次，当有角色使用【杀】指定第一个目标后，若此【杀】的目标和本局游戏内被使用的上一张【杀】的目标有交集，则你可以依次弃置交集中所有角色的至多两张牌，然后获得以此法弃置的所有基本牌。',
                            minizjjuxiang: '拒降',
                            minizjjuxiang_info: '当你不于摸牌阶段得到牌后，你可以弃置其中任意张牌，令当前回合角色于此回合额定的出牌阶段内使用【杀】的次数上限+X（X为你以此法弃置的牌的花色数）。',
                            miniwushuang: '无双',
                            miniwushuang_info: '锁定技。①你使用【杀】可以额外指定一个目标。②当你使用【杀】或【决斗】指定目标后，你令此牌需要依次使用或打出两张【闪】或【杀】响应。',
                            miniwuchang: '无常',
                            miniwuchang_info: '①当你使用【杀】或【决斗】对与你势力相同的角色造成伤害时，若其未响应过此牌，则你可以令此伤害+1，然后你变更为其他势力。②出牌阶段限一次，你可以令一名其他角色摸一张牌，然后你变更势力至与其相同并从牌堆中获得一张【杀】。',
                            minilirang: '礼让',
                            minilirang_info: '游戏开始时/准备阶段，若场上没有你选择的存活“礼让”角色，你可以选择一名其他角色作为“礼让”角色。“礼让”角色的摸牌阶段额外摸一张牌，“礼让”角色的弃牌阶段结束时，你获得本阶段进入弃牌堆的所有牌。',
                            minizhengyi: '争义',
                            minizhengyi_info: '若场上有你选择的存活“礼让”角色，则当你或其受到伤害时，另一名角色可以代替承受本次伤害并摸一张牌（不嵌套触发）。',
                            minixiaowu: '绡舞',
                            minixiaowu_info: '出牌阶段限一次，你可以选择任意名座位连续且包含你的上家/下家的角色。这些角色依次选择一项：⒈令你摸一张牌；⒉其摸一张牌。然后你获得X枚“沙”（X为选择选项一的角色数的一半，向上取整），且若选择选项二的角色数大于选项一的角色数，则你对这些角色依次造成1点伤害。',
                            minihuaping: '化萍',
                            minihuaping_info: '限定技。①一名其他角色死亡时，你可获得其当前拥有的所有不带有「Charlotte」标签的技能，然后你失去〖绡舞〗，移去所有“沙”并摸等量的牌。②当你死亡时，你可令一名其他角色获得〖沙舞〗和你的所有“沙”。',
                            minisbluanji: '乱击',
                            minisbluanji_info: '①出牌阶段，你可以将两张手牌当【万箭齐发】使用（每种颜色的牌每回合限以此法被转化一次）。②每回合限三次，当其他角色因响应你使用的【万箭齐发】而打出【闪】时，你摸一张牌。③每回合限三次，当你使用【万箭齐发】造成伤害后，你可以弃置受伤角色的一张牌。',
                            minisbxueyi: '血裔',
                            minisbxueyi_info: '主公技，锁定技。①你的手牌上限+2X（X为场上的群势力角色数）。②每回合限两次，当你使用牌指定群势力角色为目标后，你摸一张牌。',
                            minixiongzheng: '雄争',
                            minixiongzheng_info: '一轮游戏开始时，①若你上一轮发动过〖雄争〗且选择过“雄争”角色，你可以选择一项：1.视为对任意名上一轮内未对“雄争”角色造成过伤害的角色依次使用一张【杀】；2.令任意名上一轮对“雄争”角色造成过伤害的角色摸两张牌。②你可以选择一名上一轮发动过〖雄争〗未选择过的角色，称为“雄争”角色。',
                            miniluannian: '乱年',
                            miniluannian_info: '主公技。其他群势力角色的出牌阶段限一次。其可以弃置X张牌并对“雄争”角色造成1点伤害（X为所有角色于本轮发动〖乱年〗的次数+1）。',
                            minizecai: '择才',
                            minizecai_info: '限定技，非首轮游戏开始时，你可令一名角色获得〖集智〗直到下一轮游戏开始；若其是上一轮内使用过锦囊牌数量唯一最多的角色，则其获得一个额外的回合。',
                            minijianjie: '荐杰',
                            minijianjie_info: '①你的第一个准备阶段，你令一名角色获得“龙印”，然后令另一名角色获得“凤印”。②出牌阶段限一次。若当前回合不是你的第一个回合，则你可以移动场上的“龙印”或“凤印”。③拥有“龙印”或“凤印”的其他角色死亡时，你转移该角色的“龙印”和“凤印”。④拥有“龙印”/“凤印”的角色视为拥有〖火计〗/〖连环〗，且同时拥有这两种标记的角色视为拥有〖业炎〗。',
                            minijianjie_huoji: '火计',
                            minijianjie_viewAs: '火计',
                            minijianjie_huoji_info: '①出牌阶段限三次，你可以将一张红色牌当作【火攻】使用。②当你使用【火攻】需要弃牌时，你可以观看牌堆顶的四张牌，选择其中一张符合要求的牌作为需要弃置的牌，然后将其余的牌放回牌堆顶。',
                            minijianjie_lianhuan: '连环',
                            minijianjie_lianhuan_info: '出牌阶段限三次。你可以将一张♣牌当作【铁索连环】使用或重铸。',
                            minijianjie_yeyan: '业炎',
                            minijianjie_yeyan_info: '限定技，出牌阶段，你可以对至多三名角色造成至多共3点火焰伤害（你可以任意分配每名目标角色受到的伤害点数），若你将对一名角色分配2点或更多的火焰伤害，你须先弃置四张不同花色的手牌和你的“龙印”和“凤印”。',
                            miniyinshi: '隐士',
                            miniyinshi_info: '锁定技，若你没有“龙印”或“凤印”，且你有空置的防具栏，则防止你受到的属性伤害和锦囊牌造成的伤害。',
                            minihuoshui: '祸水',
                            minihuoshui_info: '出牌阶段限三次，你可以选择一名其他角色并选择一个本回合未选择过的项：①令其本回合非锁定技失效；②观看其手牌并获得其中一张；③弃置其装备区所有牌。',
                            miniqingcheng: '倾城',
                            miniqingcheng_info: '出牌阶段限一次，你可以与一名手牌数小于等于X的其他角色交换手牌（X为你的手牌数和已损失体力值之和）。',
                            minilianji: '连计',
                            minilianji_info: '出牌阶段限一次，你可以令一名其他角色使用牌堆中的一张随机武器牌，令其视为对你指定的一名角色使用一张【杀】，然后你将其装备区里的武器牌交给任意角色。',
                            minimoucheng: '谋逞',
                            minimoucheng_info: '觉醒技，回合开始时，若有角色因你发动〖连计〗使用【杀】而造成过伤害，则你获得〖矜功〗。',
                            minishanshan: '闪闪',
                            minishanshan_info: '①当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以打出一张【闪】令此牌对你无效，然后你摸一张牌。②你可以将一张装备牌当作【闪】使用或打出。',
                            minianshi: '暗示',
                            minianshi_info: '锁定技，一轮游戏开始时，你随机获得以下一个效果（仅对你可见）：①一名角色于本轮使用或打出【杀】时，其弃置所有手牌；②下一轮开始时，所有未于本轮使用、打出或弃置过【闪】的角色各受到你对其造成的1点雷属性伤害；③一名角色的装备区的牌数于本轮发生变化后，其弃置所有装备牌；④一名角色于本轮使用或打出【桃】或【酒】后，其本回合无法使用或打出手牌；⑤一名角色于本轮使用单目标锦囊牌指定目标时，你摸一张牌。',
                            miniyishe: '义舍',
                            miniyishe_info: '①结束阶段，你可以摸两张牌，然后将两张牌置于武将牌上，称为「米」。②当有「米」移至其他区域后，若你的武将牌上没有「米」，则你回复1点体力。',
                            minibushi: '布施',
                            minibushi_info: '当你受到1点伤害后，或其他角色受到你造成的1点伤害后，你可以选择一张「米」令受伤角色获得之。',
                            minimidao: '米道',
                            minimidao_info: '一名角色的判定牌生效前，你可以打出一张「米」代替之，然后你摸一张牌。',
                            minitianze: '天则',
                            minitianze_info: '①每回合限一次，其他角色于其出牌阶段内使用的黑色手牌结算结束后，你可以弃置一张黑色牌，并对其造成1点伤害。②其他角色的判定生效后，若结果为黑色，则你摸一张牌。',
                            minidifa: '地法',
                            minidifa_info: '出牌阶段限一次，你可以重铸一张红色手牌，然后选择一个锦囊牌的牌名并从牌堆中获得一张此牌名的牌。',
                            minicixiao: '慈孝',
                            minicixiao_info: '准备阶段，你可令一名没有“义子”标记的其他角色获得一个“义子”标记，然后你可以交给其一张手牌，令其视为对你选择的其攻击范围内的另一名角色使用一张【杀】。拥有“义子”标记的角色获得技能〖叛弑〗。',
                            minipanshi: '叛弑',
                            minipanshi_info: '锁定技，准备阶段，你交给有“慈孝”技能的角色一张手牌；当你于出牌阶段因使用【杀】对其他角色造成伤害时，若其拥有技能“慈孝”，则此伤害+1，且你失去“义子”标记并结束出牌阶段。',
                            minidushi: '毒逝',
                            minidushi_info: '锁定技，你处于濒死状态时，其他角色不能对你使用【桃】。当你的濒死状态结算完毕后，你失去〖毒逝〗，然后选择一名其他角色获得〖毒逝〗。',
                            miniheqia: '和洽',
                            miniheqia_info: '出牌阶段限一次，你可将任意张牌交给一名其他角色或令一名有手牌的其他角色交给你任意张牌。然后以此法得到牌的角色可以将一张手牌当作任意基本牌使用，且当其声明使用此牌后，可以为此牌增加至至多X个目标（X为本次使用者以此法得到的牌数）。',
                            miniqibie: '泣别',
                            miniqibie_info: '一名角色死亡后，你可以弃置任意张手牌，然后回复1点体力并摸X+1张牌（X为你弃置的牌数）。',
                            minixiaojuan: '骁隽',
                            minixiaojuan_info: '当你使用牌指定其他角色为唯一目标后，你可以弃置其一半的手牌（向上取整）。若这些牌中有与你使用牌花色相同的牌，则你弃置一张手牌。',
                            minizhidao: '雉盗',
                            minizhidao_info: '锁定技，当你于出牌阶段内第一次对区域里有牌的其他角色造成伤害后，你获得其手牌、装备区和判定区里的各一张牌，然后直到回合结束，本回合你不能对其使用牌。',
                            minybhijili: '寄篱',
                            minybhijili_info: '锁定技，当一名其他角色成为红色基本牌或红色普通锦囊牌的目标时，若其与你的距离为1且你既不是此牌的使用者也不是目标，你也成为此牌的目标。若此牌造成伤害，你摸一张牌。',
                            minirejiuchi: '酒池',
                            minirejiuchi_info: '你可以将一张黑色牌当做【酒】使用。你使用【酒】无次数限制，且当你于回合内使用带有【酒】效果的【杀】造成伤害后，你可以摸一张牌并令〖崩坏〗失效直到回合结束。',
                            miniroulin: '肉林',
                            miniroulin_info: '锁定技。你对女性角色、女性角色对你使用【杀】时，都需连续使用两张【闪】才能抵消。此【杀】结算结束后，若此牌未造成伤害，你摸一张黑色牌。',
                            minirebenghuai: '崩坏',
                            minirebenghuai_info: '锁定技，结束阶段，若你的体力不为全场最少，你须减1点体力或体力上限，然后摸一张牌。你的回合开始时，若你的体力为全场最少，本回合〖肉林〗改为对所有角色生效。',
                            minitanbei: '贪狈',
                            minitanbei_info: '出牌阶段限一次，你可以令一名其他角色选择一项：1.你获得其区域内的一张牌，本回合不能再对其使用牌；2.你本回合对其使用牌无距离和次数限制。',
                            minisidao: '伺盗',
                            minisidao_info: '出牌阶段限一次，当你对一名其他角色连续使用两张牌后，你可以获得其区域内一张牌。',
                            minixingluan: '兴乱',
                            minixingluan_info: '出牌阶段限一次，当你使用的指定唯一目标角色的牌结算完成后，你观看牌堆中的两张点数为6的牌并获得其中一张（没有则改为摸六张牌）。',
                            minijuxia: '居下',
                            minijuxia_info: '锁定技，若你的拼点牌点数为A，则你于确定拼点结果前将本次拼点胜利角色改为自己。',
                            miniranshang: '燃殇',
                            miniranshang_info: '锁定技。①当你受到1点火焰伤害后，你获得1枚“燃”标记。②结束阶段，你失去X点体力。然后若X不小于2，则你减2点体力上限并摸X张牌（X为“燃”标记数）。',
                            minimoukui: '谋溃',
                            minimoukui_info: '当你成为【杀】的目标或使用【杀】指定目标后，你可以选择任意项：1.摸一张牌；2.弃置该角色一张牌。若你仅选择一项，则此【杀】造成伤害后，你执行一次此选项；若你均选择，则此【杀】被无效或抵消后，该角色弃置你一张牌。',
                            minijiaoxia: '狡黠',
                            minijiaoxia_info: '①出牌阶段，你可以将一张手牌当【杀】使用；你使用以此法转化的【杀】结算完成后，若此【杀】造成过伤害，你可以使用此牌对应的原卡牌。②出牌阶段，你对你本阶段未使用过【杀】的角色使用【杀】无距离和次数限制。',
                            minihumei: '狐魅',
                            minihumei_info: '出牌阶段限X次（X为你本阶段造成的伤害数），你可以令一名角色执行本回合未选择的一项：①摸一张牌。②交给你一张牌。③回复1点体力。',
                            minidunshi: '遁世',
                            minidunshi_info: '每回合限一次，你可以视为使用或打出一张【杀】/【闪】/【桃】/【酒】，然后当前回合角色于本回合内下一次造成伤害时，你选择两项：⒈防止此伤害。系统从技能名中包含“仁/义/礼/智/信”字样的技能中随机选择三个其未拥有的技能，然后你令当前回合角色获得其中一个技能。⒉从〖遁世〗中删除你本次使用或打出的牌名。⒊减1点体力上限并摸X张牌（X为〖遁世〗的剩余牌名数）。',
                            mininiluan: '逆乱',
                            mininiluan_info: '①你可以将一张黑色牌当作【杀】使用或打出。②当你使用【杀】结算完毕后，若此【杀】未造成过伤害，则此【杀】不计入次数限制。',
                            miniluanzhan: '乱战',
                            miniluanzhan_info: '①当你造成伤害后，你获得一个“乱”。②当你使用【杀】或黑色普通锦囊牌选择目标后，你可以令至多X名角色也成为此牌的目标；当你使用这些牌指定第一个目标后，若此牌目标数小于X，则你移去X/2（向上取整）个“乱”（X为“乱”数）。',
                            minixizhen: '袭阵',
                            minixizhen_info: '出牌阶段开始时，你可选择一名其他角色，视为对其使用【杀】或【决斗】。然后当有角色于本阶段内使用或打出牌响应你时，该角色回复1点体力，你摸两张牌。',
                            minizhenliang: '贞良',
                            minizhenliang_info: '转换技。阳：出牌阶段限一次，你可以弃置一张与“任”颜色相同的牌并对攻击范围内的一名角色造成1点伤害。阴：你的回合外，一名角色使用或打出牌结算完成后，若此牌与“任”颜色相同，则你可以令一名角色摸两张牌。',
                            miniyouqi: '幽栖',
                            miniyouqi_info: '锁定技，当其他角色因〖引路〗标记弃置牌后，你获得此牌。',
                            miniyongsi: '庸肆',
                            miniyongsi_info: '锁定技。①摸牌阶段，你多摸X张牌。②弃牌阶段开始时，你弃置X张牌。③回合结束时，若你本回合造成的伤害值不大于1，你摸X张牌（X为场上势力数）。',
                            minireweidi: '伪帝',
                            minireweidi_info: '弃牌阶段结束时，你可以将其中一种颜色的所有牌交给一名其他角色。若该角色为群势力角色，你可以令其交给你等量张另一种颜色的牌。',
                            minibizhuan: '辟撰',
                            minibizhuan_info: '①当你使用黑色牌后，或成为其他角色使用黑色牌的目标后，你可以将牌堆顶的一张牌置于武将牌上，称为“书”（你至多拥有四张“书”）。②你的手牌上限+X（X为“书”数）。',
                            minitongbo: '通博',
                            minitongbo_info: '摸牌阶段结束时，你可以用任意手牌交换等量“书”。然后若“书”数至少为4，你可以将四张“书”任意交给其他角色。然后你回复1点体力且“书”的上限+1（至多增加等同存活角色数的上限）。',
                            //神
                            Mbaby_shen_lvbu: '欢杀神吕布',
                            Mbaby_shen_guanyu: '欢杀神关羽',
                            Mbaby_shen_zhugeliang: '欢杀神诸葛亮',
                            Mbaby_shen_lvmeng: '欢杀神吕蒙',
                            Mbaby_shen_liubei: '欢杀神刘备',
                            Mbaby_shen_zhangliao: '欢杀神张辽',
                            Mbaby_shen_caocao: '欢杀神曹操',
                            Mbaby_shen_zhouyu: '欢杀神周瑜',
                            Mbaby_shen_sunquan: '欢杀神孙权',
                            Mbaby_shen_simayi: '欢杀神司马懿',
                            Mbaby_shen_zhaoyun: '欢杀神赵云',
                            Mbaby_shen_ganning: '欢杀神甘宁',
                            Mbaby_shen_dianwei: '欢杀神典韦',
                            Mbaby_shen_huatuo: '欢杀神华佗',
                            Mbaby_shen_guojia: '欢杀神郭嘉',
                            Mbaby_shen_zhenji: '欢杀神甄宓',
                            Mbaby_shen_daxiaoqiao: '欢杀神大乔小乔',
                            Mbaby_shen_diaochan: '欢杀神貂蝉',
                            Mbaby_sunwukong: '欢杀孙悟空',
                            Mbaby_dalanmao: '欢杀大懒猫',
                            Mbaby_change: '欢杀嫦娥',
                            Mbaby_shen_taishici: '欢杀神太史慈',
                            Mbaby_nvwa: '欢杀女娲',
                            Mbaby_tunxingmenglix: '吞星梦狸',
                            Mbaby_shen_zuoci: '欢杀神左慈',
                            Mbaby_shen_dengai: '欢杀神邓艾',
                            Mbaby_shen_luxun: '欢杀神陆逊',
                            Mbaby_shen_pangtong: '欢杀神庞统',
                            Mbaby_jingwei: '欢杀精卫',
                            miniwuqian: '无前',
                            miniwuqian_info: '锁定技，当你于回合内第一次使用【杀】或【决斗】指定目标后，则你令此牌无视目标角色的防具且视为具有〖无双〗效果。',
                            minishenfen: '神愤',
                            minishenfen_info: '限定技，出牌阶段，你可以失去3点体力，对所有其他角色各造成1点伤害。这些角色弃置装备区内的所有牌，然后弃置四张手牌。',
                            minishelie: '涉猎',
                            minishelie_info: '锁定技，摸牌阶段，你放弃摸牌，改为亮出牌堆顶的五张牌，并获得其中不同花色的牌各一张。',
                            minigongxin: '攻心',
                            minigongxin_info: '每回合限一次，当你使用牌指定其他角色为唯一目标后，或成为其他角色使用牌的唯一目标后，你可观看对方的手牌。然后你可以展示其中的一张红色牌并选择一项：①获得此牌。②将此牌置于牌堆顶。',
                            minikuangfeng: '狂风',
                            minikuangfeng_info: '出牌阶段结束时，你可选择任意名角色并将等量的“星”置入弃牌堆，然后对这些角色各造成1点伤害。',
                            minidawu: '大雾',
                            minidawu_info: '结束阶段，你可以将一张“星”置入弃牌堆。当你于下回合开始前受到非属性伤害时，此伤害-1。',
                            miniguixin: '归心',
                            miniguixin_info: '当你受到1点伤害后，你可以随机获得所有其他角色区域一张牌，若你本次以此法获得的牌不少于五张且你正面向上，你翻面。',
                            miniwushen: '武神',
                            miniwushen_info: '你可以将红桃手牌视为【杀】使用或打出；你使用红桃【杀】无距离限制且造成的伤害+1。',
                            miniwuhun: '武魂',
                            miniwuhun_info: '锁定技，当你受到伤害后，伤害来源获得X个“梦魇”标记（X为伤害点数）。锁定技，当你死亡或脱离濒死时，你选择一名“梦魇”标记数量最多的其他角色，令该角色进行判定：若判定结果不为【桃】或【桃园结义】，则该角色失去5点体力。',
                            miniqinyin: '琴音',
                            miniqinyin_info: '弃牌阶段结束时，若你于此阶段内弃置过牌，则你可以选择一项：1. 令所有角色各回复1点体力；2. 令所有角色各失去1点体力；3.令所有角色各摸一张牌。',
                            miniyeyan: '业炎',
                            miniyeyan_info: '出牌阶段开始时，你可以对一名其他角色造成1点火焰伤害。',
                            minilongnu: '龙怒',
                            minilongnu_info: '锁定技，出牌阶段开始时，你须选择一项：①失去1点体力并摸两张牌，本回合你的红色手牌均视为无距离限制的火【杀】； ②减1点体力上限，本回合你的黑色手牌均视为无次数限制的雷【杀】。',
                            minijieying: '结营',
                            minijieying_info: '锁定技，游戏开始时或当你的武将牌重置时，你横置；所有已横置的角色手牌上限+2；结束阶段，你可以横置一名其他角色。当你受到伤害时，你摸一张牌。',
                            miniduorui: '夺锐',
                            miniduorui_info: '出牌阶段开始时，你可以观看一名其他角色的手牌并获得其中一张，本回合你使用该颜色的牌不能被其响应。',
                            minizhiti: '止啼',
                            minizhiti_info: '锁定技，若已受伤角色数：大于1，你摸牌阶段摸牌数+1；大于2， 你使用【杀】的次数上限+1。',
                            miniquantui: '劝学',
                            miniquantui_info: '出牌阶段开始时，你可令至多两名其他角色各获得1枚“学”。有“学”的角色回合开始时移除“学”并选择一项：① 出牌阶段不能对其他角色使用牌；②失去1点体力。',
                            minishehu: '射虎',
                            minishehu_info: '锁定技，当你对拥有“学”的角色使用【杀】时，你弃置其一张手牌。',
                            minidingli: '鼎立',
                            minidingli_info: '每轮限一次，其他角色移除“学”时，如果其体力值不小于你，你可以回复1点体力；如果其体力值小于你，你可以摸X张牌（X为其与你的体力值之差且至多为2）。',
                            minirenjie: '忍戒',
                            minirenjie_info: '锁定技，游戏开始时/当你受到伤害后/当你于弃牌阶段弃牌后，你获得1/X/Y枚“忍”标记。（X为伤害值，Y为你本次的弃牌数）',
                            minijilve: '极略',
                            minijilve_info: '①你可以于合理的时机弃置1枚“忍”并发动以下技能：〖鬼才〗、〖放逐〗、〖完杀〗、〖集智〗。②当你于每回合第一次发动〖极略①〗时，你可以摸一张牌。',
                            minijilve_guicai: '鬼才',
                            minijilve_guicai_info: '当一名角色的判定牌生效前，你可以弃置1枚“忍”并打出一张牌代替之，然后若此牌的花色为：红桃，你回复1点体力；梅花，你摸两张牌。',
                            minijilve_fangzhu: '放逐',
                            minijilve_fangzhu_info: '当你受到伤害后，你可以弃置1枚“忍”并令一名其他角色翻面，然后该角色摸一张牌。',
                            minijilve_jizhi: '集智',
                            minijilve_jizhi_info: '当你使用锦囊牌时，你可以弃置1枚“忍”并摸一张牌。若此牌为：基本牌，你本回合手牌上限+1；锦囊牌，你本回合使用【杀】的额定次数+1；装备牌，你可以将此牌置入一名其他角色的装备区。',
                            minijilve_wansha: '完杀',
                            minijilve_miniwansha: '完杀',
                            minijilve_wansha_info: '当一名角色于你的回合内进入濒死状态时，你可以弃置1枚“忍”并于本阶段获得〖完杀〗效果。',
                            minijuejing: '绝境',
                            minijuejing_info: '锁定技，你的手牌上限+3；当你进入或脱离濒死状态时，你摸一张牌。',
                            minilonghun: '龙魂',
                            minilonghun_info: '你可以将同花色的一至两张牌按下列规则使用或打出：红桃当【桃】，方块当火【杀】，梅花当【闪】，黑桃当普【无懈可击】。若你以此法使用了两张红色牌，则此牌回复值或伤害值+1且你摸一张牌。若你以此法使用了两张黑色牌，则你获得当前回合角色一张牌。',
                            minipoxi: '魄袭',
                            minipoxi_info: '出牌阶段限一次，你可以观看一名其他角色的手牌，然后你可以弃置你与其手牌中的三张花色不同的牌。若如此做，根据此次弃置你的牌的数量执行以下效果：没有，你减1点体力上限；两张，你回复1点体力并摸一张牌；三张，你摸三张牌。',
                            minishenwei: '神卫',
                            minishenwei_info: '准备阶段，你可以令一名没有“卫”标记的角色获得1枚“卫”标记（若你的体力值为1则改为至多两名角色）。有“卫”标记的角色受到伤害时，该角色可以弃置其“卫”标记并将伤害转移给你。',
                            minielai: '恶来',
                            minielai_info: '锁定技，当场上的“卫”标记被移除时，你须选择一项：①回复1点体力；②对一名攻击范围内的其他角色造成1点伤害。',
                            minikuangxi: '狂袭',
                            minikuangxi_info: '锁定技，当场上存在“卫”标记时，你造成的伤害+1。',
                            minijishi: '济世',
                            minijishi_info: '游戏开始时，你获得3枚“药”标记（你至多拥有3枚“药”标记）。当有角色进入濒死状态时，你可以弃置1枚“药”标记并令其回复至1点体力。当你于回合外失去红色手牌时，你获得等量的“药”标记。你的手牌上限+3。',
                            minitaoxian: '桃仙',
                            minitaoxian_info: '你可以将一张红桃牌当【桃】使用；其他角色使用【桃】时，你摸一张牌。',
                            minishenzhen: '神针',
                            minishenzhen_info: '回合开始时，你可以弃置任意枚“药”标记，然后选择一项：1.令等量角色各回复1点体力；2.令等量角色各失去1点体力。',
                            minigjtianyi: '天翊',
                            minigjtianyi_info: '觉醒技，准备阶段，若场上的所有存活角色均于本局游戏内受到过伤害，则你加2点体力上限并回复1点体力，然后令一名角色获得技能〖佐幸〗。',
                            minizuoxing: '佐幸',
                            minizuoxing_info: '出牌阶段开始时，若令你获得〖佐幸〗的角色存活且体力上限大于1，则你可以令其减1点体力上限。若如此做，你于本回合获得如下效果：出牌阶段限一次，你可以视为使用一张普通锦囊牌。',
                            minihuishi: '辉逝',
                            minihuishi_info: '限定技，出牌阶段，你可选择一名角色。若其有未发动的觉醒技且你的体力上限不小于存活人数，则你选择其中一个技能，令其发动此技能无视条件；若其没有未发动的觉醒技且你的体力上限不小于3，其摸四张牌。然后你减2点体力上限。',
                            minishenfu: '神赋',
                            minishenfu_info: '①回合结束时，若你的手牌数为：奇数，你可对一名其他角色造成1点雷属性伤害，若其死亡，你可重复此流程；偶数，你可选择一名角色，你令其摸一张牌或弃置其一张牌，若其手牌数等于体力值，你可重复此流程。（重复流程中不能选择本次技能结算中已经选择过的角色）②回合结束后，你摸X张牌（X为你本回合发动〖神赋〗的次数且至多为5）。',
                            miniqixian: '七弦',
                            miniqixian2: '七弦',
                            miniqixian_info: '锁定技，你的手牌上限视为7。出牌阶段结束时，你可以将一张牌移出游戏，此牌于回合结束后归还。',
                            minifeifu: '飞凫',
                            minifeifu_info: '你可以将一张黑色牌当作【闪】使用或打出。',
                            minishuangshu: '双姝',
                            minishuangshu_pingting: '双姝·娉婷',
                            minishuangshu_yizheng: '双姝·移筝',
                            minishuangshu_info: '准备阶段，你可以亮出牌堆顶的两张牌。若其中包含：方片牌，本回合发动〖娉婷〗可选择的选项上限+1；红桃牌，本回合发动〖移筝〗可移动装备牌上限+1；只有黑色牌，你获得展示的牌。',
                            minipingting: '娉婷',
                            minipingting_info: '出牌阶段开始时，你可以选择以下选项中的至多两项：⒈本阶段使用的第一张牌无距离限制。⒉本阶段使用第二张牌指定目标后获得此牌对应的所有实体牌。⒊本阶段使用的第三张牌结算完毕后摸两张牌。⒋本阶段使用的第四张牌额外结算一次。',
                            miniyizheng: '移筝',
                            miniyizheng_info: '出牌阶段结束时，你可以移动场上至多一张装备牌（只能移动武器、防具和坐骑牌，且一次技能结算中每种副类别的装备限移动一次），然后若你于本次技能结算中移动了：一张装备牌，你回复1点体力；两张装备牌，直到你的下回合开始，当你失去一张牌时，摸一张牌。',
                            minimeihun: '魅魂',
                            minimeihun_info: '结束阶段，或你于当前回合首次成为【杀】的目标后，你可以选择一名其他角色，然后声明一个花色，令其交给你所有你此花色的牌，若其没有此花色的牌，则你观看其手牌并获得其中一张。',
                            minihuoxin: '惑心',
                            minihuoxin_info: '出牌阶段限一次，你可以弃置一张牌并令两名角色拼点，然后你可以声明一个花色，没赢的角色须选择一项：①令你获得其所有此花色的牌；②其不能使用或打出你此次声明的花色的牌直到其下个回合结束。',
                            minidulie: '笃烈',
                            minidulie_info: '锁定技。①当你成为【杀】的目标时，你进行判定。若结果为红桃，则取消此目标。②当你首次进入濒死状态时，你将体力回复至X点（X为场上拥有“围”标记的角色数）。',
                            minichongwei: '重围',
                            minichongwei_info: '①游戏开始时，你令所有其他角色获得1个“围”。②一名角色受到伤害后，若其有“围”，则其移去“围”。③回合开始时，你选择所有有“围”的角色。这些角色失去“围”，然后这些角色的第一个不为你的下家获得等量的“围”。④一名其他角色的回合开始时，若其有“围”，则你可以选择一项：⒈弃置一张手牌并对其造成1点伤害。⒉若其体力值不大于你，则你获得其一张手牌。选择完成后，你视为在其攻击范围内直到回合结束。',
                            minipowei: '破围',
                            minipowei_info: '觉醒技。一名角色的回合结束时，若场上角色均没有“围”标记，你获得技能〖神著〗，然后摸Y张牌（Y为本轮移去的“围”数）。',
                            minishenzhu: '神著',
                            minishenzhu_info: '锁定技。①回合开始时，你从牌堆或弃牌堆获得一张【杀】。②当你使用有对应实体牌的非转化【杀】结算结束后，你选择一项：1.摸一张牌，且本回合使用【杀】的次数上限+1。2.摸三张牌，且本回合不能再使用【杀】。',
                            minibutian: '补天',
                            minibutian_info: '锁定技。①当你对其他角色造成伤害后，你回复X点体力。②当你受到伤害后或非首轮开始时，你失去X点体力。③游戏开始时，或你的体力值或体力上限变化后，若你未受伤，则你令场上所有其他角色死亡。（X为你已损失体力值的1/5，向下取整）',
                            minilianshi: '炼石',
                            minilianshi_info: '锁定技。①你的手牌上限始终为5。②当你使用、打出或弃置牌时，你记录这些牌的花色，然后若你已记录四种花色，则你摸一张牌并回复Y点体力，然后清除花色记录（Y为这些牌中的最后一张牌的点数）。',
                            minituantu: '抟土',
                            minituantu_info: '出牌阶段限一次，你可以从弃牌堆中获得你手牌中有的牌名的牌各一张。',
                            minitunxing: '吞星',
                            minitunxing_info: '锁定技，游戏开始时或你发动〖梦狸〗后，你从随机三张主公武将牌中选择一张，然后获得此武将牌上所有主公技和觉醒技外的技能直到你下次发动此技能。',
                            minitunxing_faq: '〖吞星〗将池',
                            minitunxing_faq_info: '活动武将扩展页面自定义欢杀〖评鉴〗将池的全部武将（未自定义将池/联机模式默认为欢乐三国杀全武将）。',
                            minitunxing_append: '<span style="font-family:yuanli">〖吞星〗将池：<br>活动武将扩展页面自定义欢杀〖评鉴〗将池的全部武将（未自定义将池/联机模式默认为欢乐三国杀全武将）。</span>',
                            minimengli: '梦狸',
                            minimengli_info: '锁定技，当你的体力值发生变化后，若你变化前和变化后的体力值与3的大小关系不同，则你变换形态，然后你摸一张牌。',
                            minihuanshu: '幻术',
                            minihuanshu_info: '锁定技。①一轮游戏开始时，或当你受到1点伤害后，你获得两张“幻术”牌。②当一张“幻术”牌销毁后，你摸一张牌。③出牌阶段开始时，你令所有未被〖幻化〗定向转化过的“幻术”牌随机变成本局游戏存在的另一张牌的镜像。',
                            minihuanshu_faq: '关于“幻术”牌',
                            minihuanshu_faq_info: (() => {
                                const list = [
                                    '“幻术”牌为本局游戏牌组中随机一张牌的镜像，此牌可进行常规牌可进行的任何一般操作。',
                                    '“幻术”牌不计入手牌上限，一名角色最多持有其体力上限两倍的“幻术”牌，超出的部分改为摸等量的牌',
                                    '已/未被〖幻化〗定向转化过的“幻术”牌呈现金/深蓝色与常规牌进行区分。',
                                    '无〖幻术〗技能的角色获得“幻术”牌后，“幻术”牌会被销毁。',
                                ];
                                return '<br><li>' + list.join('<br><li>');
                            })(),
                            minihuanshu_append: (() => {
                                const list = [
                                    '“幻术”牌为本局游戏牌组中随机一张牌的镜像，此牌可进行常规牌可进行的任何一般操作。',
                                    '一名角色最多持有其体力上限两倍的“幻术”牌，超出的部分改为摸等量的牌',
                                    '已/未被〖幻化〗定向转化过的“幻术”牌呈现金/深蓝色与常规牌进行区分。',
                                    '无〖幻术〗技能的角色获得“幻术”牌后，“幻术”牌会被销毁。',
                                ];
                                return '<span style="font-family: yuanli">关于“幻术”牌<br><li>' + list.join('<br><li>') + '</span>';
                            })(),
                            minihuanhua: '幻化',
                            minihuanhua_tag: '已选择',
                            minihuanhua_info: '每回合限两次，出牌阶段，你可选择一张未被〖幻化〗定向转化过的“幻术”牌和一张未被〖幻化〗选择过的非“幻术”牌，你将前者的牌名、属性、花色和点数转化为和后者一致，若两张牌的花色相同，你获得一张“幻术”牌。',
                            minihuanjing: '幻境',
                            minihuanjing_info: '限定技，出牌阶段，你可令本回合发动〖幻化〗的次数+X且你发动〖幻化〗可以选择“幻术”牌为转化目标卡牌，然后你获得X张“幻术”牌。（X为你已损失的体力值的两倍且X至少为1）',
                            minixianjin: '险进',
                            minixianjin_info: '锁定技，当你每造成或受到两次伤害后，你激活一个副区域标签并摸X张牌（X为你已激活的副区域数）。',
                            minicuike: '摧克',
                            minicuike_info: '出牌阶段开始时，若你的“军略”标记数为：奇数，你可以对一名角色造成1点伤害；偶数，你可以横置一名角色并弃置其区域内的一张牌。若你的“军略”标记数量大于场上存活角色数，则你可以移去全部“军略”标记并对任意名其他角色造成1点伤害。',
                            minilunce: '论策',
                            minilunce_info: '一轮游戏开始时，你可以选择一名角色，然后为其选择一个策略（每名角色每个策略至多拥有一个）。',
                            'minilunce_上策': '上策',
                            'minilunce_上策_info': '出牌阶段开始时，其可以对一名角色使用一张无距离限制的【杀】。',
                            'minilunce_中策': '中策',
                            'minilunce_中策_info': '其于回合内首次使用【杀】指定目标后，你获得其一张牌，直到其回合结束。',
                            'minilunce_下策': '下策',
                            'minilunce_下策_info': '其回合结束时，若其本回合未于出牌阶段使用【杀】造成过伤害，则你可以交给其至多三张牌并令其回复1点体力。',
                            minilanhai: '览害',
                            minilanhai_info: '锁定技。一名角色的回合结束时，若本回合你的计策被成功执行，则你可以摸X张牌并发动一次〖论策〗（X为你本轮策略被成功执行的次数）；否则你增加1点体力上限并回复1点体力（你以此法至多增加3点体力上限）。',
                            minitianhai: '填海',
                            minitianhai_info: '锁定技。①当你使用或打出手牌时，若此牌有点数且你未记录，则你记录之。②其他角色使用或打出与你〖填海①〗记录的点数相同的牌时，若此牌点数：不大于4，其下次受到的伤害+1；大于4且小于10，你摸一张牌；不小于10，其须弃置任意张牌直到这些牌的点数不小于此牌点数。',
                            minihaiku: '海枯',
                            minihaiku_info: '锁定技。若所有的点数均被〖填海①〗记录，其他角色于摸牌阶段外获得牌后弃置这些牌，然后你获得这些牌中位于弃牌堆的牌。',
                            //喵
                            Mmiao_caiwenji: '喵蔡琰',
                            Mmiao_diaochan: '喵貂蝉',
                            Mmiao_caifuren: '喵蔡夫人',
                            Mmiao_zhangxingcai: '喵张星彩',
                            Mmiao_zhurong: '喵祝融',
                            Mmiao_huangyueying: '喵黄月英',
                            Mmiao_daqiao: '喵大乔',
                            Mmiao_wangyi: '喵王异',
                            Mmiao_zhangchunhua: '喵张春华',
                            Mmiao_zhenji: '喵甄宓',
                            Mmiao_sunshangxiang: '喵孙尚香',
                            Mmiao_xiaoqiao: '喵小乔',
                            Mmiao_lvlingqi: '喵吕玲绮',
                            minidoumao: '逗猫',
                            minidoumao_info: '①回合开始时，你可以弃置一张牌并选择一名其他角色，你失去〖逗猫〗并令其获得〖逗猫〗，然后其摸一张牌。②回合结束时，你弃置一张牌。',
                            minimiaobeige: '悲歌',
                            minimiaobeige_info: '当一名角色受到【杀】造成的伤害后，你可以弃置一张牌，根据此牌花色执行相应效果：红桃，其回复1点体力；方片：其摸两张牌；梅花，伤害来源弃置两张牌；黑桃，伤害来源将武将牌翻面。然后若你没有技能〖逗猫〗，则你可以选择一个效果执行。',
                            minimiaoduanchang: '断肠',
                            minimiaoduanchang_info: '锁定技。①杀死你的角色失去所有技能。②当你受到有来源的伤害进入濒死状态后，若你没有技能〖逗猫〗，则伤害来源须弃置两张牌。',
                            minimiaolijian: '离间',
                            minimiaolijian_info: '出牌阶段限一次，你可以选择至少两名其他角色并弃置X张牌（X为你选择的角色数，若你没有技能〖逗猫〗则改为弃置X-1张牌）。然后每名你选择的角色依次视为对这些角色中与其逆时针座次最近的另一名角色使用一张【决斗】。',
                            minimiaobiyue: '闭月',
                            minimiaobiyue_info: '锁定技，结束阶段，你摸Y张牌（Y为本回合受到过伤害的角色数+1（若你没有技能〖逗猫〗则改为+2），且X至多为5）。',
                            minimiaoqieting: '窃听',
                            minimiaoqieting_info: '其他角色的回合结束时，你可以选择[ ]中的一项：[“摸一张牌”]。若其拥有技能〖逗猫〗，[ ]中添加“观看其两张手牌并获得其中一张”，否则[ ]中添加“将其装备区里的一张牌置入自己的装备区”。',
                            minimiaoxianzhou: '献州',
                            minimiaoxianzhou_info: '限定技，出牌阶段，你可以交给一名其他角色任意张手牌，然后其选择令你回复X点体力或对其攻击范围内的至多X名角色各造成1点伤害（X为你交给其的牌数）。当你因〖逗猫①〗获得〖逗猫〗后，你重置技能〖献州〗。',
                            minimiaoshenxian: '甚贤',
                            minimiaoshenxian_info: '每回合限一次，其他角色因弃置失去基本牌后（若你没有〖逗猫〗则改为非装备牌），你可以摸一张牌',
                            minimiaoqiangwu: '枪舞',
                            minimiaoqiangwu_info: '①你对没有/有技能〖逗猫〗的角色使用【杀】无距离/次数限制。②若你拥有技能〖逗猫〗，当你使用【杀】造成伤害后，你摸一张牌。',
                            minimiaojuxiang: '巨象',
                            minimiaojuxiang_info: '锁定技。①【南蛮入侵】对你无效。②其他角色弃置【南蛮入侵】后，你获得之。③其他角色使用【南蛮入侵】结算完毕后，你获得此牌对应的所有实体牌。④拥有技能〖逗猫〗的角色无法响应你使用的【南蛮入侵】。⑤当你使用【南蛮入侵】对没有技能〖逗猫〗的角色造成伤害后，你摸一张牌。',
                            minimiaolieren: '烈刃',
                            minimiaolieren_info: '①当你使用【杀】指定目标后，你可以和目标角色进行拼点，然后你获得其的拼点牌。若你赢，你获得其一张牌。②出牌阶段开始时，若你本回合因发动〖逗猫①〗失去过〖逗猫〗，你可以选择一名角色，对其发动〖烈刃①〗。',
                            minimiaochangbiao: '长标',
                            minimiaochangbiao_info: '出牌阶段限一次，你可以将任意张手牌当做【杀】使用（无距离限制，若你拥有技能〖逗猫〗，则此牌可以额外指定一名目标）。若你因此【杀】对目标角色造成过伤害，则你于出牌阶段结束时摸X张牌（X为此【杀】对应的实体牌数量）。',
                            minimiaojizhi: '集智',
                            minimiaojizhi_info: '①当你使用锦囊牌时，你可以摸一张牌。②每回合限一次，其他角色使用锦囊牌时，若你没有技能〖逗猫〗，你可以摸一张牌。',
                            minimiaoqicai: '奇才',
                            minimiaoqicai_info: '锁定技。①你使用锦囊牌无距离限制，你装备区内的防具牌不能被其他角色弃置。②其他角色因〖逗猫①〗获得〖逗猫〗后，你从牌堆中获得一张锦囊牌。',
                            minimiaoguose: '国色',
                            minimiaoguose_info: '出牌阶段限四次。你可以选择一项：1.将一张♦牌当【乐不思蜀】使用；2.弃置场上一张【乐不思蜀】。然后你摸一张牌（若目标角色拥有技能〖逗猫〗则改为摸两张牌并弃置一张牌）。',
                            minimiaoliuli: '流离',
                            minimiaoliuli_info: '当你成为【杀】的目标时，你可以弃置一张牌并将此【杀】转移给一名你攻击范围内的不为此【杀】使用者的角色（若你没有技能〖逗猫〗，则改为至多两名角色）。',
                            minimiaozhenlie: '贞烈',
                            minimiaozhenlie_info: '当你成为其他角色使用【杀】或普通锦囊牌的目标后，你可以失去1点体力并令此牌对你无效，然后弃置使用者一张牌（若你没有技能〖逗猫〗，则改为获得使用者一张牌）。',
                            minimiaomiji: '秘计',
                            minimiaomiji_info: '结束阶段，你可以摸X张牌，然后可以将等量的牌交给一名其他角色（X为Y已损失的体力值，Y为你，若你没有技能〖逗猫〗则本次技能结算中Y改为你发动〖秘计〗时选择场上的一名已受伤角色，且X至多为5）。',
                            minimiaojueqing: '绝情',
                            minimiaojueqing_info: '当你即将造成伤害时，你依次执行：①若你没有技能〖逗猫〗，你可以失去等同于伤害值的体力，然后令此伤害值翻倍；②你将此次伤害事件改为令受伤角色失去等同于伤害值的体力。',
                            minimiaoshangshi: '伤势',
                            minimiaoshangshi_info: '①当你的手牌数小于X时，你将手牌摸至X张（X为你已损失的体力值，且X至少为1）。②当你因发动〖逗猫①〗失去〖逗猫〗时，你加1点体力上限；当你因〖逗猫①〗获得〖逗猫〗时，你减1点体力上限。',
                            minimiaoluoshen: '洛神',
                            minimiaoluoshen_info: '①准备阶段，你可以进行判定，然后你获得此牌，若结果为黑色，你可以重复此流程。②回合结束时，若你没有技能〖逗猫〗，则你可以发动〖洛神①〗。',
                            minimiaoqingguo: '倾国',
                            minimiaoqingguo_info: '①你可以将一张黑色牌当作【闪】使用或打出。②若你没有技能〖逗猫〗，你可以将一张【闪】当作【桃】使用。',
                            minimiaojieyin: '结姻',
                            minimiaojieyin_info: '出牌阶段限一次，你可以将一张手牌交给一名其他角色或将一张装备牌置入一名其他角色的装备区，然后你回复1点体力并摸一张牌。然后若你没有技能〖逗猫〗，你可令其回复1点体力并摸一张牌。',
                            minimiaoxiaoji: '枭姬',
                            minimiaoxiaoji_info: '当你失去装备区里的一张牌后，你可以摸两张牌，然后若你没有技能〖逗猫〗，你可以弃置场上一张牌。',
                            minimiaotianxiang: '天香',
                            minimiaotianxiang2: '天香',
                            minimiaotianxiang_info: '当你受到伤害时，你可以将一张红桃牌交给一名其他角色并将此伤害转移给其。若如此做，此伤害结算完毕后，若其拥有技能〖逗猫〗，你对其造成1点伤害；没有技能〖逗猫〗，你弃置其一张牌。',
                            minimiaohongyan: '红颜',
                            minimiaohongyan_info: '锁定技。①你的黑桃牌视为红桃牌。②没有技能〖逗猫〗的角色的红桃判定牌生效后，你回复1点体力并摸一张牌。',
                            minimiaozhuangrong: '妆戎',
                            minimiaozhuangrong_info: '觉醒技，每回合结束时，若你的体力值或手牌数为1，你减少1点体力上限并回复体力至上限，将手牌摸至体力上限，然后获得〖神威〗和〖无双〗。',
                            minillqshenwei: '神威',
                            minillqshenwei_info: '锁定技。摸牌阶段，你令额外摸牌数+X；你的手牌上限+Y（若你没有〖逗猫〗，则X为3，Y为1，否则X为2，Y为2）。',
                            minimiaoguowu: '帼武',
                            minimiaoguowu_info: '出牌阶段开始时，你可以展示所有手牌，根据你展示的类型数，你获得对应效果：至少一类，从弃牌堆获得一张普通锦囊牌；至少两类，此阶段使用牌无次数限制；至少三类，此阶段使用首张【杀】或普通锦囊牌可以令之额外结算一次。',
                            //念
                            Mnian_zhugeliang: '念诸葛亮',
                            Mnian_lvbu: '念吕布',
                            Mnian_zhouyu: '念周瑜',
                            mininianxinghan: '兴汉',
                            mininianxinghan_info: '每回合限一次，回合开始时或当你受到伤害时，若默认势力和场上的势力的并集存在非蜀势力和你此前未因“定乱”成功的势力，则你可以进行一次“定乱”。若“定乱”成功，则你增加1点体力上限并回复1点体力，然后将场上的“定乱”势力角色均改为蜀势力。',
                            mininianxinghan_faq: '关于“定乱”',
                            mininianxinghan_faq_info: '<br>系统为默认势力和场上的势力的并集存在非蜀势力和你此前未因“定乱”成功的势力各建立一个势力卡牌框，然后将这些势力的各四张对应势力卡牌随机分配至各个势力卡牌框中，玩家需要在[40+10*max(0,X-5)]秒内将其中仅一个势力卡牌框的所有卡牌调整为此势力的牌，则“定乱”成功，“定乱”结果为你成功分配的这个势力（X为S所含元素个数）。',
                            mininianliaoyuan: '燎原',
                            mininianliaoyuan_info: '①出牌阶段限一次，你可以视为使用【火攻】。②你使用【火攻】可以指定任意名角色。',
                            mininianying_zgl: '念影',
                            mininianying_zgl_info: '回合开始时，若场上角色均为蜀势力；一名角色的回合结束时，若本回合场上有蜀势力角色死亡/场上有原其他势力角色变更势力至过蜀势力/场上有原蜀势力角色变更至过其他势力。则你可以摸两张牌并选择一个存在“念影”效果的技能的“念影”效果执行。',
                            mininiantazhen: '踏阵',
                            mininiantazhen_sha: '杀',
                            mininiantazhen_sha_info: '攻击力+1',
                            mininiantazhen_horse: '马',
                            mininiantazhen_horse_info: '踏阵步数+2',
                            mininiantazhen_jiu: '酒',
                            mininiantazhen_jiu_info: '下次攻击攻击力+2',
                            mininiantazhen_info: '锁定技，回合开始时，你进行一次“踏阵”，若“踏阵”成功，你从牌堆或弃牌堆随机获得一张【杀】，然后获得〖无双〗直到你的下个回合开始，然后若你此次踏阵过程中未路经的路线包含：①一整列：你令“踏阵”中被击败的角色依次交给你一张牌；②一整行：你视为对“踏阵”中被击败的角色使用一张无距离和次数限制的【杀】；③中心格：“踏阵”中被击败的角色不能对你使用【杀】直到你的下回合开始。',
                            mininiantazhen_faq: '关于“踏阵”',
                            mininiantazhen_faq_info: '<br>系统生成一个九宫格，其中有三格为随机三名其他角色，两格为【酒】（下次攻击攻击力+2），一格为【马】（步数+2），其余格为【杀】（攻击力+1），玩家初始步数为玩家体力值+1，初始攻击力为0，在满足经过的路径不交叉的条件下，任选一个不为角色的格子作为初始位置进行八向移动，最终路线上存在被击败角色（攻击力大于等于其当前体力值）即为踏阵成功。',
                            mininiandoupo: '斗破',
                            mininiandoupo_info: '锁定技。①你使用【决斗】的目标上限数+2。②你使用【决斗】的效果改为“所有目标角色与你依次打出一张【杀】，未打出【杀】的角色受到你对其造成的1点伤害。然后重复此流程直到此轮有角色受到伤害。”。③当你使用【决斗】结算完毕后，你获得所有本次【决斗】失败一方的其他角色的各一张牌。',
                            mininianying_lb: '念影',
                            mininianying_lb_info: '每回合限一次，当你造成或受到伤害后，若你本回合造成或受到的伤害数之和大于等于2，则你可以选择一个存在“念影”效果的技能的“念影”效果执行。',
                            mininiansuhui: '溯洄',
                            mininiansuhui_info: '每轮限一次，一名角色的回合结束时，你可以进行一次“奏乐”，根据其中最多的同名音符数执行对应效果：3个，令其回溯至弃牌阶段；4个，令其回溯至出牌阶段；5个，令其回溯至准备阶段。然后令其获得本回合进入弃牌堆的所有牌且其本回合手牌上限+X（X为本次“奏乐”后的同名音符数）。',
                            mininiansuhui_faq: '关于“奏乐”',
                            mininiansuhui_faq_info: '<br>系统分配五个随机音符，且初始拥有五次即兴次数，可通过点击音符的方式对音符进行保留，点击即兴可将所有未选择保留的音符进行重置，玩家可随时点击“演奏”按钮结束“奏乐”，以当前的五个音符作为本次“奏乐”结果。',
                            mininianchongzou: '重奏',
                            mininianchongzou_info: '锁定技，每种类别每回合限一次，当你使用或打出牌时，若你本回合已使用或打出过此牌名的其他牌，则你获得一张与此牌类别不同的牌，并令下一轮〖溯洄〗的可即兴次数+1。',
                            mininianying_zy: '念影',
                            mininianying_zy_info: '一名角色的回合结束时，若其本回合至少使用了两组同名牌，则你可以选择一个存在“念影”效果的技能的“念影”效果执行。',
                            zhouyu_宫: '宫',
                            zhouyu_商: '商',
                            zhouyu_角: '角',
                            zhouyu_徵: '徵',
                            zhouyu_羽: '羽',
                            //战
                            Mfight_huangzhong: '战黄忠',
                            minifightdingjun: '定军',
                            minifightdingjun_info: '战场技。①一名角色使用【杀】造成伤害后，获得1层士气。②士气变化后，你摸一张牌。③士气变化时，若士气层数大于等于场上存活角色数，则进入“定军山战场”；若士气层数为0，则退出“定军山战场”。④一名角色于一回合首次使用【杀】时，若此时处于“定军山战场”，则你可以消耗2层士气，令其于此牌结算中视为拥有〖烈弓〗。',
                            minifightliegong: '烈弓',
                            minifightliegong_info: '锁定技，当你使用【杀】指定目标后，若目标角色的手牌数或体力值大于等于你的手牌数或体力值，则其不可响应此【杀】；目标角色的手牌数和体力值均大于等于你的手牌数或体力值，则此【杀】对其造成的伤害+1。',
                            minifightlizhan: '力斩',
                            minifightlizhan_info: '出牌阶段，你可以打出任意张【杀】，然后视为使用一张需要X张【闪】响应且伤害基数为X的【杀】（X为你打出的【杀】数），目标角色每使用【闪】响应一次此牌，此牌伤害基数-1。若此【杀】造成伤害，则你可以选择一名非此【杀】目标角色，视为对其使用一张无距离和次数限制的伤害牌。',
                        },
                    }
                },
                jilueSkSr: {
                },
                DIY: {
                    diy: {
                        // type:'character',
                        name: 'QQdiy',
                        connect: true,
                        character: {
                            QQdiy_lutiandilang: {
                                sex: "male",
                                group: 'key',
                                hp: 3,
                                maxHp: 4,
                                skills: ['sw_renjie', 'sw_sanyang', 'sw_luguan', 'sw_xinhuo'],
                                trashBin: ['character:qinlang']
                            },
                            QQdiy_aoliao: {
                                sex: "male",
                                group: 'shu',
                                hp: 3,
                                maxHp: 3,
                                skills: ['sw_jincui', 'sw_zhitian', 'sw_qideng'],
                                trashBin: ['character:sb_sp_zhugeliang']
                            },
                            QQdiy_hepingshizhelang: {
                                sex: "male",
                                group: 'key',
                                hp: 2,
                                maxHp: 2,
                                skills: ['sw_gugu', 'sw_heping', 'sw_shangzhuo'],
                                trashBin: ['character:qinlang']
                            },
                            QQdiy_shouwang: {
                                sex: "female",
                                group: 'key',
                                hp: 2,
                                maxHp: 4,
                                hujia: 2,
                                skills: ['qd_tongpin', 'qd_kelian'],
                                trashBin: ['character:key_abyusa']
                            },
                            QQdiy_shenshouwang: {
                                sex: "female",
                                group: 'shen',
                                hp: 3,
                                maxHp: 7,
                                skills: ['qd_tonghun', 'shiki_omusubi'],
                                trashBin: ['character:key_abyusa']
                            },
                            QQdiy_shenqinlang: {
                                sex: "male",
                                group: 'shen',
                                hp: 4,
                                maxHp: 7,
                                skills: ['qd_nanchong', 'qd_weige'],
                                trashBin: ['character:qinlang']
                            },
                            QQdiy_gushenlangfeite: {
                                sex: "male",
                                group: 'shen',
                                hp: 3,
                                maxHp: 3,
                                skills: ['sw_shangshi', 'sw_kaipan'],
                                trashBin: ['character:qinlang']
                            },
                            QQdiy_shenaoliao: {
                                sex: "male",
                                group: 'shen',
                                hp: 3,
                                maxHp: 3,
                                skills: ['qd_kanpo', 'qd_zhinang'],
                                trashBin: ['character:sb_sp_zhugeliang']
                            },
                            QQdiy_dianmanzu: {
                                sex: 'male',
                                group: 'shu',
                                hp: 3,
                                skills: ['qd_dianmanzu', 'qd_dunwu'],
                                trashBin: []
                            },
                            QQdiy_yinmanzu: {
                                sex: 'male',
                                group: 'qun',
                                hp: 5,
                                skills: ['qd_buman', 'qd_manle'],
                                trashBin: []
                            },
                            QQdiy_yinxiaohu: {
                                sex: 'female',
                                group: 'wu',
                                hp: 3,
                                skills: ['qd_shushi', 'qd_pingyuan', 'qd_lizang'],
                                trashBin: []
                            },
                            QQdiy_zhicaochong: {
                                sex: 'male',
                                group: 'wei',
                                hp: 3,
                                skills: ['qd_zhisuan', 'qd_renxin'],
                                trashBin: []
                            },
                            QQdiy_sbzhonghui: {
                                sex: 'male',
                                group: 'wei',
                                hp: 3,
                                skills: ['qd_sbquanji', 'qd_sbzili'],
                                trashBin: []
                            },
                            QQdiy_yangyi: {
                                sex: 'male',
                                group: 'wei',
                                hp: 4,
                                skills: ['qd_ruiyan', 'qd_kuangmiu', 'qd_fengci'],
                                trashBin: []
                            },
                            QQdiy_zhonghui: {
                                sex: 'male',
                                group: 'wei',
                                hp: 3,
                                skills: ['qd_weiwo', 'qd_yajun', 'qd_moubian'],
                                trashBin: []
                            },
                            QQdiy_caoren: {
                                sex: 'male',
                                group: 'wei',
                                hp: 4,
                                skills: ['xinjushou', 'xinjiewei', 'xinshensu'],
                                trashBin: ['character:caoren']
                            },
                            QQdiy_jushou: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_jianying', 'qd_quanlue', 'qd_shibei'],
                                trashBin: []
                            },
                            QQdiy_guanyu: {
                                sex: 'male',
                                group: 'shu',
                                hp: 4,
                                skills: ['qd_wusheng', 'qd_wushen'],
                                trashBin: []
                            },
                            QQdiy_siji: {
                                sex: 'male',
                                group: 'qun',
                                hp: 2,
                                skills: ['qd_yiding', 'qd_qiuxian'],
                                trashBin: []
                            },
                            QQdiy_lansiji: {
                                sex: "male",
                                group: 'qun',
                                hp: 3,
                                maxHp: 4,
                                skills: ['qd_yinbing', 'qd_jiaozhen', 'qd_huanshen'],
                                trashBin: []
                            },
                            QQdiy_hanxiandi: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_modi', 'qd_zhaoling', 'qd_fuhan', 'qd_handi'],
                                trashBin: ["zhu"]
                            },
                            QQdiy_caojinyu: {
                                sex: 'female',
                                group: 'wei',
                                hp: 3,
                                skills: ['qd_yuqi', 'qd_shanshen', 'qd_xianjing'],
                                trashBin: []
                            },
                            QQdiy_lanmanzu: {
                                sex: 'male',
                                group: 'jin',
                                hp: 3,
                                skills: ['qd_manzu'],
                                trashBin: []
                            },
                            QQdiy_zhangjiao: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_chongdian', 'qd_shangwang', 'qd_kaigua'],
                                trashBin: ['character:re_zhangjiao']
                            },
                            QQdiy_guojia: {
                                sex: 'male',
                                group: 'wei',
                                hp: 3,
                                skills: ['qd_shisheng', 'qd_shibai', 'qd_dingce'],
                                trashBin: []
                            },
                            QQdiy_benmao: {
                                sex: 'female',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_feili', 'qd_ruoyu'],
                                trashBin: []
                            },
                            QQdiy_zhangren: {
                                sex: 'male',
                                group: 'qun',
                                hp: 4,
                                skills: ['qd_funi', 'qd_chuanxin'],
                                trashBin: []
                            },
                            QQdiy_gudasha: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_shiyun', 'qd_shiya', 'qd_gugu'],
                                trashBin: []
                            },
                            QQdiy_haomanzu: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_gouyun', 'qd_fenjin', 'qd_lanzuo'],
                                trashBin: []
                            },
                            QQdiy_chujia: {
                                sex: 'male',
                                group: 'shu',
                                hp: 3,
                                skills: ['qd_chujia', 'qd_tongli', 'qd_baishou'],
                                trashBin: []
                            },
                            QQdiy_congmingmao: {
                                sex: 'male',
                                group: 'qun',
                                hp: 3,
                                skills: ['qd_huixiao', 'qd_tongshi', 'qd_baijie'],
                                trashBin: []
                            },
                        },
                        skill: {
                            sw_shangzhuo: {
                                audio: ["dcjinjin"],
                                trigger: { player: "damageEnd" },
                                unique: true,
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "water",
                                content: function () {
                                    "step 0";
                                    var list;
                                    if (_status.characterlist) {
                                        list = [];
                                        for (var i = 0; i < _status.characterlist.length; i++) {
                                            var name = _status.characterlist[i];
                                            list.push(name);
                                        }
                                    } else if (_status.connectMode) {
                                        list = get.charactersOL(function (i) {
                                            return false;
                                        });
                                    } else {
                                        list = get.gainableCharacters(function (info) {
                                            return true;
                                        });
                                    }
                                    var players = game.players.concat(game.dead);
                                    for (var i = 0; i < players.length; i++) {
                                        list.remove(players[i].name);
                                        list.remove(players[i].name1);
                                        list.remove(players[i].name2);
                                    }
                                    // var dialog=ui.create.dialog();
                                    // dialog.add([list.randomGets(5),'character']);
                                    player
                                        .chooseButton(true)
                                        .set("ai", function (button) {
                                            return get.rank(button.link, true) - lib.character[button.link][2];
                                        })
                                        .set("createDialog", ["将武将牌替换为一名角色", [list.randomGets(player.countCards("h") + 1), "character"]]);//改为X张
                                    player.awakenSkill("sw_shangzhuo");
                                    "step 1";
                                    player.disableJudge();
                                    player.reinitCharacter(get.character(player.name2, 3).includes("sw_shangzhuo") ? player.name2 : player.name1, result.links[0]);
                                    if (3 - player.maxHp > 0) player.gainMaxHp(3 - player.maxHp);
                                    else if (player.maxHp - 3 > 0) player.loseMaxHP(player.maxHp - 3);
                                    player.recover();
                                },
                            },
                            sw_heping: {
                                audio: ["dcjinjin"],
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                forced: true,
                                filter(event, player) {
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                logTarget: function () {
                                    return game.filterPlayer(function (current) {
                                        return !current.hasSkill("sw_heping_1");
                                    });
                                },
                                onremove: true,
                                content: function () {
                                    var targets = lib.skill.sw_heping.logTarget().sortBySeat();
                                    for (var target of targets) {
                                        player.line(target);
                                        target.addSkill("sw_heping_1");
                                    }
                                    game.delayx();
                                },
                                mod: {
                                    ignoredHandcard: function (card, player) {
                                        if (get.suit(card, player) == "diamond") return true;
                                    },
                                },
                                subSkill: {
                                    1: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "和",
                                        intro: {
                                            name: "和平",
                                            content: "你的♠牌和♠判定牌的花色视为♥，♣牌和♣判定牌的花色视为♦",
                                        },
                                        mod: {
                                            suit(card, suit) {
                                                if (suit == "spade") return "heart";
                                                if (suit == "club") return "diamond";
                                            },
                                        },
                                    },
                                },
                            },
                            sw_gugu: {
                                audio: ["dchaochong", 2],
                                trigger: {
                                    global: "phaseBefore",
                                    player: ["phaseJieshuBegin", "enterGame"],
                                },
                                filter: function (event, player, name) {
                                    if (player.hasJudge("lebu")) return false;
                                    return (event.name != "phase" || game.phaseNumber == 0 || name == "phaseJieshuBegin") && player.countCards("hes", { suit: "diamond" }) > 0;
                                },
                                locked: false,
                                discard: false,
                                delay: false,
                                prepare: "throw",
                                position: "he",
                                //filterCard: function (card, player, event) {
                                //	return get.suit(card) == "diamond" && player.canAddJudge({ name: "lebu", cards: [card] });
                                //},
                                content() {
                                    "step 0";
                                    player.chooseCard("hes", "【咕咕】：选择一张♦牌当做【乐不思蜀】置入你的判定区", (card, player) => {
                                        return get.suit(card) == "diamond" && player.canAddJudge({ name: "lebu", cards: [card] });
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        player.$throw(result.cards[0]);
                                        player.addJudge({ name: "lebu" }, result.cards[0]);
                                    }
                                    else event.finish();
                                    "step 1";
                                    player.draw(1);
                                },
                                group: ["sw_gugu_1"],
                                subSkill: {
                                    1: {
                                        audio: ["dchaochong", 2],
                                        trigger: { target: "useCardToTargeted" },
                                        forced: true,
                                        filter(event, player) {
                                            return player.countCards("j") && event.targets.length == 1;
                                        },
                                        content: function () {
                                            trigger.getParent().excluded.add(player);
                                        },
                                    },
                                },
                            },
                            sw_qideng: {
                                init: function (player) {//初始化
                                    player.addMark("sw_qideng", 7);
                                    player.syncStorage("sw_qideng");
                                    player.storage.sw_qideng_binsi = false;
                                },
                                audio: ["dcqingshi", 2],
                                marktext: "灯",
                                intro: {
                                    name: "七星灯",
                                    content: "当前有#个“七星灯”",
                                },
                                onremove: true,
                                trigger: {
                                    player: "dyingBegin",
                                },
                                forced: true,
                                filter(event, player) {
                                    return !player.storage.sw_qideng_binsi;
                                },
                                content: function () {
                                    if (player.countMark("sw_qideng") > 0) {
                                        player.removeMark("sw_qideng", 1);
                                        player.recover(Math.max(1, 1 - player.hp));
                                    }
                                    else player.loseHp();
                                    player.storage.sw_qideng_binsi = true;
                                },
                                group: ["sw_qideng_1"],
                                subSkill: {
                                    1: {
                                        forced: true,
                                        nopop: true,
                                        trigger: {
                                            player: "dyingAfter",
                                        },
                                        filter(event, player) {
                                            return player.storage.sw_qideng_binsi;
                                        },
                                        content: function () {
                                            player.storage.sw_qideng_binsi = false;
                                        }
                                    },
                                },
                            },
                            sw_jincui: {
                                audio: ["dcjincui", 2],
                                enable: 'phaseUse',
                                skillAnimation: true,
                                animationColor: 'orange',
                                unique: true,
                                limited: true,
                                usable: 1,
                                init: function (player) {
                                    player.addSkill("sw_jincui_machi");
                                },
                                filterTarget(card, player, target) {
                                    return player != target;
                                },
                                content: function () {
                                    'step 0';
                                    player.awakenSkill("sw_jincui");
                                    player.loseHp();
                                    'step 1';
                                    var cards = get.cards(7);
                                    game.cardsGotoOrdering(cards);
                                    event.cards = cards;
                                    player.showCards(cards, get.translation(player) + '的【尽瘁】牌展示');
                                    'step 2';
                                    var f = false;
                                    for (var card of event.cards) {
                                        if (card.name == 'sha' && player.canUse(card, target, false)) {
                                            //game.updateRoundNumber();
                                            player.useCard(card, target, false);
                                            event.cards.remove(card);
                                            f = true;
                                            break;
                                        };
                                    }
                                    if (!f) event.goto(4);
                                    else event.goto(3);
                                    'step 3';
                                    if (target.isAlive()) event.goto(2);
                                    'step 4';
                                    //if (event.next.length == 0) {
                                    //	var isDamage = false;
                                    //	if (target.getHistory('damage').length) {
                                    //		for (const evt of target.getHistory('damage')) {
                                    //			if (evt.getParent('sw_jincui') == event) {
                                    //				isDamage = true;
                                    //			}
                                    //		}
                                    //	}

                                    //}
                                    if (event.cards.length > 0) {
                                        player.chooseButton(['###【尽瘁】###<div class="text center">请选择获得一张牌</div>', [event.cards, 'card']], false);
                                    };
                                    'step 5';
                                    if (result.links && result.links.length) {
                                        player.gain(result.links, 'gain2');
                                    };
                                },
                                subSkill: {
                                    machi: {
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        trigger: {
                                            global: ["washCard", "die"],
                                        },
                                        filter: function (event, player) {
                                            return player.hasSkill("sw_jincui", null, false, false);
                                        },
                                        content: function () {
                                            player.addSkill("sw_jincui_risutoa");
                                        },
                                    },
                                    risutoa: {
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        trigger: { global: "phaseAfter" },
                                        content: function () {
                                            if (player.awakenedSkills.includes("sw_jincui")) {
                                                player.restoreSkill("sw_jincui");
                                                game.log(player, "重置了", "#g【尽瘁】");
                                                //player.removeSkill('dcjijiao_machi');
                                            }
                                            player.removeSkill("sw_jincui_risutoa");
                                        },
                                    },
                                },
                            },
                            sw_zhitian: {
                                audio: ["dczhizhe", 2],
                                hiddenCard: function (player, name) {
                                    if (player.isTempBanned("sw_zhitian")) return false;
                                    return lib.inpile.includes(name);
                                    //player.tempBanSkill("jsrgwentian", "roundStart");
                                },
                                audio: "jsrgwentian",
                                enable: "chooseToUse",
                                //filter: function (event, player) {
                                //	return (
                                //		player.hasCard(card =>
                                //			lib.inpile.some(name => {
                                //				if (get.type(name) != "basic" && get.type(name) != "trick") return false;
                                //				if (event.filterCard({ name: name, isCard: true, cards: [card] }, player, event)) return true;
                                //				if (name == "sha") {
                                //					for (var nature of lib.inpile_nature) {
                                //						if (event.filterCard({ name: name, nature: nature, isCard: true, cards: [card] }, player, event)) return true;
                                //					}
                                //				}
                                //				return false;
                                //			}, "hes")
                                //		) > 0
                                //	);
                                //},
                                onremove: true,
                                chooseButton: {
                                    dialog: function (event, player) {
                                        var list = [];
                                        for (var name of lib.inpile) {
                                            if (get.type(name) != "equip")
                                                list.push([get.translation(get.type(name)), "", name]);
                                            if (name == "sha") {
                                                for (var j of lib.inpile_nature) list.push(["基本", "", "sha", j]);
                                            }
                                        }
                                        return ui.create.dialog("知天", [list, "vcard"]);
                                    },
                                    filter: function (button, player) {
                                        return _status.event.getParent().filterCard({ name: button.link[2] }, player, _status.event.getParent());
                                    },
                                    backup: function (links, player) {
                                        return {
                                            audio: "jsrgwentian",
                                            popname: true,
                                            //precontent() {
                                            //	//player.logSkill("jsrgwentian");
                                            //	//const cards = get.cards();
                                            //	//event.result.cards = cards;
                                            //	//delete event.result.skill;
                                            //	//game.cardsGotoOrdering(cards);
                                            //	//const color = event.result.card.name == "wuxie" ? "black" : "red";
                                            //	//if (get.color(cards, false) != color) {
                                            //	//	player.tempBanSkill("jsrgwentian", "roundStart");
                                            //	//}
                                            //	event.result.links = links;
                                            //},
                                            //content: function () {
                                            //	"step 0";
                                            //	alert(event.result.links[0]);
                                            //	//player.chooseUseTarget("是否使用？", {name: "sha"}, false, true);

                                            //	//player
                                            //	//	.chooseUseTarget(card, true, false, "nodistance")
                                            //	//	.set("filterTarget", function (card, player, target) {
                                            //	//		var evt = _status.event;
                                            //	//		if (_status.event.name == "chooseTarget") evt = evt.getParent();
                                            //	//		if (target != player && target != evt.juetao_target) return false;
                                            //	//		return lib.filter.targetEnabledx(card, player, target);
                                            //	//	})
                                            //	//	.set("juetao_target", target);
                                            //	//"step 1";
                                            //	//var card = get.cards()[0];
                                            //	//event.ca = card;
                                            //	//game.cardsGotoOrdering(card);
                                            //	//player.showCards(card);
                                            //},
                                            viewAs: { name: links[0][2], nature: links[0][3], isCard: true },
                                            selectCard: -1,
                                            filterCard: () => false,
                                            onuse: function (result, player) {//视为技使用牌时执行的内容
                                                //game.log("执行完毕");
                                                //const cards = get.cards();
                                                //game.cardsGotoOrdering(cards);
                                                //result.cards = lib.skill[result.skill].cards;
                                                //var card = result.cards[0];//定义变量card为视为前的牌
                                            },
                                            precontent() {
                                                const cards = get.cards();
                                                event.result.cards = cards;
                                                delete event.result.skill;
                                                game.cardsGotoOrdering(cards);
                                                if (cards[0].name != event.result.card.name) {
                                                    player.loseHp();
                                                    player.tempBanSkill("sw_zhitian");
                                                }
                                                //game.log("成功");
                                                //game.log(player,links[0][2]);
                                                //event.result.cards = cards;
                                                //delete event.result.skill;
                                                //game.cardsGotoOrdering(cards);
                                                //const color = event.result.card.name == "wuxie" ? "black" : "red";
                                                //if (get.color(cards, false) != color) {
                                                //	player.tempBanSkill("jsrgwentian", "roundStart");
                                                //}
                                            },
                                        };
                                    },
                                    prompt: function (links, player) {
                                        return "将牌堆顶的牌当做" + (get.translation(links[0][3]) || "") + get.translation(links[0][2]) + "使用";
                                    },
                                },
                                group: "sw_zhitian_1",
                                subSkill: {
                                    1: {
                                        trigger: { player: "changeHp" },
                                        prompt2: function (event, player) {
                                            return `观看牌堆顶的${get.cnNumber(player.hp + 2)}张牌，并以任意顺序将其置于牌堆顶或牌堆底`;
                                        },
                                        filter: function (event, player) {
                                            return player.hp + 2 > 0;
                                        },
                                        async content(event, trigger, player) {
                                            const cards = get.cards(player.hp + 2);
                                            await game.cardsGotoOrdering(cards);
                                            const next = player.chooseToMove();
                                            next.set("list", [["牌堆顶", cards.filterInD()], ["牌堆底"]]);
                                            next.set("prompt", "知天：点击或拖动将牌移动到牌堆顶或牌堆底");
                                            next.processAI = list => {
                                                const cards = list[0][1],
                                                    player = _status.event.player;
                                                const top = [];
                                                const judges = player.getCards("j");
                                                let stopped = false;
                                                if (!player.hasWuxie()) {
                                                    for (let i = 0; i < judges.length; i++) {
                                                        const judge = get.judge(judges[i]);
                                                        cards.sort((a, b) => judge(b) - judge(a));
                                                        if (judge(cards[0]) < 0) {
                                                            stopped = true;
                                                            break;
                                                        } else {
                                                            top.unshift(cards.shift());
                                                        }
                                                    }
                                                }
                                                let bottom;
                                                if (!stopped) {
                                                    cards.sort((a, b) => get.value(b, player) - get.value(a, player));
                                                    while (cards.length) {
                                                        if (get.value(cards[0], player) <= 5) break;
                                                        top.unshift(cards.shift());
                                                    }
                                                }
                                                bottom = cards;
                                                return [top, bottom];
                                            };
                                            const {
                                                result: { moved },
                                            } = await next;
                                            const top = moved[0];
                                            const bottom = moved[1];
                                            top.reverse();
                                            game.cardsGotoPile(top.concat(bottom), ["top_cards", top], (event, card) => {
                                                if (event.top_cards.includes(card)) return ui.cardPile.firstChild;
                                                return null;
                                            });
                                            player.popup(get.cnNumber(top.length) + "上" + get.cnNumber(bottom.length) + "下");
                                            game.log(player, "将" + get.cnNumber(top.length) + "张牌置于牌堆顶");
                                            await game.delayx();
                                        },
                                    },
                                },
                            },
                            qd_tonghun: {
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event) {
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget('选择一名角色与其获得“同婚”标记<br>且其回复体力后你回复等量体力，其摸牌后你摸等量牌', lib.filter.notMe).set('ai', target => {
                                        return get.attitude(_status.event.player, target)
                                    }).forResult()
                                },
                                init(player) {
                                    player.storage.qd_tonghunTargets = []
                                    //game.addGlobalSkill('qd_caibu')
                                },
                                async content(event, trigger, player) {
                                    for (const target of event.targets) {
                                        target.addMark('qd_tonghun', 1)
                                        player.markCharacter(target.name)
                                        player.storage.qd_tonghunTargets.push(target)
                                    }
                                    player.addMark('qd_tonghun', 1)
                                    player.addSkill('qd_tonghun_xianfu')
                                },
                                onreset(player) {
                                    game.players.forEach(current => {
                                        current.clearMark('qd_tonghun')
                                        current.unmarkSkill('qd_tonghun')
                                    })
                                    player.remove('qd_tonghun_xianfu')
                                },
                                onremove(player) {
                                    game.removeGlobalSkill('qd_caibu')
                                    game.players.forEach(current => {
                                        current.clearMark('qd_tonghun')
                                        current.unmarkSkill('qd_tonghun')
                                    })
                                    player.remove('qd_tonghun_xianfu')
                                },
                                mark: true,
                                marktext: "嫁",
                                intro: {
                                    name: "同婚",
                                    content(err, player) {
                                        return `同婚标记个数为${player.countMark('qd_tonghun')}`
                                    },
                                    markcount(err, player) {
                                        return `${player.countMark('qd_tonghun')}`
                                    }
                                },
                            },
                            sw_renjie_mark: {
                                //mark: true,
                                direct: true,
                                marktext: "精",
                                intro: {
                                    name: "精气",
                                    content: function (storage, player) {
                                        return get.translation(player.name) + "通过戒鹿获得的精气，手牌上限+" + player.countMark("sw_renjie_mark");
                                    },
                                },
                                onremove: true,
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark("sw_renjie_mark");
                                    },
                                },
                            },
                            sw_renjie: {
                                audio: ["dchaochong", 2],
                                init: player => {
                                    player.addSkill("sw_renjie_mark");
                                },
                                trigger: { source: "damageBegin4" },
                                forced: true,
                                content() {
                                    player.addMark("sw_renjie_mark", Math.min((5 - player.countMark("sw_renjie_mark")), trigger.num * 2));
                                    trigger.cancel();
                                },
                                group: ["sw_renjie_1"],
                                subSkill: {
                                    1: {
                                        audio: ["dchaochong", 2],
                                        trigger: { player: "damageBegin3" },
                                        forced: true,
                                        content() {
                                            if (trigger.num > 2) trigger.num = 2;
                                            player.addMark("sw_renjie_mark", Math.min((5 - player.countMark("sw_renjie_mark")), 1));
                                            player.logSkill("sw_renjie");
                                        },
                                    },
                                }
                            },
                            sw_sanyang: {
                                audio: ["dchaochong", 2],
                                trigger: { target: "useCardToTargeted" },
                                filter(event, player) {
                                    return player.hasMark("sw_renjie_mark") && player.countMark("sw_renjie_mark") >= 1;
                                },
                                content: function () {
                                    player.removeMark("sw_renjie_mark", 1);
                                    trigger.targets.length = 0;
                                    trigger.getParent().triggeredTargets1.length = 0;
                                },
                            },
                            sw_luguan: {
                                audio: ["dcjinjin", 2],
                                enable: "phaseUse",
                                usable: 1,
                                filter(event, player) {
                                    return player.hasMark("sw_renjie_mark") && player.countMark("sw_renjie_mark") >= 1;
                                },
                                skillAnimation: true,
                                animationColor: "ice",
                                filterTarget: function (card, player, target) {
                                    return target != player;
                                },
                                content() {
                                    "step 0";
                                    event.num3 = player.countMark("sw_renjie_mark");
                                    event.num = player.countMark("sw_renjie_mark");
                                    player.removeMark("sw_renjie_mark", event.num);
                                    event.num2 = event.num * 2 + Math.floor(Math.random() * (15 - 4 + 1)) + 4;
                                    event.time = get.utc();
                                    event.num = 0;
                                    "step 1";
                                    player.chooseBool("是否继续鹿关？").ai = function () {
                                        return true;
                                    };
                                    event.num++;
                                    "step 2";
                                    if (result.bool && event.num < event.num2) event.goto(1);
                                    else if (result.bool && event.num >= event.num2) event.goto(3);
                                    else {
                                        game.log(player, "鹿关总次数：" + event.num);
                                        game.log(player, "鹿关失败...阳气散尽...");
                                        event.finish();
                                    }
                                    "step 3";
                                    game.log(player, "鹿关总次数：" + event.num);
                                    game.log(player, "鹿关成功！");
                                    game.log(player, "鹿关总时长：" + Math.round((get.utc() - event.time) / 100) / 10 + "s");
                                    player.line(target);
                                    player.logSkill("对着TA鹿关了！", target);
                                    target.damage("fire", Math.max(0, Math.min(Math.round(event.num3 * (event.num2 / 8) / (Math.round((get.utc() - event.time) / 100) / 10)), 2)), "nocard");
                                    player.addMark("sw_luguan_mark", 1);
                                    //获得技能
                                    if (target.hasSex("female")) {
                                        if (!target.hasSkill("sw_haixiu")) target.addSkill("sw_haixiu");
                                    }
                                    else {
                                        if (!target.hasSkill("sw_fenmen")) target.addSkill("sw_fenmen");
                                    }
                                    "step 4";
                                    if (player.countMark("sw_luguan_mark") >= 3) {
                                        player.die();
                                    }
                                },
                                subSkill: {
                                    mark: {
                                        direct: true,
                                        marktext: "鹿",
                                        intro: {
                                            name: "鹿关",
                                            content: "当前鹿关次数#",
                                        },
                                    },
                                },
                            },
                            sw_haixiu: {
                                forced: true,
                                trigger: { player: "gainAfter" },
                                logTarget: "player",
                                content() {
                                    player.addMark("sw_haixiu_mark", trigger.cards.length);
                                    if (player.countMark("sw_haixiu_mark") >= 8) {
                                        var num = Math.floor(player.countMark("sw_haixiu_mark") / 8);
                                        player.loseHp(num);
                                        player.removeMark("sw_haixiu_mark", num * 8);
                                    }
                                },
                                group: ["sw_haixiu_mark"],
                                subSkill: {
                                    mark: {
                                        mark: true,
                                        direct: true,
                                        marktext: "羞",
                                        intro: {
                                            name: "害羞",
                                            content: "mark",
                                        },
                                    },
                                },
                            },
                            sw_fenmen: {
                                forced: true,
                                trigger: { source: "damageEnd" },
                                logTarget: "player",
                                content() {
                                    player.addMark("sw_fenmen_mark", trigger.num);
                                    if (player.countMark("sw_fenmen_mark") >= 3) {
                                        var num = Math.floor(player.countMark("sw_fenmen_mark") / 3);
                                        player.loseHp(num);
                                        player.removeMark("sw_fenmen_mark", num * 3);
                                    }
                                },
                                group: ["sw_fenmen_mark"],
                                subSkill: {
                                    mark: {
                                        mark: true,
                                        direct: true,
                                        marktext: "愤",
                                        intro: {
                                            name: "愤懑",
                                            content: "mark",
                                        },
                                    },
                                },
                            },
                            sw_xinhuo: {
                                init: function (player) {
                                    player.storage.cnt = 0;
                                    //player.syncStorage("cnt");
                                },
                                audio: ["dcjinjin", 2],
                                trigger: {
                                    player: "useCardEnd",
                                },
                                forced: true,
                                content: function () {
                                    player.addMark("sw_xinhuo_mark", 1);
                                    if (!(player.countMark("sw_xinhuo_mark") % 2)) {
                                        var skills = game.filterSkills(
                                            player.getStockSkills(true, true).filter(skill => {
                                                const info = get.info(skill);
                                                return !info.persevereSkill || !info.charlotte;
                                            }),
                                            player
                                        );
                                        var num = 1;
                                        skills = skills.slice(0, num);
                                        if (skills[0] == "sw_xinhuo") player.loseMaxHp();
                                        player.disableSkill("sw_xinhuo", skills);
                                        player.addTempSkill("sw_xinhuo_restore");
                                        player.storage.cnt += 1;
                                        //player.syncStorage("cnt");
                                        var str = "";
                                        for (var i of skills) {
                                            str += "【" + get.translation(i) + "】、";
                                            player.popup(i);
                                        }
                                        str = str.slice(0, -1);
                                        game.log(player, "的技能", "#g" + str, "失效了");
                                        player.draw(player.storage.cnt);
                                    }
                                },
                                subSkill: {
                                    restore: {
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        onremove: function (player) {
                                            player.enableSkill("sw_xinhuo");
                                            player.storage.cnt = 0;
                                            game.log(player, "恢复了技能");
                                            player.removeMark("sw_xinhuo_mark", player.countMark("sw_xinhuo_mark"));
                                        },
                                    },
                                    mark: {
                                        direct: true,
                                        marktext: "火",
                                        intro: {
                                            name: "心火",
                                            content: "本回合使用牌数#",
                                        },
                                    },
                                },
                            },
                            sw_shangshi: {
                                audio: ["dchaochong", 2],
                                trigger: { player: "phaseJieshuBegin" },
                                init: function (player) {
                                    if (!player.storage.sw_shangshi) player.storage.sw_shangshi = [3, 3];
                                },
                                getInfo: function (player) {
                                    if (!player.storage.sw_shangshi) player.storage.sw_shangshi = [3, 3];
                                    return player.storage.sw_shangshi;
                                },
                                broadcast(card) {
                                    game.broadcast(
                                        (card, storage) => {
                                            card.storage = storage;
                                        },
                                        card,
                                        card.storage
                                    );
                                },
                                //recordGuPiao: function (player, target, color, num) {
                                //	if (!player.storage.sw_shangshi_record) player.storage.sw_shangshi_record = {};
                                //	if (!player.storage.sw_shangshi_record.target) player.storage.sw_shangshi_record.target = {red: 0,black: 0};

                                //	if (color == "red") player.storage.sw_shangshi_record.target.red += num;
                                //	else player.storage.sw_shangshi_record.target.black += num;
                                //	//alert(player.storage.sw_shangshi_record.target.red);
                                //},
                                filter: function (event, player) {
                                    return player.countCards("he") && player.maxHp > 0;
                                },
                                content: function* (event, map) {
                                    "step 0";
                                    var player = map.player;
                                    var list = lib.skill.sw_shangshi.getInfo(player);
                                    var num = list[0];
                                    var result = yield player
                                        .chooseCard(get.prompt("sw_shangshi"), "将至多" + get.cnNumber(num) + "张牌称为“股”置于武将牌上并摸等量的牌或取消可以选择进行判定", "he", [1, num])
                                        .set("complexCard", true)
                                        .set("triggerName", event.triggername);
                                    if (result.bool) {
                                        player.logSkill("sw_shangshi");
                                        for (var k of result.cards) {
                                            //k.storage.sw_shangshi_hidden = true;
                                            //投股记录
                                            //lib.skill.sw_shangshi.recordGuPiao(player, player, get.color(k), 1);

                                            var color = get.color(k);
                                            //if (!player.storage.sw_shangshi_record) player.storage.sw_shangshi_record = {};
                                            //if (!player.storage.sw_shangshi_record.player) player.storage.sw_shangshi_record.player = { red: 0, black: 0 };
                                            //if (color == "red") player.storage.sw_shangshi_record.player.red += 1;
                                            //else player.storage.sw_shangshi_record.player.black += 1;
                                            if (!player.storage.sw_shangshi_record) player.storage.sw_shangshi_record = 0;
                                            if (color == "red") player.storage.sw_shangshi_record += 1;
                                        }
                                        //alert(player.storage.sw_shangshi_record.player.red);

                                        //player.$throw(result.cards, 1000);
                                        player.lose(result.cards, ui.cardPile, "insert");
                                        game.log(player, "将" + get.cnNumber(result.cards.length) + "张牌置于了牌堆顶");
                                        player.addToExpansion(result.cards, player, "draw").gaintag.add("sw_shangshi");

                                        player.draw(result.cards.length);
                                        if (player.hujia == 0) player.changeHujia();

                                        event.finish();
                                    }
                                    else event.goto(1);
                                    "step 1";
                                    result.bool = player.chooseBool("是否进行一次判定并将判定牌称为“股”置于武将牌上");
                                    "step 2";
                                    if (result.bool) {
                                        player.logSkill("sw_shangshi");
                                        player.judge(card => 1).callback = lib.skill.sw_shangshi.callback;
                                    }
                                },
                                callback: function () {
                                    if (typeof card.number == "number") {

                                        if (!card.storage) card.storage = {};
                                        card.storage.sw_shangshi_hidden = true;
                                        lib.skill.sw_shangshi.broadcast(card);

                                        player.addToExpansion(card, "gain2").gaintag.add("sw_shangshi");
                                        player.popup("判定生效", "wood");
                                    }
                                },
                                marktext: "股",
                                intro: {
                                    markcount: "expansion",
                                    mark(dialog, content, player) {
                                        const cards = player.getExpansions("sw_shangshi"),
                                            hidden = cards.filter(card => !card.storage.sw_shangshi_hidden),
                                            dis = cards.removeArray(hidden);
                                        dialog.addText("股票形势");
                                        if (dis.length) dialog.addSmall(dis);
                                        else dialog.addText("暂无明股");
                                        if (hidden.length) {
                                            return "此外，还有" + get.cnNumber(hidden.length) + "张暗“股”，在无形间改变股票形势";
                                        }
                                    },
                                    content(content, player) {
                                        const cards = player.getExpansions("sw_shangshi"),
                                            hidden = cards.filter(card => card.storage.sw_shangshi_hidden),
                                            dis = cards.removeArray(hidden);
                                        dialog.addText("股票形势");
                                        if (dis.length) dialog.addSmall(dis);
                                        else dialog.addText("暂无明股");
                                        if (hidden.length) {
                                            return "此外，还有" + get.cnNumber(hidden.length) + "张暗“股”，在无形间改变股票形势";
                                        }
                                    },
                                },
                                onremove: function (player, skill) {//失去技能时失去所有的股票牌
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                    player.storage.sw_shangshi_record = {};
                                },
                                group: ["sw_shangshi_1", "sw_shangshi_2"],
                                subSkill: {
                                    1: {
                                        forced: true,
                                        trigger: { global: "phaseZhunbeiBegin" },
                                        popup: false,
                                        filter(trigger, player) {
                                            return trigger.player !== player && player.getExpansions("sw_shangshi").length;
                                        },

                                        async content(event, trigger, player) {
                                            const target = trigger.player
                                            player.logSkill("sw_shangshi");
                                            player.line(trigger.player);
                                            var num = lib.skill.sw_shangshi.getInfo(player)[1];
                                            var list = [], choiceList = ["将一张牌称为“股”置于" + get.translation(player) + "的武将牌上", "失去" + num + "点体力"];
                                            if (game.hasPlayer(target => target.countCards("he"))) list.push("入“股”");
                                            else choiceList[0] = '<span style="opacity:0.5">' + choiceList[0] + "</span>";
                                            list.push("失去体力");
                                            var str = "";
                                            for (var i of list) {
                                                str += i;
                                                str += "、";
                                            }
                                            str = str.slice(0, -1);
                                            list = list.filter(control => {
                                                if (control == "失去体力") return true;
                                                return target.countDiscardableCards(target, "he");
                                            });


                                            const {
                                                result: { control },
                                            } = await target.chooseControl(list)
                                                .set("prompt", "【上市②】：请选择一项")
                                                .set(
                                                    "choiceList",
                                                    choiceList.map(str => str)
                                                )
                                                .set("target", target);
                                            switch (control) {
                                                case "入“股”":
                                                    const {
                                                        result: { bool, cards },
                                                    } = await trigger.player.chooseCard("he", choiceList[0], true);
                                                    if (bool) {
                                                        //target.$throw(cards, 1000);
                                                        target.lose(cards, ui.cardPile, "insert");
                                                        game.log(target, "将" + get.cnNumber(cards.length) + "张牌置于了牌堆顶");
                                                        player.addToExpansion(cards, target, "draw").gaintag.add("sw_shangshi");
                                                        //投股记录
                                                        for (var k of cards) {
                                                            var color = get.color(k);
                                                            if (!target.storage.sw_shangshi_record) target.storage.sw_shangshi_record = 0;
                                                            if (color == "red") target.storage.sw_shangshi_record += 1;
                                                        }
                                                    }
                                                    break;
                                                case "失去体力":
                                                    target.loseHp(num);
                                                    break;
                                            }
                                            player.judge(card => 1).callback = lib.skill.sw_shangshi.callback;
                                        },
                                    },
                                    2: {
                                        forced: true,
                                        mod: {
                                            maxHandcard: function (player, num) {
                                                return num + lib.skill.sw_shangshi.getInfo(player)[0];
                                            },
                                        },
                                    },
                                },
                            },
                            sw_kaipan: {
                                audio: ["dcjinjin", 2],
                                trigger: { player: "phaseZhunbeiBegin" },
                                forced: true,
                                filter(trigger, player) {
                                    return player.getExpansions("sw_shangshi").length;
                                },
                                content: function () {
                                    "step 0";
                                    player
                                        .chooseControl("<span class=firetext>涨涨涨</span>", "<span class=greentext>跌跌跌</span>")
                                        .set("prompt", "请预测股票：")
                                        .set("ai", function () {
                                            return Math.Random();
                                        });
                                    "step 1";
                                    event.boolGuPiao = (result.control == "<span class=firetext>涨涨涨</span>");
                                    //alert(event.boolGuPiao);
                                    var cards = player.getExpansions("sw_shangshi");
                                    var zhang = 0, die = 0;
                                    for (var k of cards) {
                                        if (get.color(k) == "red") zhang += get.number(k);
                                        if (get.color(k) == "black") die += get.number(k);
                                    }
                                    var res = zhang > die;
                                    event.boolRes = res;
                                    var str = `${get.translation(player)}的股票开盘！！：<br>涨幅度：<span class=firetext>${zhang}</span>  跌幅度：<span class=greentext>${die}</span><br>预测结果：${res == event.boolGuPiao ? "<span class=greentext>正确！</span>" : "<span class=firetext>错误！</span>"}`;
                                    //var dialog = ui.create.dialog(str, cards, true);
                                    event.videoId = lib.status.videoId++;
                                    game.broadcastAll(
                                        function (ss, cards, id) {
                                            var dialog = ui.create.dialog(ss, cards, true);
                                            dialog.videoId = id;
                                        },
                                        str,
                                        cards,
                                        event.videoId
                                    );
                                    game.delay(7);
                                    "step 2";
                                    game.broadcastAll('closeDialog', event.videoId);
                                    var targets = game.filterPlayer().sortBySeat(player);
                                    for (var k of targets) {
                                        if (k.storage.sw_shangshi_record) {
                                            if (event.boolRes) k.draw(2 * k.storage.sw_shangshi_record);
                                            else k.loseHp(k.storage.sw_shangshi_record);
                                        }
                                        k.storage.sw_shangshi_record = 0;
                                    }
                                    if (event.boolGuPiao == event.boolRes) {
                                        if (event.boolRes) {
                                            player.addTempSkill("dcjinjing");
                                            player.addTempSkill("sw_ziben");
                                        }
                                        else {
                                            player.recover();
                                            player.addTempSkill("fankui", { player: "phaseZhunbeiBegin" });
                                        }
                                    }
                                    else {
                                        var list = lib.skill.sw_shangshi.getInfo(player);
                                        var index = 0;
                                        if (!event.boolRes) index = 1;
                                        list[index] = Math.max(0, list[index] - 1);
                                        game.log(player, "将【上市", index == 0 ? "①" : "②", "】数字改为", "#y" + list[index]);
                                        player.markSkill("sw_shangshi");
                                    }
                                    "step 3";
                                    var cards = player.getExpansions("sw_shangshi");
                                    if (cards.length) {
                                        player.loseToDiscardpile(cards);

                                        for (var card of cards) {
                                            if (card && card.storage) {
                                                card.storage.sw_shangshi_hidden = false;
                                                lib.skill.sw_shangshi.broadcast(card);
                                            }
                                        }

                                        //game.broadcastAll(function (c) {
                                        //	for(var k of c){
                                        //		c.storage.sw_shangshi_hidden = false;
                                        //	}
                                        //}, cards);
                                    }

                                },
                            },
                            sw_ziben: {
                                trigger: { source: "damageEnd" },
                                logTarget: "player",
                                frequent: true,
                                forced: false,
                                filter: function (event, player) {
                                    if (event._notrigger.includes(event.player)) return false;
                                    return event.player != player && event.player.isIn() && event.player.countGainableCards(player, "hej") > 0;
                                },
                                check: function () {
                                    return false;
                                },
                                content: function () {
                                    player.gainPlayerCard(trigger.player, "he", false);
                                    player.line(trigger.player, "green");
                                },
                            },
                            qd_kelian: {
                                trigger: { player: "damageBefore" },
                                forced: true,
                                filter: function (event) {
                                    return event.source && event.source.isIn();
                                },
                                content: function () {
                                    if (!trigger.source.hasSkill("qd_kelian_mark2")) trigger.source.addSkill("qd_kelian_mark2");
                                    trigger.source.addMark("qd_kelian_mark2", 1);
                                    if (!player.hasSkill("qd_kelian_mark")) player.addSkill("qd_kelian_mark");
                                    player.addMark("qd_kelian_mark", trigger.num);
                                },
                                subSkill: {
                                    mark: {
                                        trigger: { player: "phaseBefore" },
                                        forced: true,
                                        content: function () {
                                            player.removeMark("qd_kelian_mark", trigger.player.countMark("qd_kelian_mark"));
                                            player.removeSkill("qd_kelian_mark");
                                        },
                                        mark: true,
                                        direct: true,
                                        marktext: "玉",
                                        intro: {
                                            name: "惜玉",
                                            content: function (storage) {
                                                if (storage > 0) {
                                                    return "其他角色计算与你的距离时+" + storage;
                                                } else if (storage < 0) {
                                                    return "其他角色计算与你的距离时" + storage;
                                                } else {
                                                    return "无距离变化";
                                                }
                                            },
                                        },
                                        init: function (player) {
                                            if (typeof player.storage.qd_kelian_mark != "number") player.storage.qd_kelian_mark = 0;
                                        },
                                        mod: {
                                            globalTo: function (from, to, distance) {
                                                if (typeof to.storage.qd_kelian_mark == "number") {
                                                    return distance + to.storage.qd_kelian_mark;
                                                }
                                            },
                                        },
                                    },
                                    mark2: {
                                        mark: true,
                                        direct: true,
                                        marktext: "惜",
                                        intro: {
                                            name: "惜玉",
                                            content: "跳过下个摸牌阶段",
                                        },
                                        trigger: { player: "phaseDrawBefore" },
                                        forced: true,
                                        content: function () {
                                            trigger.cancel();
                                            trigger.player.removeMark("qd_kelian_mark2", trigger.player.countMark("qd_kelian_mark2"));
                                            trigger.player.removeSkill("qd_kelian_mark2");
                                        },
                                    },
                                },
                            },
                            qd_tongpin2: {
                                //audio: 2,
                                group: ["qd_tongpin2_0", "qd_tongpin2_1", "qd_tongpin2_2", "qd_tongpin2_3"],
                                subSkill: {
                                    0: {
                                        trigger: { global: "damageBegin3" },
                                        filter(event, player) {
                                            if (player.hasSkill("qd_tongpin2_round")) return false;
                                            return event.player && event.player.isIn() && event.player.hasMark("qd_tongpin_mark") && player.countCards("he") >= event.num;
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            //"step 0";
                                            const num = trigger.num;
                                            const {
                                                result: { bool },
                                            } = await player.chooseToDiscard("he", num, get.prompt("qd_tongpin2", trigger.target), "弃置" + num + "张牌，并转移" + num + "点伤害给自己");
                                            //"step 1";
                                            if (bool) {
                                                player.discard(event.cards);
                                                player.damage(trigger.source ? trigger.source : "nosource");
                                                player.line(trigger.player);
                                                player.addTempSkill("qd_tongpin2_round", "roundStart");
                                                trigger.cancel();
                                            }
                                        },
                                    },
                                    1: {
                                        trigger: { global: "damageEnd" },
                                        filter(event, player) {
                                            return event.player && event.player.isIn() && event.player.hasMark("qd_tongpin_mark");
                                        },
                                        forced: true,
                                        logTarget: "player",
                                        content() {
                                            //trigger.player.recover(trigger.player.countMark("qd_tongpin_mark"));
                                            if (!player.hasSkill("qd_tongpin2_round")) {
                                                player.recover(trigger.player.countMark("qd_tongpin_mark"));
                                                player.addTempSkill("qd_tongpin2_round", "roundStart");
                                            }
                                            trigger.player.removeMark("qd_tongpin_mark", trigger.player.countMark("qd_tongpin_mark"));
                                            trigger.player.removeSkill("qd_tongpin_mark");
                                            if (player.isTurnedOver()) player.turnOver(false);
                                            player.removeSkill("qd_tongpin2");
                                            player.line(trigger.player);
                                        },
                                    },
                                    2: {
                                        trigger: {
                                            player: "turnOverBefore",
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.hasMark("qd_tongpin_mark");
                                            });
                                        },
                                        content() {
                                            //player.logSkill("qd_tongpin");
                                            trigger.cancel();
                                        },
                                    },
                                    3: {
                                        trigger: {
                                            player: "damageBegin4",
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.hasMark("qd_tongpin_mark");
                                            });
                                        },
                                        content() {
                                            //player.logSkill("qd_tongpin");
                                            trigger.cancel();
                                        },
                                    },
                                    round: {
                                        mark: true,
                                        marktext: "守",
                                        intro: { name: "同嫁", content: "本轮的伤害转移已使用" },
                                    },
                                },
                            },
                            qd_tongpin: {
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget: function (card, player, target) {
                                    return target != player;
                                },
                                content() {
                                    "step 0";
                                    player.line(target);
                                    if (!player.isTurnedOver()) player.turnOver(true);
                                    "step 1";
                                    target.addSkill("qd_tongpin_mark");
                                    target.addMark("qd_tongpin_mark", 1);
                                    player.addSkill("qd_tongpin2");
                                },
                                subSkill: {
                                    mark: {
                                        trigger: { source: "damageBegin1" },
                                        forced: true,
                                        charlotte: true,
                                        filter: function (event, player) {
                                            return event.card.name == "sha";
                                        },
                                        content() {
                                            trigger.num++;
                                            game.log(player, "造成了", "#y暴击伤害");
                                        },
                                        marktext: "嫁",
                                        intro: {
                                            name: "同嫁",
                                            content: function (storage, player) {
                                                return "有女同嫁给了你！";
                                            },
                                        },
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (player.hasMark("qd_tongpin_mark") && card.name == "sha")
                                                    return (
                                                        num +
                                                        game.countPlayer(function (current) {
                                                            return current.hasSkill("qd_tongpin");
                                                        })
                                                    );
                                            },
                                        },
                                    },
                                },

                            },
                            qd_zhinang: {
                                audio: 2,
                                trigger: { player: "useCardEnd", },
                                forced: true,
                                filter(event, player) {
                                    return get.zhinangs().includes(event.card.name) && event.card.isCard && event.cards && event.cards.length == 1;
                                },
                                content() {
                                    "step 0";
                                    if (!_status.dunshi_list) {
                                        var list,
                                            skills = [];
                                        //var banned = ["xunyi", "mbyilie"];
                                        if (get.mode() == "guozhan") {
                                            list = [];
                                            for (var i in lib.characterPack.mode_guozhan) list.push(i);
                                        } else if (_status.connectMode) list = get.charactersOL();
                                        else {
                                            list = [];
                                            for (var i in lib.character) {
                                                if (lib.filter.characterDisabled2(i) || lib.filter.characterDisabled(i)) continue;
                                                list.push(i);
                                            }
                                        }
                                        for (var i of list) {
                                            if (i.indexOf("gz_jun") == 0) continue;
                                            for (var j of lib.character[i][3]) {
                                                var skill = lib.skill[j];
                                                if (!skill || skill.zhuSkill) continue;
                                                if (skill.ai && (skill.ai.combo || skill.ai.notemp || skill.ai.neg)) continue;
                                                var info = get.translation(j + "_info");
                                                for (var ix = 0; ix < info.length - 4; ix++) {
                                                    // 匹配四字成语
                                                    if (/无懈可击|过河拆桥|顺手牵羊|无中生有|乐不思蜀/.test(info.substring(ix, ix + 4))) {
                                                        skills.add(j);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        _status.dunshi_list = skills;
                                    }
                                    var list = _status.dunshi_list
                                        .filter(function (i) {
                                            return !player.hasSkill(i, null, null, false);
                                        })
                                        .randomGets(3);
                                    if (list.length == 0) game.log(player, "没有技能可选");
                                    else {
                                        event.videoId = lib.status.videoId++;
                                        var func = function (skills, id, target) {
                                            var dialog = ui.create.dialog("forcebutton");
                                            dialog.videoId = id;
                                            dialog.add("选择一个技能获得");
                                            for (var i = 0; i < skills.length; i++) {
                                                dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">【' + get.translation(skills[i]) + "】</div><div>" + lib.translate[skills[i] + "_info"] + "</div></div>");
                                            }
                                            dialog.addText(" <br> ");
                                        };
                                        func(list, event.videoId, player);
                                        player.chooseControl(list).set("ai", function () {
                                            var controls = _status.event.controls;
                                            if (controls.includes("cslilu")) return "cslilu";
                                            if (controls.includes("zhichi")) return "zhichi";
                                            return controls[0];
                                        });
                                    }
                                    "step 1";
                                    game.broadcastAll("closeDialog", event.videoId);
                                    player.addSkills(result.control);
                                },
                            },
                            qd_jincui: {
                                audio: ["dcjincui", 2],
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                forced: true,
                                charlotte: true,
                                filter: function (event, player) {
                                    return true;
                                },
                                content: function () {
                                    var num = 0;
                                    for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
                                        var card = ui.cardPile.childNodes[i];
                                        if (get.zhinangs().includes(card.name)) num++;
                                    }
                                    game.log(player, "牌堆中剩余智囊数：" + num.toString());
                                    if (num > 9) {
                                        player.draw();
                                        player.gainMaxHp();
                                    }
                                    if (num >= 7) {
                                        player.addTempSkill("qd_jincui_buff", { player: "phaseAfter" });
                                        player.addMark("qd_jincui_buff", 1, false);
                                    }
                                    if (num < 7) {
                                        if (player.MaxHp > 3) player.loseMaxHp(1);
                                    }
                                },
                                group: "dcsbpingliao_hide",
                                subSkill: {
                                    hide: {
                                        trigger: { player: "useCard0" },
                                        forced: true,
                                        filter(event, player) {
                                            return event.card.name == "sha";
                                        },
                                        async content(event, trigger, player) {
                                            ;
                                        },
                                    },
                                    buff: {
                                        onremove: true,
                                        charlotte: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == "sha") return num + player.countMark("qd_jincui_buff");
                                            },
                                        },
                                        mark: true,
                                        intro: {
                                            content: "本阶段内使用【杀】的次数上限+#",
                                        },
                                    },
                                },
                            },
                            qd_kanpo: {
                                init: function (player) {
                                    if (!player.storage.sbkanpo) {
                                        player.storage.sbkanpo = [12, [], []];
                                        player.markSkill("sbkanpo");
                                    }
                                },
                                audio: ["sbkanpo", 2],
                                trigger: { global: "roundStart" },
                                filter: function (event, player) {
                                    var storage = player.storage.sbkanpo;
                                    return storage[0] || storage[1].length;
                                },
                                forced: true,
                                locked: false,
                                content: function* (event, map) {
                                    var player = map.player,
                                        storage = player.storage.sbkanpo;
                                    var sum = storage[0];
                                    storage[1] = [];
                                    player.markSkill("sbkanpo");
                                    if (!sum) {
                                        "step 0";
                                        if (player.hasSkill("qd_kanpo")) player.removeSkill("qd_kanpo");
                                        player.addSkill("qd_jincui");
                                        var cards = [];
                                        for (var i of get.zhinangs()) {
                                            var card = get.cardPile2(function (card) {
                                                return card.name == i;
                                            });
                                            if (card) cards.push(card);
                                        }
                                        if (cards.length) player.gain(cards, "gain2");
                                        return;
                                    }
                                    const list = get.inpileVCardList(info => {
                                        if (info[2] == "sha" && info[3]) return false;
                                        //return info[0] != "equip";
                                        return true;
                                    });
                                    const func = () => {
                                        const event = get.event();
                                        const controls = [
                                            link => {
                                                const evt = get.event();
                                                if (evt.dialog && evt.dialog.buttons) {
                                                    for (let i = 0; i < evt.dialog.buttons.length; i++) {
                                                        const button = evt.dialog.buttons[i];
                                                        button.classList.remove("selectable");
                                                        button.classList.remove("selected");
                                                        const counterNode = button.querySelector(".caption");
                                                        if (counterNode) {
                                                            counterNode.childNodes[0].innerHTML = ``;
                                                        }
                                                    }
                                                    ui.selected.buttons.length = 0;
                                                    game.check();
                                                }
                                                return;
                                            },
                                        ];
                                        event.controls = [ui.create.control(controls.concat(["清除选择", "stayleft"]))];
                                    };
                                    if (event.isMine()) func();
                                    else if (event.isOnline()) event.player.send(func);
                                    var result = yield player
                                        .chooseButton(["看破：是否记录至多" + get.cnNumber(sum) + "个牌名？", [list, "vcard"]], [1, sum], false)
                                        .set("ai", function (button) {
                                            //if (ui.selected.buttons.length >= Math.max(3, game.countPlayer() / 2)) return 0;
                                            switch (button.link[2]) {
                                                case "wuxie":
                                                    return 5 + Math.random();
                                                case "sha":
                                                    return 5 + Math.random();
                                                case "tao":
                                                    return 4 + Math.random();
                                                case "jiu":
                                                    return 3 + Math.random();
                                                case "lebu":
                                                    return 3 + Math.random();
                                                case "shan":
                                                    return 4.5 + Math.random();
                                                case "wuzhong":
                                                    return 4 + Math.random();
                                                case "shunshou":
                                                    return 2.7 + Math.random();
                                                case "nanman":
                                                    return 2 + Math.random();
                                                case "wanjian":
                                                    return 1.6 + Math.random();
                                                default:
                                                    return 1.5 + Math.random();
                                            }
                                        })
                                        //.set("filterButton", button => {
                                        //    return !_status.event.names.includes(button.link[2]);
                                        //})
                                        .set("names", storage[2])
                                        .set("custom", {
                                            add: {
                                                confirm: function (bool) {
                                                    if (bool != true) return;
                                                    const event = get.event().parent;
                                                    if (event.controls) event.controls.forEach(i => i.close());
                                                    if (ui.confirm) ui.confirm.close();
                                                    game.uncheck();
                                                },
                                                button: function () {
                                                    if (ui.selected.buttons.length) return;
                                                    const event = get.event();
                                                    if (event.dialog && event.dialog.buttons) {
                                                        for (let i = 0; i < event.dialog.buttons.length; i++) {
                                                            const button = event.dialog.buttons[i];
                                                            const counterNode = button.querySelector(".caption");
                                                            if (counterNode) {
                                                                counterNode.childNodes[0].innerHTML = ``;
                                                            }
                                                        }
                                                    }
                                                    if (!ui.selected.buttons.length) {
                                                        const evt = event.parent;
                                                        if (evt.controls) evt.controls[0].classList.add("disabled");
                                                    }
                                                },
                                            },
                                            replace: {
                                                button: function (button) {
                                                    const event = get.event(),
                                                        sum = event.sum;
                                                    if (!event.isMine()) return;
                                                    if (button.classList.contains("selectable") == false) return;
                                                    if (ui.selected.buttons.length >= sum) return false;
                                                    button.classList.add("selected");
                                                    ui.selected.buttons.push(button);
                                                    let counterNode = button.querySelector(".caption");
                                                    const count = ui.selected.buttons.filter(i => i == button).length;
                                                    if (counterNode) {
                                                        counterNode = counterNode.childNodes[0];
                                                        counterNode.innerHTML = `×${count}`;
                                                    } else {
                                                        counterNode = ui.create.caption(`<span style="font-size:24px; font-family:xinwei; text-shadow:#FFF 0 0 4px, #FFF 0 0 4px, rgba(74,29,1,1) 0 0 3px;">×${count}</span>`, button);
                                                        counterNode.style.right = "5px";
                                                        counterNode.style.bottom = "2px";
                                                    }
                                                    const evt = event.parent;
                                                    if (evt.controls) evt.controls[0].classList.remove("disabled");
                                                    game.check();
                                                },
                                            },
                                        })
                                        .set("sum", sum);
                                    if (result.bool) {
                                        var names = result.links.map(link => link[2]);
                                        storage[0] -= names.length;
                                        storage[1] = names;
                                        storage[2] = names;
                                    } else storage[2] = [];
                                    player.markSkill("sbkanpo");
                                },
                                marktext: "破",
                                intro: {
                                    markcount: function (storage) {
                                        return storage[1].length;
                                    },
                                    mark: function (dialog, content, player) {
                                        const storage = player.getStorage("sbkanpo");
                                        const sum = storage[0];
                                        const names = storage[1];
                                        dialog.addText("剩余可记录" + sum + "次牌名");
                                        if (player.isUnderControl(true) && names.length) {
                                            dialog.addText("本轮记录牌名：");
                                            dialog.addSmall([names, "vcard"]);
                                        }
                                    },
                                },
                                group: "sbkanpo_kanpo",
                                subSkill: {
                                    kanpo: {
                                        audio: "sbkanpo",
                                        trigger: { global: "useCard" },
                                        filter: function (event, player) {
                                            return event.player != player && player.storage.sbkanpo[1].includes(event.card.name);
                                        },
                                        prompt2: function (event, player) {
                                            return "移除" + get.translation(event.card.name) + "的记录，令" + get.translation(event.card) + "无效";
                                        },
                                        check: function (event, player) {
                                            var effect = 0;
                                            if (event.card.name == "wuxie" || event.card.name == "shan") {
                                                if (get.attitude(player, event.player) < -1) effect = -1;
                                            } else if (event.targets && event.targets.length) {
                                                for (var i = 0; i < event.targets.length; i++) {
                                                    effect += get.effect(event.targets[i], event.card, event.player, player);
                                                }
                                            }
                                            if (effect < 0) {
                                                if (event.card.name == "sha") {
                                                    var target = event.targets[0];
                                                    if (target == player) return !player.countCards("h", "shan");
                                                    else return target.hp == 1 || (target.countCards("h") <= 2 && target.hp <= 2);
                                                } else return true;
                                            }
                                            return false;
                                        },
                                        logTarget: "player",
                                        content: function () {
                                            player.storage.sbkanpo[1].remove(trigger.card.name);
                                            player.markSkill("sbkanpo");
                                            trigger.targets.length = 0;
                                            trigger.all_excluded = true;
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            qd_nanchong: {
                                audio: ["dchaochong", 2],
                                trigger: { player: "useCardAfter" },
                                filter: function (event, player) {
                                    return player.maxHp != player.countCards("h");
                                },
                                direct: true,
                                locked: false,
                                content: function () {
                                    "step 0";
                                    var del = player.maxHp - player.countCards("h");
                                    event.delta = del;
                                    if (del > 0) {
                                        player.chooseBool(get.prompt("qd_nanchong"), "摸" + get.cnNumber(del) + "张牌，然后令你的体力上限-1").set("ai", () => {
                                            var player = _status.event.player;
                                            if (player.isPhaseUsing() && player.hasCard(cardx => player.hasUseTarget(cardx) && player.hasValueTarget(cardx), "hs")) return false;
                                            return true;
                                        });
                                    } else if (del < 0) {
                                        player
                                            .chooseToDiscard(get.prompt("qd_nanchong"), "弃置" + get.cnNumber(-del) + "张手牌，然后令你的体力上限+1", -del)
                                            .set("ai", card => {
                                                var player = _status.event.player;
                                                if (player.isPhaseUsing() && player.hasCard(cardx => player.hasValueTarget(cardx), "hs")) return 6 - player.getUseValue(card);
                                                return 5 - get.value(card);
                                            })
                                            .set("logSkill", "qd_nanchong");
                                    }
                                    "step 1";
                                    if (result.bool) {
                                        if (event.delta > 0) {
                                            player.logSkill("qd_nanchong");
                                            player.draw(event.delta);
                                            //lib.skill.qd_nanchong.change(player, -1);
                                            player.loseMaxHp();
                                        } else if (event.delta < 0) {
                                            //lib.skill.qd_nanchong.change(player, 1);
                                            player.gainMaxHp();
                                        }
                                    }
                                },
                                change: function (player, num) {
                                    if (typeof player.storage.qd_nanchong !== "number") player.storage.qd_nanchong = 0;
                                    if (!num) return;
                                    player.storage.qd_nanchong += num;
                                    player.markSkill("qd_nanchong");
                                    game.log(player, "的手牌上限", "#g" + (num > 0 ? "+" : "") + num);
                                },
                                markimage: "image/card/handcard.png",
                                intro: {
                                    content: function (storage, player) {
                                        var num = player.storage.qd_nanchong;
                                        return "手牌上限" + (num >= 0 ? "+" : "") + num;
                                    },
                                },
                                mod: {
                                    maxHandcard: function (player, num) {
                                        return num + player.countMark("qd_nanchong");
                                    },
                                },
                                ai: { threaten: 2.2 },
                            },
                            qd_weige: {
                                audio: ["dcjinjin", 2],
                                trigger: {
                                    source: "damageSource",
                                    player: "damageEnd",
                                },
                                usable: 2,
                                logTarget: "source",
                                check: function (event, player) {
                                    if (player.maxHp == 7) return true;
                                    var evt = event.getParent("useCard");
                                    if (evt && evt.player == player && event.source == player) return false;
                                    if (player.isPhaseUsing() && player.maxHp - 7 == -1) return true;
                                    return Math.abs(7 - player.maxHp) >= 2;
                                },
                                prompt2: function (event, player) {
                                    var str = "";
                                    if (player.maxHp != 7) {
                                        str += "重置因〖男宠〗增加或减少的体力上限，";
                                    }
                                    var num = Math.abs(7 - player.maxHp) || 1;
                                    if (event.source && event.source.isIn()) {
                                        str += "令伤害来源弃置至多" + get.cnNumber(num) + "张牌，然后你摸" + num + "-X张牌（X为其弃置的牌数）";
                                    } else str += "你摸" + get.cnNumber(num) + "张牌";
                                    return str;
                                },
                                content: function () {
                                    "step 0";
                                    var del = Math.abs(7 - player.maxHp) || 1;
                                    event.delta = del;
                                    //player.storage.dchaochong = 0;
                                    if (7 - player.maxHp > 0) player.gainMaxHp(7 - player.maxHp);
                                    else player.loseMaxHP(player.maxHp - 7);
                                    if (player.hasSkill("qd_nanchong", null, false, false)) player.markSkill("qd_nanchong");
                                    game.log(player, "重置了体力上限");
                                    if (trigger.source && trigger.source.isIn()) {
                                        trigger.source
                                            .chooseToDiscard(get.translation(player) + "对你发动了【伟哥】", "弃置至多" + get.cnNumber(del) + "张牌，然后" + get.translation(player) + "摸" + del + "-X张牌（X为你弃置的牌数）。", [1, del], "he")
                                            .set("ai", card => {
                                                if (_status.event.goon) return 5.5 - get.value(card);
                                                return 0;
                                            })
                                            .set("goon", get.attitude(trigger.source, player) < 0);
                                    }
                                    "step 1";
                                    var num = event.delta;
                                    if (result.bool) num -= result.cards.length;
                                    if (num > 0) player.draw(num);
                                },
                                ai: {
                                    combo: "qd_nanchong",
                                    maixie: true,
                                    maixie_hp: true,
                                    threaten: 0.85,
                                    effect: {
                                        target: function (card, player, target) {
                                            if (get.tag(card, "damage")) {
                                                if (player.hasSkillTag("jueqing", false, target)) return [1, -2];
                                                if (!target.hasFriend()) return;
                                                var num = 0;
                                                if (typeof target.storage.dcninchong == "number") num = Math.abs(target.storage.dcninchong);
                                                if (num <= 0) return;
                                                return [1, Math.min(1, num / 3)];
                                            }
                                        },
                                    },
                                },
                            },
                            qd_tonghun_xianfu: {
                                charlotte: true,
                                trigger: { global: ["drawEnd", "recoverEnd"] },
                                forced: true,
                                filter(event, player) {
                                    if (event.player.isDead() || !player.storage.qd_tonghunTargets || !player.storage.qd_tonghunTargets.includes(event.player) || event.num <= 0) return false;
                                    return true
                                },
                                async content(event, trigger, player) {
                                    const name = event.triggername
                                    if (name === 'drawEnd') {
                                        await player.draw(trigger.num)
                                    }
                                    if (name === 'recoverEnd') {
                                        await player.recover(trigger.num)
                                    }
                                },
                                popup: false,
                            },
                            qd_dianmanzu: {
                                init(player) {
                                    player.storage.qd_dianmanzu = ['equip', 'trick', 'basic']
                                },
                                mark: true,
                                marktext: "剩",
                                intro: {
                                    name: "满足",
                                    content(err, { storage }) {
                                        if (!storage.qd_dianmanzu.length) {
                                            return '本回合全都触发过了，牌序不错'
                                        }
                                        return '剩余[' + get.translation(storage.qd_dianmanzu) + ']这类型没有触发过'
                                    },
                                    markcount(err, { storage }) {
                                        return (storage.qd_dianmanzu.length || 0).toString();
                                    },
                                },
                                group: ['qd_dianmanzu_1', 'qd_dianmanzu_2', 'qd_dianmanzu_3', 'qd_dianmanzu_end'],
                                subSkill: {
                                    "1": {
                                        trigger: {
                                            player: ["useCard", "respond"],
                                        },
                                        filter(e, player) {
                                            return player.storage.qd_dianmanzu.includes('equip') && player.countCards('h', { type: 'equip' }) === 1
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseBool('是否摸两张牌？').forResult()
                                        },
                                        async content(event, trigger, player) {
                                            await player.draw(2)
                                            player.storage.qd_dianmanzu.remove('equip')
                                        },
                                    },
                                    "2": {
                                        trigger: {
                                            player: ["useCard", "respond"],
                                        },
                                        filter(e, player) {
                                            return player.storage.qd_dianmanzu.includes('trick') && player.countCards('h', { type: 'trick' }) === 2
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget('弃置一名角色区域内的一张牌').set('ai', target => {
                                                const att = get.attitude(_status.event.player, target)
                                                if (att > 0 && target.countCards('j') && !target.hasCard('shandian', 'j')) {
                                                    return 10
                                                }
                                                return att
                                            }).forResult()
                                        },
                                        async content(event, trigger, player) {
                                            for await (const target of event.targets) {
                                                await player.discardPlayerCard(target, true, "hej");
                                            }
                                            player.storage.qd_dianmanzu.remove('trick')
                                        },
                                    },
                                    "3": {
                                        trigger: {
                                            player: ["useCard", "respond"],
                                        },
                                        filter(e, player) {
                                            return player.storage.qd_dianmanzu.includes('basic') && player.countCards('h', { type: 'basic' }) === 3
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget('令一名角色失去一点体力值').set('ai', target => {
                                                return get.attitude(_status.event.player, target)
                                            }).forResult()
                                        },
                                        async content(event, trigger, player) {
                                            for await (const target of event.targets) {
                                                await target.loseHp()
                                            }
                                            player.storage.qd_dianmanzu.remove('basic')
                                        },
                                    },
                                    'end': {
                                        trigger: { player: 'phaseEnd' },
                                        forced: true,
                                        charlotte: true,
                                        popup: false,
                                        async content(event, trigger, player) { player.storage.qd_dianmanzu = ['equip', 'trick', 'basic'] }
                                    }
                                }
                            },
                            qd_dunwu: {
                                init() {
                                    if (!_status.cardTypeList) lib.skill.qd_weiwo.getCardTypeList()
                                },
                                trigger: {
                                    player: 'damageEnd',
                                    source: "damageSource"
                                },
                                async cost(event, trigger, player) {
                                    const result = await player.chooseControl(_status.cardTypeList, 'cancel').set('prompt', '请选择一种类型').forResult()
                                    event.result = {
                                        bool: result.control !== 'cancel',
                                        cost_data: result.control
                                    }
                                },
                                usable: 1,
                                async content(event, trigger, player) {
                                    const card = get.cardPile(card => {
                                        return get.type2(card) === event.cost_data
                                    })
                                    if (card) {
                                        await player.gain(card, 'gain2')
                                    }
                                },
                            },
                            qd_buman: {
                                group: ['qd_buman_all', 'qd_buman_show'],
                                init(player) {
                                    player.markSkill('qd_buman_all')
                                    player.storage.qd_buman = [1, 2, 3]
                                },
                                mark: true,
                                marktext: "满",
                                intro: {
                                    name: "不满",
                                    content(err, { storage }) {
                                        return '剩余' + get.translation(storage.qd_buman)
                                    }
                                },
                                subSkill: {
                                    all: {
                                        forced: true,
                                        trigger: { player: 'showCardsEnd' },
                                        filter(trigger) {
                                            return trigger.cards && trigger.cards.length > 0
                                        },
                                        async content(event, trigger, player) {
                                            player.addMark('qd_buman_show', trigger.cards.length)
                                            const mark = player.countMark('qd_buman_show')
                                            if (mark >= 8 && player.storage.qd_buman.includes(1)) {
                                                await player.draw(3)
                                                player.storage.qd_buman.remove(1)
                                            }
                                            if (mark >= 16 && player.storage.qd_buman.includes(2)) {
                                                player.addSkill('qd_buman_add')
                                                player.storage.qd_buman.remove(2)
                                            }
                                            if (mark >= 32 && player.storage.qd_buman.includes(3)) {
                                                player.addSkill('qd_buman_numadd')
                                                player.storage.qd_buman.remove(3)
                                            }
                                            if (player.storage.qd_buman.length === 0) {
                                                event.trigger('manleOK')
                                            }
                                        },
                                        mark: true,
                                        marktext: "不",
                                        intro: {
                                            name: "不满",
                                            markcount(err, { storage }) {
                                                return (storage.qd_buman_show || 0).toString();
                                            },
                                            content(err, { storage }) {
                                                return "本局游戏展示过" + (storage.qd_buman_show || 0).toString() + "张牌";
                                            },
                                        },
                                    },
                                    show: {
                                        trigger: {
                                            player: ['useCard', 'damageEnd'],
                                            source: "damageSource"
                                        },
                                        filter(trigger, player, name) {
                                            if (name === 'damageSource' || name === 'damageEnd') {
                                                return true
                                            }
                                            if (name === 'useCard') {
                                                const type = get.type2(trigger.card)
                                                if (type === 'trick') return true
                                                return type === 'basic' && player.hp > 0
                                            }
                                            return true
                                        },
                                        prompt(trigger, player, name) {
                                            const x = lib.skill.qd_buman_show.getX(get.type2(trigger.card), name, player)
                                            return `是否展示牌堆顶的${x}张牌？`
                                        },
                                        getX(type, name, player) {
                                            let x;
                                            if (name === 'damageEnd' || type === 'trick') x = player.getDamagedHp()
                                            if (name === 'damageSource' || type === 'basic') x = player.hp
                                            return x
                                        },
                                        async content(event, trigger, player) {
                                            const name = event.triggername
                                            const type = get.type2(trigger.card)
                                            const x = lib.skill.qd_buman_show.getX(get.type2(trigger.card), name, player)
                                            const bool = name === 'damageEnd' || type === 'trick'//判断一下是不是受伤或者出锦囊，如果是，那就要从底部拿牌然后可以放顶
                                            const fn = bool ? 'bottomCards' : 'cards'
                                            const cards = get[fn](x, true)
                                            await player.showCards(cards)
                                            const { result } = await player.chooseButton([`选择要置于牌堆<span style="color:red;">${bool ? '顶' : '底'}</span>部的牌<br>先选择的在最下`, cards], [1, Infinity])
                                            if (result.bool && result.links.length) {
                                                const bottom = result.links.reverse()
                                                bottom.forEach(card => {
                                                    card.fix();
                                                    if (bool) {
                                                        ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                                                    } else {
                                                        ui.cardPile.appendChild(card)
                                                    }
                                                })
                                            }
                                        }
                                    },
                                    add: {
                                        trigger: { player: "useCard2" },
                                        async cost(event, trigger, player) {
                                            const { result } = await player.chooseTarget('不满', "为" + get.translation(trigger.card) + "额外指定一个目标", function (card, player, target) {
                                                return !_status.event.sourcex.includes(target) && player.canUse(_status.event.card, target);
                                            }).set("sourcex", trigger.targets).set("ai", target => {
                                                const player = _status.event.player;
                                                return get.effect(target, _status.event.card, player, player);
                                            }).set("card", trigger.card);
                                            event.result = {
                                                bool: result.bool,
                                                cost_data: result.targets
                                            }
                                        },
                                        async content(event, trigger, player) {
                                            const targets = event.cost_data
                                            if (!event.isMine() && !event.isOnline()) game.delayx();
                                            event.targets = targets;
                                            trigger.targets.addArray(targets);
                                        }
                                    },
                                    numadd: {
                                        trigger: { player: ["recoverBegin", "damageBegin1"] },
                                        filter(trigger, player, name) {
                                            return Boolean(trigger.card)
                                        },
                                        async content(event, trigger, player) {
                                            player.loseMaxHp();
                                            trigger.num++;
                                        },
                                    }
                                }
                            },
                            qd_manle: {
                                trigger: { player: "manleOK" },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "thunder",
                                derivation: ["qd_yinmanzu"],
                                async content(event, trigger, player) {
                                    player.awakenSkill("qd_manle");
                                    await player.gainMaxHp()
                                    const { result } = await player.chooseControl(["摸三张牌", '回复一点体力值']).set('prompt', '请选择一项')
                                    if (result.index === 0) {
                                        await player.draw(3)
                                    } else {
                                        await player.recover(1)
                                    }
                                    await player.addSkills('qd_yinmanzu')
                                }
                            },
                            qd_yinmanzu: {
                                init() {
                                    if (!_status.cardTypeList) {
                                        lib.skill.qd_weiwo.getCardTypeList()
                                    }
                                },
                                trigger: { global: 'roundStart' },
                                async cost(event, trigger, player) {
                                    delete player.storage.qd_yinmanzu_choose
                                    const result = await player.chooseControl(_status.cardTypeList, 'cancel').set('prompt', '请选择一种类型').forResult()
                                    event.result = {
                                        bool: result.control !== 'cancel',
                                        cost_data: result.control
                                    }
                                },
                                async content(event, trigger, player) {
                                    player.storage.qd_yinmanzu_choose = event.cost_data
                                },
                                mark: true,
                                intro: {
                                    name: "满足",
                                    content(err, { storage }) {
                                        if (!storage.qd_yinmanzu_choose) return '暂时没有选择类型'
                                        return '本轮内获得' + storage.qd_yinmanzu_choose + '类型的牌时可以选择执行一次【不满】的选项'
                                    }
                                },
                                group: 'qd_yinmanzu_gain',
                                subSkill: {
                                    gain: {
                                        trigger: {
                                            player: "gainAfter",
                                            global: "loseAsyncAfter",
                                        },
                                        filter(event, player) {
                                            if (event.getg(player).length == 0) return false
                                            if (get.type2(event.card) !== player.storage.qd_yinmanzu_choose) return false
                                            return event.getParent(2).name != "qd_yinmanzu_gain";
                                        },
                                        async content(event, trigger, player) {
                                            const { result } = await player.chooseControl(['摸三张牌', '本局使用牌多指定一个目标', '本局造成和回复的值加一']).set('prompt', '请选择一项<br>我不理解这个设计是什么意思，除了摸牌其他的没意义')
                                            if (result.index === 1) {
                                                player.addSkill('qd_buman_add')
                                            }
                                            if (result.index === 2) {
                                                player.addSkill('qd_buman_numadd')
                                            }
                                            if (result.index === 0) {
                                                await player.draw(3)
                                            }
                                        },
                                    }
                                }
                            },
                            qd_shushi: {
                                trigger: { global: "phaseZhunbeiBegin" },
                                filter(event, player) {
                                    return player.countCards('he') > 0
                                },
                                async cost(event, trigger, player) {
                                    const { result } = await player.chooseCard(`是否将一张牌置于${get.translation(trigger.player)}的武将牌上？`, 'he', 1)
                                    event.result = {
                                        bool: result.bool,
                                        cost_data: result.cards
                                    }
                                },
                                async content(event, trigger, player) {
                                    const card = event.cost_data
                                    const control = player.chooseControl(['止', '息'])
                                    control.set('prompt', `请将${get.translation(card)}当做“止”或“息”<br>置于${get.translation(trigger.player)}武将牌上`)
                                    const { result } = await control
                                    const add = trigger.player.addToExpansion(card, player, "give")
                                    if (result.control === '止') {
                                        player.addSkill('qd_shushi_zhi')
                                        add.gaintag.add("qd_shushi_zhi");
                                    } else {
                                        add.gaintag.add('qd_shushi_xi')
                                        player.addSkill('qd_shushi_xi')
                                    }
                                    await add
                                },
                                group: "qd_shushi_check",
                                subSkill: {
                                    check: {
                                        trigger: { global: ["loseAfter", "addToExpansionAfter", "cardsGotoSpecialAfter", "loseAsyncAfter"] },
                                        filter(event) {
                                            const { player } = event
                                            const zhi = player.getExpansions('qd_shushi_zhi')
                                            const xi = player.getExpansions('qd_shushi_xi')
                                            return zhi.length >= player.maxHp || xi.length >= player.hp
                                        },
                                        async content(event, trigger) {
                                            const { player } = trigger
                                            const zhi = player.getExpansions('qd_shushi_zhi')
                                            const xi = player.getExpansions('qd_shushi_xi')
                                            if (zhi.length >= player.maxHp) {//如果止大于体力上限
                                                await player.chooseToDiscard(zhi.length, 'he', true)
                                                const evt = event.getParent("phaseUse");
                                                if (evt && evt.player == player) evt.skipped = true;
                                            }
                                            if (xi > player.hp) {
                                                await player.draw(xi.length)
                                            }
                                        },
                                        forced: true,
                                    },
                                    zhi: {
                                        forced: true,
                                        trigger: {
                                            player: ["useCard", "respond"],
                                        },
                                        filter(event, player) {
                                            debugger
                                            return !player.getExpansions("qd_shushi_zhi").map(card => get.type2(card)).includes(get.type2(event.card))
                                        },
                                        async content(event, trigger, player) {
                                            const { result } = await player.chooseControl(['失去体力', '弃置一张牌']).set('prompt', '止：选择一项')
                                            if (result.control === '失去体力') {
                                                await player.loseHp()
                                            } else {
                                                await player.chooseToDiscard(1, 'he', true)
                                            }
                                            if (trigger.cards.length) {
                                                const add = player.addToExpansion(trigger.cards, player, "give")
                                                add.gaintag.add("qd_shushi_zhi");
                                                await add
                                            }
                                        },
                                        marktext: "止",
                                        intro: {
                                            content: "expansion",
                                            markcount: "expansion",
                                        },
                                        onremove(player, skill) {
                                            const cards = player.getExpansions(skill);
                                            if (cards.length) player.loseToDiscardpile(cards);
                                        },
                                    },
                                    xi: {
                                        forced: true,
                                        trigger: {
                                            player: ["useCard", "respond"],
                                        },
                                        filter(event, player) {
                                            return player.getExpansions("qd_shushi_zhi").map(card => get.type2(card)).includes(get.type2(event.card))
                                        },
                                        async content(event, trigger, player) {
                                            const { result } = await player.chooseControl(['回复体力', '摸一张牌', 'cancel']).set('prompt', '止：选择一项')
                                            if (!result.control !== 'cancel') {
                                                trigger.targets.length = 0
                                                trigger.all_excluded = true;
                                                game.log(trigger.card, "被无效了");
                                                if (result.control === '回复体力') {
                                                    await player.recover()
                                                } else {
                                                    await player.draw()
                                                }
                                                if (trigger.cards.length) {
                                                    const add = player.addToExpansion(trigger.cards, player, "give")
                                                    add.gaintag.add("qd_shushi_xi");
                                                    await add
                                                }
                                            }
                                        },
                                        marktext: "息",
                                        intro: {
                                            content: "expansion",
                                            markcount: "expansion",
                                        },
                                        onremove(player, skill) {
                                            const cards = player.getExpansions(skill);
                                            if (cards.length) player.loseToDiscardpile(cards);
                                        },
                                    }
                                }
                            },
                            qd_pingyuan: {
                                enable: "phaseUse",
                                selectTarget: 1,
                                filterTarget(card, player, target) {
                                    const zhi = target.getExpansions('qd_shushi_zhi')
                                    const xi = target.getExpansions('qd_shushi_xi')
                                    return zhi.length || xi.length
                                },
                                prompt: "选择一名有“止”或者“息”的角色",
                                filter(event, player) {
                                    return !player.hasSkill('qd_pingyuan_useed') && game.hasPlayer(current => {
                                        const zhi = current.getExpansions('qd_shushi_zhi')
                                        const xi = current.getExpansions('qd_shushi_xi')
                                        return zhi.length || xi.length
                                    })
                                },
                                async content(event, trigger, player) {
                                    const [target] = event.targets
                                    const zhi = target.getExpansions('qd_shushi_zhi')
                                    const xi = target.getExpansions('qd_shushi_xi')
                                    function createDialog(target, zhi, xi, id) {
                                        const dialog = ui.create.dialog(`平怨：获得${get.translation(target)}的一张“止”或“息”`)
                                        dialog.videoId = id
                                        if (zhi.length) {
                                            dialog.add("止")
                                            dialog.add(zhi)
                                        }
                                        if (xi.length) {
                                            dialog.add('息')
                                            dialog.add(xi)
                                        }
                                    }
                                    const videoId = lib.status.videoId++
                                    if (player.isOnline2()) {
                                        player.send(createDialog, target, zhi, xi, videoId)
                                    } else {
                                        createDialog(target, zhi, xi, videoId)
                                    }
                                    const choose = player.chooseButton(1, true)
                                    choose.set('dialog', videoId)
                                    const { result } = await choose
                                    game.broadcastAll((id) => {
                                        const dialog = get.idDialog(id)
                                        if (dialog) dialog.close()
                                    }, videoId)
                                    await player.gain(result.links, 'gain2')
                                    const { result: select } = await target.chooseTarget('你可以对攻击范围内一名角色造成一点伤害或取消摸两张牌', (card, player, target) => {
                                        return _status.event.player.inRange(target);
                                    })
                                    if (select.bool) {
                                        await select.targets[0].damage(target)
                                    } else {
                                        await target.draw(2)
                                    }
                                    if (player.getHistory('useSkill', evt => evt.skill === 'qd_pingyuan').length >= player.hp) {
                                        player.addTempSkill('qd_pingyuan_useed', 'phaseUseEnd')
                                    }
                                },
                                subSkill: { useed: { charlotte: true } }
                            },
                            qd_lizang: {
                                trigger: { player: "dieAfter" },
                                limited: true,
                                skillAnimation: true,
                                animationColor: "orange",
                                unique: true,
                                async cost(event, trigger, player) {
                                    const { result } = await player.chooseTarget('选择令一名角色重铸区域内所有的牌', (card, player, target) => {
                                        const zhi = target.getExpansions('qd_shushi_zhi')
                                        const xi = target.getExpansions('qd_shushi_xi')
                                        return zhi.length || xi.length
                                    })
                                    event.result = {
                                        bool: result.bool,
                                        cost_data: result.targets
                                    }
                                },
                                async content(event, trigger, player) {
                                    const [target] = event.cost_data
                                    const cards = target.getCards('hej')
                                    if (cards.length) {
                                        await target.recast(target.getCards('hej'))
                                    }
                                    const num = target.countCards('h')
                                    if (num > target.maxHp) {
                                        await target.chooseToDiscard("h", true, num - target.maxHp);
                                    } else {
                                        await target.draw(target.maxHp - num)
                                    }
                                },
                                filter() {
                                    game.hasPlayer(current => {
                                        const zhi = current.getExpansions('qd_shushi_zhi')
                                        const xi = current.getExpansions('qd_shushi_xi')
                                        return zhi.length || xi.length
                                    })
                                },
                            },
                            qd_sbquanji: {
                                audio: '',
                                trigger: { player: 'damageEnd' },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseBool('是否摸两张牌？').forResult()
                                },
                                async content(event, trigger, player) {
                                    await player.draw(2)
                                    let num = trigger.num - 1
                                    while (num) {
                                        const { result } = await player.chooseBool('是否摸两张牌？')
                                        if (result.bool) {
                                            await player.draw(2)
                                        }
                                        num--
                                    }
                                },
                                audio: 'requanji',
                                group: 'qd_sbquanji_phaseUse',
                                subSkill: {
                                    phaseUse: {
                                        audio: 'requanji',
                                        enable: "phaseUse",
                                        position: 'he',
                                        filterCard: true,
                                        discard: false,
                                        lose: false,
                                        delay: 0,
                                        check(card) {
                                            return 8 - get.value(card);
                                        },
                                        selectCard: [1, Infinity],
                                        prompt: "你可以将任意张牌置于武将牌上",
                                        async content(event, trigger, player) {
                                            const cards = event.cards
                                            const next = player.addToExpansion(cards, player, "give")
                                            next.gaintag.add("qd_sbquanji");
                                            await next
                                        },
                                    }
                                },
                                marktext: "权",
                                intro: {
                                    content: "expansion",
                                    markcount: "expansion",
                                },
                                onremove(player, skill) {
                                    const cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                onrestore(player) {
                                    lib.skill.qd_sbquanji_phaseUse.onremove(player)
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.getExpansions("qd_sbquanji").length;
                                    },
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    threaten: 0.8,
                                }
                            },
                            qd_sbzili: {
                                audio: "xinzili",
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.getExpansions('qd_sbquanji').length > 2
                                },
                                forced: true,
                                lokced: true,
                                async content(event, trigger, player) {
                                    await player.removeSkills('qd_sbzili')
                                    await player.addSkills('qd_sbpaiyi')
                                    await player.recover()
                                    await player.draw(2)
                                },
                                ai: {
                                    threaten(player, target) {
                                        if (target.hp == 1) return 2;
                                        return 0.2;
                                    },
                                }
                            },
                            qd_sbpaiyi: {
                                enable: "phaseUse",
                                filter(event, player) {
                                    return player.getExpansions('qd_sbquanji').length > 0
                                },
                                init(player) {
                                    player.storage.qd_sbpaiyi_selected = []
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        const list = [
                                            "1.体力值", "2.手牌数", '3.装备数'
                                        ]
                                        const cards = player.getExpansions('qd_sbquanji')
                                        const dialog = ui.create.dialog('排异：请弃置一张“权”', cards, 'hidden')
                                        dialog.add('请选择一项')
                                        dialog.add([list, "tdnodes"])
                                        return dialog
                                    },
                                    select: 2,
                                    check(button) {
                                        return 1;
                                    },
                                    filter(button, player) {
                                        if (player.storage.qd_sbpaiyi_selected.includes(button.link)) return false
                                        if (!ui.selected.buttons.length) return true;
                                        if (ui.selected.buttons[0]._args[1] === 'card') {
                                            // if (!player.storage.qd_sbpaiyi_selected) return button._args[1] === 'tdnodes'
                                            return button._args[1] === 'tdnodes'
                                        } else {
                                            return button._args[1] === 'card'
                                        }
                                    },
                                    backup(links, player) {
                                        let card, link
                                        links.forEach(item => {
                                            if (typeof item === 'string') link = item
                                            else card = item
                                        })
                                        return {
                                            async precontent(event, trigger, player) {
                                                player.addTempSkill('qd_sbpaiyi_selected')
                                                player.storage.qd_sbpaiyi_selected.push(link)

                                            },
                                            async content(event, unknow, player) {
                                                const { result } = await player.chooseTarget(`选择与一名其他角色比较${link}`, lib.filter.notMe, true)
                                                await player.loseToDiscardpile(card);
                                                const [target] = result.targets
                                                function equal(num1, num2) {
                                                    if (num1 < num2) return 1
                                                    if (num1 == num2) return 2
                                                    return 3
                                                }

                                                let numresult;
                                                switch (link[0]) {
                                                    case '1': {
                                                        numresult = equal(player.hp, target.hp)
                                                        break;
                                                    }
                                                    case '2': {
                                                        numresult = equal(player.countCards('h'), target.countCards('h'))
                                                        break
                                                    }
                                                    case '3': {
                                                        numresult = equal(player.countCards('e'), target.countCards('e'))
                                                        break;
                                                    }
                                                }
                                                switch (numresult) {
                                                    case 1: {
                                                        if (target.countCards('h') <= 0) break
                                                        const list = []
                                                        const dialog = [`排异：弃置${get.translation(target)}一种花色的所有手牌`]
                                                        for (const suit of lib.suit.concat("none")) {
                                                            if (target.countCards("h", { suit: suit })) {
                                                                dialog.push(
                                                                    '<div class="text center">' + get.translation(suit + "2") + "牌</div>"
                                                                );
                                                                dialog.push(target.getCards("h", { suit: suit }));
                                                                list.push(suit);
                                                            }
                                                        }
                                                        if (list.length) {
                                                            const { result } = await player.chooseControl(list).set('dialog', dialog).set("ai", () => _status.event.control).set(
                                                                "control",
                                                                (() => {
                                                                    var getv = (cards) =>
                                                                        cards.map((i) => get.value(i)).reduce((p, c) => p + c, 0);
                                                                    return list.sort((a, b) => {
                                                                        return (
                                                                            getv(target.getCards("h", { suit: b })) -
                                                                            getv(target.getCards("h", { suit: a }))
                                                                        );
                                                                    })[0];
                                                                })()
                                                            );
                                                            const cards2 = target.getCards("h", { suit: result.control });
                                                            const dis = target.discard(cards2, "notBySelf")
                                                            dis.set("discarder", player);
                                                            await dis
                                                        }
                                                        break
                                                    }
                                                    case 2: {
                                                        await player.draw(2)
                                                        break
                                                    }
                                                    case 3: {
                                                        await target.damage(player)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                subSkill: {
                                    selected: {
                                        onremove(player) {
                                            player.storage.qd_sbpaiyi_selected = []
                                        },
                                        charlotte: true
                                    },
                                }
                            },
                            qd_zhisuan: {
                                trigger: { player: ['useCard', 'damage'] },
                                filter(trigger, player, triggerName) {
                                    if (ui.cardPile.childElementCount < 4) return false
                                    if (triggerName === 'useCard') {
                                        return get.number(trigger.card) === player.storage.qd_zhisuanNum
                                    }
                                    return true
                                },
                                async content(event, trigger, player) {
                                    const cards = get.cards(4)
                                    game.cardsGotoOrdering(cards)
                                    const videoId = lib.status.videoId++
                                    game.broadcastAll((player, id, cards) => {
                                        const dialog = ui.create.dialog(`${get.translation(player)}可以获得任意张牌`, cards)
                                        dialog.videoId = id
                                    }, player, videoId, cards)
                                    const next = player.chooseButton([0, Infinity])
                                    next.set('dialog', videoId)
                                    next.set('ai', button => {
                                        const player = _status.event.player
                                        const name = get.name(button.link)
                                        const val = get.value(button.link, player)
                                        if (name === "tao") return val + 2 * Math.min(3, 1 + player.getDamagedHp());
                                        if (name === "jiu" && player.hp < 3) return val + 2 * (2.8 - player.hp);
                                        if (name === "wuxie" && player.countCards("j") && !player.hasWuxie()) return val + 5;
                                        if (
                                            player.hp > 1 &&
                                            player.hasSkill("renxin") &&
                                            player.hasFriend() &&
                                            get.type(button.link) === "equip"
                                        )
                                            return val + 4;
                                        return val;
                                    })
                                    const { result } = await next
                                    game.broadcastAll((id) => {
                                        const dialog = get.idDialog(id)
                                        if (dialog) {
                                            dialog.close()
                                        }
                                    }, videoId)
                                    const num = result.links.reduce((now, card) => {
                                        now += get.number(card, player)
                                        return now
                                    }, 0)
                                    player.setMark('qd_zhisuanNum', num)
                                    await player.gain(result.links, "log", "gain2");
                                    if (num === 13) {
                                        await player.recover()
                                    }
                                },
                                mark: true,
                                marktext: "算",
                                intro: {
                                    name: "算(智算)",
                                    name2: "算",
                                    content: "mark",
                                    markcount(storage, player) {
                                        return (player.storage.qd_zhisuanNum || 0).toString().slice(-2);
                                    },
                                },
                            },
                            qd_renxin: {
                                trigger: {
                                    global: ["dyingAfter", 'phaseZhunbeiBegin'],
                                },
                                filter(e, player, triggerName) {
                                    if (triggerName === 'phaseZhunbeiBegin') {
                                        return e.player !== player && _status.renku.length
                                    }
                                    return player.countCards('he') > 0
                                },
                                async cost(event, trigger, player) {
                                    if (event.triggername === 'dyingAfter') {
                                        event.result = await player.chooseCard('he', '你可以将一张牌置入仁区', 1).set('ai', card => {
                                            if (_status.event.player.countCards('he') < 2) return false
                                            return get.value(card) < 3
                                        }).forResult()
                                    } else {
                                        if (!_status.cardTypeList) {
                                            lib.skill.qd_weiwo.getCardTypeList()
                                        }
                                        const aiselect = _status.cardTypeList.slice()
                                        const { result } = await player.chooseButton(
                                            [
                                                `仁心：弃置仁库中任意张牌并令${get.translation(trigger.player)}本回合不能使用该类型的牌`,
                                                _status.renku.slice()
                                            ], [1, Infinity]
                                        ).set("types", aiselect).set('ai', button => {
                                            const type = get.type2(button.link)
                                            if (aiselect.includes(type)) {
                                                aiselect.remove(type)
                                                return true
                                            }
                                            return false
                                        })

                                        event.result = {
                                            bool: result.bool || result.links.length > 0,
                                            cost_data: result.links
                                        }
                                    }
                                },
                                async content(event, trigger, player) {
                                    if (event.triggername === 'dyingAfter') {
                                        const card = event.cards[0]
                                        player.$throw(card, 1000)
                                        await player.lose(card, 'toRenku')
                                        game.updateRenku();
                                    } else {
                                        debugger
                                        const cards = event.cost_data
                                        game.cardsDiscard(cards).fromRenku = true;
                                        _status.renku.removeArray(cards)
                                        player.$throw(cards, 1000);
                                        game.updateRenku();
                                        game.log(cards, "从仁库进入了弃牌堆");

                                        trigger.player.addTempSkill('qd_renxin_ban')
                                        const types = []
                                        cards.forEach(card => types.add(get.type2(card)))
                                        trigger.player.storage.renxinBanList.addArray(types)
                                    }
                                },
                                subSkill: {
                                    ban: {
                                        init(player) {
                                            if (!player.storage.renxinBanList) {
                                                player.storage.renxinBanList = []
                                            }
                                        },
                                        onremove(player) {
                                            player.storage.renxinBanList = []
                                        },
                                        charlotte: true,
                                        mod: {
                                            cardEnabled(card, player) {
                                                if (player.storage.renxinBanList.includes(get.type2(card))) {
                                                    return false
                                                }
                                            },
                                            cardSavable(card, player) {
                                                if (player.storage.renxinBanList.includes(get.type2(card))) {
                                                    return false
                                                }
                                            }
                                        },
                                        mark: true,
                                        marktext: '仁',
                                        intro: {
                                            name: "仁心",
                                            content(err, player) {
                                                if (!player.storage.renxinBanList || !player.storage.renxinBanList.length) return '无禁用的类型'
                                                return '本回合不能使用' + get.translation(player.storage.renxinBanList) + '类型的牌'
                                            }
                                        }
                                    }
                                }
                            },
                            qd_ruiyan: {
                                forced: true,
                                trigger: { player: 'phaseUseBegin' },
                                async content(event, trigger, player) {
                                    const map = {}
                                    game.players.forEach(p => map[p.playerid] = [p.countCards('h'), p.hp])
                                    const { result } = await player.chooseTarget('令一名角色将手牌数值调整至其体力值', true)
                                        .set('map', map)
                                        .set("ai", target => {
                                            const [cards, hp] = _status.event.map[target.playerid];
                                            const att = get.attitude(_status.event.player, target);
                                            if (cards === hp) return 0
                                            if (att > 0) {
                                                if (hp > cards) {
                                                    return hp - cards
                                                }
                                                if (cards - hp < 2) {
                                                    return hp - cards
                                                }
                                                return 0
                                            }
                                            return cards - hp
                                        });
                                    if (!result.bool) {
                                        event.finish()
                                        return;
                                    }
                                    const [target] = result.targets
                                    if (target) {
                                        const [countCards, hp] = [target.countCards('h'), target.hp]
                                        if (countCards === hp) return;
                                        if (countCards > hp) {
                                            await target.chooseToDiscard(countCards - hp, true)
                                            await target.recover()
                                        } else {
                                            await target.draw(hp - countCards)
                                            await player.loseHp()
                                        }
                                    }
                                }
                            },
                            qd_kuangmiu: {
                                forced: true,
                                trigger: { player: ["phaseChange", 'phaseDiscardAfter'] },
                                filter(event, player, triggerName) {
                                    if (triggerName === 'phaseDiscardAfter') return true
                                    if (event.phaseList[event.num].startsWith("phaseUse")) return false;
                                    const num1 = player.getDamagedHp()
                                    const num2 = event.num + 1;
                                    return num1 == num2;
                                },
                                async content(event, trigger, player) {
                                    if (trigger.name === 'phaseDiscard') {
                                        const next = player.phaseUse();
                                        event.next.remove(next);
                                        trigger.getParent().next.push(next);
                                    } else {
                                        trigger.phaseList[trigger.num] = "phaseDraw|qd_kuangmiu";
                                        game.delayx();
                                    }
                                },
                            },
                            qd_fengci: {
                                forced: true,
                                trigger: {
                                    player: ["damageEnd", 'recoverBegin'],
                                    source: "damageSource",
                                },
                                derivation: ['zhuandui', 'zhenlue'],
                                filter(trigger, player, triggerName) {
                                    if (triggerName === 'recoverBegin') return player.hp === player.maxHp
                                    const history = player.getHistory('useSkill')
                                    return history.reduce((nowNumb, event) => {
                                        if (event.event && event.event.triggername === triggerName) {
                                            nowNumb++
                                        }
                                        return nowNumb
                                    }, 0) < 2
                                },
                                async content(event, trigger, player) {
                                    const name = event.triggername
                                    if (name === 'recoverBegin') {
                                        if (player.hp === player.maxHp) {
                                            trigger.cancel()
                                            await player.gainMaxHp()
                                        }
                                    } else if (name === 'damageEnd') {
                                        await player.gainMaxHp()
                                        await player.addSkill('zhuandui')
                                    } else if (name === 'damageSource') {
                                        await player.loseMaxHp()
                                        await player.addSkills('zhenlue')
                                    }
                                },
                                group: 'qd_fengci_maxHp',
                                subSkill: {
                                    maxHp: {
                                        trigger: { player: ["gainMaxHpEnd", "loseMaxHpEnd"] },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            player.draw(2);
                                        }
                                    }
                                }
                            },
                            qd_weiwo: {
                                // get round() {
                                //     if (game.players.length < 4) return 1
                                //     return 2
                                // },
                                trigger: { global: 'phaseZhunbeiBegin' },
                                filter(trigger, player) {
                                    return trigger.player !== player && !player.hasSkill("qd_weiwo_used")
                                },
                                getCardTypeList() {
                                    _status.cardTypeList = []
                                    lib.inpile.forEach(card => {
                                        _status.cardTypeList.add(get.type2(card))
                                    })
                                },
                                init() {
                                    if (!_status.cardTypeList) {
                                        lib.skill.qd_weiwo.getCardTypeList()
                                    }
                                },
                                async cost(event, trigger, player) {
                                    const choiceList = _status.cardTypeList
                                    const { result } = await player.chooseControl(...choiceList, 'cancel2')
                                        .set("choice", choiceList).set("prompt", `请声明${get.translation(trigger.player)}一种类型的牌`)
                                        .set('ai', (event, player) => {
                                            const target = _status.event.target
                                            const att = get.attitude(player, target)
                                            if (att > 0) return 'cancel2'
                                            return 'basic'
                                        })
                                        .set('target', trigger.player)
                                    event.result = {
                                        bool: result.control !== 'cancel2',
                                        targets: [trigger.player],
                                        cost_data: result.control
                                    }
                                },
                                async content(event, trigger, player) {
                                    const type = event.cost_data
                                    await trigger.player.showHandcards(get.translation(player) + '对' + get.translation(trigger.player) + "发动了【帷幄】");
                                    const cards = trigger.player.getCards('h')
                                    const bool = cards.some(c => get.type2(c) === type)
                                    if (bool) {
                                        await player.discardPlayerCard(trigger.player, "he", true, 'visible')
                                        await player.draw(player.maxHp)
                                    }
                                    if (game.players.length < 4) {
                                        player.addTempSkill('qd_weiwo_used', 'roundStart')
                                    } else {
                                        const history = player.getRoundHistory('useSkill', evt => evt.skill === 'qd_weiwo')
                                        if (history.length > 1) {
                                            player.addTempSkill('qd_weiwo_used', 'roundStart')
                                        }
                                    }
                                },
                                subSkill: { used: { charlotte: true } }
                            },
                            qd_yajun: {
                                enable: 'phaseUse',
                                selectTarget: 1,
                                filter(trigger, player) {
                                    return !player.hasSkill('qd_yajun_band')
                                },
                                filterCard() { return true },
                                discard: false,
                                lose: false,
                                delay: 0,
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    return get.value(card, player)
                                },
                                async content(event, trigger, player) {
                                    const [card] = event.cards
                                    player.give(event.cards, event.target);
                                    if (event.target.hasUseTarget(card, null, true)) {
                                        const { result } = await event.target.chooseControl(`失去一点体力值并使用${get.translation(card)}`, '摸两张牌')
                                        if (result.index === 0) {
                                            await event.target.loseHp()
                                            await event.target.chooseUseTarget(card)
                                        } else {
                                            await event.target.draw(2)
                                        }
                                    } else {
                                        await event.target.draw(2)
                                    }
                                    const skills = player.getHistory('useSkill')
                                    const num = skills.reduce((nownum, event) => {
                                        if (event.skill === 'qd_yajun') {
                                            nownum++
                                        }
                                        return nownum
                                    }, 0)
                                    const times = player.storage.qd_moubian ? 2 : 1
                                    if (num <= times) {
                                        player.addTempSkill('qd_yajun_band')
                                    }
                                },
                                subSkill: {
                                    band: { charlotte: true }
                                }
                            },
                            qd_moubian: {
                                skillAnimation: true,
                                animationColor: "orange",
                                forced: true,
                                unique: true,
                                juexingji: true,
                                trigger: {
                                    player: 'phaseEnd'
                                },
                                derivation: 'qd_jushu',
                                filter(trigger, player, triggerName) {
                                    if (player.storage.qd_moubian) return false
                                    return player.storage.qd_moubian_damage >= 3
                                },
                                mark: true,
                                intro: {
                                    content(err, { storage }) {
                                        return (storage.qd_moubian_damage || 0).toString()
                                    },
                                    markcount(err, { storage }) {
                                        return (storage.qd_moubian_damage || 0)
                                    },
                                },
                                init(player) {
                                    player.storage.qd_moubian_damage = 0
                                },
                                async content(event, trigger, player) {
                                    await player.awakenSkill('qd_moubian')
                                    player.storage.qd_moubian = true
                                    await player.gainMaxHp()
                                    await player.draw(2)
                                    await player.recover()
                                    await player.addSkills('qd_jushu')
                                },
                                group: 'qd_moubian_damage',
                                subSkill: {
                                    damage: {
                                        trigger: {
                                            player: 'damage',
                                            source: "damageSource",
                                        },
                                        forced: true,
                                        charlotte: true,
                                        lokced: true,
                                        async content(event, trigger, player) {
                                            if (!player.storage.qd_moubian_damage) {
                                                player.storage.qd_moubian_damage = 0
                                            }
                                            player.storage.qd_moubian_damage += trigger.num
                                        },
                                        popup: false,
                                    }
                                }
                            },
                            qd_jushu: {
                                forced: true,
                                trigger: { player: ['phaseAfter', 'phaseDrawBegin2', 'useCard'] },
                                filter(trigger, player, triggername) {
                                    if (triggername === 'useCard') {
                                        const num = player.getHistory('useCard').length
                                        return num < player.getDamagedHp()
                                    }
                                    return true
                                },
                                async content(event, trigger, player) {
                                    const num = Math.max(player.getDamagedHp(), 1)
                                    const eventname = event.triggername
                                    if (eventname === 'phaseDrawBegin2') {
                                        trigger.num += num
                                    } else if (eventname === 'phaseAfter') {
                                        await player.damage(num)
                                    } else if (eventname === 'useCard') {
                                        trigger.directHit.addArray(game.players);
                                    }
                                },
                                mod: {
                                    cardUsable: (card, player, target) => {
                                        const useCard = player.getHistory('useCard').length
                                        if (useCard < player.getDamagedHp()) { return Infinity; }
                                    },
                                    targetInRange: (card, player, target) => {
                                        const useCard = player.getHistory('useCard').length
                                        if (useCard < player.getDamagedHp()) return true;
                                    },
                                }
                            },
                            qd_jianying: {
                                audio: 'xinjianying',
                                trigger: { player: "useCard" },
                                frequent: true,
                                filter(event, player) {
                                    const evt = player.getLastUsed(1);
                                    if (!evt || !evt.card) return false;
                                    if (!player.isPhaseUsing()) return false;
                                    const evt2 = evt.getParent("phaseUse");
                                    if (!evt2 || evt2.name != "phaseUse" || evt2 !== event.getParent("phaseUse")) return false;
                                    if (!get.cardNameLength(evt.card)) return
                                    return true//get.cardNameLength(evt.card) == get.cardNameLength(event.card)
                                },
                                locked: false,
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (typeof card == "object" && player.isPhaseUsing()) {
                                            const evt = player.getLastUsed();
                                            if (!evt || !evt.card || evt.getParent("phaseUse") !== _status.event.getParent("phaseUse")) return num;
                                            if ((get.cardNameLength(evt.card) && get.cardNameLength(evt.card) == get.cardNameLength(card))) {
                                                return num + 10;
                                            }
                                        }
                                    },
                                    cardUsable(card, player) {
                                        if (player.isPhaseUsing() && typeof card == "object") {
                                            const evt = player.getLastUsed();
                                            if (evt && evt.card && evt.getParent("phaseUse") === _status.event.getParent("phaseUse")) {
                                                const cardLength = get.cardNameLength(card)
                                                const evtCardLength = get.cardNameLength(evt.card)
                                                const abs = Math.abs(evtCardLength - cardLength)
                                                if (abs === 1) return Infinity
                                            }
                                        }
                                    },
                                    targetInRange(card, player) {
                                        if (player.isPhaseUsing() && typeof card == "object") {
                                            const evt = player.getLastUsed();
                                            if (evt && evt.card && evt.getParent("phaseUse") === _status.event.getParent("phaseUse")) {
                                                const cardLength = get.cardNameLength(card)
                                                const evtCardLength = get.cardNameLength(evt.card)
                                                const abs = Math.abs(evtCardLength - cardLength)
                                                if (abs === 1) return true
                                            }
                                        }
                                    },
                                },
                                async content(event, trigger, player) {
                                    const evt = player.getLastUsed(1);
                                    const evenCardnum = get.cardNameLength(trigger.card)
                                    const lastCardnum = get.cardNameLength(evt.card)
                                    if (evenCardnum === lastCardnum) {
                                        await player.draw()
                                    }
                                    if (Math.abs(evenCardnum - lastCardnum) > 1) {
                                        delete player.getStat("skill")['qd_quanlue']
                                    }
                                },
                                group: "qd_jianying_mark",
                                init(player) {
                                    if (player.isPhaseUsing()) {
                                        const evt = _status.event.getParent("phaseUse");
                                        const history = player.getHistory("useCard", evt2 => evt2.getParent("phaseUse") == evt);
                                        if (history.length) {
                                            const trigger = history[history.length - 1];
                                            if (get.cardNameLength(trigger.card)) return;
                                            player.storage.qd_jianying_mark = trigger.card;
                                            player.markSkill("qd_jianying_mark");
                                            game.broadcastAll(
                                                (player, cardNameLength) => {
                                                    if (player.marks.qd_jianying_mark) player.marks.qd_jianying_mark.firstChild.innerHTML = get.translation(cardNameLength);
                                                },
                                                player,
                                                get.cardNameLength(trigger.card)
                                            );
                                            player.when("phaseUseAfter").then(() => {
                                                player.unmarkSkill("qd_jianying_mark");
                                                delete player.storage.qd_jianying_mark;
                                            });
                                        }
                                    }
                                },
                                onremove(player) {
                                    player.unmarkSkill("qd_jianying_mark");
                                    delete player.storage.qd_jianying_mark;
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        trigger: { player: "useCard1" },
                                        filter(event, player) {
                                            return player.isPhaseUsing();
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        async content(event, trigger, player) {
                                            if (!get.cardNameLength(trigger.card)) player.unmarkSkill("qd_jianying_mark");
                                            else {
                                                player.storage.qd_jianying_mark = trigger.card;
                                                player.markSkill("qd_jianying_mark");
                                                game.broadcastAll(
                                                    (player, cardNameLength) => {
                                                        if (player.marks.qd_jianying_mark) player.marks.qd_jianying_mark.firstChild.innerHTML = get.translation(cardNameLength);
                                                    },
                                                    player,
                                                    get.cardNameLength(trigger.card, player)
                                                );
                                                player.when("phaseUseAfter").then(() => {
                                                    player.unmarkSkill("qd_jianying_mark");
                                                    delete player.storage.qd_jianying_mark;
                                                });
                                            }
                                        },
                                        intro: {
                                            markcount(card, player) {
                                                return parseFloat(get.cardNameLength(card));
                                            },
                                            content(card, player) {
                                                return `<li>上一张使用的牌名字<br>${get.translation(get.name(card, player))}</li>`;
                                            },
                                        },
                                    },
                                },
                            },
                            qd_quanlue: {
                                enable: "phaseUse",
                                usable: 1,
                                selectCard: 1,
                                position: 'he',
                                filterCard: () => true,
                                // prompt:'弃置一张牌然后从牌堆中获得一张任意点数的牌',
                                async content(event, trigger, player) {
                                    let numbers = []
                                    lib.inpile.forEach(name => numbers.add(String(get.cardNameLength(name))))
                                    numbers = numbers.sort((a, b) => a - b)
                                    const { result } = await player.chooseControl(...numbers).set('prompt', '要获得几个字的牌？')
                                    if (result.control) {
                                        const card = get.cardPile2(card => get.cardNameLength(card) == result.control);
                                        if (card) {
                                            await player.gain(card, 'gain2')
                                        } else {
                                            game.log(`牌堆没有${result.control}个字的牌`)
                                        }
                                    }
                                },
                            },
                            qd_shibei: {
                                inherit: 'shibei',
                                filter(trigger, player) {
                                    const damage = player.getHistory("damage")
                                    const index = damage.indexOf(trigger)
                                    return index === 1 || index === 0
                                },
                                async content(event, trigger, player) {
                                    const damage = player.getHistory("damage")
                                    if (damage.indexOf(trigger) === 0) {
                                        await player.recover();
                                    } else if (damage.indexOf(trigger) === 1) {
                                        await player.loseHp();
                                        await player.draw()
                                    }
                                }
                            },
                            qd_wusheng: {
                                group: ['qd_wusheng_mark', 'qd_wusheng_give', 'qd_wusheng_zhunbei'],
                                mark: true,
                                marktext: "武",
                                intro: {
                                    name: "武圣",
                                    content: "mark",
                                },
                                subSkill: {
                                    mark: {
                                        audio: 'sbwusheng',
                                        trigger: {
                                            global: "phaseBefore",
                                            player: "enterGame",
                                        },
                                        filter(event, player) {
                                            return event.name != "phase" || game.phaseNumber == 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            player.addMark("qd_wusheng", 3);
                                            lib.skill.qd_wusheng_give.addSkill(player, player.countMark('qd_wusheng'))
                                        },
                                    },
                                    give: {
                                        trigger: { player: 'phaseBegin' },
                                        filter(trigger, player) {
                                            return player.countMark('qd_wusheng') > 0
                                        },
                                        moveMark(add, remove, number) {
                                            add.addMark('qd_wusheng', number)
                                            remove.removeMark('qd_wusheng', number)
                                            const addMark = add.countMark('qd_wusheng')
                                            const removeMark = remove.countMark('qd_wusheng')
                                            if (removeMark === 0) {
                                                remove.marks.qd_wusheng.remove()
                                                delete remove.marks.qd_wusheng
                                            }
                                            const skills = [0, 1, 2, 3]
                                            if (skills.includes(addMark)) {
                                                lib.skill.qd_wusheng_give.addSkill(add, addMark)
                                            }
                                            if (skills.includes(removeMark)) {
                                                lib.skill.qd_wusheng_give.addSkill(remove, removeMark)
                                            }
                                        },
                                        addSkill(player, marknum) {
                                            const skills = ['qd_wusheng_sha1', 'qd_wusheng_unuse2', 'qd_wusheng_phase3']
                                            const skill = skills.slice(0, marknum)
                                            if (player.storage.qd_wusheng_skill && player.storage.qd_wusheng_skill.toString() === skill.toString()) return
                                            player.storage.qd_wusheng_skill = skill
                                            const after = skills.filter(s => !skill.includes(s))
                                            if (skill) {
                                                skill.forEach(s => player.addSkill(s))
                                            }
                                            if (after) {
                                                after.forEach(s => player.removeSkill(s))
                                            }
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget('选择一名其他角色交给其“武”标记', lib.filter.notMe)
                                                .set('ai', target => {
                                                    const player = _status.event.player
                                                    return get.attitude(player, target) > 2
                                                }).forResult()
                                        },
                                        async content(event, trigger, player) {
                                            const [target] = event.targets
                                            const marks = Array.from({ length: player.countMark('qd_wusheng') }, (_, i) => String(i + 1))
                                            const { result } = await player.chooseControl(...marks).set('prompt', `请选择要交给${get.translation(target)}的“武”标记数量`)
                                            if (result.control) {
                                                lib.skill.qd_wusheng_give.moveMark(target, player, Number(result.control))
                                            }
                                            while (player.countMark('qd_wusheng') > 0) {
                                                const { result } = await player.chooseTarget('选择一名其他角色交给其“武”标记', lib.filter.notMe)
                                                    .set('ai', target => {
                                                        const player = _status.event.player
                                                        return get.attitude(player, target) > 2
                                                    })
                                                if (result.bool) {
                                                    const [target] = result.targets
                                                    const marks = Array.from({ length: player.countMark('qd_wusheng') }, (_, i) => String(i + 1))
                                                    const controlResult = await player.chooseControl(...marks).set('prompt', `请选择要交给${get.translation(target)}的“武”标记数量`)
                                                    if (controlResult.result.control) {
                                                        lib.skill.qd_wusheng_give.moveMark(target, player, Number(controlResult.result.control))
                                                    }
                                                } else break
                                            }
                                        },
                                    },
                                    zhunbei: {
                                        trigger: { player: 'phaseZhunbeiBegin' },
                                        filter(trigger) {
                                            return game.players.filter(player => player.countMark('qd_wusheng') > 0).length > 0 && game.players.length > 1
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await player.chooseTarget(2, '移动一名角色的“武”标记', (card, player, target) => {
                                                if (ui.selected.targets.length === 0) {
                                                    return target.countMark('qd_wusheng') > 0
                                                }
                                                return target !== ui.selected.targets[0]
                                            })
                                                .set('multitarget', true)
                                                .set('targetprompt', ['失去标记', '获得标记'])
                                                .set('ai', target => {
                                                    const player = _status.event.player
                                                    return get.attitude(player, target) < 2
                                                }).forResult()
                                        },
                                        async content(event, trigger, player) {
                                            const [source, target] = event.targets
                                            trigger.moveTargets = [source]
                                            const marks = Array.from({ length: source.countMark('qd_wusheng') }, (_, i) => String(i + 1))
                                            const { result } = await player.chooseControl(...marks).set('prompt', `选择要移动${get.translation(source)}的“武”标记数量`)
                                            lib.skill.qd_wusheng_give.moveMark(target, source, Number(result.control))
                                            while (game.players.some(p => p.countMark('qd_wusheng') > 0 && !trigger.moveTargets.includes(p))) {
                                                const { result: targetResult } = await player.chooseTarget(2, '移动一名角色的“武”标记', (card, player, target) => {
                                                    if (ui.selected.targets.length === 0) {
                                                        return target.countMark('qd_wusheng') > 0 && !trigger.moveTargets.includes(target)
                                                    }
                                                    return target !== ui.selected.targets[0]
                                                })
                                                    .set('multitarget', true)
                                                    .set('targetprompt', ['失去标记', '获得标记'])
                                                    .set('ai', target => {
                                                        const player = _status.event.player
                                                        return get.attitude(player, target) < 2
                                                    })
                                                if (!result.bool) {
                                                    break
                                                }
                                                const [source, target] = targetResult.targets
                                                trigger.moveTargets.push(source)
                                                const marks = Array.from({ length: source.countMark('qd_wusheng') }, (_, i) => String(i + 1))
                                                const { result: controlResult } = await player.chooseControl(...marks).set('prompt', `选择要移动${get.translation(source)}的“武”标记数量`)
                                                lib.skill.qd_wusheng_give.moveMark(target, source, Number(controlResult.control))
                                            }
                                        }
                                    },
                                    sha1: {
                                        marktext: '一',
                                        mark: true,
                                        intro: {
                                            name: '武一',
                                            content: '使用【杀】指定目标后其需弃置一半的手牌或交给你两张牌'
                                        },
                                        ai: {
                                            unequip: true,
                                            unequip_ai: true,
                                            skillTagFilter(player, tag, arg) {
                                                if (tag == "unequip") {
                                                    if (arg && get.name(arg.card, player) === 'sha') return true;
                                                    return false;
                                                }
                                            },
                                        },
                                        trigger: { player: 'useCardToPlayered' },
                                        filter(trigger, player) {
                                            return get.name(trigger.card, player) == "sha";
                                        },
                                        foreced: true,
                                        async content(event, trigger, player) {
                                            const thisplayer = player
                                            const translate = get.translation(player)
                                            for await (const target of trigger.targets) {
                                                const half = Math.ceil(target.countCards('h') / 2)
                                                const { result } = await target.chooseToDiscard(half, "h", `弃置${half}张手牌，否则交给` + translate + "两张牌", lib.filter.cardDiscardable).set('ai', card => 8 - get.value(card));
                                                if (!result.bool) {
                                                    let cards;
                                                    if (target.countCards('he') < 2) {
                                                        cards = target.getCards('he')
                                                    } else {
                                                        const { result: giveResult } = await target.chooseCard(`交给${translate}两张牌`, 'he', 2)
                                                        cards = giveResult.cards
                                                    }
                                                    if (cards && cards.length) {
                                                        await target.give(cards, player, "giveAuto")
                                                    }
                                                }
                                            }
                                        },
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == "sha") {
                                                    const discardnum = game.players.reduce((now, p) => {
                                                        const his = p.getHistory('lose', evt => evt.type === 'discard')
                                                        now += his.length
                                                        return now
                                                    }, 0)
                                                    return num + Math.min(discardnum, 3)
                                                }
                                            },
                                        }
                                    },
                                    unuse2: {
                                        marktext: '二',
                                        forced: true,
                                        mark: true,
                                        intro: {
                                            name: '武二',
                                            content: '首次使用【杀】指定目标后没有武标记的角色的非目标角色本回合不能使用或打出牌'
                                        },
                                        trigger: { player: 'useCardToPlayered' },
                                        filter(trigger, player) {
                                            return get.name(trigger.card, player) == "sha" && !player.hasSkill('qd_wusheng_used');
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            player.addTempSkill('qd_wusheng_used')
                                            game.players.forEach(p => {
                                                if (p.countMark('qd_wusheng') < 1 && !trigger.targets.includes(p)) {
                                                    p.addTempSkill('qd_wusheng_ban')
                                                }
                                            })
                                        }
                                    },
                                    ban: {
                                        mark: true,
                                        intro: {
                                            name: '禁',
                                            content: '不能使用或打出牌'
                                        },
                                        marktext: '禁',
                                        charlotte: true,
                                        mod: {
                                            cardEnabled(card, player) {
                                                return false
                                            },
                                            cardRespondable(card, player) {
                                                return false
                                            },
                                            cardSavable: function (card, player) {
                                                return false
                                            },
                                        },
                                    },
                                    used: { charlotte: true },
                                    phase3: {
                                        marktext: '三',
                                        mark: true,
                                        intro: {
                                            name: '武三',
                                            content: '回合结束获得一个回合'
                                        },
                                        round: 1,
                                        trigger: { player: 'phaseEnd' },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            player.insertPhase();
                                        },
                                        group: 'qd_wusheng_phase4'
                                    },
                                    phase4: {
                                        trigger: { global: 'dieAfter' },
                                        forced: true,
                                        round: 1,
                                        filter(event, player) {
                                            return _status.currentPhase === player
                                        },
                                        async content(event, trigger, player) {
                                            delete player.getStat('skill')['qd_wusheng_phase3']
                                        }
                                    }
                                },
                            },
                            qd_wushen: {
                                dutySkill: true,
                                audio: 'wushen',
                                group: ['qd_wushen_achieve', 'qd_wushen_fail', 'qd_wushen_dying'],
                                subSkill: {
                                    dying: {
                                        trigger: { global: 'dying' },
                                        filter(trigger, player) {
                                            return trigger.source && trigger.source.countMark('qd_wusheng') > 0
                                        },
                                        init(player) {
                                            player.storage.qd_wushenDying = 0
                                        },
                                        async content(e, t, player) {
                                            player.storage.qd_wushenDying++
                                        },
                                        forced: true,
                                        charlotte: true,
                                    },
                                    achieve: {
                                        audio: 'wushen',
                                        forced: true,
                                        skillAnimation: true,
                                        animationColor: "metal",
                                        filter(event, player) {
                                            return player.storage.qd_wushenDying > 2
                                        },
                                        async content(event, trigger, player) {
                                            game.log(player, "成功完成使命");
                                            player.awakenSkill("qd_wushen");
                                            player.addMark('qd_wusheng', 3)
                                            lib.skill.qd_wusheng_give.addSkill(player, player.countMark('qd_wusheng'))
                                        },
                                        trigger: { player: "phaseBegin" },
                                    },
                                    fail: {
                                        audio: "wushen",
                                        trigger: { player: "dying" },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            game.log(player, "使命失败");
                                            player.awakenSkill("qd_wushen");
                                            if (player.hp < 1) player.recover(1 - player.hp);
                                            player.addSkill('qd_wushen_remove')
                                        },
                                    },
                                    remove: {
                                        forced: true,
                                        trigger: { player: 'phaseBegin' },
                                        filter() {
                                            return game.players.some(p => p.countMark('qd_wushen') > 0)
                                        },
                                        async content(event, trigger, player) {
                                            const { result } = await player.chooseTarget(true, '移去一名角色的一个“武”标记', (card, player, target) => {
                                                return target.countMark('qd_wushen') > 0
                                            })
                                            if (result.bool) {
                                                result.targets[0].removeMark('qd_wushen', 1)
                                            }
                                        }
                                    }
                                }
                            },
                            qd_yiding: {
                                trigger: { target: "useCardToTargeted" },
                                filter(trigger, player) {
                                    if (!trigger.cards) return;
                                    const bool = trigger.cards.some(c => !c.sourceUsePlayer)
                                    return trigger.player !== player && bool
                                },
                                async content(event, trigger, player) {
                                    trigger.getParent().excluded.add(player)
                                    const cards = trigger.cards.filter(c => {
                                        if (!c.gaintag.includes('qd_yiding')) {
                                            c.sourceUsePlayer = trigger.player
                                            c.gaintag.add('qd_yiding')
                                            return true
                                        }
                                    })
                                    player.addToExpansion(cards, player, "give").gaintag.add("qd_yiding");
                                },
                                marktext: "定",
                                intro: {
                                    content: "expansion",
                                    markcount: "expansion",
                                },
                                group: ['qd_yiding_use', 'qd_yiding_dying'],
                                forced: true,
                                subSkill: {
                                    use: {
                                        trigger: { player: 'phaseBeginStart' },
                                        filter(trigger, player) {
                                            return player.getExpansions("qd_yiding").length > 0;
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            const qd_yidingCards = player.getExpansions("qd_yiding")
                                            const cards = qd_yidingCards.filter(c => c.sourceUsePlayer).sort((a, b) => a.sourceUsePlayer.seatNum - b.sourceUsePlayer.seatNum)
                                            const discard = qd_yidingCards.filter(c => c.sourceUsePlayer || !c.sourceUsePlayer.isIn())
                                            const target = player
                                            for await (const card of cards) {
                                                const use = card.sourceUsePlayer
                                                if (use.canUse(card, player, false)) {
                                                    await use.useCard(card, target, true)
                                                }
                                            }
                                            if (discard.length > 0) {
                                                await player.loseToDiscardpile(discard)
                                                discard.forEach(card => delete card.sourceUsePlayer)
                                            }
                                        }
                                    },
                                    dying: {
                                        forced: true,
                                        trigger: { player: 'dying' },
                                        filter(trigger, player) {
                                            return _status.currentPhase === player
                                        },
                                        async content(event, trigger, player) {
                                            const num = game.players.reduce((now, p) => {
                                                const history = p.getHistory('useCard')
                                                history.forEach(evt => {
                                                    if (evt.targets.includes(player)) {
                                                        now++
                                                    }
                                                })
                                                return now
                                            }, 0)
                                            if (num > 0) {
                                                await player.draw(num)
                                            }
                                        }
                                    }
                                }
                            },
                            qd_qiuxian: {
                                trigger: { player: 'useCard' },
                                filter(trigger, player) {
                                    return _status.currentPhase === player
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget('选择一名其他角色进行“求贤”', lib.filter.notMe).set('ai', target => {
                                        return get.attitude(_status.event.player, target) > 0
                                    }).forResult()
                                },
                                async content(event, trigger, player) {
                                    const [target] = event.targets
                                    const name = get.translation(player)
                                    const cardName = get.translation(trigger.card)
                                    const { result } = await target.chooseControl(`交给${name}一张牌`, `令${cardName}不能响应`, `弃置一张牌令${cardName}伤害/回复值加一`, 'cancel')
                                        .set('ai', event => {
                                            const now = _status.event
                                            const choose = now.player
                                            const useSkill = event.player
                                            const att = get.attitude(choose, useSkill)
                                            if (att > 0) {
                                                const type = get.type(now.card)
                                                if ((type === 'equip' || type === 'delay') && att > 2) {
                                                    if (choose.countCards('he') > 3) return `交给${name}一张牌`
                                                    return `令${cardName}不能响应`
                                                }
                                                const [target] = control.targets
                                                const targetAtt = get.attitude(choose, target)
                                                if (targetAtt > 0) {
                                                    return `令${cardName}不能响应`
                                                }
                                                return `弃置一张牌令${cardName}伤害/回复值加一`
                                            }
                                            return `cancel`
                                        })
                                    if (result.control !== 'cancel') {
                                        switch (result.index) {
                                            case 0: {
                                                const { result: give } = await target.chooseCard(`交给${name}一张牌`, 'he', true).set('ai', card => get.value(card) < 3)
                                                if (give.cards) {
                                                    await target.give(give.cards, player, 'giveAuto')
                                                }
                                                break;
                                            }
                                            case 1: {
                                                trigger.directHit.addArray(game.players)
                                                break
                                            }
                                            case 2: {
                                                const { result: cards } = await target.chooseToDiscard(`弃置一张牌令${cardName}伤害/回复值加一`, true)
                                                if (cards.cards.length > 0) {
                                                    trigger.num++
                                                }
                                            }
                                        }
                                    }
                                },
                            },
                            qd_yinbing: {
                                enable: "phaseUse",
                                usable: 1,
                                prompt: '令所有角色选择“从”或者“决”',
                                async content(event, trigger, player) {
                                    const players = game.players.filter(p => p !== player)
                                    player.line(players)
                                    const cong = [player]
                                    const jue = []
                                    for await (const p of players) {
                                        const { result } = await p.chooseControl('从', '决').set('prompt', '请选择一项').set('ai', event => {
                                            const player = _status.event.player
                                            const target = event.player
                                            const att = get.attitude(target, player)
                                            if (target.hp < 3) return '从'
                                            if (att < 0) {
                                                return '决'
                                            }
                                            return '从'
                                        })
                                        if (result.control === '从') {
                                            cong.push(p)
                                        } else {
                                            jue.push(p)
                                        }
                                    }
                                    if (cong.length >= jue.length) {
                                        for await (const c of cong) {
                                            await c.recover()
                                        }
                                    } else {
                                        for await (const c of cong) {
                                            const cards = c.getCards('he').randomGets(2)
                                            await c.discard(cards)
                                        }
                                    }
                                }
                            },
                            qd_jiaozhen: {
                                enable: "phaseUse",
                                selectTarget: 1,
                                filterTarget(card, player, current) {
                                    return !current.hasSkill('qd_jiaozhen_used')
                                },
                                async content(event, trigger, player) {
                                    const { target } = event
                                    target.addTempSkill('qd_jiaozhen_used', 'roundStart')
                                    const { result } = await target.chooseControl('弃置一张牌并回复一点体力', '失去一点体力并移动场上一张牌然后摸一张牌').set('ai', event => {
                                        const player = _status.event.player
                                        if (player.hp < 3) return '弃置一张牌并回复一点体力'
                                        if (player.canMoveCard(null, true)) {
                                            return '失去一点体力并移动场上一张牌然后摸一张牌'
                                        }
                                        return '弃置一张牌并回复一点体力'
                                    }).set('prompt', '请选择一项')
                                    if (result.index === 0) {
                                        await target.chooseToDiscard(1, true, 'he').set('prompt', '弃置一张牌并回复一点体力值')
                                        await target.recover()
                                    } else {
                                        await target.loseHp()
                                        const can = target.canMoveCard(null, true)
                                        if (can) {
                                            await target.moveCard(true)
                                        }
                                        await target.draw()
                                    }
                                },
                                subSkill: { used: { charlotte: true } }
                            },
                            qd_huanshen: {
                                limited: true,
                                skillAnimation: true,
                                animationColor: "metal",
                                enable: "phaseUse",
                                selectTarget: [1, 3],
                                filterTarget: () => true,
                                async content(event, trigger, player) {
                                    const { targets } = event
                                    for await (const p of targets) {
                                        const { result } = await p.judge(card => {
                                            if (get.color(card) === 'red') {
                                                return 3
                                            }
                                            const suit = get.suit(card)
                                            if (suit === 'club') {
                                                return 2
                                            }
                                            if (suit === 'spade') {
                                                return 2
                                            }
                                        }).set('judge2', result => result.bool)
                                        if (result.color === 'red') {
                                            await p.damage("fire", "nocard");
                                        }
                                        if (result.suit === 'spade') {
                                            await p.turnOver()
                                        }
                                        if (result.suit === 'club') {
                                            await player.discardPlayerCard(p, 'he', Math.min(3, p.countCards('he')))
                                        }
                                    }
                                }
                            },
                            qd_modi: {
                                trigger: { global: 'phaseBeginStart' },
                                filter(trigger, player) {
                                    return trigger.player !== player
                                },
                                async content(event, trigger, player) {
                                    const target = trigger.player
                                    const { result } = await target.chooseCard(`将一张牌交给${get.translation(player)}，否则其他角色均可能对你出【杀】`, 1, 'he')
                                    if (result.bool || (result.cards && result.cards.length > 0)) {
                                        await target.give(result.cards, player, 'giveAuto', 'bySelf')
                                        const { result: huan } = await player.chooseCard(`将一张牌交给${get.translation(target)}`, 1, true, 'he')
                                        await player.give(huan.cards, target, 'giveAuto', 'bySelf')
                                    } else {
                                        const players = game.players.filter(p => p !== target)
                                        for await (const p of players) {
                                            const { result } = await p.chooseToUse(function (card) {
                                                if (get.name(card) !== "sha") return false;
                                                return lib.filter.filterCard.apply(this, arguments);
                                            }, `对${get.translation(target)}使用一张【杀】否则失去一点体力值`)
                                                .set("targetRequired", true)
                                                .set("complexSelect", true)
                                                .set("filterTarget", function (card, player, target) {
                                                    if (target != _status.event.sourcex && !ui.selected.targets.includes(_status.event.sourcex)) return false;
                                                    return lib.filter.filterTarget.apply(this, arguments);
                                                })
                                                .set("sourcex", target);
                                            if (!result.bool) {
                                                await p.loseHp()
                                            }
                                        }
                                    }
                                },
                                forced: true,
                            },
                            qd_zhaoling: {
                                mark: true,
                                marktext: '诏',
                                intro: {
                                    name: "诏令",
                                    content: "mark",
                                },
                                group: 'qd_zhaoling_use',
                                enable: "phaseUse",
                                usable: 1,
                                selectCard: [1, Infinity],
                                selectTarget: 1,
                                position: 'he',
                                selectTarget: 1,
                                filterTarget: lib.filter.notMe,
                                filterCard: () => true,
                                async content(event, trigger, player) {
                                    const { target, cards } = event
                                    player.give(cards, target).gaintag.add("qd_zhaoling_tag");
                                    await player.draw(cards.length)
                                },
                                delay: false,
                                lose: false,
                                discard: false,
                                check(card) {
                                    if (ui.selected.cards.length && ui.selected.cards[0].name == "du") return 0;
                                    if (!ui.selected.cards.length && card.name == "du") return 20;
                                    const player = get.owner(card);
                                    if (ui.selected.cards.length >= Math.max(1, player.countCards("h") - player.hp)) return 0;
                                    return 10 - get.value(card);
                                },
                                subSkill: {
                                    use: {
                                        forced: true,
                                        trigger: { global: ["useCardAfter", "respondAfter"] },
                                        filter(event, player) {
                                            return event.player.hasHistory("lose", evt => {
                                                if (event !== evt.getParent()) return false;
                                                for (const i in evt.gaintag_map) {
                                                    if (evt.gaintag_map[i].includes("qd_zhaoling_tag")) return true;
                                                }
                                            });
                                        },
                                        async content(event, trigger, player) {
                                            await player.draw()
                                            player.addMark('qd_zhaoling', 1)
                                        }
                                    }
                                }
                            },
                            qd_fuhan: {
                                trigger: { player: 'phaseZhunbeiBegin' },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "metal",
                                filter(event, player) {
                                    if (player.storage.qd_fuhanAwake) return false
                                    return player.countMark("qd_zhaoling") >= game.countGroup();
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill("qd_fuhan");
                                    player.storage.qd_fuhanAwake = true
                                    await player.gainMaxHp(3)
                                    await player.removeSkills('qd_fuhan')
                                    await player.addSkills('qd_tianzi')
                                }
                            },
                            qd_tianzi: {
                                mod: {
                                    targetInRange(card, player, target, now) {
                                        return true;
                                    },
                                },
                                forced: true,
                                trigger: { player: ['phaseDrawBegin2', 'phaseDiscardBegin'] },
                                async content(event, trigger, player) {
                                    const name = event.triggername
                                    if (name === 'phaseDrawBegin2') {
                                        trigger.num += 4
                                    } else if (name === 'phaseDiscardBegin') {
                                        trigger.cancel()
                                        // await player.skip("phaseDisacrd");
                                    }
                                }
                            },
                            qd_handi: {
                                unique: true,
                                zhuSkill: true,
                                trigger: { global: ["useCardAfter", "respondAfter"] },
                                filter(event, player) {
                                    return event.player.hasHistory("lose", evt => {
                                        if (event !== evt.getParent()) return false;
                                        for (const i in evt.gaintag_map) {
                                            if (evt.gaintag_map[i].includes("qd_zhaoling_tag")) return true;
                                        }
                                    });
                                },
                                async content(event, trigger, player) {
                                    trigger.player.addSkill('qd_handi_buff')
                                    trigger.player.when("useCardAfter").then(() => {
                                        player.removeSkill('qd_handi_buff')
                                    })
                                },
                                forced: true,
                                subSkill: {
                                    buff: {
                                        mod: {
                                            targetInRange: () => true,
                                            cardUsable: () => Infinity,
                                        },
                                        charlotte: true,
                                        mark: true,
                                        marktext: '诏',
                                        intro: {
                                            name: '诏书',
                                            content: '使用的下一张牌无距离和次数限制'
                                        }
                                    }
                                }
                            },
                            qd_yuqi: {
                                audio: 'yuqi',
                                trigger: { player: 'damageBegin2' },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget('选择要弃置的角色', [1, player.maxHp], (card, player, target) => {
                                        return !target.hasHistory('damage') && target.countCards('h') > 0
                                    }).set('ai', target => {
                                        const att = get.attitude(player, target)
                                        if (att < 0) return 10 - target.countCards('h')
                                        return target.countCards('h') - 8
                                    }).forResult()
                                },
                                async content(event, trigger, player) {
                                    const targets = event.targets.sortBySeat()
                                    const yu = []
                                    const shatao = []
                                    for await (const target of targets) {
                                        if (target.countCards('h') > 0) {
                                            const { result } = await player.discardPlayerCard(target, "h", true)
                                            result.cards.forEach(card => {
                                                const name = get.name(card)
                                                if (name === 'tao' || name === 'sha') {
                                                    shatao.push(card)
                                                } else {
                                                    yu.push(card)
                                                }
                                            })
                                        }
                                    }
                                    while (shatao.length > 0) {
                                        const { result } = await player.chooseButton(["隅泣：是否使用其中的一张牌？", shatao])
                                            .set("filterButton", button => {
                                                const player = _status.event.player
                                                const skill = `qd_yuqi_${get.name(button.link)}`
                                                return !player.hasSkill(skill) && player.hasUseTarget(button.link);
                                            })
                                            .set("ai", button => {
                                                const player = _status.event.player,
                                                    card = button.link,
                                                    cards = _status.event.getParent().cards;
                                                const val = player.getUseValue(card) + 0.01;
                                                if ((val > 0 && cards.length > 1) || (val > 4 && cards.length == 1 && (player.maxHp > 3 || player.isDamaged()))) return get.order(card) + val / 5;
                                                return 0;
                                            });
                                        if (result && result.bool) {
                                            const card = result.links[0];
                                            player.$gain2(card, false);
                                            game.delayx();
                                            player.chooseUseTarget(true, card, false);
                                            shatao.remove(card)
                                            player.addTempSkill(`qd_yuqi_${get.name(card)}`)
                                            yu.addArray(shatao)
                                        } else {
                                            yu.addArray(shatao)
                                            break
                                        }
                                    }
                                    player.addToExpansion(yu, player, "give").gaintag.add("qd_yuqi");
                                    const num = player.storage.qd_xianjingAwake ? player.maxHp : player.hp
                                    await player.draw(num)
                                },
                                marktext: "隅",
                                intro: {
                                    content: "expansion",
                                    markcount: "expansion",
                                },
                                subSkill: {
                                    sha: { charlotte: true },
                                    tao: { charlotte: true },
                                }
                            },
                            qd_shanshen: {
                                audio: 'shanshen',
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return player.getExpansions("qd_yuqi").length > 0 && player.countCards("he") > 0;
                                },
                                async cost(event, trigger, player) {
                                    const expansions = player.getExpansions("qd_yuqi");
                                    const cards = player.getCards('he')
                                    // const name = get.translation(player)
                                    const num = player.storage.qd_xianjingAwake ? player.maxHp : player.hp
                                    const max = Math.min(expansions.length, cards.length, num)
                                    const { result, moved } = await player.chooseToMove("善身：交换至多" + get.cnNumber(max) + "张牌")
                                        .set("list", [
                                            ["你的“隅”", expansions, "qd_shanshen_tag"],
                                            ["你的手牌", cards],
                                        ])
                                        .set("filterMove", (from, to, moved) => {
                                            if (typeof to == "number") return false;
                                            const { player, max } = _status.event;
                                            const hs = player.getCards("h");
                                            const changed = hs.filter(card => !moved[1].includes(card));
                                            const changed2 = moved[1].filter(card => !hs.includes(card));
                                            if (changed.length < max) return true;
                                            const pos1 = moved[0].includes(from.link) ? 0 : 1
                                            const pos2 = moved[0].includes(to.link) ? 0 : 1;
                                            if (pos1 == pos2) return true;
                                            if (pos1 == 0) {
                                                if (changed.includes(from.link)) return true;
                                                return changed2.includes(to.link);
                                            }
                                            if (changed2.includes(from.link)) return true;
                                            return changed.includes(to.link);
                                        })
                                        .set("max", max)
                                        .set("processAI", function (list) {
                                            if (_status.event.max) {
                                                let gain = list[0][1]
                                                    .sort((a, b) => {
                                                        return player.getUseValue(b, null, true) - player.getUseValue(a, null, true);
                                                    })
                                                    .slice(0, _status.event.max),
                                                    give = list[1][1]
                                                        .sort((a, b) => {
                                                            return get.value(a, player) - get.value(b, player);
                                                        })
                                                        .slice(0, _status.event.max);
                                                for (let i of gain) {
                                                    if (get.value(i, player) < get.value(give[0], player)) continue;
                                                    let j = give.shift();
                                                    list[0][1].remove(i);
                                                    list[0][1].push(j);
                                                    list[1][1].remove(j);
                                                    list[1][1].push(i);
                                                    if (!give.length) break;
                                                }
                                            }
                                            return [list[0][1], list[1][1]];
                                        })
                                    const top = expansions.filter(card => !moved[0].includes(card))
                                    const bottom = cards.filter(card => !moved[1].includes(card))
                                    event.result = {
                                        cost_data: { top, bottom },
                                        bool: result.bool
                                    }
                                },
                                async content(event, trigger, player) {
                                    const { top, bottom } = event.cost_data
                                    player.addToExpansion(bottom, "give", player).gaintag.add("qd_yuqi");
                                    await player.gain(top, "gain2")
                                    const { damage, another } = player.getExpansions("qd_yuqi").reduce((now, card) => {
                                        const add = get.tag(card, "damage") ? 'damage' : 'another'
                                        now[add]++
                                        return now
                                    }, { damage: 0, another: 0 })
                                    if (damage > another) {
                                        player.addTempSkill('qd_shanshen_gt')
                                    }
                                    if (damage === another) {
                                        player.addTempSkill('qd_shanshen_eq')
                                    }
                                    if (damage < another) {
                                        await player.recover()
                                        player.addTempSkill('qd_shanshen_lt')
                                        // player.addTempSkill('zishou2')
                                    }
                                },
                                subSkill: {
                                    gt: {
                                        forced: true,
                                        charlotte: true,
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (get.name(card, player) === 'sha') return num + 1
                                            }
                                        },
                                        trigger: { player: 'useCard' },
                                        filter(trigger, player) {
                                            return get.name(trigger.card, player) === 'sha'
                                        },
                                        async content(event, trigger, player) {
                                            if (player.getHistory('useCard', evt => get.name(evt.card) === 'sha').length === 1) {
                                                trigger.directHit.addArray(game.players)
                                            }
                                        }
                                    },
                                    eq: {
                                        trigger: { player: 'phaseDiscardBefore' },
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        async content(e, trigger) {
                                            trigger.cancel()
                                        }
                                    },
                                    lt: {
                                        charlotte: true,
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (target !== player) {
                                                    const { cards } = card
                                                    const bool = cards.some(c => get.position(c) === 'h')
                                                    if (bool) return false
                                                }
                                            },
                                        }
                                    }
                                }
                            },
                            qd_xianjing: {
                                trigger: { player: 'phaseBeginStart' },
                                audio: 'xianjing',
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "gray",
                                filter(trigger, player) {
                                    return !player.storage.qd_xianjingAwake && player.getExpansions("qd_yuqi").length >= 9
                                },
                                async content(e, t, player) {
                                    player.awakenSkill('qd_xianjing')
                                    player.storage.qd_xianjingAwake = true
                                    await player.gainMaxHp()
                                    await player.recover()
                                }
                            },
                            qd_manzu: {
                                group: ['qd_manzu_x', 'qd_manzu_y'],
                                init(player) {
                                    player.storage.manzu = { x: [0, false], y: [0, false] }
                                },
                                async addBuff(x, y, player) {
                                    x = Number(x)
                                    y = Number(y)
                                    player.storage.manzu = {
                                        x: [x, false],
                                        y: [y, false]
                                    }
                                    const abs = Math.abs(x - y)
                                    if (abs >= 0 && abs <= 4) {
                                        await player.draw(3)
                                        game.log(get.translation(player) + "获得了范围0到4的效果")
                                    }
                                    if (abs >= 5 && abs <= 8) {
                                        player.removeSkill('qd_manzu_912')
                                        player.addSkill('qd_manzu_58')
                                        game.log(get.translation(player) + "获得了范围5到8的效果")
                                    }
                                    if (abs >= 9 && abs <= 12) {
                                        player.removeSkill('qd_manzu_58')
                                        player.addSkill('qd_manzu_912')
                                        game.log(get.translation(player) + "获得了范围9到12的效果")
                                    }
                                    player.unmarkSkill('qd_manzu_x')
                                    player.unmarkSkill('qd_manzu_y')
                                },
                                subSkill: {
                                    x: {
                                        priority: 3,
                                        forced: true,
                                        mark: true,
                                        marktext: 'X',
                                        intro: {
                                            name: 'X',
                                            content(err, { storage }) {
                                                return `X的值为${storage.manzu.x[0]}`
                                            },
                                            markcount(err, { storage }) {
                                                return `${storage.manzu.x[0]}`
                                            }
                                        },
                                        trigger: { player: ['useCard', 'damageEnd'] },
                                        filter(trigger, player, triggerName) {
                                            if (triggerName === 'useCard') {
                                                return get.type(trigger.card) === 'basic'
                                            }
                                            return get.name(trigger.card) === 'sha'
                                        },
                                        async content(event, trigger, player) {
                                            const card = Array.from(ui.cardPile.childNodes).randomGet()
                                            const { number } = card
                                            await player.showCards(card, get.translation(player) + "改变了X");
                                            player.storage.manzu.x = [String(number), 'change']
                                            player.markSkill('qd_manzu_x')
                                            if (player.storage.manzu.y[1] === 'change') {
                                                const { x, y } = player.storage.manzu
                                                lib.skill.qd_manzu.addBuff(x[0], y[0], player)
                                            }
                                        }
                                    },
                                    y: {
                                        priority: 3,
                                        forced: true,
                                        mark: true,
                                        marktext: 'Y',
                                        intro: {
                                            name: 'Y',
                                            content(err, { storage }) {
                                                return `Y的值为${storage.manzu.x[0]}`
                                            },
                                            markcount(err, { storage }) {
                                                return `${storage.manzu.y[0]}`
                                            }
                                        },
                                        trigger: { player: ['useCard', 'damageEnd'] },
                                        filter(trigger, player, triggerName) {
                                            if (triggerName === 'useCard') {
                                                return get.type(trigger.card) === 'trick'
                                            }
                                            return get.name(trigger.card) !== 'sha'
                                        },
                                        async content(event, trigger, player) {
                                            const card = Array.from(ui.cardPile.childNodes).randomGet()
                                            const { number } = card
                                            await player.showCards(card, get.translation(player) + "改变了Y");
                                            player.storage.manzu.y = [String(number), 'change']
                                            player.markSkill('qd_manzu_y')
                                            if (player.storage.manzu.x[1] === 'change') {
                                                const { x, y } = player.storage.manzu
                                                lib.skill.qd_manzu.addBuff(x[0], y[0], player)
                                            }
                                        }
                                    },
                                    "58": {
                                        priority: 2,
                                        mod: {
                                            selectTarget(card, player, range) {
                                                if (range[1] !== -1) range[1]++;
                                            },
                                        },
                                        trigger: { player: 'damageEnd' },
                                        forced: true,
                                        charlotte: true,
                                        async content(event, trigger, player) {
                                            if (game.hasPlayer(current => current.countCards('he') > 0)) {
                                                const { result } = await player.chooseTarget('选择获得一名角色的一张牌', (card, player, target) => {
                                                    return target !== player && target.countCards('he') > 0
                                                }, true, 1).set('ai', target => {
                                                    return get.attitude(_status.event.player, target) < 1
                                                })
                                                if (result.bool) {
                                                    const [target] = result.targets
                                                    await player.gainPlayerCard(target, 'he', true)
                                                }
                                            }
                                        }
                                    },
                                    "912": {
                                        priority: 2,
                                        trigger: { player: ['damageEnd', 'useCard'] },
                                        forced: true,
                                        charlotte: true,
                                        async content(event, trigger, player) {
                                            const name = event.triggername
                                            if (name === 'useCard') {
                                                // trigger.num++
                                                trigger.baseDamage++
                                            } else if (name === 'damageEnd') {
                                                const { result } = await player.chooseTarget('选择令一名角色翻面并弃置其一张牌', lib.filter.notMe, true, 1).set('ai', target => {
                                                    return get.attitude(_status.event.player, target) < 1
                                                })
                                                if (result.targets && result.targets.length) {
                                                    const [target] = result.targets
                                                    await target.turnOver()
                                                    if (target.countCards('he') > 0) {
                                                        await player.discardPlayerCard(target, "he", true)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            qd_chongdian: {
                                mark: true,
                                intro: {
                                    name: '电量',
                                    content(err, player) {
                                        return String((player.storage.BartteryLevel) || 0)
                                    },
                                    markcount(err, player) {
                                        return String((player.storage.BartteryLevel) || 0)
                                    }
                                },
                                marktext: '电',
                                audio: 'xinguidao',
                                trigger: {
                                    player: 'phaseDrawBegin2',
                                    source: "damageBegin1"
                                },
                                forced: true,
                                filter(trigger, player, triggerName) {
                                    if (!player.playerBarttery) return false
                                    if (triggerName === 'damageBegin1') return player.playerBarttery.charging
                                    return true
                                },
                                async content(event, trigger, player) {
                                    const name = event.triggername
                                    if (name === 'damageBegin1' && player.playerBarttery.charging) {
                                        trigger.num++
                                    } else if (name === 'phaseDrawBegin2') {
                                        const num = Math.max(Math.ceil(player.playerBarttery.level / 25), 1)
                                        trigger.num += num
                                    }
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        if (player.playerBarttery) {
                                            return num + Math.max(Math.ceil(player.playerBarttery.level / 25), 1)
                                        }
                                        return num++
                                    },
                                },
                                setBarttery(player, level, charging) {
                                    if (!player.playerBarttery) {
                                        player.playerBarttery = {
                                            level: level * 100,
                                            charging,
                                        }
                                    } else {
                                        player.playerBarttery.level = level * 100
                                        player.playerBarttery.charging = charging
                                    }
                                    player.setMark('BartteryLevel', player.playerBarttery.level)
                                    player.markSkill('qd_chongdian_ing')
                                    player.updateMark('BartteryLevel')
                                    // player.updateMark('qd_chongdian_ing')
                                    if (player.marks.qd_chongdian_ing) {
                                        player.marks.qd_chongdian_ing.firstElementChild.innerHTML = player.playerBarttery.charging ? '充' : '断'
                                    }
                                },
                                init() {
                                    lib.message.server.playerBarttery = function (level, charging) {
                                        const player = lib.playerOL[this.id]
                                        if (!player) return;
                                        lib.skill.qd_chongdian.setBarttery(player, level, charging)
                                    }
                                    game.broadcast(() => {
                                        navigator.getBattery().then(barttery => {
                                            lib.skill.qd_chongdian.setBarttery(game.me, barttery.level, barttery.charging)
                                            game.send('playerBarttery', barttery.level, barttery.charging)
                                            barttery.addEventListener('chargingchange', e => {
                                                lib.skill.qd_chongdian.setBarttery(game.me, barttery.level, barttery.charging)
                                                game.send('playerBarttery', barttery.level, barttery.charging)
                                            })
                                        })
                                    })
                                    navigator.getBattery().then(barttery => {
                                        lib.skill.qd_chongdian.setBarttery(game.me, barttery.level, barttery.charging)
                                        barttery.addEventListener('chargingchange', e => {
                                            lib.skill.qd_chongdian.setBarttery(game.me, barttery.level, barttery.charging)
                                        })
                                    })
                                },
                                group: 'qd_chongdian_ing',
                                subSkill: {
                                    ing: {
                                        forced: true,
                                        charlotte: true,
                                        mark: true,
                                        marktext: '充',
                                        intro: {
                                            name: '充电',
                                            content(err, player) {
                                                if (player.playerBarttery) {
                                                    return player.playerBarttery.charging ? '充电中' : '断电中'
                                                }
                                                return '无'
                                            },
                                        }
                                    }
                                }
                            },
                            qd_shangwang: {
                                mark: true,
                                marktext: (() => {
                                    let online;
                                    if (navigator.onLine) {
                                        if (navigator.connection.type !== 'none' && navigator.connection.type !== 'cellular') {
                                            online = navigator.connection.type
                                        } else {
                                            online = navigator.connection.effectiveType
                                        }
                                    } else {
                                        online = '无网'
                                    }
                                    return `<span style="font-size: 15px;">${online}</span>`
                                })(),
                                intro: {
                                    name: '网络',
                                    content(err, player) {
                                        if (player.playerBarttery) {
                                            return '连'
                                        }
                                        return '断'
                                    },
                                },
                                audio: 'xinleiji',
                                filter(event, player) {
                                    return !player.hasSkill('qd_shangwang_jieyin')
                                },
                                enable: "phaseUse",
                                selectCard: 1,
                                selectTarget: 1,
                                position: 'he',
                                filterCard: () => true,
                                filterTarget: lib.filter.notMe,
                                check(card) {
                                    let num = 2
                                    if (get.type(card) === 'equip') num += 5
                                    if (get.type(card) === 'trick') num += 5
                                    if (get.type(card) === 'delay') num += 10
                                    return num
                                },
                                async content(event, trigger, player) {
                                    const num = player.getHistory('useSkill', evt => evt.skill === 'qd_shangwang').length
                                    let g = player.playerBarttery.effectiveType
                                    if (g.includes('g')) {
                                        const index = g.indexOf('g')
                                        g = (Number(g.slice(0, index)) - 1) || 3
                                    } else if (g === '无网络') {
                                        g = 0
                                    } else {
                                        g = 3
                                    }
                                    if (num >= g) {
                                        player.addTempSkill('qd_shangwang_jieyin')
                                    }
                                    const { cards, target } = event
                                    const card = cards[0]
                                    const has = target.hasCard(get.name(card))
                                    await player.give(card, target);
                                    if (!has) {
                                        const cardx = game.createCard2(card.name, card.suit, card.number, card.nature);
                                        await target.gain(cardx)
                                    }
                                    const { result } = await target.chooseCard(`你可以交给${get.translation(player)}任意张牌`, 'he', [1, Infinity]).set('ai', card => get.value(card))
                                    if (result.bool && result.cars.length > 0) {
                                        await target.give(result.cards, player)
                                    }
                                },
                                init() {
                                    lib.message.server.playerEffectiveType = function (effectiveType) {
                                        const player = lib.playerOL[this.id]
                                        if (!player) return;
                                        lib.skill.qd_shangwang.seteffectiveType(player, effectiveType)
                                    }
                                    game.broadcast(() => {
                                        let online;
                                        if (navigator.onLine) {
                                            if (navigator.connection.type !== 'none' && navigator.connection.type !== 'cellular') {
                                                online = navigator.connection.type
                                            } else {
                                                online = navigator.connection.effectiveType
                                            }
                                        } else {
                                            online = '无网'
                                        }
                                        lib.skill.qd_shangwang.seteffectiveType(game.me, online)
                                        game.send('playerEffectiveType', online)
                                        navigator.connection.addEventListener('change', e => {
                                            let online;
                                            if (navigator.connection.type !== 'none' && navigator.connection.type !== 'cellular') {
                                                online = navigator.connection.type
                                            } else {
                                                online = navigator.connection.effectiveType
                                            }
                                            lib.skill.qd_shangwang.seteffectiveType(game.me, online)
                                            game.send('playerEffectiveType', online)
                                        })
                                    })
                                    let online;
                                    if (navigator.onLine) {
                                        if (navigator.connection.type !== 'none' && navigator.connection.type !== 'cellular') {
                                            online = navigator.connection.type
                                        } else {
                                            online = navigator.connection.effectiveType
                                        }
                                    } else {
                                        online = '无网'
                                    }
                                    lib.skill.qd_shangwang.seteffectiveType(game.me, online)
                                    navigator.connection.addEventListener('change', e => {
                                        lib.skill.qd_shangwang.seteffectiveType(game.me, online)
                                    })
                                },
                                seteffectiveType(player, effectiveType) {
                                    if (!player.playerBarttery) {
                                        player.playerBarttery = {
                                            effectiveType
                                        }
                                    }
                                    if (player.marks.qd_shangwang) {
                                        let online;
                                        if (navigator.onLine) {
                                            if (navigator.connection.type !== 'none' && navigator.connection.type !== 'cellular') {
                                                online = navigator.connection.type
                                            } else {
                                                online = navigator.connection.effectiveType
                                            }
                                        } else {
                                            online = '无网'
                                        }
                                        player.marks.qd_shangwang.firstElementChild.innerHTML = `<span style="font-size: 15px;">${online}</span>`
                                    }
                                },
                                subSkill: { jieyin: { charlotte: true } }
                            },
                            qd_kaigua: {
                                audio: 'xinhuangtian',
                                enable: "phaseUse",
                                skillAnimation: "epic",
                                animationColor: "gray",
                                // group:'qd_kaigua_damage',
                                trigger: { player: 'damageEnd' },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget('令一名角色获得一个技能').set('ai', target => {
                                        return get.attitude(_status.event.player, target) > 5
                                    }).forResult()
                                },
                                limited: true,
                                selectTarget: 1,
                                filterTarget: () => true,
                                async content(event, trigger, player) {
                                    player.awakenSkill('qd_kaigua')
                                    const [target] = event.targets
                                    const createDialog = function (list, id, player) {
                                        if (list) {
                                            if (!_status.characterlist || !_status.characterlist.length !== list.length) {
                                                _status.characterlist = list;
                                            }
                                        }
                                        const filter = name => !_status.characterlist.includes(name);
                                        const dialog = ui.create.characterDialog('heightset', filter)
                                        if (player === game.me || !player) {
                                            dialog.open()
                                        }
                                        dialog.videoId = id;
                                        _status.selectDialog = dialog
                                    }
                                    event.videoId = lib.status.videoId++;
                                    if (target.isOnline2()) {
                                        target.send(createDialog, _status.characterlist, event.videoId)
                                    } else {
                                        createDialog(null, event.videoId, player)
                                    }
                                    const { result } = await target.chooseButton(true).set('ai', Math.random).set('dialog', event.videoId)
                                    if (result.links.length === 0) {
                                        result.links.push(_status.characterlist.randomGet())
                                    }
                                    const { result: control } = await target.chooseControl(...lib.character[result.links[0]].skills).set('prompt', '请选择一个技能')
                                    if (target.isOnline2()) {
                                        target.send(() => {
                                            _status.selectDialog.close()
                                            delete _status.selectDialog
                                        })
                                    } else {
                                        _status.selectDialog.close()
                                        delete _status.selectDialog
                                    }
                                    await target.addSkills(control.control)
                                },
                                // subSkill:{
                                //     audio:'xinhuangtian',
                                //     skillAnimation: "epic",
                                //     animationColor: "gray",
                                //     limited:true,
                                //     trigger:{player:'damageEnd'},
                                //     async cost(event,trigger,player){
                                //         event.result = await player.chooseTarget('令一名角色获得一个技能').set('ai',target=>{
                                //             return get.attitude(_status.event.player,target)>5
                                //         }).forResult()
                                //     },
                                //     content:lib.skill.qd_kaigua.content
                                // }
                            },
                            qd_shisheng: {
                                enable: "phaseUse",
                                usable: 1,
                                selectTarget: 1,
                                filterTarget: () => true,
                                selectCard: -1,
                                async content(event, t, player) {
                                    const { target } = event
                                    if (target === player) {
                                        game.log(get.translation(player) + '十胜选择了自己，然而无事发生')
                                        return;
                                    }
                                    let num = 0
                                    const [cards1, cards2, hp1, hp2, eq1, eq2] = [
                                        player.countCards('h'), target.countCards('h'),
                                        player.hp, target.hp,
                                        player.countCards('e'), target.countCards('e')
                                    ]
                                    if (cards1 > cards2) {
                                        num++
                                    }
                                    if (hp1 > hp2) {
                                        num++
                                    }
                                    if (eq1 > eq2) {
                                        num++
                                    }
                                    if (num >= 0) {
                                        if (num > 1) {
                                            await player.gainMaxHp()
                                            await player.recover()
                                        }
                                        if (num === 3) {
                                            await player.draw(3)
                                        }
                                        if (num === 1) {
                                            await player.gainMaxHp()
                                        }
                                    }
                                },
                                ai: {
                                    order: 7,
                                    threaten: 5,
                                    result: { target: 1 },
                                },
                            },
                            qd_shibai: {
                                trigger: { player: 'damage' },
                                async cost(event, trigger, player) {
                                    const list = ['re_guojia', 'ol_xunyu', 're_simayi', 're_caocao', 'xizhicai', 're_xunyou']
                                    const skills = ['new_reyiji', 'oljieming', 'refankui', 'new_rejianxiong', 'chouce', 'rezhiyu', 'cancel']
                                    if (!trigger.source) {
                                        skills.remove('refankui')
                                        list.remove('re_simayi')
                                    }
                                    const { result } = await player.chooseControl(skills).set("dialog", ["请选择尝试发动的技能", [list, "character"]])
                                    event.result = {
                                        bool: result.control !== 'cancel',
                                        cost_data: result.control
                                    }
                                },
                                async content(event, trigger, player) {
                                    const skill = event.cost_data
                                    player.addTempSkill(skill, 'damageAfter')
                                }
                            },
                            qd_dingce: {
                                init(player) {
                                    player.storage.qd_dingceUse = []
                                },
                                subSkill: {
                                    round: {
                                        charlotte: true,
                                        trigger: { global: "roundStart" },
                                        forced: true,
                                        lastDo: true,
                                        async content(e, t, player) {
                                            player.storage.qd_dingceUse = []
                                        }
                                    }
                                },
                                enable: ["chooseToUse", "chooseToRespond"],
                                group: 'qd_dingce_round',
                                chooseButton: {
                                    dialog(event, player) {
                                        const list = [];
                                        for (let i = 0; i < lib.inpile.length; i++) {
                                            const name = lib.inpile[i];
                                            if (player.storage.qd_dingceUse.includes(name)) continue
                                            if (name == "sha") {
                                                if (event.filterCard(get.autoViewAs({ name }, "unsure"), player, event)) list.push(["基本", "", "sha"]);
                                                for (var nature of lib.inpile_nature) {
                                                    if (event.filterCard(get.autoViewAs({ name, nature }, "unsure"), player, event)) list.push(["基本", "", "sha", nature]);
                                                }
                                            } else if (get.type2(name) == "trick" && event.filterCard(get.autoViewAs({ name }, "unsure"), player, event)) list.push(["锦囊", "", name]);
                                            else if (get.type(name) == "basic" && event.filterCard(get.autoViewAs({ name }, "unsure"), player, event)) list.push(["基本", "", name]);
                                        }
                                        return ui.create.dialog("定策", [list, "vcard"]);
                                    },
                                    check(button) {
                                        if (_status.event.getParent().type != "phase") return 1;
                                        var player = _status.event.player;
                                        if (["wugu", "zhulu_card", "yiyi", "lulitongxin", "lianjunshengyan", "diaohulishan"].includes(button.link[2])) return 0;
                                        return player.getUseValue({
                                            name: button.link[2],
                                            nature: button.link[3],
                                        });
                                    },
                                    backup(links, player) {
                                        return {
                                            filterCard(card) {
                                                return get.cardNameLength(card) === get.cardNameLength(links[0][2])
                                            },
                                            popname: true,
                                            check(card) {
                                                return 8 - get.value(card);
                                            },
                                            position: "hse",
                                            viewAs: { name: links[0][2], nature: links[0][3] },
                                            async precontent(event, unkown, player) {
                                                player.storage.qd_dingceUse.push(links[0][2])
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        return `将一张牌名字数为${get.cardNameLength(links[0][2])}的牌当做` + (get.translation(links[0][3]) || "") + get.translation(links[0][2]) + "使用";
                                    },
                                },
                                hiddenCard(player, name) {
                                    if (!lib.inpile.includes(name)) return false;
                                    return !player.storage.qd_dingceUse.includes(name)
                                },
                            },
                            qd_feili: {
                                zhuanhuanji: true,
                                mark: true,
                                marktext: "☯",
                                intro: {
                                    content(storage) {
                                        if (storage) return "阳：当你造成伤害时改为弃置目标的一张牌|或|当你受到伤害时防止之";
                                        return "阴：当你即将失去牌时防止之改为失去一点体力值";
                                    },
                                },
                                forced: true,
                                trigger: {
                                    player: ['damageBegin4', 'loseBefore', 'disableEquipBefore'],
                                    source: "damageBegin1",
                                },
                                filter(trigger, player, name) {
                                    if (player.storage.qd_feili) {
                                        return name === 'damageBegin1' || name === 'damageBegin4'
                                    }
                                    return 'disableEquipBefore' === name || (name === 'loseBefore' && trigger.cards && trigger.cards.length > 0)
                                },
                                async content(event, trigger, player) {
                                    const name = event.triggername
                                    player.changeZhuanhuanji('qd_feili')
                                    //因为已经转了所以要缓过来
                                    if (player.storage.qd_feili) {
                                        if (trigger.name === 'lose') {
                                            trigger.cancel()
                                        } else {
                                            trigger.slots.forEach(item => {
                                                if (player.getEquip(item)) {
                                                    trigger.slots.remove(item)
                                                }
                                            })
                                        }
                                        await player.loseHp()
                                    } else {
                                        if (name === 'damageBegin1') {
                                            trigger.cancel()
                                            if (trigger.player && trigger.player.countCards('he') > 0) {
                                                await player.discardPlayerCard(trigger.player, 'he', 1, true)
                                            }
                                        } else if (name === 'damageBegin4') {
                                            trigger.cancel()
                                        }
                                    }
                                },
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (!player.storage.qd_feili) {
                                            if (get.type(card) === 'equip') return 0
                                            return get.value(card, player) + 10
                                        }
                                        return num
                                    },
                                },
                                effect: {
                                    target(card, player, target, current) {
                                        if (player.storage.qd_feili) {
                                            return "zeroplayertarget";
                                        }
                                        return "zerotarget";
                                    },
                                },
                            },
                            qd_ruoyu: {
                                enable: "phaseUse",
                                filter(e, player) {
                                    if (player.storage.qd_ruoyu_num && player.storage.qd_ruoyu_num.length >= 3) return false
                                    return !player.hasSkill('qd_ruoyu_band')
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        const dialog = ui.create.dialog("若愚：请选择你要执行的一项", "hidden");
                                        let choose = [
                                            [1, "令一名体力大于等于你的角色将手牌数摸至体力上限且至多到5"],
                                            [2, "令一名手牌大于等于你的其他角色失去一点体力值"],
                                            [3, "令一名手牌数和体力值都大于你其他角色获得【肥狸】；然后你可以改变其的状态"],
                                        ]
                                        if (player.storage.qd_ruoyu_num) {
                                            choose = choose.filter(item => {
                                                return !player.storage.qd_ruoyu_num.includes(item[0])
                                            })
                                        }
                                        dialog.add([
                                            choose,
                                            "textbutton",
                                        ]);
                                        return dialog;
                                    },
                                    filter(button, player) {
                                        switch (button.link) {
                                            case 1: {
                                                return game.hasPlayer(current => {
                                                    return current.hp >= player.hp
                                                })
                                            }
                                            case 2: {
                                                return game.hasPlayer(current => {
                                                    return current.countCards('h') >= player.countCards('h')
                                                })
                                            }
                                            case 3: {
                                                return game.hasPlayer(current => {
                                                    return (current.countCards('h') > player.countCards('h')) && (current.hp > player.hp)
                                                })
                                            }
                                        }
                                    },
                                    check(button) {
                                        const player = get.event("player")
                                        if (!player) return 3
                                        switch (button.link) {
                                            case 1: {
                                                const bool = game.hasPlayer(target => {
                                                    let att = get.attitude(player, target);
                                                    if (target.hasSkillTag("nogain")) att /= 6;
                                                    if (att > 2) {
                                                        return Math.max(0, Math.min(5, target.maxHp) - target.countCards("h"));
                                                    }
                                                    return att / 3;
                                                })
                                                if (bool) return 7
                                            }
                                            case 2: {
                                                const bool = game.hasPlayer(target => {
                                                    return -get.attitude(player, target)
                                                })
                                                if (bool) return 6
                                                return 1
                                            }
                                            case 3: {//不知道怎么写了，乱写吧
                                                const bool = game.hasPlayer(target => {
                                                    return Math.max(0, get.recoverEffect(target, player, player)) + get.attitude(player, target);
                                                })
                                                if (bool) {
                                                    return 8
                                                }
                                                return 1
                                            }
                                        }
                                    },
                                    backup(links, player) {
                                        return {
                                            num: links[0],
                                            filterCard: () => false,
                                            selectCard: -1,
                                            filterTarget(card, player, target) {
                                                switch (lib.skill.qd_ruoyu_backup.num) {
                                                    case 1: {
                                                        return target.hp >= player.hp
                                                    }
                                                    case 2: {
                                                        return target.countCards('h') >= player.countCards('h')
                                                    }
                                                    case 3: {
                                                        return (target.countCards('h') > player.countCards('h')) && (target.hp > player.hp)
                                                    }
                                                }
                                            },
                                            selectTarget: 1,
                                            async content(event, trigger, player) {
                                                const target = event.targets[0];
                                                const num = lib.skill.qd_ruoyu_backup.num
                                                switch (num) {
                                                    case 1: {
                                                        const num = Math.min(target.maxHp, 5) - target.countCards('h')
                                                        if (num > 0) {
                                                            await target.draw(num)
                                                        }
                                                        break;
                                                    }
                                                    case 2: {
                                                        await target.loseHp()
                                                        break;
                                                    }
                                                    case 3: {
                                                        await target.addSkills('qd_feili')
                                                        const { result } = await player.chooseBool(`是否改变${get.translation(target)}的【肥狸】状态`)
                                                        if (result && result.bool) {
                                                            target.changeZhuanhuanji('qd_feili')
                                                        }
                                                        break;
                                                    }
                                                }
                                                player.addTempSkill('qd_ruoyu_num')
                                                player.storage.qd_ruoyu_num.push(num)
                                                if (player.storage.qd_ruoyu_num.length >= 3) {
                                                    player.addSkill('qd_ruoyu_band')
                                                }
                                            },
                                            ai: {
                                                result: {
                                                    target(player, target) {
                                                        switch (lib.skill.qd_ruoyu_backup.num) {
                                                            case 1: {
                                                                let att = get.attitude(player, target);
                                                                if (target.hasSkillTag("nogain")) att /= 6;
                                                                if (att > 2) {
                                                                    return Math.max(0, Math.min(5, target.maxHp) - target.countCards("h"));
                                                                }
                                                                return att / 3;
                                                            }
                                                            case 2: {
                                                                return -get.attitude(player, target)
                                                            }
                                                            case 3: {//不知道怎么写了，乱写吧
                                                                return Math.max(0, get.recoverEffect(target, player, player)) + get.attitude(player, target);
                                                            }
                                                        }
                                                    },
                                                },
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        const str = "###若愚###";
                                        switch (links[0]) {
                                            case 1:
                                                return str + "令一名体力值大于等于你的摸牌";
                                            case 2:
                                                return str + "令一名手牌数大于等于你的失去体力";
                                            case 3:
                                                return str + "令一名手牌数和体力值都大于你的获得【肥狸】";
                                        }
                                    },
                                },
                                subSkill: {
                                    ban: { charlotte: true },
                                    num: {
                                        charlotte: true,
                                        init(player) {
                                            player.storage.qd_ruoyu_num = []
                                        },
                                        onremove(player) {
                                            player.storage.qd_ruoyu_num = []
                                        },
                                    }
                                }
                            },
                            qd_funi: {
                                trigger: { global: 'roundStart' },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseToDiscard('he', '你可以弃置牌并视为装备等量张加一马', [1, Infinity]).set('ai', card => {
                                        return get.value(card)
                                    }).forResult()
                                },
                                async content(event, trigger, player) {
                                    player.addMark('qd_funi_distance', event.cards.length)
                                    player.addTempSkill('qd_funi_distance', 'roundStart')
                                },
                                subSkill: {
                                    distance: {
                                        forced: true,
                                        onremove(player) {
                                            player.clearMark('qd_funi_distance', true)
                                        },
                                        mark: true,
                                        marktext: '伏',
                                        intro: {
                                            name: '伏匿',
                                            content(err, player) {
                                                return `其他角色计算你的攻击距离减${player.countMark('qd_funi_distance')}`
                                            },
                                            markcount(err, player) {
                                                return player.countMark('qd_funi_distance')
                                            },
                                        },
                                        charlotte: true,
                                        trigger: { player: 'useCard' },
                                        async content(event, trigger, player) {
                                            trigger.directHit.addArray(game.filterPlayer(current => {
                                                return !current.inRange(player)
                                            }))
                                        },
                                        mod: {
                                            globalTo(from, to, distance) {
                                                return distance + to.countMark('qd_funi_distance')
                                            },
                                        },
                                    }
                                }
                            },
                            qd_chuanxin: {
                                trigger: { global: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    return event.player !== player && event.player.isIn() && !event.player.inRange(player)
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseBool(`是否摸一张牌并视为对${get.translation(trigger.player)}使用一张杀？`).set('ai', () => {
                                        return get.attitude(player, trigger.player) > 0;
                                    }).forResult()
                                },
                                async content(event, trigger, player) {
                                    player.addTempSkill('qd_chuanxin_distance', 'roundStart')
                                    await player.draw()
                                    player.addMark('qd_chuanxin_distance', 1)
                                    const target = trigger.player
                                    const card = { name: "sha", isCard: true, qd_chuanxin: true }
                                    if (player.canUse(card, target, false)) {
                                        const when = target.when('dying')
                                        when.vars({ card })
                                        when.then(() => {
                                            if (card && card.qd_chuanxin) {
                                                player.die()
                                            }
                                        })
                                        await player.useCard(card, target, false);
                                    }
                                },
                                ai: {
                                    unequip: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (!arg || !arg.card || arg.card.qd_chuanxin !== true) return false;
                                    },
                                },
                                subSkill: {
                                    distance: {
                                        mod: {
                                            globalTo(from, to, distance) {
                                                return distance - (to.countMark('qd_chuanxin_distance'))
                                            },
                                        },
                                        charlotte: true,
                                        mark: true,
                                        marktext: '穿',
                                        intro: {
                                            name: '穿心',
                                            content(err, player) {
                                                return `其他角色计算你的攻击距离减${player.countMark('qd_chuanxin_distance')}`
                                            },
                                            markcount(err, player) {
                                                return player.countMark('qd_chuanxin_distance')
                                            },
                                        },
                                        onremove(player) {
                                            player.clearMark('qd_chuanxin_distance', true)
                                        }
                                    },
                                }
                            },
                            qd_shiyun: {
                                trigger: { player: "phaseDrawBegin2" },
                                filter(event, player) {
                                    return !event.numFixed
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    trigger.num--;
                                    const card = get.cardPile(card => get.type(card) === 'basic');
                                    if (card) {
                                        player.gain(card, "gain2");
                                    } else {
                                        player.chat('牌堆没有基本牌了')
                                    }
                                },
                                ai: {
                                    threaten: -1.5,
                                },
                            },
                            qd_shiya: {
                                trigger: { global: 'phaseEnd' },
                                forced: true,
                                filter(trigger, player) {
                                    const target = trigger.player
                                    if (target === player) return;
                                    const history = target.getHistory()
                                    for (const evt in history) {
                                        switch (evt) {
                                            case 'useSkill':
                                                return history[evt].length === 0
                                            case 'useCard':
                                                return history[evt].length < 2
                                            case 'sourceDamage':
                                                return history[evt].length === 0
                                        }
                                    }
                                    return false
                                },
                                async content(event, trigger, player) {
                                    const target = trigger.player
                                    let x = 0
                                    if (target.getHistory('useSkill').length === 0) x++
                                    if (target.getHistory('useCard').length < 2) x++
                                    if (target.getHistory('sourceDamage').length === 0) x++
                                    if (x > 0) {
                                        player.line(target)
                                        await target.loseHp(x)
                                        await player.discardPlayerCard(target, x, true)
                                        if (x > 2) {
                                            target.addTempSkill("fengyin", { player: "phaseBegin" });
                                        }
                                    }
                                },
                                ai: {
                                    threaten: 10.5,
                                },
                            },
                            qd_gugu: {
                                init() {
                                    if (!_status.cardTypeList) {
                                        _status.cardTypeList = []
                                        lib.inpile.forEach(card => {
                                            _status.cardTypeList.add(get.type2(card))
                                        })
                                    }
                                },
                                trigger: { global: 'drawAfter' },
                                forced: true,
                                filter(trigger, player) {
                                    return _status.currentPhase === player && trigger.player !== player
                                },
                                group: 'qd_gugu_end',
                                async content(event, trigger, player) {
                                    const evt = trigger.getParent()
                                    if (evt.name in lib.skill || evt.skill in lib.skill) {
                                        await player.draw(trigger.result.length)
                                    }
                                },
                                subSkill: {
                                    end: {
                                        trigger: { player: 'phaseDiscardBegin' },
                                        filter(trigger, player) {
                                            return player.getHistory('useCard').length < 2
                                        },
                                        forced: true,
                                        async content(event, trigger, player) {
                                            const { result } = await player.chooseControl(..._status.cardTypeList).set('prompt', '请选择获得一种类型的牌')
                                            const card = get.cardPile(card => get.type2(card) === result.control)
                                            if (card) {
                                                await player.gain(card, 'gian')
                                            } else {
                                                player.chat(`牌堆中没有${get.translation(result.control)}类型的卡牌了`)
                                            }
                                            if (player.getHistory('sourceDamage').length === 0) {
                                                player.addTempSkill('qd_gugu_max', { player: 'phaseDiscardEnd' })
                                            }
                                        }
                                    },
                                    max: {
                                        charlotte: true,
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num += 2
                                            },
                                        },
                                    }
                                }
                            },
                            qd_gouyun: {
                                trigger: {
                                    player: "gainAfter",
                                    global: "loseAsyncAfter",
                                },
                                filter(event, player) {
                                    if (event.getg(player).length == 0) return false;
                                    return event.getParent(2).name != "qd_gouyun";
                                },
                                async content(event, trigger, player) {
                                    await player.draw("nodelay");
                                    if (player.isPhaseUsing()) {
                                        player.addTempSkill("qd_gouyun_sha");
                                        player.addMark("qd_gouyun_sha", 1, false);
                                    }
                                },
                                subSkill: {
                                    sha: {
                                        mod: {
                                            cardUsable(card, player, num) {
                                                if (card.name == "sha") return num + player.storage.qd_gouyun_sha;
                                            },
                                        },
                                        intro: {
                                            content: "<li>使用【杀】的次数上限+#",
                                        },
                                        charlotte: true,
                                        onremove: true,
                                    }
                                }
                            },
                            qd_fenjin: {
                                group: ['qd_fenjin_num', 'qd_fenjin_draw'],
                                enable: "chooseToUse",
                                selectTarget: 1,
                                filter(event, player) {
                                    return player.storage.gouyun > 0
                                },
                                filterTarget: lib.filter.notMe,
                                async content(event, trigger, player) {
                                    player.useCard({ name: "sha", isCard: true }, false, event.targets)
                                },
                                prompt: "视为使用一张无距离限制的【杀】",
                                filterCard: () => false,
                                selectCard: -1,
                                init(player) {
                                    if (!player.storage.gouyun) {
                                        player.storage.gouyun = 0
                                    }
                                    if (!player.storage.gouyundraw) {
                                        player.storage.gouyundraw = 0
                                    }
                                },
                                mark: true,
                                intro: {
                                    name: '奋进',
                                    content(err, player) {
                                        return `可以使用${player.storage.gouyun}张杀`
                                    },
                                    markcount(err, player) {
                                        return player.storage.gouyun
                                    }
                                },
                                subSkill: {
                                    num: {
                                        forced: true,
                                        trigger: { global: 'phaseEnd' },
                                        filter(event, player) {
                                            const history = player.getHistory('useSkill', evt => {
                                                return evt.skill === 'qd_gouyun' || evt.name === 'qd_gouyun'
                                            })
                                            return history.length === 0
                                        },
                                        async content(event, trigger, player) {
                                            const history = player.getHistory('useSkill', evt => {
                                                return evt.skill === 'qd_gouyun' || evt.name === 'qd_gouyun'
                                            })
                                            if (history.length === 0) {
                                                const { result } = await player.chooseControl('X加一', '摸牌阶段多摸两张').set('ai', () => {
                                                    if (player.hp < 3) return '摸牌阶段多摸两张'
                                                    return 'X加一'
                                                }).set('prompt', '请选择一项')
                                                if (result.index === 0) {
                                                    player.storage.gouyun++
                                                } else {
                                                    player.storage.gouyundraw += 2
                                                }
                                            }
                                        },
                                        popup: false
                                    },
                                    draw: {
                                        trigger: { player: "phaseDrawBegin2" },
                                        forced: true,
                                        filter(event, player) {
                                            return !event.numFixed && player.storage.gouyundraw > 0;
                                        },
                                        async content(event, trigger, player) {
                                            trigger.num += player.storage.gouyundraw;
                                            player.storage.gouyundraw = 0
                                        },
                                        ai: {
                                            threaten: 2.5,
                                        },
                                        mark: true,
                                        intro: {
                                            name: '奋进',
                                            content(err, player) {
                                                return `摸牌阶段多摸${player.storage.gouyundraw}张牌`
                                            },
                                            markcount(err, player) {
                                                return player.storage.gouyundraw
                                            }
                                        },
                                    }
                                },
                                ai: {
                                    order() {
                                        return get.order({ name: "sha" }) + 0.1;
                                    },
                                },
                            },
                            qd_lanzuo: {
                                trigger: { global: 'phaseEnd' },
                                filter(event, player) {
                                    if (player.getHistory('useCard').length !== 0) return false
                                    const has = game.hasPlayer(current => {
                                        return current !== player && Math.abs(current.countCards('h') - player.countCards('h')) <= 3
                                    })
                                    return has
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player.chooseTarget('选择和一名角色交换手牌', (card, player, target) => {
                                        return target !== player && Math.abs(target.countCards('h') - player.countCards('h')) <= 3
                                    }).set('ai', target => {
                                        return get.attitude(player, target) < 2
                                    }).forResult()
                                },
                                async content(event, trigger, player) {
                                    player.swapHandcards(event.targets[0]);
                                }
                            },
                            qd_chujia: {
                                group: ['qd_chujia_mark', 'qd_chujia_use'],
                                subSkill: {
                                    mark: {
                                        trigger: {
                                            global: "phaseBefore",
                                            player: "enterGame",
                                        },
                                        filter(event, player) {
                                            return event.name != "phase" || game.phaseNumber == 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addMark("qd_chujia_mark", 3);
                                            player.markSkill('qd_chujia_mark')
                                        },
                                        mark: true,
                                        marktext: '嫁',
                                        intro: {
                                            name: '出嫁',
                                            content(err, player) {
                                                return `当前拥有${player.storage.qd_chujia_mark}个标记`
                                            },
                                            markcount(err, player) {
                                                return player.storage.qd_chujia_mark
                                            },
                                        }
                                    },
                                    use: {
                                        trigger: { player: 'phaseUseBegin' },
                                        filter(event, player) {
                                            return player.countMark('qd_chujia_mark') > 0
                                        },
                                        async chooseTarget(player) {
                                            return await player.chooseTarget('选择一名角色交给其任意个标记', 1, (card, player, target) => {
                                                return target !== player && !target.hasSkill('qd_chujia_jia')
                                            }).set('ai', target => {
                                                return get.attitude(player, target) > 0
                                            }).forResult()
                                        },
                                        async giveMark(target, player) {
                                            if (!player.storage.qd_chujia_jiaTarget) {
                                                player.storage.qd_chujia_jiaTarget = []
                                            }
                                            if (!target.storage.qd_chujia_jiaTarget) {
                                                target.storage.qd_chujia_jiaTarget = []
                                            }
                                            player.storage.qd_chujia_jiaTarget.push(target)
                                            target.storage.qd_chujia_jiaTarget.push(player)
                                            const marks = Array.from({ length: player.countMark('qd_chujia_mark') }, (_, i) => String(i + 1))
                                            const { result: control } = await player.chooseControl(marks).set('prompt', `请选择要交给${get.translation(target)}的标记个数`)
                                            target.addSkill('qd_chujia_jia')
                                            const num = Number(control.control)
                                            target.addMark('qd_chujia_mark', num)
                                            player.removeMark('qd_chujia_mark', num)
                                            if (player.countMark('qd_chujia_mark') === 0) {
                                                player.unmarkSkill('qd_chujia_mark')
                                            }
                                            if (target.countMark('qd_chujia_mark') === 0) {
                                                target.unmarkSkill('qd_chujia_mark')
                                            }
                                        },
                                        async cost(event, trigger, player) {
                                            event.result = await lib.skill.qd_chujia_use.chooseTarget(player)
                                        },
                                        async content(event, trigger, player) {
                                            player.addSkill('qd_chujia_jia')
                                            await lib.skill.qd_chujia_use.giveMark(event.targets[0], player)
                                            for (let i = 0; i < player.countMark('qd_chujia_mark'); i++) {
                                                if (i > 3) break
                                                const bool = await lib.skill.qd_chujia_use.chooseTarget(player)
                                                if (!bool.bool) break
                                                await lib.skill.qd_chujia_use.giveMark(bool.targets[0], player)
                                            }
                                        }
                                    },
                                    jia: {
                                        mark: true,
                                        marktext: '嫁',
                                        charlotte: true,
                                        trigger: {
                                            player: 'damageBegin3',
                                            global: 'damageBegin4'
                                        },
                                        filter(event, player, name) {
                                            if (name === 'damageBegin4') {
                                                return player.countCards('h') > 0 && event.player.countMark('qd_chujia_mark') > 0
                                            }
                                            return game.hasPlayer(current => current.countMark('qd_chujia_mark') > 0)
                                        },
                                        async cost(event, trigger, player) {
                                            const name = event.triggername
                                            if (name === 'damageBegin4') {
                                                event.result = await player.chooseTarget(`选择将全部手牌交给一名其他角色，然后防止对${get.translation(trigger.player)}的伤害`, lib.filter.notMe).set('ai', target => {
                                                    return get.attitude(player, target) > 2
                                                }).forResult()
                                            } else {
                                                event.result = await player.chooseTarget(`你让有嫁的角色受到${trigger.num}+其嫁标记个数点伤害`, (card, player, target) => {
                                                    return target !== player && target.countMark('qd_chujia_mark') > 0
                                                }).set('ai', target => {
                                                    return get.attitude(player, target) < 2
                                                }).forResult()
                                            }
                                        },
                                        async content(event, trigger, player) {
                                            const [target] = event.targets
                                            const name = event.triggername
                                            if (name === 'damageBegin4') {
                                                await player.give(player.getCards('h'), target, 'give')
                                                trigger.cancel()
                                                player.addMark('qd_chujia_mark', 1)
                                                await player.changeHujia(2, null, true);
                                            } else {
                                                await target.damage(target.countMark('qd_chujia_mark') + trigger.num)
                                                target.setMark('qd_chujia_mark', 0)
                                                target.unmarkSkill('qd_chujia_mark')
                                            }
                                        }
                                    }
                                }
                            },
                            qd_tongli: {
                                trigger: { player: 'useCardToPlayered' },
                                filter(event, player) {
                                    return player.isPhaseUsing() && player.countMark('qd_chujia_mark') > 0
                                },
                                usable: 1,
                                async cost(event, trigger, player) {
                                    const marks = Array.from({ length: player.countMark('qd_chujia_mark') }, (_, i) => String(i + 1))
                                    const { result } = await player.chooseControl(...marks, 'cancel').set('prompt', `弃置任意个“嫁”标记并令${get.translation(trigger.card)}多结算等量次数`)
                                    event.result = {
                                        bool: result.control !== 'cancel',
                                        cost_data: result.control
                                    }
                                },
                                async content(event, trigger, player) {
                                    const num = Number(event.cost_data)
                                    player.removeMark('qd_chujia_mark', num)
                                    trigger.getParent().effectCount += num;
                                    player.storage.qd_tongliNum = num
                                    trigger.card.qd_tongli = true
                                    player.when('useCardAfter').then(() => {
                                        if (trigger.card.qd_tongli) {
                                            const num = player.storage.qd_tongliNum
                                            delete player.storage.qd_tongliNum
                                            player.loseHp(2 * num)
                                        }
                                    })
                                },
                            },
                            qd_baishou: {
                                global: 'qd_baishou_dying',
                                subSkill: {
                                    dying: {
                                        mod: {
                                            cardSavable(card, player, target) {
                                                if (target.isDying() && player.countMark('qd_chujia_mark') <= 0 && target.hasSkill('qd_baishou')) {
                                                    if (card.name === 'jiu' || card.name === "tao") {
                                                        return false
                                                    }
                                                }
                                            },
                                        },
                                    }
                                }
                            },
                            qd_huixiao: {
                                trigger: {
                                    player: ["loseAfter", "equipAfter"],
                                    global: ["loseAsyncAfter", "cardsDiscardAfter"],
                                },
                                filter(event, player) {
                                    const num = lib.skill.qd_huixiao.getNum(player)
                                    if (num <= 0) return false
                                    const cards2 = [];
                                    if (event.name == "cardsDiscard") {
                                        const evtx = event.getParent();
                                        if (evtx.name != "orderingDiscard") return false;
                                        const evtx2 = evtx.relatedEvent || evtx.getParent();
                                        player.getHistory("lose", (evtx3) => {
                                            var evtx4 = evtx3.relatedEvent || evtx3.getParent();
                                            if (evtx2 != evtx4) return false;
                                            if (!evtx3.cards2 || !evtx3.cards2.length) return false;
                                            cards2.addArray(evtx3.cards2.filterInD("d"));
                                        });
                                    } else if (event.name == "loseAsync") {
                                        player.hasHistory("lose", evt => {
                                            if (evt.getParent() != event || evt.position != ui.discardPile) return false;
                                            cards2.addArray(evt.cards2.filterInD("d"));
                                        });
                                    } else {
                                        cards2.addArray(event.getd(player).filterInD("d"));
                                    }
                                    return cards2.length > 0
                                },
                                getNum(player) {
                                    return player.maxHp - player.getHistory('useSkill').reduce((current, event) => {
                                        if (event.sourceSkill === 'qd_huixiao' || event.skill === 'qd_huixiao') current++
                                        return current
                                    }, 0)
                                },
                                prompt(event, player) {
                                    const num = lib.skill.qd_huixiao.getNum(player)
                                    return `是否观看牌堆顶的${num}张牌并获得一张？`
                                },
                                async content(event, trigger, player) {
                                    const num = lib.skill.qd_huixiao.getNum(player)
                                    const cards = get.cards(num + 1)
                                    const next = player.chooseToMove("选择要获得的一张牌然后其余的置于牌堆底部")
                                    next.set('list', [
                                        ['牌堆顶', cards],
                                        ['获得的牌']
                                    ])
                                    next.set("filterOk", moved => moved[1].length === 1)
                                    const { result } = await next
                                    const [bottom, top] = result.moved
                                    await player.gain(top, 'gain2')
                                    bottom.forEach(card => {
                                        ui.cardPile.appendChild(card);
                                    })
                                    player.addTempSkill('qd_huixiao_suit')
                                    if (!player.storage.qd_huixiao_suit || !player.storage.qd_huixiao_suit.includes(top[0].suit)) {
                                        await player.gainMaxHp()
                                    }
                                    player.storage.qd_huixiao_suit.add(top[0].suit)
                                },
                                subSkill: {
                                    suit: {
                                        charlotte: true,
                                        mark: true,
                                        intro: {
                                            name: '慧晓',
                                            content(err, player) {
                                                return `本回合已经获得过的花色${get.translation(player.storage.qd_huixiao_suit)}`
                                            },
                                            markcount(err, player) {
                                                return player.storage.qd_huixiao_suit || 0
                                            }
                                        },
                                        init(player) {
                                            player.storage.qd_huixiao_suit = []
                                        },
                                        onremove(player) {
                                            player.storage.qd_huixiao_suit = []
                                        }
                                    }
                                }
                            },
                            qd_tongshi: {
                                group: ['qd_tongshi_add'],
                                trigger: {
                                    global: ["useSkill", "logSkillBegin", "useCard", "respond"],
                                },
                                getSkillName(event) {
                                    let skill = event.sourceSkill || event.skill;
                                    if (!skill || skill === "qd_tongshi") return false;
                                    let info = get.info(skill);
                                    while (true) {
                                        if (!info || info.charlotte || info.equipSkill) return false;
                                        if (info && !info.sourceSkill) break;
                                        skill = info.sourceSkill;
                                        info = get.info(skill);
                                    }
                                    return { skill, info }
                                },
                                filter(event, player) {
                                    if (["global", "equip"].includes(event.type)) return false;
                                    const getSkillName = lib.skill.qd_tongshi.getSkillName
                                    const { skill, info } = getSkillName(event)
                                    return skill && info
                                },
                                mark: true,
                                intro: {
                                    name: '通识',
                                    content(err, player) {
                                        return `已记录的技能${get.translation(player.storage.qd_tongshi_used)}`
                                    }
                                },
                                async cost(event, trigger, player) {
                                    const storage = player.getStorage("qd_tongshi_used")
                                    const getSkillName = lib.skill.qd_tongshi.getSkillName
                                    const { skill } = getSkillName(trigger)
                                    if (!storage.includes(skill)) {
                                        event.result = {
                                            bool: true,
                                            cost_data: 'add'
                                        }
                                    } else {
                                        const name = get.translation(trigger.player) + '发动了' + get.translation(trigger.skill)
                                        const { result } = await player.chooseCard(`${name}<br>选择要重铸的牌`, 1, 'he').set('ai', card => {
                                            return 6 - get.value(card)
                                        })
                                        event.result = {
                                            bool: result.cards.length > 0,
                                            cost_data: result.cards
                                        }
                                    }
                                },
                                async content(event, trigger, player) {
                                    const data = event.cost_data
                                    if (data === 'add') {
                                        const getSkillName = lib.skill.qd_tongshi.getSkillName
                                        const { skill } = getSkillName(trigger)
                                        player.markAuto("qd_tongshi_used", skill);
                                    } else {
                                        await player.recast(data);
                                    }
                                },
                                subSkill: {
                                    add: {
                                        trigger: { player: 'phaseZhunbeiBegin' },
                                        filter(e, player) {
                                            const skills = []
                                            const storage = player.getStorage("qd_tongshi_used")
                                            game.players.forEach(current => {
                                                const playerSkills = current.getSkills(null, false, false).filter(i => {
                                                    const info = get.info(i);
                                                    return info && !info.charlotte && !storage.includes(i);
                                                });
                                                skills.addArray(playerSkills)
                                            })
                                            return skills.length > 0
                                        },
                                        async cost(event, trigger, player) {
                                            const skills = []
                                            const storage = player.getStorage("qd_tongshi_used")
                                            game.players.forEach(current => {
                                                const playerSkills = current.getSkills(null, false, false).filter(i => {
                                                    const info = get.info(i);
                                                    return lib.translate[i] && lib.translate[i + "_info"] && info && !info.charlotte && !storage.includes(i);
                                                });
                                                skills.addArray(playerSkills)
                                            })
                                            const list = [];
                                            for (const skill of skills) {
                                                list.push([skill, '<div class="popup text" style="width:calc(100% - 10px);display:inline-block"><div class="skill">【' + get.translation(skill) + "】</div><div>" + lib.translate[skill + "_info"] + "</div></div>"]);
                                            }
                                            const { result } = await player.chooseButton(["请选择要添加的技能", [list, "textbutton"]], 1);
                                            event.result = {
                                                bool: result.bool,
                                                cost_data: result.links
                                            }
                                        },
                                        async content(event, trigger, player) {
                                            const skill = event.cost_data
                                            player.markAuto("qd_tongshi_used", skill);
                                        }
                                    }
                                },
                                ai: {
                                    threaten: 6,
                                },
                            },
                            qd_baijie: {
                                skillAnimation: true,
                                animationColor: "wood",
                                juexingji: true,
                                unique: true,
                                trigger: { player: 'phaseZhunbeiBegin' },
                                filter(event, player) {
                                    const storage = player.getStorage("qd_tongshi_used")
                                    return storage.length >= 3 && !player.storage.qd_baijie
                                },
                                derivation: 'qd_jizhi',
                                async content(event, trigger, player) {
                                    player.awakenSkill('qd_baijie');
                                    await player.loseMaxHp(2);
                                    await player.recover()
                                    await player.addSkills('qd_jizhi');
                                },
                                ai: {
                                    threaten(player, target) {
                                        return target.getStorage('qd_tongshi_used').length
                                    },
                                }
                            },
                            qd_jizhi: {
                                enable: "phaseUse",
                                filter(trigger, player) {
                                    const num = player.getHistory('useSkill', evt => {
                                        return evt.skill === 'qd_jizhi' || evt.sourceSkill === 'qd_jizhi'
                                    }).length
                                    return num < game.players.length
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        const storage = player.getStorage('qd_jizhi_used')
                                        const list = []
                                        lib.inpile.forEach(name => {
                                            const card = { name, isCard: true }
                                            const bool = !storage.includes(name)
                                            const tag = get.tag(card, 'damage')
                                            if (bool && tag && player.hasUseTarget(card)) {
                                                const type = get.type(card)
                                                if (lib.filter.filterCard(card, player, event)) {
                                                    list.push([type, "", name]);
                                                }
                                            }
                                        })
                                        return ui.create.dialog("极智", [list, "vcard"]);
                                    },
                                    filter(button, player) {
                                        const num = player.getHistory('useSkill', evt => {
                                            return evt.skill === 'qd_jizhi' || evt.sourceSkill === 'qd_jizhi'
                                        }).length
                                        if (num < game.players.length) {
                                            return lib.filter.filterCard({ name: button.link[2] }, player, _status.event.getParent());
                                        }
                                    },
                                    check(button) {
                                        return _status.event.player.getUseValue({ name: button.link[2] });
                                    },
                                    backup(links, player) {
                                        return {
                                            popname: true,
                                            viewAs: { name: links[0][2], qd_jizhi: true, playerNum: game.players.length },
                                            selectCard: -1,
                                            filterCard: () => false,
                                            async precontent({ result }, no, player) {
                                                const name = result.card.name
                                                if (!player.storage.qd_jizhi_used) {
                                                    player.storage.qd_jizhi_used = []
                                                }
                                                player.storage.qd_jizhi_used.add(name)
                                                player.when('useCardAfter').then(() => {
                                                    'step 0'
                                                    if (trigger.card.qd_jizhi) {
                                                        if (game.players.length < trigger.card.playerNum) {
                                                            player.recover()
                                                            const num = Math.ceil(game.players.length / 2)
                                                            const next = player.chooseToMove(`获得${num}张牌`)
                                                            const cards = get.cards(game.players.length)
                                                            next.set('list', [
                                                                ['牌堆顶', cards],
                                                                ['获得的牌']
                                                            ])
                                                            next.set("filterOk", moved => moved[1].length === num)
                                                        }
                                                    }
                                                    'step 1'
                                                    if (result && result.moved) {
                                                        const [, bottom] = result.moved
                                                        player.gain(bottom, 'gain2')
                                                        player.chooseCardTarget({
                                                            prompt: `将${bottom.length}张手牌交给一名其他角色并对其造成一点伤害`,
                                                            selectTarget: 1,
                                                            filterTarget: lib.filter.notMe,
                                                            selectCard: bottom.length,
                                                            filterCard: () => true,
                                                            position: 'h',
                                                        })
                                                    }
                                                    'step 2'
                                                    if (result && result.bool) {
                                                        const target = result.targets[0]
                                                        const cards = result.cards
                                                        player.give(cards, target, 'give')
                                                        target.damage(player)
                                                    }
                                                })
                                            }
                                        };
                                    },
                                    prompt(links, player) {
                                        return "视为使用一张" + get.translation(links[0][2]);
                                    },
                                }
                            }
                        },
                        characterSort: {

                        },
                        translate: {
                            QQdiy_shenshouwang: "神守望",
                            QQdiy_shenshouwang_prefix: "神",
                            qd_tonghun: "同婚",
                            qd_tonghun_info: "游戏开始时，你可以选择一名其他角色与其获得一枚“嫁”，然后本局游戏其恢复体力时你回复等量体力，其摸牌时你摸等量的牌。",

                            QQdiy_shouwang: "守望",
                            qd_tongpin: "同嫁",
                            qd_tongpin2: "同嫁",
                            qd_tongpin_info: `①出牌阶段限一次，你可以翻面并选择一名其他角色使其获得一枚“同嫁”标记，拥有“同嫁”标记的角色回合内【杀】使用次数+1，【杀】的伤害+1。<br>
							②每轮限一次，拥有“同嫁”标记的角色即将受到伤害时，你可以弃置X张牌（X为伤害数），将伤害转移自己。<br>
							③拥有“同嫁”标记的角色受到伤害后，其移除“同嫁”标记，你复原你的武将牌。若你本轮未发动过【同嫁②】，你回复1点体力。<br>
							④若场上存在“同嫁”标记，你的武将状态无法被更改，当你受到伤害时，防止之。
							`,
                            qd_kelian: "惜玉",
                            qd_kelian_info: "锁定技。当你即将受到伤害前，你令伤害来源跳过下个摸牌阶段，且直到你的下个回合开始，你计算与其他角色距离+X（X为累积总伤害点数）。",

                            QQdiy_lutiandilang: "鹿天帝朗",
                            QQdiy_lutiandilang_prefix: "鹿天帝",
                            sw_renjie: "戒忍",
                            sw_renjie_info: "锁定技。当你即将造成伤害时，取消之，并获得等同于伤害数量两倍的“精气”。当你受到伤害时，获得一枚“精气“（“精气“上限为5）。你每次受到的伤害最多不会超过2点。你的手牌上限+X（X为“精气”标记个数）。",
                            sw_sanyang: "散阳",
                            sw_sanyang_info: "当你成为任意牌的目标时，若你有“精气”，你可以弃置一枚“精气”，取消此牌的所有目标。",
                            sw_luguan: "鹿关",
                            sw_luguan_info: `出牌阶段限一次。你可以弃置所有“精气”并表演鹿关，根据你鹿关完成的速度和弃置的“精气”数量对一名其他玩家等比造成0-2点火焰伤害（完成速度越快，标记越多，伤害越高），然后根据其性别额外执行如下效果：<br>
							①含女性：若其没有技能【害羞】，其获得之。<br>
							②其他：若其没有技能【愤懑】，其获得之。<br>
							当你在一局游戏中第三次使用该技能并结算完毕后，你死亡。<br>
							`,
                            sw_xinhuo: "心火",
                            sw_xinhuo_info: "锁定技。每当你使用偶数次牌时，你令武将牌上的前一个未失效的技能失效直到你的回合开始/回合结束。然后你摸等同于你当前失效技能个数的牌。当你因为【心火】导致此技能失效时，你减一点体力上限。",
                            sw_haixiu: "害羞",
                            sw_haixiu_info: "锁定技。每当你获得牌后，你获得等同于获得牌数的“害羞”标记。每获得8个害羞标记，你失去一点体力。",
                            sw_fenmen: "愤懑",
                            sw_fenmen_info: "锁定技。每当你造成伤害后，你获得等同于造成伤害数的“愤懑”标记。每获得3个愤懑标记，你失去一点体力。",


                            QQdiy_shenqinlang: "神秦朗",
                            QQdiy_shenqinlang_prefix: "神",
                            qd_nanchong: "男宠",
                            qd_nanchong_info: "当你使用牌后，你可以将手牌摸至或弃置至你的体力上限数。然后若你以此法：得到牌，你的体力上限-1；失去牌，你的体力上限+1。",
                            qd_weige: "伟哥",
                            qd_weige_info: "每回合限两次。当你造成或受到伤害后，你可以将体力上限重置为 7，令伤害来源弃置至多X张牌，然后你摸Y张牌（X为你以此法变化的体力上限且至少为1，Y为X减其以此法弃置的牌数）。",

                            QQdiy_gushenlangfeite: "股神朗菲特",
                            QQdiy_gushenlangfeite_prefix: "股神",
                            sw_shangshi: "上市",
                            sw_shangshi_info: "①你的回合结束时，你可以选择至多<span class=thundertext>3</span>张牌置于你的武将牌上并摸等量的牌，称为股，若你至少选择了一张牌入股且你没有护甲，你获得一点护甲。若你没有选择任何牌，则你可以进行一次判定并将判定牌置入股。②其他角色的回合开始时，若你的武将牌上有股，你令其选择一项：1.选择一张牌入股2.流失<span class=firetext>3</span>点体力。然后其进行一次判定，你将其选择的牌和判定牌置入股。③你的手牌上限始终+X（X为【上市①】中的数字）",
                            sw_kaipan: "开盘",
                            sw_kaipan_info: "锁定技。你的回合开始时，若你有股，你需猜测股票的涨跌情况并展示所有股，分别统计红色牌和黑色牌点数之和，若①红色牌点数和大于黑色牌点数和(涨)，所有入股角色摸等同于入股红色牌数量乘2的牌，且你1.猜测正确：你获得【金睛】【资本】直到回合结束。2.猜测错误：你令【上市①】中的数字减1。②黑色牌点数和大于等于红色牌点数数量的和(跌)，所有入股角色失去等同于入股红色牌数量的体力，且你1.猜测正确：你回复1点体力，获得技能【反馈】直到你的下回合开始。2.猜测错误：你令【上市②】中的数字减1。结算完毕后你弃置所有股。",
                            sw_ziben: "资本",
                            sw_ziben_info: "当你对其他角色造成伤害后，你可以获得目标区域内的一张牌。",

                            QQdiy_shenaoliao: "神奥利奥",
                            QQdiy_shenaoliao_prefix: "神",
                            qd_kanpo: "看破",
                            qd_kanpo_info: "①一轮游戏开始时，你清除〖看破①〗记录的牌名，然后你可以依次记录任意个牌名（对其他角色不可见），每轮至多记录4个牌名，总共最多记录12个牌名。若你没有记录次数，则你失去〖看破〗，从剩余牌堆中获得所有智囊牌各一张，并获得技能〖尽瘁〗。②其他角色使用你〖看破①〗记录过的牌名的牌时，你可以移去一个〖看破①〗中的此牌名的记录令此牌无效，然后你摸一张牌。",
                            qd_zhinang: "智囊",
                            qd_zhinang_info: "锁定技。当你使用非虚拟非转化且对应实体牌为1的智囊锦囊牌时，系统从技能描述中包含“无懈可击|过河拆桥|顺手牵羊|无中生有|乐不思蜀”字样的技能中随机选择三个你未拥有的技能，然后你令自己获得其中一个技能",
                            qd_jincui: "尽瘁",
                            qd_jincui_info: "锁定技。准备阶段，若牌堆剩余智囊数：大于9，你加一点体力上限并摸一张牌;大于等于7，你使用【杀】的次数上限+1;小于7，你减一点体力上限且至多减至三",

                            QQdiy_aoliao: "奥利奥",
                            sw_zhitian: "知天",
                            sw_zhitian_backup: "知天",
                            sw_zhitian_info: "①你可以将牌堆顶的牌当任意非装备牌使用，若此牌牌名不同于你使用的牌名，〖知天〗于本回合失效且你流失一点体力。②当你的体力值变化时，你可以观看牌堆顶X张牌（X为你变化后的体力值+2），并以任意顺序将牌置于牌堆顶或者牌堆底。",
                            sw_jincui: "尽瘁",
                            sw_jincui_info: "限定技。你可以失去1点体力并选择一名其他角色，然后亮出牌堆顶的七张牌，依次对其使用其中的【杀】。结算完毕后若仍有未使用的牌，你可以从中选择一张并获得之，将其余牌置入弃牌堆。一名角色的回合结束后，若本回合牌堆洗过牌或有角色死亡，你重置〖尽瘁〗。",
                            sw_qideng: "七灯",
                            sw_qideng_info: "锁定技。游戏开始时，你获得七个“灯”。当你进入濒死状态时，若你有“灯”，你须移除一个“灯”并回复体力至1点，否则你失去1点体力",

                            QQdiy_hepingshizhelang: "和平使者朗",
                            //QQdiy_hepingshizhelang_prefix: "和平使者",
                            sw_gugu: "咕咕",
                            sw_gugu_info: "①游戏开始时/结束阶段，你可以将一张♦牌当做【乐不思蜀】对自己使用，然后摸1张牌。②当你成为牌的目标时，若目标数为1且你的判定区有牌，你令此牌无效。",
                            sw_heping: "和平",
                            sw_heping_info: "锁定技。游戏开始时，你令所有存活且未拥有“和平”的角色获得“和平”标记，拥有“和平”标记角色的♠牌和♠判定牌的花色视为♥，♣牌和♣判定牌的花色视为♦。你的♦牌不计入手牌上限。",
                            sw_shangzhuo: "上桌",
                            sw_shangzhuo_info: "觉醒技。当你受到伤害后，你须废除自己的判定区，然后将武将牌替换为从X张武将牌中选择的一张（X为你的手牌数+1），并将体力和体力上限调整至3点，回复1点体力。",

                            QQdiy_dianmanzu: '典满足',
                            QQdiy_dianmanzu_prefix: '典',
                            qd_dianmanzu: "满足",
                            qd_dianmanzu_info: `每回合每项限一次，当你使用或打出牌时，若你手牌区中<br>
                            1.装备牌数量为1，你可以摸2张牌<br>
                            2.锦囊牌数量为2，你可以弃置一名角色区域内的一张牌<br>
                            3.基本牌数量为3，你可以令一名角色失去一点体力<br>
                            若均满足，你可选择顺序执行
                            `,
                            qd_dianmanzu_1: "满足·装备",
                            qd_dianmanzu_2: "满足·锦囊",
                            qd_dianmanzu_3: "满足·基本",
                            qd_dunwu: "顿悟",
                            qd_dunwu_info: "每回合限一次，当你造成或受到伤害后你可以选择任意一种类型然后从牌堆获得。",

                            QQdiy_yinmanzu: "阴满足",
                            QQdiy_yinmanzu_prefix: "阴",
                            qd_buman: "不满",
                            qd_buman_info: `
                            当你使用基本牌或成伤害时，你可以展示牌堆顶X张牌并将任意张置于牌堆底；<br>
                            当你使用普通锦囊或受到伤害时，你展示牌堆底的Y张牌并将任意张置于牌堆顶。（X为你的体力值，Y为你已损失的体力值）;<br>
                            你根据你本局展示过的牌张数执行以下效果：<br>
                            8，你摸3张牌<br>
                            16，你本局游戏使用牌可多指定一个目标+1<br>
                            32，你本局游戏使用牌造成或回复值+1<br>
                            `,
                            qd_manle: "满了",
                            qd_manle_info: "锁定技，觉醒技，你本局游戏展示的牌大于等于32张时，你加一点体力上限、摸三张牌或回复一点体力。然后获得【满足】",
                            qd_yinmanzu: "满足",
                            qd_yinmanzu_info: "每轮游戏开始时，你可选择一种类型的牌，当你获得同类型的牌时，你可以选择【不满】中三个效果之一执行。",


                            QQdiy: '自定义武将',
                            QQdiy_caoren: '速曹仁',
                            QQdiy_caoren_prefix: '速',

                            QQdiy_yinxiaohu: "阴小虎",
                            QQdiy_yinxiaohu_prefix: "阴",
                            qd_shushi: "淑识",
                            qd_shushi_info: `
                            一名角色的准备阶段，你可以将一张牌置于其武将牌上记作“止”或“息”；<br>
                            拥有“止”的角色回合内使用或打出与“止”不同类型的牌时其需选择弃一张牌或失去一点体力然后其将使用的实体牌置于武将牌上称为“止”；一名角色的“此”大于等于体力上限时其弃置所有“止”并弃置等量张牌然后结束出牌阶段；<br>
                            拥有“息”的角色回合内使用或打出与“息”相同类型的牌时其可选择摸一张牌或回复一点体力然后令此牌无效并将此置于武将牌上称为“息”；一名角色的“积”大于等于体力上限时其弃置所有“息”并摸等量张牌。
                            `,
                            qd_shushi_zhi: "止",
                            qd_shushi_xi: "息",
                            qd_pingyuan: "平怨",
                            qd_pingyuan_info: "出牌阶段限X次，你可以获得场上的一张“止”或“息”，令被获得的角色选择摸两张牌或对攻击范围内的角色造成一点伤害。（X为你的体力值）",
                            qd_lizang: "礼葬",
                            qd_lizang_info: "限定技，你死亡时，你可令一名有“止”或“息”的角色重铸区域内所有牌，然后将手牌数调整为其体力上限。",

                            QQdiy_sbzhonghui: '谋钟会',
                            QQdiy_sbzhonghui_prefix: '谋',
                            qd_sbquanji: '权记',
                            qd_sbquanji_info: '当你受到一点伤害后可以摸两张牌，出牌阶段你可以将任意张牌置于武将牌上称之为“权”，你的手牌上限加等同于“权”的数量',
                            qd_sbzili: "自立",
                            qd_sbzili_info: "锁定技，准备阶段若你的“权”数量大于2你失去自立获得【排异】然后回复一点体力并摸两张牌。",
                            qd_sbpaiyi: "排异",
                            qd_sbpaiyi_info: "出牌阶段每项限一次，你可以弃置一张“权”并选择一项与一名其他角色对比：1.体力值 2.手牌数 3.装备区牌数。若其的数：<br>大于你，你观看其手牌并弃置其一种花色的手牌。<br>等于你，你摸两张牌。<br>小于你，你对其造成一点伤害。",
                            qd_sbpaiyi_selected: "排异",
                            qd_sbpaiyi_backup: "排异",

                            QQdiy_zhicaochong: "智曹冲",
                            QQdiy_zhicaochong_prefix: "智",
                            qd_zhisuan: '智算',
                            qd_zhisuan_info: '当你受到伤害或使用点数为X的牌时，若牌堆剩余数大于3，你展示牌堆顶4张牌然后获得其中任意张，将获得的点数记为X，若X为13你回复一点体力值。',
                            qd_renxin: '仁心',
                            qd_renxin_info: '一名角色脱离濒死状态后你可将一张牌置入仁区，其他角色回合开始时你可弃置仁区任意张牌令其本回合不能使用该类型的牌。',

                            QQdiy_yangyi: '杨昱',
                            qd_ruiyan: '睿言',
                            qd_ruiyan_info: '锁定技，出牌阶段开始时，你令一名角色把手牌数调整至其体力值，若其以此法 失去/获得牌，其回复/你失去一点体力',
                            qd_kuangmiu: '匡谬',
                            qd_kuangmiu_info: '锁定技，你的第X阶段改为一个摸牌阶段，并于弃牌阶段后再执行一个额外的出牌阶段（X为已损失的体力）',
                            qd_fengci: '锋辞',
                            qd_fengci_info: '锁定技，每轮各项各限两次，当你造成/受到伤害，你扣减/增加一点体力上限，然后获得缜略/专对，当你的体力上限变化时摸两张牌',

                            QQdiy_zhonghui: '异钟会',
                            QQdiy_zhonghui_prefix: '异',
                            qd_weiwo: '帷幄',
                            qd_weiwo_info: '一轮限两次（当存活人数小于4则修改为一次），其他角色的准备阶段，你可以声明一种类型的牌并令其展示所有手牌，若有你声明的类型的牌，则你弃置其中一张牌，你摸X张牌（X为自身体力上限）。',
                            qd_yajun: '严军',
                            qd_yajun_info: '出牌阶段限一次，你可以将一张牌交给其他一名角色，并令其选择一项：1.失去一点体力并使用这张牌。2.摸两张牌',
                            qd_moubian: '谋变',
                            qd_moubian_info: '觉醒技，自己回合结束时，累计受到或造成3点及以上伤害，你增加一点体力上限，摸两张牌并回复一点体力，获得“据蜀”，并将严军描述修改为出牌阶段限两次。',
                            qd_jushu: '据蜀',
                            qd_jushu_info: '锁定技，每回合结束时自身受到Y点伤害，摸牌阶段多摸Y张，自身使用的前Y张牌无距离和次数限制，且不可响应（Y为自身已损失体力值且至少为一）',

                            QQdiy_jushou: '异沮授',
                            QQdiy_jushou_prefix: '异',
                            qd_jianying: '渐营',
                            qd_jianying_info: '每当你于出牌阶段内使用的牌与此阶段你使用的上一张字数相同时，你可以摸一张牌，字数相差为1下一张牌无距离和次数限制，字数相差为2或更多时重置权略',
                            qd_quanlue: '权略',
                            qd_quanlue_info: '出牌阶段限一次，你可以弃置一张牌从牌堆中抽取一张任意字数的牌',
                            qd_shibei: '矢北',
                            qd_shibei_info: '锁定技，当你每回合首次受到伤害后，你回复1点体力，然后当你本回合第二受到伤害后，你失去1点体力并摸一张牌',

                            QQdiy_guanyu: '逆天关羽',
                            QQdiy_guanyu_prefix: '逆天',
                            qd_wusheng: '武圣',
                            qd_wusheng_info: `①游戏开始时你获得3枚“武”标记。你的回合开始时，你可以将任意枚“武”标记分配给任意名角色。<br>
                            准备阶段开始时你可以移动任意角色的任意枚"武"标记。<br>
                            ②若一名角色的“武”标记数量为1/2/3，依次获得以下效果：其使用的杀无视防具，被指定目标需弃置一半手牌（向上取整）或交给其2张牌，其本回合使用杀的次数＋X(X为本回合因弃置而进入弃牌堆的牌的数量，且最多为3）；其使用的第一张杀指定目标后，除目标与拥有"武"标记角色外其余角色本回合能不能使用或者打出手牌；①每轮限一次，其回合结束后执行一个额外的回合，
                            ②每轮限一次，其回合内若有角色死亡，其重置①。`,
                            qd_wushen: '武神',
                            qd_wushen_info: '使命技。使命：你的回合开始时，若所有拥有"武"标记的角色一共击杀3个及以上的角色，你获得额外3个"武"标记。失败：当你进入濒死状态时，你将体力值恢复为1点，然后每个回合开始时，你移去场上一个"武"标记。',

                            QQdiy_siji: 'sunshine',
                            qd_yiding: '亿定',
                            qd_yiding_info: '锁定技，其他角色不因此技能使用牌指定你为目标时，若此牌有实体牌，你令此牌对你无效记录此牌使用者并将此牌置于你的武将牌上，称为“定”；<br>回合开始时，若你武将牌上有“定”，你令“定”的原使用者视为对你使用此牌，不能使用或使用者不在场上的的则置入弃牌堆。若你因此进入濒死状态，你摸X张牌（X为你本回合已成为其他角色使用牌的目标次数）',
                            qd_qiuxian: '求贤',
                            qd_qiuxian_info: '当你于回合内使用牌时，你可选择一名角色，其可以选择一项：<br>1.交给你一张牌<br>2.令此牌不可响应<br>3.弃置一张牌并令此牌造成或回复的数值加一',

                            QQdiy_lansiji: '烂司机',
                            QQdiy_lansiji_prefix: '烂',
                            qd_yinbing: '引兵',
                            qd_yinbing_info: '出牌阶段限一次，你可令所有角色在“从”和“决”中选择一项，且你自己固定为选“从”，<br>若“从”的人数大于等于“决”的人数，则选择“从”的玩家回复一点体力值，否则选择“从”的玩家随机弃置两张牌。',
                            qd_jiaozhen: '叫阵',
                            qd_jiaozhen_info: '每名角色每轮限一次，出牌阶段，你可选择一名角色令其<br>1.弃置一张牌并回复一点体力值<br>2.失去一点体力并移动场上一张牌然后摸一张牌',
                            qd_huanshen: '唤神',
                            qd_huanshen_info: '限定技，出牌阶段，你可令至多三名角色进行判定，若有角色判定为<br>红色：其受到一点火焰伤害<br>梅花：你弃置其3张牌<br>黑桃：其翻面',

                            QQdiy_hanxiandi: '异汉末献帝',
                            qd_modi: '末帝',
                            qd_modi_info: '锁定技，其他角色的回合开始时，其可交给你一张牌然后你交给其一张牌，否则除你和其外的角色需对其使用一张【杀】或失去一点体力值',
                            qd_zhaoling: '诏令',
                            qd_zhaoling_tag: '诏',
                            qd_zhaoling_info: '出牌阶段限一次，你可将任意张牌交给一名角色，称为“诏”然后摸等量张牌；当有角色使用或打出“诏”后你摸一张牌并获得一枚“汉”标记',
                            qd_fuhan: '复汉',
                            qd_fuhan_info: '觉醒技，准备阶段，若你的“汉”数量大于等于场上势力数时，你增加三点体力上限，失去[复汉]并获得[天子]',
                            qd_tianzi: '天子',
                            qd_tianzi_info: '锁定技，你使用牌无距离限制，你的摸牌阶段摸牌数量加四，你始终跳过弃牌阶段',
                            qd_handi: '汉帝',
                            qd_handi_info: '主公技，每名角色每轮限一次，当其使用“诏”后，其使用的下一张牌无视距离且无次数限制',

                            QQdiy_caojinyu: '异曹金玉',
                            QQdiy_caojinyu_prefix: '异',
                            qd_yuqi: '隅泣',
                            qd_shanshen_tag: '隅',
                            qd_yuqi_info: '当你受到伤害时，你可弃置至多X名本回合未受伤过的角色的一张手牌，若弃置的牌中有【杀】或【桃】则你可以使用之（每回合每张牌名限一次），然后你将未使用的牌置于你的武将牌上，称为“隅”并摸Y张牌。（X为你的体力上限，Y为你的体力值）',
                            qd_shanshen: '善身',
                            qd_shanshen_info: '准备阶段，你可以使用至多Y张牌交换“隅”，然后根据“隅”中伤害牌和其他牌的大小关系获得以下对应效果：<br>大于，则你本回合：使用【杀】的次数加一，使用的第一张【杀】不可响应<br>等于：你跳过本回合的弃牌阶段<br>小于：你回复一点体力且本回合无法对其他角色使用手牌<br>（X为你的体力上限，Y为你的体力值）',
                            qd_xianjing: '娴静',
                            qd_xianjing_info: '觉醒技，你的回合开始时，若你武将牌上的“隅”数量大于等于9，你增加一点体力上限并回复一点体力，然后将【隅泣】和【善身】中的Y值改为X值。',

                            QQdiy_lanmanzu: '烂满足',
                            QQdiy_lanmanzu_prefix: '烂',
                            qd_manzu: '满足',
                            qd_manzu_info: `
                            1.当你使用一张基本牌时或你受到【杀】造成的伤害后，你随机展示牌堆中的一张牌并将此牌点数记录为X；
                            2.当你使用普通锦囊牌时或受到非【杀】造成的伤害后，你随机展示牌堆中的一张牌并将此牌点数记录为Y；
                            当X和Y均变化后，获得或执行以下集合中包含(X和Y差值)的相应效果并失去此前以此法获得的效果：
                            [0-4] 你摸三张牌
                            [5-8] 你使用牌可多指定一个目标；你受到伤害后可获得一名角色一张牌
                            [9-12] 你使用的牌伤害或回复值+1；你受到伤害后可令一名角色武将牌翻面并弃置其一张牌
                            `,

                            QQdiy_zhangjiao: '智能张角',
                            QQdiy_zhangjiao_prefix: '智能',
                            qd_chongdian: '充电',
                            qd_chongdian_info: '锁定技，摸牌阶段你多摸X张牌，你的手牌上限加X；当你造成伤害时，若你的设备处于充电状态，你令此伤害加一（X为你的电量百分比除以二十五向上取整且至少为1）',
                            qd_shangwang: '上网',
                            qd_shangwang_info: '出牌阶段限X次，你可以将一张牌交给一名其他角色，若其原先未拥有与此牌名相同的牌，则其获得一张此牌的复制牌，然后其可以交给你任意张牌（X为你使用的网络G数减一，若无则X为3）',
                            qd_kaigua: '开挂',
                            qd_kaigua_info: '限定技，出牌阶段或当你受到伤害后，你可以令一名角色在已开启的武将里选择并获得一个武将的一个技能。',

                            QQdiy_guojia: '经典郭嘉',
                            QQdiy_guojia_prefix: '经典',
                            qd_shisheng: '十胜',
                            qd_shisheng_info: '出牌阶段限一次，你可与一名角色比较手牌数、血量、装备区牌数，然后执行前X项<br>1.增加一点体力上限<br>2.回复一点体力值<br>3.摸三张牌（X为比较中你大于其的次数）。',
                            qd_shibai: '十败',
                            qd_shibai_info: '每当你受到一点伤害后你可以在[遗计，节命，反馈，奸雄，筹策，智愚]中选择一个发动。',
                            qd_dingce: '定策',
                            qd_dingce_info: '你可以将一张牌当做任意同字数的牌使用，每个牌名每轮限一次。',

                            QQdiy_benmao: '笨猫',
                            qd_feili: '肥狸',
                            qd_feili_info: '转换技，锁定技，<br>阴：当你即将失去牌时，防止之，改为你失去一点体力。<br>阳：当你：受到一点伤害时，防止之；造成一点伤害时改为弃置目标一张牌。',
                            qd_ruoyu: '若愚',
                            qd_ruoyu_info: '出牌阶段每项限一次，你可以令一名体力值大于等于你的角色将手牌摸至体力上限（至多为5），你可以令一名手牌不少于你的其他角色失去一点体力，你可以令一名体力和手牌都多于你的角色获得【肥狸】直到其回合开始，随后你可以更改其【肥狸】的状态',

                            QQdiy_zhangren: '张任',
                            qd_funi: '伏匿',
                            qd_funi_info: '一轮游戏开始时，你可以弃置任意张牌并令本轮其他角色计算与你的距离加等量的数，若如此做，攻击范围没有你的角色无法响应你使用的牌。',
                            qd_chuanxin: '穿心',
                            qd_chuanxin_info: '一名角色的回合开始时，若其攻击范围内没有你，你可令本轮其他角色计算与你的距离减一然后摸一张牌并视为对其使用一张无视防具的【杀】。若此【杀】令其进入了濒死状态，其死亡。',

                            QQdiy_gudasha: '咕哒鲨',
                            qd_shiyun: '失运',
                            qd_shiyun_info: '锁定技，摸牌阶段你少摸一张牌并从牌堆中获得一张基本牌。',
                            qd_shiya: '施压',
                            qd_shiya_info: '锁定技，其他角色的结束阶段，若X大于0，其失去X点体力值然后你弃置其X张牌<br>1.没有使用过技能<br>2.使用的牌张数小于3<br>3.没有造成伤害；若X大于等于2，其技能失效直到其下个回合开始（X为其以上满足的项数）',
                            qd_gugu: '咕咕',
                            qd_gugu_info: '锁定技，你的回合内，其他角色因使用技能摸牌后你摸等量的牌；弃牌阶段开始时若你本回合:使用过的牌数小于3你从牌堆中获得一张指定类型的牌；未造成伤害，你的手牌上限+2直到你的下个弃牌阶段结束；',

                            QQdiy_haomanzu: '好满足',
                            QQdiy_haomanzu_prefix: '好',
                            qd_gouyun: '狗运',
                            qd_gouyun_info: '你不因摸牌阶段和此技能获得牌时你可以摸一张牌，若此时为你的出牌阶段你本回合使用的【杀】次数加一。',
                            qd_fenjin: '奋进',
                            qd_fenjin_info: '你可以视为使用X张无距离和次数限制的【杀】<br>（X初始为0）；<br>一名角色的回合结束后，若你本回合没有发动过【狗运】，你可以选择<br>1.摸牌阶段摸牌数加二<br>2.X加一',
                            qd_lanzuo: '懒做',
                            qd_lanzuo_info: '其他角色的回合结束后，若你本回合没有使用过牌，你可以与一名与你手牌数差值小于等于3的角色交换手牌',

                            QQdiy_chujia: '初嫁',
                            qd_chujia: '出嫁',
                            qd_chujia_info: '游戏开始时你获得3个“嫁”标记；出牌阶段开始时你可以至多3名角色任意个“嫁”标记然后你与其获得如下效果:<br>1.当你受到伤害时，你可以令有“嫁”标记的角色受到嫁标记数加本次伤害点数点伤害然后其移去所有“嫁”<br>2.当有“嫁”的角色受到伤害时你可以将所有手牌交给一名其他角色然后防止此伤害并且你获得2点护甲',
                            qd_tongli: '同礼',
                            qd_tongli_info: '出牌阶段限一次，当你使用牌指定目标时，你可以弃置任意个“嫁”并令此牌多结算等量次，结算结束后你失去两倍的体力值；',
                            qd_baishou: '白首',
                            qd_baishou_info: '锁定技，当你进入濒死状态，只有有“嫁”的角色能对你使用【桃】或【酒】。',

                            QQdiy_congmingmao: '聪明猫',
                            qd_huixiao: '慧晓',
                            qd_huixiao_info: '当你的牌进入弃牌堆后，你可以观看牌堆顶的X张牌然后获得一张并将其余的置于牌堆底，且X减一，若此牌的花色为本回合第一次因本技能获得，你加一点体力上限。（X为你的体力上限）',
                            qd_tongshi: '通识',
                            qd_tongshi_info: '锁定技，一名角色使用技能时，若你记录过此技能你记录之否则你可以重铸一张牌；回合开始时，你可以在场上的技能中增加【通识】中一个技能；',
                            qd_baijie: '百解',
                            qd_baijie_info: '觉醒技，准备阶段若你【通识】记录的技能个数大于等于3，你减2点体力上限恢复一点体力值然后获得【极智】',
                            qd_jizhi: '极智',
                            qd_jizhi_info: '出牌阶段限X此，你可以失去一点体力上限然后视为使用一张伤害锦囊，此牌结算结束后若场上人数减少，你恢复一点体力值然后观看牌堆顶的X张牌并选择获得一半的牌，随后你可以将等量的手牌交给一名角色并对其造成一点伤害。（X为存活人数）',
                        },
                        dynamicTranslate: {
                            qd_yajun(player) {
                                return `出牌阶段限${player.storage.qd_moubian ? '两' : '一'}次，你可以将一张牌交给其他一名角色，并令其选择一项：1.失去一点体力并使用这张牌。2.摸两张牌`
                            },
                            qd_feili(player) {
                                if (player.storage.qd_feili) return `
                                转换技，锁定技，<br>阴：当你即将失去牌时，防止之，改为你失去一点体力。<br><span style="color:skyblue;">阳：当你：受到一点伤害时，防止之；造成一点伤害时改为弃置目标一张牌。</span>
                                `
                                return `
                                转换技，锁定技，<br><span style="color:skyblue;">阴：当你即将失去牌时，防止之，改为你失去一点体力。</span><br>阳：当你：受到一点伤害时，防止之；造成一点伤害时改为弃置目标一张牌。
                                `
                            },
                            sw_shangshi(player) {
                                var info = lib.skill.sw_shangshi.getInfo(player);
                                return "①你的回合结束时，你可以选择至多<span class=thundertext>" + info[0] + "</span>张牌置于你的武将牌上并摸等量的牌，称为股，若你至少选择了一张牌入股且你没有护甲，你获得一点护甲。若你没有选择任何牌，则你可以进行一次判定并将判定牌置入股。②其他角色的回合开始时，若你的武将牌上有股，你令其选择一项：1.选择一张牌入股2.流失<span class=firetext>" + info[1] + "</span>点体力。然后其进行一次判定，你将其选择的牌和判定牌置入股。③你的手牌上限始终+等同于【上市①】中的数字";
                            }
                        },
                        characterReplace: {
                            QQdiy_lanmanzu: ['QQdiy_lanmanzu', 'QQdiy_yinmanzu', 'QQdiy_haomanzu', 'QQdiy_dianmanzu'],
                            QQdiy_siji: ['QQdiy_siji', 'QQdiy_lansiji'],
                        }
                    }
                },
                LM: {
                    //by：凌梦
                    oldCharacter: {
                        name: "oldCharacter",
                        connect: true,
                        //武将分包
                        characterSort: {
                            oldCharacter: {
                                mb_old: ["old_new_simayi", "old_shen_lusu", "old_mb_jushou", "old_mb_zhuzhi", "old_mb_sp_zhenji", "old_fuqian", "old_mb_guozhao", "old_mb_chengui", "old_yangfu", "old_lizhaojiaobo", "old_wangling", "old_sp_wangshuang", "old_wujing", "old_qiaogong", "old_sp_lvfan", "old_xin_zhangzhongjing", "old_sp_zhujun", "old_yj_weiyan", "old_yj_zhoubuyi", "old_liwei", "old_shenpei", "old_mb_sp_guanqiujian", "old_mb_wangjing", "old_sp_jianggan", "old_sb_huangzhong", "old_sb_huangyueying", "old_sb_gongsunzan", "old_sb_sunquan", "old_sb_huanggai", "old_sb_ganning", "old_sb_xiaoqiao", "old_sb_daqiao", "old_sb_sunce", "old_sb_sp_zhugeliang", "old_sb_zhugeliang", "oldx_sb_sp_zhugeliang", "oldx_sb_zhugeliang", "old_sb_menghuo", "old_sb_zhurong", "old_sb_guanyu", "old_sb_zhaoyun", "old_sb_fazheng", "old_sb_xuhuang", "old_sb_yuanshao", "old_sb_handang", "old_sb_huaxiong", "old_sb_jiaxu", "old_sb_zhugejin", "old_sb_zhangliao", "old_sb_guojia", "old_sb_gaoshun", "old_sb_luxun", "old_friend_xushu"],
                                ol_old: ["oldx_clan_xuncai", "old_clan_zhonghui", "old_clan_hanrong", "old_clan_hanshao", "old_zhanghua", "old_yuanji", "old_tengfanglan", "old_dengzhong", "old_wangyan", "old_ol_luyusheng", "old_ol_hujinding", "old_ol_feiyi", "old_ol_pengyang", "old_sp_sunce", "old_ol_yufan", "old_zhugejin", "old_ruiji", "old_xurong", "old_ol_qianzhao", "old_ol_sb_dongzhuo", "old_ol_nanhualaoxian", "old_ol_sb_dengai", "old_ol_wangyi", "old_ol_xuelingyun"],
                                xin_old: ["old_re_zhangchunhua", "old_re_caorui", "old_dc_xushu", "old_yuechen", "old_ruanyu", "old_bailingyun", "old_dc_liuli", "old_yue_miheng", "old_wu_zhugeliang", "old_wu_guanyu", "old_wu_huangfusong", "old_dc_shen_huatuo", "old_xunyuxunyou", "old_zhugejing", "old_xin_zhonghui", "old_yj_majun", "old_star_fazheng", "old_pangfengyi", "old_v_sunquan"],
                                tw_old: ["old_tw_huojun", "old_tw_guohuai", "oldx_quancong", "old_tw_baoxin", "old_tw_zhangmancheng", "old_tw_guanqiujian", "old_tw_niufudongxie", "old_xia_tongyuan", "old_xia_guanyu", "old_huan_zhugeliang", "old_huan_weiyan", "old_huan_zhugeguo", "old_tw_shen_lvmeng", "old_huan_caoang"],
                                other_old: ["old_gaowang", "old_zhangren"],
                            },
                        },
                        //武将
                        character: {
                            //手杀
                            old_new_simayi: ["male", "shen", 4, ["old_jilin", "old_yingyou", "old_yingtian"], ["character:new_simayi", "die:new_simayi", "wei", "name:司马|懿"]],
                            old_shen_lusu: ["male", "shen", 3, ["old_tamo", "old_dingzhou", "old_zhimeng"], ["character:shen_lusu", "die:shen_lusu", "wu"]],
                            old_mb_jushou: ["male", "qun", 3, ["old_xinjianying", "xinshibei"], ["character:xin_jushou", "die:xin_jushou"]],
                            old_mb_zhuzhi: ["male", "wu", 4, ["old_sbanguo"], ["character:xin_zhuzhi", "die:xin_zhuzhi"]],
                            old_mb_sp_zhenji: ["female", "qun", 3, ["old_mbbojian", "old_mbjiwei"], ["character:mb_sp_zhenji", "die:mb_sp_zhenji"]],
                            old_fuqian: ["male", "shu", 4, ["old_jueyong", "old_poxiang"], ["character:fuqian", "die:fuqian"]],
                            old_mb_guozhao: ["female", "wei", 3, ["old_yichong", "old_wufei"], ["character:xin_guozhao", "die:xin_guozhao"]],
                            old_mb_chengui: ["male", "qun", 3, ["old_guimou", "zhouxian"], ["character:mb_chengui", "die:mb_chengui"]],
                            old_yangfu: ["male", "wei", 4, ["oldx_jiebing", "old_hannan"], ["character:yangfu", "die:yangfu"]],
                            old_lizhaojiaobo: ["male", "wei", 4, ["old_mbzuoyou", "old_mbshishou"], ["character:lizhaojiaobo", "die:lizhaojiaobo", "name:李|昭-焦|伯"]],
                            old_wangling: ["male", "wei", 4, ["mouli", "zifu"], ["character:wangling", "die:wangling", "clan:太原王氏"]],
                            old_sp_wangshuang: ["male", "wei", 4, ["yiyong", "old_shanxie"], ["character:sp_wangshuang", "die:sp_wangshuang"]],
                            old_wujing: ["male", "wu", 4, ["heji", "old_liubing"], ["character:wujing", "die:wujing"]],
                            old_qiaogong: ["male", "wu", 3, ["old_yizhu", "luanchou"], ["character:qiaogong", "die:qiaogong", "name:桥|null"]],
                            old_sp_lvfan: ['male', 'wu', 3, ['spdiaodu', 'spdiancai', 'spyanji'], ["character:sp_lvfan", "die:sp_lvfan"]],
                            old_xin_zhangzhongjing: ["male", "qun", 3, ["jishi", "liaoyi", "binglun"], ["character:zhangzhongjing", "die:zhangzhongjing"]],
                            old_sp_zhujun: ["male", "qun", 4, ["yangjie", "zjjuxiang", "houfeng"], ["character:sp_zhujun", "die:sp_zhujun"]],
                            old_yj_weiyan: ["male", "qun", 5, ["mbguli", "mbaosi"], ["character:yj_weiyan", "die:yj_weiyan"]],
                            old_yj_zhoubuyi: ["male", "wei", 3, ["old_mbhuiyao", "old_mbquesong"], ["character:yj_zhoubuyi", "die:yj_zhoubuyi"]],
                            old_shenpei: ["male", "qun", 3, ["shouye", "liezhi"], ["character:shenpei", "die:shenpei"]],
                            old_mb_sp_guanqiujian: ["male", "wei", 4, ["old_mbcuizhen", "mbkuili"], ["character:mb_sp_guanqiujian", "die:mb_sp_guanqiujian", "name:毌丘|俭"]],
                            old_mb_wangjing: ["male", "wei", 3, ["mbzujin", "old_mbjiejian"], ["character:mb_wangjing", "die:mb_wangjing"]],
                            old_sp_jianggan: ["male", "wei", 3, ["spdaoshu", "spdaizui"], ["character:sp_jianggan", "die:sp_jianggan"]],
                            old_liwei: ["male", "shu", 4, ["old_jiaohua"], ["character:liwei", "die:tw_liwei"]],
                            old_friend_xushu: ["male", "qun", 3, ["old_friendxiaxing", "friendqihui", "friendxushugongli"], ["character:friend_xushu", "die:friend_xushu"]],

                            old_sb_huangyueying: ["female", "shu", 3, ["sbjizhi", "old_sbqicai"], ["character:sb_huangyueying", "die:sb_huangyueying"]],
                            old_sb_huangzhong: ["male", "shu", 4, ["old_sbliegong"], ["character:sb_huangzhong", "die:sb_huangzhong"]],
                            old_sb_gongsunzan: ["male", "qun", 4, ["sbyicong", "old_sbqiaomeng"], ["character:sb_gongsunzan", "die:sb_gongsunzan", "name:公孙|瓒"]],
                            old_sb_sunquan: ["male", "wu", 4, ["old_sbzhiheng", "old_sbtongye", "sbjiuyuan"], ["character:sb_sunquan", "die:sb_sunquan", "zhu"]],
                            old_sb_huanggai: ["male", "wu", "2/4/2", ["sbkurou", "sbzhaxiang"], ["character:sb_huanggai", "die:sb_huanggai"]],
                            old_sb_ganning: ["male", "wu", 4, ["old_sbqixi", "old_sbfenwei"], ["character:sb_ganning", "die:sb_ganning"]],
                            old_sb_xiaoqiao: ["female", "wu", 3, ["old_sbtianxiang", "xinhongyan"], ["character:sb_xiaoqiao", "die:sb_xiaoqiao", "name:桥|null"]],
                            old_sb_daqiao: ["female", "wu", 3, ["old_sbguose", "sbliuli"], ["character:sb_daqiao", "die:sb_daqiao", "name:桥|null"]],
                            old_sb_sunce: ["male", "wu", 4, ["sbjiang", "old_sbhunzi", "sbzhiba"], ["character:sb_sunce", "die:sb_sunce", "zhu"]],
                            old_sb_sp_zhugeliang: ["male", "shu", 3, ["old_sbhuoji", "old_sbkanpo"], ["character:sb_sp_zhugeliang", "die:sb_sp_zhugeliang", "name:诸葛|亮"]],
                            old_sb_zhugeliang: ["male", "shu", 3, ["old_sbguanxing", "old_sbkongcheng"], ["character:sb_zhugeliang", "die:sb_zhugeliang", "name:诸葛|亮"]],
                            oldx_sb_sp_zhugeliang: ["male", "shu", 3, ["oldx_sbhuoji", "oldx_sbkanpo"], ["character:sb_sp_zhugeliang", "die:sb_sp_zhugeliang", "name:诸葛|亮"]],
                            oldx_sb_zhugeliang: ["male", "shu", 3, ["oldx_sbguanxing", "oldx_sbkongcheng"], ["character:sb_zhugeliang", "die:sb_zhugeliang", "name:诸葛|亮"]],
                            old_sb_menghuo: ["male", "shu", 4, ["sbhuoshou", "old_sbzaiqi"], ["character:sb_menghuo", "die:sb_menghuo", "doublegroup:shu:qun"]],
                            old_sb_zhurong: ["female", "shu", 4, ["sblieren", "old_sbjuxiang"], ["character:sb_zhurong", "die:sb_zhurong", "doublegroup:shu:qun"]],
                            old_sb_guanyu: ["male", "shu", 4, ["old_sbwusheng", "sbyijue"], ["character:sb_guanyu", "die:sb_guanyu"]],
                            old_sb_zhaoyun: ["male", "shu", 4, ["old_sblongdan", "old_sbjizhu"], ["character:sb_zhaoyun", "die:sb_zhaoyun"]],
                            old_sb_fazheng: ["male", "shu", 3, ["old_sbxuanhuo", "old_sbenyuan"], ["character:sb_fazheng", "die:sb_fazheng"]],
                            old_sb_xuhuang: ["male", "wei", 4, ["old_sbduanliang", "sbshipo"], ["character:sb_xuhuang", "die:sb_xuhuang"]],
                            old_sb_yuanshao: ["male", "qun", 4, ["old_sbluanji", "old_sbxueyi"], ["character:sb_yuanshao", "die:sb_yuanshao", "zhu"]],
                            // old_sb_zhangjiao: ["male", "qun", 3, ["old_sbleiji", "old_sbguidao", "old_sbhuangtian"], ["character:sb_zhangjiao", "die:sb_zhangjiao", "zhu"]],
                            old_sb_huaxiong: ["male", "qun", "4/4/5", ["new_reyaowu", "sbyangwei"], ["character:sb_huaxiong", "die:sb_huaxiong"]],
                            old_sb_handang: ["male", "wu", 4, ["sbgongqi", "old_sbjiefan"], ["character:sb_handang", "die:sb_handang"]],
                            // old_sb_caopi: ["male", "wei", 3, ["old_sbxingshang", "old_sbfangzhu", "old_sbsongwei"], ["die:ext:凌梦自用/audio/die:true", "zhu"]],
                            old_sb_jiaxu: ["male", "qun", 3, ["old_sbwansha", "old_sbluanwu", "old_sbweimu"], ["character:sb_jiaxu", "die:sb_jiaxu"]],
                            old_sb_zhugejin: ["male", "wu", 3, ["old_sbhuanshi", "old_sbhongyuan", "old_sbmingzhe"], ["character:sb_zhugejin", "die:sb_zhugejin", "name:诸葛|瑾"]],
                            old_sb_zhangliao: ["male", "wei", 4, ["old_sbtuxi", "old_sbdengfeng"], ["character:sb_zhangliao", "die:sb_zhangliao"]],
                            old_sb_guojia: ["male", "wei", 3, ["sbtiandu", "old_sbyiji"], ["character:sb_guojia", "die:sb_guojia"]],
                            old_sb_gaoshun: ["male", "qun", 4, ["old_sbxianzhen", "sbjinjiu"], ["character:sb_gaoshun", "die:sb_gaoshun"]],
                            old_sb_luxun: ["male", "wu", 3, ["sbqianxun", "old_sblianying"], ["character:sb_luxun", "die:sb_luxun"]],

                            //OL
                            oldx_clan_xuncai: ["female", "qun", 3, ["oldx_clanlieshi", "oldx_clandianzhan", "clanhuanyin", "clandaojie"], ["character:clan_xuncai", "die:clan_xuncai", "clan:颍川荀氏"]],
                            old_clan_zhonghui: ["male", "wei", "3/4", ["old_clanyuzhi", "old_clanxieshu", "clanbaozu"], ["character:clan_zhonghui", "die:clan_zhonghui", "clan:颍川钟氏", "die:3"]],
                            old_clan_hanrong: ["male", "qun", 3, ["old_lianhe", "old_huanjia", "old_xumin"], ["character:clan_hanrong", "die:clan_hanrong", "clan:颍川韩氏"]],
                            old_clan_hanshao: ["male", "qun", 3, ["old_fangzhen", "old_liuju", "old_xumin"], ["character:clan_hanshao", "die:clan_hanshao", "clan:颍川韩氏"]],
                            old_zhanghua: ["male", "jin", 3, ["olbihun", "olchuanwu", "oljianhe"], ["character:zhanghua", "die:zhanghua"]],
                            old_yuanji: ["female", "wu", 3, ["dcmengchi", "dcjiexing"], ["character:yuanji", "die:yuanji", "name:袁|null"]],
                            old_tengfanglan: ["female", "wu", 3, ["old_luochong", "old_aichen"], ["character:tengfanglan", "die:tengfanglan"]],
                            old_dengzhong: ["male", "wei", 4, ["old_dzkanpo", "old_dzgengzhan"], ["character:dengzhong", "die:dengzhong"]],
                            old_wangyan: ["male", "jin", 3, ["yangkuang", "old_cihuang", "old_sanku"], ["character:wangyan", "die:wangyan"]],
                            old_ol_luyusheng: ["female", "wu", 3, ["old_olcangxin", "olrunwei"], ["character:ol_luyusheng", "die:ol_luyusheng"]],
                            old_ol_hujinding: ["female", "shu", 3, ["olqingyuan", "old_olchongshen"], ["character:ol_hujinding", "die:ol_hujinding"]],
                            old_ol_feiyi: ["male", "shu", 3, ["yanru", "old_hezhong"], ["character:ol_feiyi", "die:ol_feiyi"]],
                            old_ol_pengyang: ["male", "shu", 3, ["olxiaofan", "old_oltuishi", "nzry_cunmu"], ["character:ol_pengyang", "die:ol_pengyang"]],
                            old_sp_sunce: ["male", "qun", 4, ["olliantao"], ["character:sp_sunce", "die:sp_sunce"]],
                            old_ol_yufan: ["male", "wu", 3, ["old_olzongxuan", "old_olzhiyan"], ["tempname:re_yufan", "character:ol_yufan", "die:re_yufan"]],
                            old_zhugejin: ["male", "wu", 3, ["olhuanshi", "olhongyuan", "olmingzhe"], ["character:zhugejin", "die:zhugejin", "name:诸葛|瑾"]],
                            old_ruiji: ["female", "wu", 3, ["old_qiaoli", "old_qingliang"], ["character:ruiji", "die:ruiji"]],
                            old_xurong: ["male", "qun", 4, ["old_xionghuo", "old_shajue"], ["character:xurong", "die:xurong"]],
                            old_ol_qianzhao: ["male", "wei", 4, ["olweifu", "old_olkuansai"], ["character:ol_qianzhao", "die:ol_qianzhao"]],
                            old_ol_sb_dongzhuo: ["male", "qun", 5, ["old_olguanbian", "old_olxiongni", "old_olfengshang", "old_olzhibin"], ["character:ol_sb_dongzhuo", "ol_sb_dongzhuo", "zhu", "tempname:ol_sb_dongzhuo", "die:3"]],
                            old_ol_nanhualaoxian: ["male", "qun", 4, ["old_olqingshu", "old_olshoushu", "old_olhedao"], ["character:ol_nanhualaoxian", "die:ol_nanhualaoxian", "name:庄|周"]],
                            old_ol_sb_dengai: ["male", "wei", 4, ["old_olsbjiewan", "olsbpixian"], ["character:ol_sb_dengai", "die:ol_sb_dengai"]],
                            old_ol_wangyi: ["female", "wei", 3, ["old_olzhenlie", "olmiji"], ["character:ol_wangyi", "die:ol_wangyi"]],
                            old_ol_xuelingyun: ["female", "wei", 3, ["old_olsiqi", "olqiaozhi"], ["character:ol_xuelingyun", "die:ol_xuelingyun"]],
                            //十周年
                            old_re_zhangchunhua: ["female", "wei", 3, ["rejueqing", "reshangshi"], ["character:re_zhangchunhua", "die:re_zhangchunhua"]],
                            old_re_caorui: ["male", "wei", 3, ["huituo", "remingjian", "rexingshuai"], ["character:re_caorui", "re_caorui", "zhu"]],
                            old_dc_xushu: ["male", "shu", 4, ["old_rezhuhai", "xsqianxin"], ["character:dc_xushu", "die:dc_xushu"]],
                            old_yuechen: ["male", "wei", 4, ["old_dcporui", "old_dcgonghu"], ["character:yuechen", "die:yuechen"]],
                            old_ruanyu: ["male", "wei", 3, ["xingzuo", "old_miaoxian"], ["character:ruanyu", "die:ruanyu"]],
                            old_bailingyun: ["female", "wei", 3, ["oldx_dclinghui", "dcxiace", "dcyuxin"], ["character:bailingyun", "die:bailingyun"]],
                            old_dc_liuli: ["male", "shu", 3, ["old_dcfuli", "old_dcdehua"], ["character:dc_liuli", "die:dc_liuli"]],
                            old_yue_miheng: ["male", "qun", 3, ["old_dcjigu", "dcsirui"], ["character:yue_miheng", "die:yue_miheng"]],
                            old_wu_zhugeliang: ["male", "shu", "4/7", ["dcjincui", "old_dcqingshi", "old_dczhizhe"], ["character:wu_zhugeliang", "die:wu_zhugeliang", "name:诸葛|亮"]],
                            old_wu_guanyu: ["male", "shu", 4, ["old_dcjuewu", "old_dcwuyou", "old_dcyixian"], ["character:wu_guanyu", "die:wu_guanyu"]],
                            old_wu_huangfusong: ["male", "qun", 4, ["old_dcchaozhen", "old_dclianjie", "old_dcjiangxian"], ["character:wu_huangfusong", "die:wu_huangfusong", "name:皇甫|嵩"]],
                            old_dc_shen_huatuo: ["male", "shen", 3, ["old_jingyu", "lvxin", "huandao"], ["character:dc_shen_huatuo", "die:dc_shen_huatuo", "qun"]],
                            old_xunyuxunyou: ["male", "wei", 3, ["old_zhinang", "old_gouzhu"], ["die:xunyuxunyou", "name:荀|彧-荀|攸"]],
                            old_zhugejing: ["male", "qun", 4, ["dcyanzuo", "dczuyin", "old_dcpijian"], ["character:zhugejing", "die:zhugejing", "name:诸葛|京"]],
                            old_xin_zhonghui: ["male", "wei", 4, ["old_xinquanji", "old_xinzili"], ["character:xin_zhonghui", "die:xin_zhonghui", "clan:颍川钟氏"]],
                            old_yj_majun: ["male", "wei", 3, ["gongqiao", "old_jingyi"], ["character:yj_majun", "die:yj_majun"]],
                            old_star_fazheng: ["male", "shu", 3, ["starzhiji", "old_staranji"], ["character:star_fazheng", "die:star_fazheng"]],
                            old_pangfengyi: ["female", "shu", 3, ["old_dcyitong", "old_dcpeiniang"], ["character:pangfengyi", "die:pangfengyi"]],
                            old_v_sunquan: ["male", "wu", 4, ["old_dcwoheng", "old_dcjizheng"], ["character:v_sunquan", "die:v_sunquan"]],

                            //海外
                            old_tw_huojun: ["male", "shu", 4, ["twsidai", "old_twjieyu"], ["character:tw_huojun", "die:tw_huojun"]],
                            old_tw_guohuai: ["male", "wei", 4, ["old_twjingce", "old_yuzhang"], ["character:tw_guohuai", "die:tw_guohuai"]],
                            oldx_quancong: ["male", "wu", 4, ["old_zhenshan"], ["character:quancong", "die:quancong"]],
                            old_tw_baoxin: ["male", "qun", 4, ["old_twmutao", "twyimou"], ["character:tw_baoxin", "die:tw_baoxin"]],
                            old_tw_zhangmancheng: ["male", "qun", 4, ["twfengji", "twyiju", "old_twbudao"], ["character:tw_zhangmancheng", "die:tw_zhangmancheng"]],
                            old_tw_guanqiujian: ["male", "wei", 4, ["twzhengrong", "twhongju"], ["character:tw_guanqiujian", "die:tw_guanqiujian", "name:毌丘|俭"]],
                            old_tw_niufudongxie: ["double", "qun", 4, ["old_twjuntun", "old_twxiongxi", "twxiafeng"], ["character:tw_niufudongxie", "die:tw_niufudongxie", "name:牛|辅-董|翓"]],
                            old_xia_tongyuan: ["male", "qun", 4, ["twchaofeng", "old_twchuanshu"], ["character:xia_tongyuan", "die:xia_tongyuan"]],
                            old_xia_guanyu: ["male", "qun", 4, ["old_twzhongyi", "old_twchue"], ["character:xia_guanyu", "die:xia_guanyu"]],
                            old_huan_zhugeliang: ["male", "shu", "3/4", ["twbeiding", "twjielv", "old_twhunyou"], ["character:huan_zhugeliang", "die:huan_zhugeliang", "name:诸葛|亮"]],
                            old_huan_weiyan: ["male", "shu", 4, ["twqiji", "old_twpiankuang"], ["character:huan_weiyan", "die:huan_weiyan"]],
                            old_huan_zhugeguo: ["female", "shu", 3, ["old_rexianyuan", "twlingyin"], ["character:huan_zhugeguo", "die:huan_zhugeguo"]],
                            old_tw_shen_lvmeng: ["male", "shen", 3, ["old_twgongxin", "old_twshelie"], ["character:tw_shen_lvmeng", "die:tw_shen_lvmeng", "wu"]],
                            old_huan_caoang: ["male", "wei", "3/4", ["old_twchihui", "old_twfuxi"], ["character:huan_caoang", "die:huan_caoang"]],
                            //其他
                            old_gaowang: ["male", "qun", 3, ["scsanruo"], ["character:scs_gaowang", "die:scs_gaowang", "sex:male_castrated"]],
                            old_zhangren: ["male", "qun", 4, ["chuanxin", "zfengshi"], ["character:zhangren", "die:zhangren"]],
                        },
                        //武将介绍
                        characterIntro: {},
                        characterTitle: {},
                        characterSubstitute: {
                            // old_huan_zhugeliang: [
                            //     ["old_huan_zhugeliang_shadow", [((lib.device || lib.node) ? "ext:" : "db:extension-") + "凌梦自用/image/character/old_huan_zhugeliang_shadow.jpg"]],
                            // ],
                            old_huan_zhugeliang: [["huan_zhugeliang_shadow", []]],
                            old_huan_caoang: [["huan_caoang_shadow", []]],
                            old_ol_sb_dongzhuo: [
                                ["ol_sb_dongzhuo_shadow1", ["tempname:ol_sb_dongzhuo", "die:ol_sb_dongzhuo"]],
                                ["ol_sb_dongzhuo_shadow2", ["tempname:ol_sb_dongzhuo", "die:ol_sb_dongzhuo"]],
                            ],
                        },
                        //武将替换
                        characterReplace: {},
                        //珠联璧合
                        perfectPair: {},
                        //卡牌
                        card: {},
                        //部分搬运自旧本体、怀旧计划
                        //技能
                        skill: {
                            //应天司马懿！复活
                            old_jilin: {
                                audio: "jilin",
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event, player) {
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                forced: true,
                                locked: false,
                                logAudio: () => ["jilin1.mp3"],
                                async content(event, trigger, player) {
                                    const cards = get.cards(3);
                                    const next = player.addToExpansion(cards, "draw");
                                    next.gaintag.add(event.name);
                                    await next;
                                },
                                marktext: "志",
                                intro: {
                                    markcount: "expansion",
                                    mark(dialog, content, player) {
                                        const cards = player.getExpansions("old_jilin"),
                                            mingzhi = cards.filter(card => card.storage.old_jilin),
                                            hidden = cards.removeArray(mingzhi);
                                        if (mingzhi.length) {
                                            dialog.addText("已明之志");
                                            dialog.addSmall(mingzhi);
                                        }
                                        if (hidden.length) {
                                            if (player == game.me || player.isUnderControl()) {
                                                dialog.addText("未明之志");
                                                dialog.addSmall(hidden);
                                            } else {
                                                return "共有" + get.cnNumber(hidden.length) + "张暗“志”";
                                            }
                                        }
                                    },
                                    content(content, player) {
                                        const cards = player.getExpansions("old_jilin"),
                                            mingzhi = cards.filter(card => card.storage.old_jilin),
                                            hidden = cards.removeArray(mingzhi);
                                        if (mingzhi.length) {
                                            dialog.addText("已明之志");
                                            dialog.addSmall(mingzhi);
                                        }
                                        if (hidden.length) {
                                            if (player == game.me || player.isUnderControl()) {
                                                dialog.addText("未明之志");
                                                dialog.addSmall(hidden);
                                            } else {
                                                return "共有" + get.cnNumber(hidden.length) + "张暗“志”";
                                            }
                                        }
                                    },
                                },
                                group: ["old_jilin_kanpo", "old_jilin_change"],
                                subSkill: {
                                    kanpo: {
                                        audio: "jilin",
                                        logAudio: () => ["jilin2.mp3", "jilin3.mp3"],
                                        trigger: {
                                            target: "useCardToTarget",
                                        },
                                        filter(event, player) {
                                            return event.player != player && player.getExpansions("old_jilin").some(card => !card.storage.old_jilin);
                                        },
                                        async cost(event, trigger, player) {
                                            const hidden = player.getExpansions("old_jilin").filter(card => !card.storage.old_jilin);
                                            const goon = get.effect(player, trigger.card, trigger.player, player) < 0;
                                            const suits = player
                                                .getExpansions("old_jilin")
                                                .filter(card => card.storage.old_jilin)
                                                .map(card => get.suit(card))
                                                .toUniqued();
                                            if (hidden.length == 1) {
                                                const bool = await player
                                                    .chooseBool("戢鳞：明置一张“志”", `令${get.translation(trigger.card)}对你无效`)
                                                    .set("choice", goon)
                                                    .forResultBool();
                                                event.result = {
                                                    bool: bool,
                                                    cost_data: hidden,
                                                };
                                            } else {
                                                const {
                                                    result: { bool, links },
                                                } = await player
                                                    .chooseButton(["戢鳞：明置一张“志”", hidden])
                                                    .set("ai", button => {
                                                        const player = get.player(),
                                                            card = button.link,
                                                            suits = get.event("suits");
                                                        if (!get.event("goon")) return 0;
                                                        if (!suits.includes(get.suit(card))) return 10;
                                                        return 6 - get.value(card);
                                                    })
                                                    .set("suits", suits)
                                                    .set("goon", goon);
                                                event.result = {
                                                    bool: bool,
                                                    cost_data: links,
                                                };
                                            }
                                        },
                                        async content(event, trigger, player) {
                                            event.cost_data[0].storage.old_jilin = true;
                                            trigger.getParent().excluded.add(player);
                                        },
                                    },
                                    change: {
                                        audio: "jilin",
                                        logAudio: () => ["jilin4.mp3", "jilin5.mp3"],
                                        trigger: {
                                            player: "phaseBegin",
                                        },
                                        filter(event, player) {
                                            return player.countCards("h") && player.getExpansions("old_jilin").some(card => !card.storage.old_jilin);
                                        },
                                        async cost(event, trigger, player) {
                                            const hidden = player.getExpansions("old_jilin").filter(card => !card.storage.old_jilin);
                                            const next = player.chooseToMove("戢鳞：是否交换“志”和手牌？");
                                            next.set("list", [
                                                [get.translation(player) + "（你）的未明之“志”", hidden],
                                                ["手牌区", player.getCards("h")],
                                            ]);
                                            next.set("filterMove", (from, to) => {
                                                return typeof to != "number";
                                            });
                                            next.set("processAI", list => {
                                                let player = get.player(),
                                                    cards = list[0][1].concat(list[1][1]).sort(function (a, b) {
                                                        return get.useful(a) - get.useful(b);
                                                    }),
                                                    cards2 = cards.splice(0, player.getExpansions("old_jilin").length);
                                                return [cards2, cards];
                                            });
                                            const {
                                                result: { bool, moved },
                                            } = await next;
                                            event.result = {
                                                bool: bool,
                                                cost_data: moved,
                                            };
                                        },
                                        async content(event, trigger, player) {
                                            const moved = event.cost_data;
                                            const pushs = moved[0],
                                                gains = moved[1];
                                            pushs.removeArray(player.getExpansions("old_jilin"));
                                            gains.removeArray(player.getCards("h"));
                                            if (!pushs.length || pushs.length != gains.length) return;
                                            const next = player.addToExpansion(pushs);
                                            next.gaintag.add("old_jilin");
                                            await next;
                                            await player.gain(gains, "draw");
                                        },
                                    },
                                },
                            },
                            old_yingyou: {
                                audio: "yingyou",
                                trigger: {
                                    player: "phaseUseBegin",
                                },
                                filter(event, player) {
                                    return player.countCards("h") && player.getExpansions("old_jilin").some(card => !card.storage.old_jilin);
                                },
                                async cost(event, trigger, player) {
                                    const hidden = player.getExpansions("old_jilin").filter(card => !card.storage.old_jilin);
                                    const suits = player
                                        .getExpansions("old_jilin")
                                        .filter(card => card.storage.old_jilin)
                                        .map(card => get.suit(card))
                                        .toUniqued();
                                    const {
                                        result: { bool, links },
                                    } = await player
                                        .chooseButton(["英猷：你可以明志", hidden])
                                        .set("ai", button => {
                                            const player = get.player(),
                                                card = button.link,
                                                suits = get.event("suits");
                                            const getNum = player => {
                                                var list = [];
                                                for (var i of lib.suit) list.push(player.countCards("h", { suit: i }) + 3);
                                                return list.sort((a, b) => b - a)[0];
                                            };
                                            if (!suits.includes(get.suit(card))) return 10;
                                            if (get.suit(card) == getNum(player)) return 5;
                                            return 0;
                                        })
                                        .set("suits", suits);
                                    event.result = {
                                        bool: bool,
                                        cost_data: links,
                                    };
                                },
                                logAudio: () => ["yingyou1.mp3", "yingyou2.mp3"],
                                async content(event, trigger, player) {
                                    event.cost_data[0].storage.old_jilin = true;
                                    const num = player.getExpansions("old_jilin").filter(card => card.storage.old_jilin).length;
                                    await player.draw(num);
                                },
                                ai: {
                                    combo: "old_jilin",
                                },
                                group: "old_yingyou_draw",
                                subSkill: {
                                    draw: {
                                        audio: "yingyou",
                                        logAudio: () => ["yingyou3.mp3", "yingyou4.mp3"],
                                        trigger: {
                                            player: "loseAfter",
                                            global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                        },
                                        filter(event, player) {
                                            const suits = player
                                                .getExpansions("old_jilin")
                                                .filter(card => card.storage.old_jilin)
                                                .map(card => get.suit(card))
                                                .toUniqued();
                                            const evt = event.getl(player);
                                            if (!evt || !evt.cards2 || !evt.cards2.length) return false;
                                            return evt.cards2.some(card => {
                                                return suits.includes(get.suit(card, player));
                                            });
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            const suits = player
                                                .getExpansions("old_jilin")
                                                .filter(card => card.storage.old_jilin)
                                                .map(card => get.suit(card))
                                                .toUniqued();
                                            const num = trigger.getl(player).cards2.filter(card => {
                                                return suits.includes(get.suit(card, player));
                                            }).length;
                                            await player.draw(num);
                                        },
                                    },
                                },
                            },
                            old_yingtian: {
                                audio: "yingtian",
                                trigger: {
                                    global: "dieAfter",
                                },
                                filter(event, player) {
                                    return game.countGroup() < 3;
                                },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "gray",
                                async content(event, trigger, player) {
                                    const skill = event.name;
                                    player.awakenSkill(skill);
                                    await player.changeSkills(get.info(skill).derivation, ["old_yingyou"]);
                                    player.addSkill(skill + "_effect");
                                },
                                derivation: ["reguicai", "rewansha", "lianpo"],
                                subSkill: {
                                    effect: {
                                        mod: {
                                            targetInRange: () => true,
                                        },
                                    },
                                },
                            },
                            //神鲁肃
                            old_dingzhou: {
                                audio: "dingzhou",
                                enable: "phaseUse",
                                usable: 1,
                                filter(event, player) {
                                    const num = player.countCards("he");
                                    return game.hasPlayer(current => {
                                        if (current == player) return false;
                                        const total = current.countCards("ej");
                                        return total > 0 && num >= total;
                                    });
                                },
                                filterCard: true,
                                selectCard() {
                                    return [1, Math.max(...game.filterPlayer(i => i != get.player()).map(i => i.countCards("ej")))];
                                },
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                filterTarget(card, player, target) {
                                    const num = target.countCards("ej");
                                    if (!num) return false;
                                    return ui.selected.cards.length == num && player != target;
                                },
                                filterOk() {
                                    return ui.selected.cards.length == ui.selected.targets[0].countCards("ej");
                                },
                                position: "he",
                                lose: false,
                                discard: false,
                                delay: false,
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    await player.give(event.cards, target);
                                    const cards = target.getGainableCards(player, "ej");
                                    if (cards.length) player.gain(cards, "give", target);
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            let eff = 0;
                                            if (ui.selected.cards.length) eff = ui.selected.cards.map(card => get.value(card)).reduce((p, c) => p + c, 0);
                                            if (player.hasSkill("old_zhimeng")) eff *= 1 + get.sgnAttitude(player, target) * 0.15;
                                            const es = target.getCards("e"),
                                                js = target.getCards("j");
                                            es.forEach(card => {
                                                eff -= get.value(card, target);
                                            });
                                            js.forEach(card => {
                                                eff -= get.effect(
                                                    target,
                                                    {
                                                        name: card.viewAs || card.name,
                                                        cards: [card],
                                                    },
                                                    target,
                                                    target
                                                );
                                            });
                                            return eff;
                                        },
                                    },
                                },
                            },
                            old_tamo: {
                                audio: "tamo",
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event, player) {
                                    return (
                                        (event.name != "phase" || game.phaseNumber == 0) &&
                                        game.countPlayer(current => {
                                            return !current.isZhu2();
                                        }) > 1
                                    );
                                },
                                direct: true,
                                changeSeat: true,
                                seatRelated: true,
                                derivation: "old_tamo_faq",
                                async content(event, trigger, player) {
                                    const toSortPlayers = game.filterPlayer(current => {
                                        return !current.isZhu2();
                                    });
                                    toSortPlayers.sortBySeat(game.findPlayer2(current => current.getSeatNum() == 1, true));
                                    const next = player.chooseToMove("榻谟：是否分配" + (game.hasPlayer(cur => cur.isZhu2()) ? "除主公外" : "") + "所有角色的座次？");
                                    next.set("list", [
                                        [
                                            "（以下排列的顺序即为发动技能后角色的座次顺序）",
                                            [
                                                toSortPlayers.map(i => `${i.getSeatNum()}|${i.name}`),
                                                (item, type, position, noclick, node) => {
                                                    const info = item.split("|"),
                                                        _item = item;
                                                    const seat = parseInt(info[0]);
                                                    item = info[1];
                                                    if (node) {
                                                        node.classList.add("button");
                                                        node.classList.add("character");
                                                        node.style.display = "";
                                                    } else {
                                                        node = ui.create.div(".button.character", position);
                                                    }
                                                    node._link = item;
                                                    node.link = item;

                                                    const func = function (node, item) {
                                                        const currentPlayer = game.findPlayer(current => current.getSeatNum() == seat);
                                                        if (currentPlayer.classList.contains("unseen_show")) node.setBackground("hidden_image", "character");
                                                        else if (item != "unknown") node.setBackground(item, "character");
                                                        if (node.node) {
                                                            node.node.name.remove();
                                                            node.node.hp.remove();
                                                            node.node.group.remove();
                                                            node.node.intro.remove();
                                                            if (node.node.replaceButton) node.node.replaceButton.remove();
                                                        }
                                                        node.node = {
                                                            name: ui.create.div(".name", node),
                                                            group: ui.create.div(".identity", node),
                                                            intro: ui.create.div(".intro", node),
                                                        };
                                                        const infoitem = [currentPlayer.sex, currentPlayer.group, `${currentPlayer.hp}/${currentPlayer.maxHp}/${currentPlayer.hujia}`];
                                                        node.node.name.innerHTML = get.slimName(item);
                                                        if (lib.config.buttoncharacter_style == "default" || lib.config.buttoncharacter_style == "simple") {
                                                            if (lib.config.buttoncharacter_style == "simple") {
                                                                node.node.group.style.display = "none";
                                                            }
                                                            node.classList.add("newstyle");
                                                            node.node.name.dataset.nature = get.groupnature(get.bordergroup(infoitem));
                                                            node.node.group.dataset.nature = get.groupnature(get.bordergroup(infoitem), "raw");
                                                        }
                                                        node.node.name.style.top = "8px";
                                                        if (node.node.name.querySelectorAll("br").length >= 4) {
                                                            node.node.name.classList.add("long");
                                                            if (lib.config.buttoncharacter_style == "old") {
                                                                node.addEventListener("mouseenter", ui.click.buttonnameenter);
                                                                node.addEventListener("mouseleave", ui.click.buttonnameleave);
                                                            }
                                                        }
                                                        node.node.intro.innerHTML = lib.config.intro;
                                                        if (!noclick) {
                                                            lib.setIntro(node);
                                                        }
                                                        node.node.group.innerHTML = `<div>${get.cnNumber(seat, true)}号</div>`;
                                                        node.node.group.style.backgroundColor = get.translation(`${get.bordergroup(infoitem)}Color`);
                                                    };
                                                    node.refresh = func;
                                                    node.refresh(node, item);

                                                    node.link = _item;
                                                    node.seatNumber = seat;
                                                    node._customintro = uiintro => {
                                                        uiintro.add(`${get.translation(node._link)}(原${get.cnNumber(node.seatNumber, true)}号位)`);
                                                    };
                                                    return node;
                                                },
                                            ],
                                        ],
                                    ]);
                                    next.set("toSortPlayers", toSortPlayers.slice(0));
                                    next.set("processAI", () => {
                                        const players = get.event("toSortPlayers"),
                                            player = get.player();
                                        players.randomSort().sort((a, b) => get.attitude(player, b) - get.attitude(player, a));
                                        return [players.map(i => `${i.getSeatNum()}|${i.name}`)];
                                    });
                                    const { result } = await next;
                                    if (!result.bool) return;
                                    await player.logSkill("old_tamo");
                                    const resultList = result.moved[0].map(info => {
                                        return parseInt(info.split("|")[0]);
                                    });
                                    const toSwapList = [];
                                    const cmp = (a, b) => {
                                        return resultList.indexOf(a) - resultList.indexOf(b);
                                    };
                                    for (let i = 0; i < toSortPlayers.length; i++) {
                                        for (let j = 0; j < toSortPlayers.length; j++) {
                                            if (cmp(toSortPlayers[i].getSeatNum(), toSortPlayers[j].getSeatNum()) < 0) {
                                                toSwapList.push([toSortPlayers[i], toSortPlayers[j]]);
                                                [toSortPlayers[i], toSortPlayers[j]] = [toSortPlayers[j], toSortPlayers[i]];
                                            }
                                        }
                                    }
                                    game.broadcastAll(toSwapList => {
                                        for (const list of toSwapList) {
                                            game.swapSeat(list[0], list[1], false);
                                        }
                                    }, toSwapList);
                                    if (trigger.name === "phase" && !trigger.player.isZhu2() && trigger.player !== toSortPlayers[0] && !trigger._finished) {
                                        trigger.finish();
                                        trigger._triggered = 5;
                                        const evt = toSortPlayers[0].insertPhase();
                                        delete evt.skill;
                                        const evt2 = trigger.getParent();
                                        if (evt2.name == "phaseLoop" && evt2._isStandardLoop) {
                                            evt2.player = toSortPlayers[0];
                                        }
                                        //跳过新回合的phaseBefore
                                        evt.pushHandler("onPhase", (event, option) => {
                                            if (event.step === 0 && option.state === "begin") {
                                                event.step = 1;
                                            }
                                        });
                                    }
                                    await game.delay();
                                },
                            },
                            //什么均贫卡
                            old_zhimeng: {
                                audio: "zhimeng",
                                trigger: { player: "phaseAfter" },
                                filter(event, player) {
                                    return game.hasPlayer(target => {
                                        return target != player && target.countCards("h") + player.countCards("h") != 0;
                                    });
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const {
                                        result: { bool, targets },
                                    } = await player
                                        .chooseTarget(get.prompt("old_zhimeng"), "与一名其他角色平分手牌", (card, player, target) => {
                                            return target != player && target.countCards("h") + player.countCards("h") != 0;
                                        })
                                        .set("ai", target => {
                                            const player = get.player();
                                            const pvalue = -player
                                                .getCards("h")
                                                .map(card => get.value(card, player))
                                                .reduce((p, c) => p + c, 0);
                                            const tvalue =
                                                -target
                                                    .getCards("h")
                                                    .map(card => get.value(card, target))
                                                    .reduce((p, c) => p + c, 0) * get.sgnAttitude(player, target);
                                            return (pvalue + tvalue) / 2;
                                        });
                                    if (!bool) return;
                                    const target = targets[0];
                                    player.logSkill("old_zhimeng", target);
                                    const lose_list = [];
                                    let cards = [];
                                    [player, target].forEach(current => {
                                        const hs = current.getCards("h");
                                        if (hs.length) {
                                            cards.addArray(hs);
                                            current.$throw(hs.length, 500);
                                            game.log(current, "将", get.cnNumber(hs.length), "张牌置入了处理区");
                                            lose_list.push([current, hs]);
                                        }
                                    });
                                    await game
                                        .loseAsync({
                                            lose_list: lose_list,
                                        })
                                        .setContent("chooseToCompareLose");
                                    await game.delay();
                                    cards = cards.filterInD();
                                    const pcards = cards.randomGets(Math.ceil(cards.length / 2));
                                    const tcards = cards.removeArray(pcards);
                                    const list = [];
                                    if (pcards.length) {
                                        list.push([player, pcards]);
                                        game.log(player, "获得了", get.cnNumber(pcards.length), "张牌");
                                    }
                                    if (tcards.length) {
                                        list.push([target, tcards]);
                                        game.log(target, "获得了", get.cnNumber(tcards.length), "张牌");
                                    }
                                    game.loseAsync({
                                        gain_list: list,
                                        player: player,
                                        animate: "draw",
                                    }).setContent("gaincardMultiple");
                                },
                                ai: {
                                    threaten: 4,
                                },
                            },
                            //手杀界沮授
                            old_xinjianying: {
                                audio: "xinjianying",
                                subfrequent: ["draw"],
                                enable: "phaseUse",
                                usable: 1,
                                filter(event, player) {
                                    if (!player.countCards("he")) return false;
                                    for (var i of lib.inpile) {
                                        if (i != "du" && get.type(i, null, false) == "basic") {
                                            var card = { name: i };
                                            if (player.hasUseTarget(card)) return true;
                                        }
                                    }
                                    return false;
                                },
                                onChooseToUse(event) {
                                    if (event.type == "phase" && !game.online) {
                                        var last = event.player.getLastUsed();
                                        if (last && last.getParent("phaseUse") == event.getParent()) {
                                            var suit = get.suit(last.card, false);
                                            if (suit != "none") event.set("old_xinjianying_suit", suit);
                                        }
                                    }
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        var suit = event.old_xinjianying_suit || "",
                                            str = get.translation(suit);
                                        for (var i of lib.inpile) {
                                            if (i != "du" && get.type(i, null, false) == "basic") {
                                                if (i == "sha") {
                                                    for (var j of lib.inpile_nature) {
                                                        var card = { name: i, nature: j };
                                                        if (player.hasUseTarget(card)) list.push(["基本", str, i, j]);
                                                    }
                                                }
                                                if (i == "sha" || i == "jiu") {
                                                    var card = { name: i };
                                                    if (player.hasUseTarget(card)) list.push(["基本", str, i]);
                                                } else if (event.filterCard({ name: i }, player, event)) list.push(["基本", str, i]);
                                            }
                                        }
                                        return ui.create.dialog("渐营", [list, "vcard"]);
                                    },
                                    check(button) {
                                        if (button.link[2] == "jiu") return 0;
                                        return _status.event.player.getUseValue({
                                            name: button.link[2],
                                            nature: button.link[3],
                                        });
                                    },
                                    backup(links, player) {
                                        var next = {
                                            audio: "xinjianying",
                                            filterCard: true,
                                            popname: true,
                                            position: "he",
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                                storage: { old_xinjianying: true },
                                            },
                                            ai1(card) {
                                                return 7 - _status.event.player.getUseValue(card, null, true);
                                            },
                                        };
                                        if (_status.event.old_xinjianying_suit) next.viewAs.suit = _status.event.old_xinjianying_suit;
                                        return next;
                                    },
                                    prompt(links) {
                                        return "将一张牌当做" + (get.translation(links[0][3]) || "") + get.translation(links[0][2]) + (_status.event.old_xinjianying_suit ? "(" + get.translation(_status.event.old_xinjianying_suit) + ")" : "") + "使用";
                                    },
                                },
                                mod: {
                                    cardUsable(card, player, num) {
                                        if (card.storage && card.storage.old_xinjianying) return Infinity;
                                    },
                                },
                                ai: {
                                    order(item, player) {
                                        if (_status.event.old_xinjianying_suit) return 16;
                                        return 3;
                                    },
                                    result: {
                                        player: 7,
                                    },
                                },
                                group: ["old_xinjianying_draw", "jianying_mark"],
                                init(player) {
                                    if (player.isPhaseUsing()) {
                                        var evt = _status.event.getParent("phaseUse");
                                        var history = player.getHistory("useCard", function (evt2) {
                                            return evt2.getParent("phaseUse") == evt;
                                        });
                                        if (history.length) {
                                            var trigger = history[history.length - 1];
                                            player.storage.jianying_mark = trigger.card;
                                            player.markSkill("jianying_mark");
                                            game.broadcastAll(
                                                function (player, suit) {
                                                    if (player.marks.jianying_mark) player.marks.jianying_mark.firstChild.innerHTML = get.translation(suit);
                                                },
                                                player,
                                                get.suit(trigger.card, player)
                                            );
                                            player.when("phaseUseAfter").then(() => {
                                                player.unmarkSkill("jianying_mark");
                                                delete player.storage.jianying_mark;
                                            });
                                        }
                                    }
                                },
                                onremove(player) {
                                    player.unmarkSkill("jianying_mark");
                                    delete player.storage.jianying_mark;
                                },
                                subSkill: {
                                    draw: { inherit: "jianying", audio: "xinjianying" },
                                },
                            },
                            xinshibei: {
                                trigger: { player: "damageEnd" },
                                forced: true,
                                audio: "shibei_xin_jushou",
                                check(event, player) {
                                    return player.getHistory("damage").indexOf(event) == 0;
                                },
                                content() {
                                    if (player.getHistory("damage").indexOf(trigger) > 0) {
                                        player.loseHp();
                                    } else {
                                        player.recover();
                                    }
                                },
                                subSkill: {
                                    damaged: {},
                                    ai: {},
                                },
                                ai: {
                                    maixie_defend: true,
                                    threaten: 0.9,
                                    effect: {
                                        target(card, player, target) {
                                            if (player.hasSkillTag("jueqing", false, target)) return;
                                            if (target.hujia) return;
                                            if (player._xinshibei_tmp) return;
                                            if (target.hasSkill("xinshibei_ai")) return;
                                            if (_status.event.getParent("useCard", true) || _status.event.getParent("_wuxie", true)) return;
                                            if (get.tag(card, "damage")) {
                                                if (target.getHistory("damage").length > 0) {
                                                    return [1, -2];
                                                } else {
                                                    if (get.attitude(player, target) > 0 && target.hp > 1) {
                                                        return 0;
                                                    }
                                                    if (get.attitude(player, target) < 0 && !player.hasSkillTag("damageBonus")) {
                                                        if (card.name == "sha") return;
                                                        var sha = false;
                                                        player._xinshibei_tmp = true;
                                                        var num = player.countCards("h", function (card) {
                                                            if (card.name == "sha") {
                                                                if (sha) {
                                                                    return false;
                                                                } else {
                                                                    sha = true;
                                                                }
                                                            }
                                                            return get.tag(card, "damage") && player.canUse(card, target) && get.effect(target, card, player, player) > 0;
                                                        });
                                                        delete player._xinshibei_tmp;
                                                        if (player.hasSkillTag("damage")) {
                                                            num++;
                                                        }
                                                        if (num < 2) {
                                                            var enemies = player.getEnemies();
                                                            if (enemies.length == 1 && enemies[0] == target && player.needsToDiscard()) {
                                                                return;
                                                            }
                                                            return 0;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            //手杀界朱治
                            old_sbanguo: {
                                audio: "sbanguo",
                                trigger: { global: "phaseBefore", player: "enterGame" },
                                forced: true,
                                locked: false,
                                direct: true,
                                group: ["old_sbanguo_move", "old_sbanguo_damage", "old_sbanguo_dying"],
                                filter(event, player) {
                                    return game.hasPlayer(current => current != player) && (event.name != "phase" || game.phaseNumber == 0);
                                },
                                content() {
                                    "step 0";
                                    player.chooseTarget("安国：令一名其他角色获得“安国”标记", lib.filter.notMe, true);
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_sbanguo", target);
                                        target.addMark("old_sbanguo_mark", 1, false);
                                        target.addAdditionalSkill("old_sbanguo_" + player.playerid, "old_sbanguo_mark");
                                        target.addMark("old_sbanguo_marked", 1, false);
                                    }
                                },
                                subSkill: {
                                    mark: {
                                        onremove: true,
                                        marktext: "安国",
                                        charlotte: true,
                                        intro: {
                                            name: "安国",
                                            name2: "安国",
                                            content: "已拥有“安国”标记",
                                        },
                                        mod: {
                                            maxHandcardBase(player, num) {
                                                return player.maxHp;
                                            },
                                        },
                                    },
                                    move: {
                                        audio: "sbanguo",
                                        direct: true,
                                        trigger: { player: "phaseUseBegin" },
                                        filter(event, player) {
                                            return game.hasPlayer(current => current.hasSkill("old_sbanguo_mark")) && game.hasPlayer(current => !current.hasMark("old_sbanguo_marked") && current != player);
                                        },
                                        content() {
                                            "step 0";
                                            var targets = game.filterPlayer(current => current.hasSkill("old_sbanguo_mark"));
                                            var prompt2 = targets.length == 1 ? "将" + get.translation(targets[0]) + "的“安国”交给一名未获得过“安国”的其他角色" : "选择一名有“安国”的角色，将该标记交给一名未获得过“安国”的其他角色";
                                            player
                                                .chooseTarget(get.prompt("old_sbanguo"), prompt2, targets.length == 1 ? 1 : 2, (card, player, target) => {
                                                    if (ui.selected.targets.length == 0 && _status.event.targets.length > 1) return target.hasSkill("old_sbanguo_mark");
                                                    return !target.hasMark("old_sbanguo_marked") && target != player;
                                                })
                                                .set("ai", target => {
                                                    var player = _status.event.player;
                                                    if (ui.selected.targets.length == 0 && _status.event.targets.length > 1) return -get.attitude(player, target);
                                                    return get.attitude(player, _status.event.targets[0]) < get.attitude(player, target);
                                                })
                                                .set("targets", targets);
                                            "step 1";
                                            if (result.bool) {
                                                var targets = result.targets;
                                                if (targets.length == 1) {
                                                    var target1 = game.filterPlayer(current => current.hasSkill("old_sbanguo_mark"))[0];
                                                    var target2 = targets[0];
                                                } else {
                                                    var target1 = targets[0];
                                                    var target2 = targets[1];
                                                }
                                                player.logSkill("old_sbanguo_move", target2, false);
                                                player.line2([target1, target2], "green");
                                                var map = target1.additionalSkills;
                                                for (var key in map) {
                                                    if (key.indexOf("old_sbanguo_") != 0) continue;
                                                    var id = parseInt(key.slice(8));
                                                    target1.removeAdditionalSkill("old_sbanguo_" + id);
                                                    target2.addMark("old_sbanguo_mark", 1, false);
                                                    target2.addAdditionalSkill("old_sbanguo_" + id, "old_sbanguo_mark");
                                                    target2.addMark("old_sbanguo_marked", 1, false);
                                                }
                                            }
                                        },
                                    },
                                    damage: {
                                        audio: "sbanguo",
                                        forced: true,
                                        locked: false,
                                        trigger: { player: "damageBegin4" },
                                        filter(event, player) {
                                            if (!game.hasPlayer(current => current.hasSkill("old_sbanguo_mark"))) return false;
                                            if (event.source && event.source.isIn() && event.source.hasSkill("old_sbanguo_mark")) return false;
                                            return event.num >= player.hp;
                                        },
                                        content() {
                                            trigger.cancel();
                                        },
                                        ai: {
                                            nofire: true,
                                            nothunder: true,
                                            nodamage: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (!game.hasPlayer(current => current.hasSkill("old_sbanguo_mark"))) return;
                                                    if (player.hasSkill("old_sbanguo_mark")) return;
                                                    if (get.tag(card, "damage")) {
                                                        if (target.hp <= 1) return [0, 0];
                                                        return 0.5;
                                                    }
                                                },
                                            },
                                        },
                                    },
                                    dying: {
                                        audio: "sbanguo",
                                        forced: true,
                                        locked: false,
                                        trigger: { global: "dying" },
                                        filter(event, player) {
                                            var skills = event.player.additionalSkills["old_sbanguo_" + player.playerid];
                                            return skills && skills.length;
                                        },
                                        logTarget: "player",
                                        content() {
                                            "step 0";
                                            trigger.player.removeAdditionalSkill("old_sbanguo_" + player.playerid);
                                            var num = 1 - trigger.player.hp;
                                            if (num > 0) trigger.player.recover(num);
                                            "step 1";
                                            var hp = player.hp - 1,
                                                maxhp = player.maxHp - 1;
                                            if (hp > 0 && maxhp > 0) {
                                                player
                                                    .chooseControl()
                                                    .set("prompt", "安国：请选择一项")
                                                    .set("choiceList", ["失去" + hp + "点体力，令" + get.translation(trigger.player) + "获得" + hp + "点护甲", "减" + maxhp + "点体力上限，令" + get.translation(trigger.player) + "获得" + maxhp + "点护甲"])
                                                    .set("ai", () => "选项一");
                                            } else if (hp > 0) event._result = { control: "选项一" };
                                            else if (maxhp > 0) event._result = { control: "选项二" };
                                            else event.finish();
                                            "step 2";
                                            if (result.control == "选项一") {
                                                var num = player.hp - 1;
                                                if (num > 0) {
                                                    player.loseHp(num);
                                                    trigger.player.changeHujia(num);
                                                }
                                            } else {
                                                var num = player.maxHp - 1;
                                                if (num > 0) {
                                                    player.loseMaxHp(num);
                                                    trigger.player.changeHujia(num);
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            //SP甄宓
                            old_mbbojian: {
                                audio: "mbbojian",
                                init(player) {
                                    player.addSkill("old_mbbojian_record");
                                },
                                trigger: {
                                    player: "phaseUseEnd",
                                },
                                filter(event, player) {
                                    const record = _status.old_mbbojian;
                                    if (!record || !record[player.playerid]) return false;
                                    const history = player.getHistory("useCard", evt => evt.getParent("phaseUse", true));
                                    const num1 = history.length,
                                        num2 = history.map(evt => get.suit(evt.card)).toUniqued().length,
                                        cards = history.reduce((list, evt) => list.addArray(evt.cards.filterInD("d")), []);
                                    return (num1 != record[player.playerid][0] && num2 != record[player.playerid][1]) || cards.length;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const record = _status.old_mbbojian;
                                    const history = player.getHistory("useCard", evt => evt.getParent("phaseUse", true));
                                    const num1 = history.length,
                                        num2 = history.map(evt => get.suit(evt.card)).toUniqued().length,
                                        cards = history.reduce((list, evt) => list.addArray(evt.cards.filterInD("d")), []);
                                    if (num1 != record[player.playerid][0] && num2 != record[player.playerid][1]) await player.draw(2);
                                    else {
                                        const links =
                                            cards.length == 1
                                                ? cards
                                                : await player
                                                    .chooseButton(["博鉴：请选择要分配的牌", cards], true)
                                                    .set("ai", button => {
                                                        return get.value(button.link);
                                                    })
                                                    .forResultLinks();
                                        const togive = links[0];
                                        const { result } = await player.chooseTarget("选择获得" + get.translation(togive) + "的角色", true).set("ai", target => {
                                            const player = get.player();
                                            return get.attitude(player, target);
                                        });
                                        if (result.bool) {
                                            await result.targets[0].gain(togive, "gain2");
                                        }
                                    }
                                },
                                subSkill: {
                                    record: {
                                        trigger: {
                                            player: "phaseUseAfter",
                                        },
                                        firstDo: true,
                                        charlotte: true,
                                        forced: true,
                                        popup: false,
                                        async content(event, trigger, player) {
                                            const history = player.getHistory("useCard", evt => evt.getParent("phaseUse", true));
                                            const num1 = history.length,
                                                num2 = history.map(evt => get.suit(evt.card)).toUniqued().length;
                                            if (!_status.old_mbbojian) _status.old_mbbojian = {};
                                            _status.old_mbbojian[player.playerid] = [num1, num2];
                                            player.markSkill(event.name);
                                        },
                                        intro: {
                                            markcount: () => 0,
                                            content(storage, player) {
                                                const record = _status.old_mbbojian;
                                                if (!record || !record[player.playerid]) return "无信息";
                                                return "上个出牌阶段使用牌情况：①牌数：" + record[player.playerid][0] + "；②花色数：" + record[player.playerid][1];
                                            },
                                        },
                                    },
                                },
                            },
                            old_mbjiwei: {
                                audio: "mbjiwei",
                                getNum(event, player) {
                                    let num = 0;
                                    if (game.countPlayer2(current => current.hasHistory("lose")) >= 1) num++;
                                    if (game.countPlayer2(current => current.hasHistory("damage")) >= 1) num++;
                                    if (event.name == "phase") return num;
                                    return Math.max(game.countPlayer(), player.getHp());
                                },
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                    global: "phaseEnd",
                                },
                                filter(event, player) {
                                    const num = get.info("old_mbjiwei").getNum(event, player);
                                    if (event.name == "phaseZhunbei") return player.countCards("h") >= num && game.hasPlayer(current => current != player);
                                    return event.player != player && num > 0;
                                },
                                logAudio(event, player) {
                                    if (event.name == "phaseZhunbei") return ["old_mbjiwei3.mp3", "old_mbjiwei4.mp3"];
                                    return ["old_mbjiwei1.mp3", "old_mbjiwei2.mp3"];
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const num = get.info("old_mbjiwei").getNum(trigger, player);
                                    if (trigger.name == "phase") await player.draw(num);
                                    else {
                                        const cards = player.getCards("h"),
                                            map = {};
                                        for (let color of ["red", "black", "none"]) {
                                            if (typeof map[color] != "number") map[color] = 0;
                                            map[color] += cards.filter(card => get.color(card) == color).length;
                                        }
                                        const list = [];
                                        for (var i in map) {
                                            if (map[i] > 0) list.push([`${i}2`, map[i]]);
                                        }
                                        list.sort((a, b) => b[1] - a[1]);
                                        let colors = list.filter(i => i[1] == list[0][1]).map(i => i[0]);
                                        const control = colors.length == 1 ? colors[0] : await player.chooseControl(colors).set("prompt", "济危：请选择一个颜色").forResultControl();
                                        let togive = player.getCards("h").filter(card => get.color(card) == control.slice(0, -1));
                                        if (_status.connectMode) game.broadcastAll(() => (_status.noclearcountdown = true));
                                        let given_map = [];
                                        while (togive.length) {
                                            const {
                                                result: { bool, cards, targets },
                                            } = await player.chooseCardTarget({
                                                forced: true,
                                                filterCard(card, player) {
                                                    return get.event("togive").includes(card) && !card.hasGaintag("olsujian_given");
                                                },
                                                selectCard: [1, Infinity],
                                                position: "h",
                                                filterTarget: lib.filter.notMe,
                                                prompt: "济危：请选择要分配的卡牌和目标",
                                                ai1(card) {
                                                    return !ui.selected.cards.length && card.name == "du" ? 1 : 0;
                                                },
                                                ai2(target) {
                                                    const player = get.event("player");
                                                    const card = ui.selected.cards[0];
                                                    if (card) return get.value(card, target) * get.attitude(player, target);
                                                    return 0;
                                                },
                                                togive: togive,
                                            });
                                            if (bool) {
                                                togive.removeArray(cards);
                                                const target = targets[0];
                                                if (given_map.some(i => i[0] == target)) {
                                                    given_map[given_map.indexOf(given_map.find(i => i[0] == target))][1].addArray(cards);
                                                } else given_map.push([target, cards]);
                                                player.addGaintag(cards, "olsujian_given");
                                            } else break;
                                        }
                                        if (_status.connectMode) {
                                            game.broadcastAll(() => {
                                                delete _status.noclearcountdown;
                                                game.stopCountChoose();
                                            });
                                        }
                                        if (given_map.length) {
                                            await game
                                                .loseAsync({
                                                    gain_list: given_map,
                                                    player: player,
                                                    cards: given_map.slice().map(list => list[1]),
                                                    giver: player,
                                                    animate: "giveAuto",
                                                })
                                                .setContent("gaincardMultiple");
                                        }
                                    }
                                },
                            },
                            //傅佥
                            old_jueyong: {
                                audio: "jueyong",
                                trigger: { target: "useCardToTarget" },
                                forced: true,
                                filter(event, player) {
                                    return event.card.name != "jiu" && event.card.name != "tao" && event.targets.length == 1 && event.card.isCard && event.cards.length == 1 && event.getParent(2).name != "old_jueyong_timeout" && get.position(event.cards[0], true) == "o" && event.card.name == event.cards[0].name && (!player.storage.old_jueyong || player.storage.old_jueyong[0].length < player.getHp());
                                },
                                content() {
                                    trigger.targets.remove(player);
                                    trigger.getParent().triggeredTargets2.remove(player);
                                    trigger.untrigger();
                                    var card = trigger.cards[0];
                                    player.addToExpansion(card, "gain2").gaintag.add("old_jueyong");
                                    if (!player.storage.old_jueyong) player.storage.old_jueyong = [[], []];
                                    player.storage.old_jueyong[0].push(card);
                                    player.storage.old_jueyong[1].push(trigger.player);
                                    game.delayx();
                                },
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                    delete player.storage[skill];
                                },
                                intro: {
                                    markcount(storage) {
                                        if (!storage) return 0;
                                        return storage[0].length;
                                    },
                                    mark(dialog, storage, player) {
                                        if (!storage) return;
                                        dialog.addAuto(storage[0]);
                                        dialog.addText(get.translation(storage[1]));
                                    },
                                    onunmark(storage, player) {
                                        player.storage.old_jueyong = [[], []];
                                    },
                                },
                                ai: {
                                    reverseEquip: true,
                                    effect: {
                                        target_use(card, player, target, current) {
                                            if (get.type(card) == "equip" && !get.tag(card, "gifts") && target.storage.old_jueyong && target.storage.old_jueyong[1].length) {
                                                var result1 = get.equipResult(player, target, card),
                                                    subtype = get.subtype(card);
                                                for (var i of target.storage.old_jueyong[0]) {
                                                    if (get.subtype(i, false) == subtype && get.equipResult(target, target, i) >= result1) return "zerotarget";
                                                }
                                            }
                                        },
                                    },
                                },
                                group: "old_jueyong_timeout",
                                subSkill: {
                                    timeout: {
                                        audio: "jueyong",
                                        trigger: { player: "phaseJieshuBegin" },
                                        forced: true,
                                        filter(event, player) {
                                            return player.storage.old_jueyong && player.storage.old_jueyong[0].length > 0; //=Math.max(1,player.getDamagedHp());
                                        },
                                        content() {
                                            var list = player.storage.old_jueyong,
                                                card = list[0].shift(),
                                                source = list[1].shift();
                                            if (player.getExpansions("old_jueyong").includes(card)) {
                                                if (source && source.isIn() && source.canUse(card, player, false)) source.useCard(card, player, false);
                                                else player.loseToDiscardpile(card);
                                            }
                                            if (list[0].length) event.redo();
                                        },
                                    },
                                },
                            },
                            old_poxiang: {
                                audio: "poxiang",
                                enable: "phaseUse",
                                usable: 1,
                                filter: (event, player) => player.countCards("he") > 0,
                                filterCard: true,
                                filterTarget: lib.filter.notMe,
                                position: "he",
                                discard: false,
                                lose: false,
                                delay: false,
                                check(card) {
                                    var player = _status.event.player;
                                    if (
                                        !player.storage.old_jueyong ||
                                        !player.storage.old_jueyong[0].length ||
                                        (player.hp <= 1 &&
                                            !player.storage.old_jueyong[0].some(function (card) {
                                                return get.tag(card, "damage") > 0;
                                            })) ||
                                        !player.storage.old_jueyong[0].some(function (card) {
                                            return get.effect(player, card, player.storage.old_jueyong[1][player.storage.old_jueyong[0].indexOf(card)], player) < 0;
                                        })
                                    )
                                        return -1;
                                    return 20 - get.value(card);
                                },
                                content() {
                                    "step 0";
                                    player.give(cards, target);
                                    player.draw(3);
                                    "step 1";
                                    var cards = player.getExpansions("old_jueyong");
                                    if (cards.length) player.loseToDiscardpile(cards);
                                    player.unmarkSkill("old_jueyong");
                                    player.loseHp();
                                    "step 2";
                                    player.skip("phaseDiscard");
                                    game.delayx();
                                },
                                ai: {
                                    order: 12,
                                    result: {
                                        player: 4,
                                        target: 1,
                                    },
                                },
                            },
                            //手杀郭照
                            old_yichong: {
                                initSkill(skill) {
                                    if (!lib.skill[skill]) {
                                        lib.skill[skill] = {
                                            charlotte: true,
                                            onremove: true,
                                            mark: true,
                                            marktext: "雀",
                                            intro: {
                                                markcount(storage) {
                                                    return (storage || 0).toString();
                                                },
                                                content(storage) {
                                                    return "已被掠夺" + (storage || 0) + "张牌";
                                                },
                                            },
                                        };
                                        lib.translate[skill] = "易宠";
                                        lib.translate[skill + "_bg"] = "雀";
                                    }
                                },
                                getLimit: 5,
                                audio: "yichong",
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseTarget(get.prompt("old_yichong"), "选择一名其他角色并选择一个花色，获得其此花色的所有牌并令其获得“雀”标记", lib.filter.notMe).set("ai", function (target) {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        if (att > 0) return 0;
                                        var getNum = function (player) {
                                            var list = [];
                                            for (var i of lib.suit) list.push(player.countCards("he", { suit: i }) + 3);
                                            return list.sort((a, b) => b - a)[0];
                                        };
                                        return getNum(target) + target.countCards("h") / 10;
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_yichong", target);
                                        event.target = target;
                                        player
                                            .chooseControl(lib.suit.slice(0).reverse())
                                            .set("prompt", "请声明一个花色")
                                            .set("ai", function () {
                                                var target = _status.event.target,
                                                    cards = target.getCards("he");
                                                var suits = lib.suit.slice(0);
                                                suits.sort(function (a, b) {
                                                    var num = function (suit) {
                                                        return cards.filter(function (card) {
                                                            return get.suit(card) == suit;
                                                        }).length;
                                                    };
                                                    return num(b) - num(a);
                                                });
                                                return suits[0];
                                            })
                                            .set("target", target);
                                    } else event.finish();
                                    "step 2";
                                    var suit = result.control;
                                    event.suit = suit;
                                    player.chat(get.translation(suit + 2));
                                    game.log(player, "选择了", "#y" + get.translation(suit + 2));
                                    if (target.countCards("he", { suit: suit })) player.gain(target.getCards("he", { suit: suit }), target, "giveAuto");
                                    "step 3";
                                    var suit = event.suit;
                                    player.storage.old_yichong = suit;
                                    player.markSkill("old_yichong");
                                    var skill = "old_yichong_" + player.playerid;
                                    game.broadcastAll(lib.skill.old_yichong.initSkill, skill);
                                    game.broadcastAll(
                                        function (player, suit) {
                                            if (player.marks.old_yichong) player.marks.old_yichong.firstChild.innerHTML = get.translation(suit);
                                        },
                                        player,
                                        suit
                                    );
                                    game.countPlayer(function (current) {
                                        current.removeSkill("old_yichong_" + player.playerid);
                                        if (current == target) target.addSkill("old_yichong_" + player.playerid);
                                    });
                                    player.addTempSkill("old_yichong_clear", { player: "phaseBegin" });
                                },
                                onremove: true,
                                intro: {
                                    content: "拥有“雀”标记的角色得到$牌后，你获得之",
                                },
                                group: "old_yichong_gain",
                                subSkill: {
                                    gain: {
                                        audio: "yichong",
                                        trigger: {
                                            global: ["gainAfter", "loseAsyncAfter"],
                                        },
                                        filter(event, player) {
                                            if (!player.storage.old_yichong) return false;
                                            return game.hasPlayer(function (current) {
                                                if (!event.getg(current).length || !current.hasSkill("old_yichong_" + player.playerid)) return false;
                                                if (current.countMark("old_yichong_" + player.playerid) >= lib.skill.old_yichong.getLimit) return false;
                                                return event.getg(current).some(card => get.suit(card, current) == player.storage.old_yichong && lib.filter.canBeGained(card, current, player));
                                            });
                                        },
                                        forced: true,
                                        content() {
                                            var target = game.findPlayer(function (current) {
                                                if (!trigger.getg(current).length || !current.hasSkill("old_yichong_" + player.playerid)) return false;
                                                if (current.countMark("old_yichong_" + player.playerid) >= lib.skill.old_yichong.getLimit) return false;
                                                return trigger.getg(current).some(card => get.suit(card, current) == player.storage.old_yichong && lib.filter.canBeGained(card, current, player));
                                            });
                                            var cards = trigger.getg(target).filter(card => get.suit(card, target) == player.storage.old_yichong && lib.filter.canBeGained(card, target, player));
                                            var num = lib.skill.old_yichong.getLimit - target.countMark("old_yichong_" + player.playerid);
                                            cards = cards.randomGets(num);
                                            player.gain(cards, target, "giveAuto");
                                            target.addMark("old_yichong_" + player.playerid, cards.length, false);
                                        },
                                        sourceSkill: "old_yichong",
                                    },
                                    clear: {
                                        charlotte: true,
                                        onremove(player) {
                                            game.countPlayer(function (current) {
                                                current.removeSkill("old_yichong_" + player.playerid);
                                            });
                                        },
                                        sourceSkill: "old_yichong",
                                    },
                                },
                            },
                            old_wufei: {
                                audio: "wufei",
                                trigger: {
                                    player: ["useCardToPlayered", "damageEnd"],
                                },
                                filter(event, player) {
                                    var target = game.findPlayer(current => current.hasSkill("old_yichong_" + player.playerid));
                                    if (!target) return false;
                                    if (event.name == "damage") return target.hp > 1 && target.hp > player.hp;
                                    return event.isFirstTarget && (event.card.name == "sha" || (get.type(event.card) == "trick" && get.tag(event.card, "damage")));
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    var target = game.findPlayer(current => current.hasSkill("old_yichong_" + player.playerid));
                                    event.target = target;
                                    if (trigger.name == "damage") {
                                        player.chooseBool(get.prompt("old_wufei", target), "令" + get.translation(target) + "受到1点无来源伤害").set("choice", get.damageEffect(target, player, player) > 0);
                                    } else {
                                        player.logSkill("old_wufei", target);
                                        player.addTempSkill("old_wufei_effect");
                                        player.markAuto("old_wufei_effect", [trigger.card]);
                                        game.log(target, "成为了", trigger.card, "的伤害来源");
                                        event.finish();
                                    }
                                    "step 1";
                                    if (result.bool) {
                                        player.logSkill("old_wufei", target);
                                        target.damage("nosource");
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        trigger: {
                                            source: "damageBefore",
                                        },
                                        filter(event, player) {
                                            if (!event.card) return false;
                                            return player.getStorage("old_wufei_effect").includes(event.card);
                                        },
                                        forced: true,
                                        popup: false,
                                        firstDo: true,
                                        content() {
                                            var target = game.findPlayer(current => current.hasSkill("old_yichong_" + player.playerid));
                                            if (!target) delete trigger.source;
                                            else trigger.source = target;
                                        },
                                        sub: true,
                                        sourceSkill: "old_wufei",
                                        _priority: 0,
                                    },
                                },
                                ai: {
                                    combo: "old_yichong",
                                },
                                _priority: 0,
                            },
                            //手杀陈珪
                            old_guimou: {
                                audio: "guimou",
                                trigger: {
                                    global: "phaseBefore",
                                    player: ["enterGame", "phaseEnd", "phaseZhunbeiBegin"],
                                },
                                filter(event, player, name) {
                                    if (event.name == "phaseZhunbei" || name == "phaseEnd") return true;
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                direct: true,
                                locked: true,
                                *content(event, map) {
                                    var player = map.player,
                                        trigger = map.trigger;
                                    if (trigger.name != "phaseZhunbei") {
                                        player.logSkill("old_guimou");
                                        var result,
                                            choiceList = ["惩罚期间使用牌最少的角色", "惩罚期间弃置牌最少的角色", "惩罚期间得到牌最少的角色"];
                                        if (trigger.name != "phase" || game.phaseNumber == 0) result = { index: get.rand(0, 2) };
                                        else
                                            result = yield player
                                                .chooseControl()
                                                .set("choiceList", choiceList)
                                                .set("ai", () => get.rand(0, 2));
                                        var str = choiceList[result.index];
                                        game.log(player, "选择", "#g" + str);
                                        player.addSkill("old_guimou_" + result.index);
                                        return;
                                    }
                                    var targets = [];
                                    for (var i = 0; i <= 2; i++) {
                                        var skill = "old_guimou_" + i;
                                        if (player.hasSkill(skill)) {
                                            var storage = player.storage[skill],
                                                nums = storage[0].slice();
                                            var targetx = nums.sort((a, b) => storage[1][storage[0].indexOf(a)] - storage[1][storage[0].indexOf(b)]);
                                            targetx = targetx.filter(target => storage[1][storage[0].indexOf(target)] == storage[1][storage[0].indexOf(targetx[0])]);
                                            targets.addArray(targetx);
                                            player.removeSkill(skill);
                                        }
                                    }
                                    targets = targets.filter(target => target != player && target.countCards("h"));
                                    if (targets.length) {
                                        var result = yield player
                                            .chooseTarget(
                                                "请选择【诡谋】的目标",
                                                "观看一名可选择的角色的手牌并选择其中至多三张牌，然后你可以将其中至多两张牌交给另一名其他角色，然后弃置剩余的牌",
                                                (card, player, target) => {
                                                    return _status.event.targets.includes(target) && target.countCards("h");
                                                },
                                                true
                                            )
                                            .set("ai", target => {
                                                return Math.sqrt(Math.min(3, target.countCards("h"))) * get.effect(target, { name: "guohe_copy2" }, player, player);
                                            })
                                            .set("targets", targets);
                                        if (result.bool) {
                                            var target = result.targets[0];
                                            player.logSkill("old_guimou", target);
                                            player.addExpose(0.3);
                                            var result2 = yield player.choosePlayerCard(target, "h", "visible", "<div class='text center'>选择其中至多三张牌，然后你可以将其中至多两张牌交给另一名其他角色，然后弃置剩余的牌</div>", [1, 3], true).set("ai", button => get.value(button.link));
                                            if (result2.bool) {
                                                var cards = result2.links.slice();
                                                var result3;
                                                if (!game.hasPlayer(targetx => targetx != player && targetx != target)) result3 = { bool: false };
                                                else
                                                    result3 = yield player
                                                        .chooseCardButton("是否将其中至多两张牌交给另一名其他角色", cards, [1, Math.min(2, cards.length)])
                                                        .set("ai", button => {
                                                            var player = _status.event.player;
                                                            if (!game.hasPlayer(target => target != player && target != _status.event.target && get.attitude(player, target) > 0)) return 0;
                                                            return get.value(button.link, _status.event.player);
                                                        })
                                                        .set("target", target);
                                                if (result3.bool) {
                                                    var result4 = yield player
                                                        .chooseTarget("请选择获得" + get.translation(result3.links) + "的目标", (card, player, target) => {
                                                            return target != player && target != _status.event.target;
                                                        })
                                                        .set("ai", target => get.attitude(_status.event.player, target))
                                                        .set("target", target);
                                                    if (result4.bool) {
                                                        var targetx = result4.targets[0];
                                                        player.line(targetx);
                                                        targetx.gain(result3.links, target, "give");
                                                        cards.removeArray(result3.links);
                                                    }
                                                }
                                                if (cards.length) target.discard(cards).discarder = player;
                                            }
                                        }
                                    }
                                },
                                subSkill: {
                                    0: {
                                        charlotte: true,
                                        onremove: true,
                                        init(player, skill) {
                                            if (!player.storage[skill]) {
                                                player.storage[skill] = [[], []];
                                                var targets = game.filterPlayer(i => i !== player).sortBySeat(player);
                                                targets.forEach(target => {
                                                    player.storage[skill][0].push(target);
                                                    player.storage[skill][1].push(0);
                                                });
                                            }
                                        },
                                        mark: true,
                                        intro: {
                                            markcount: storage => 0,
                                            content(storage, player) {
                                                var str = "当前使用牌数排行榜";
                                                var lose = storage[1].slice().sort((a, b) => a - b)[0];
                                                storage[0].forEach(target => {
                                                    str += "<br><li>";
                                                    var score = storage[1][storage[0].indexOf(target)];
                                                    if (score == lose) str += '<span class="texiaotext" style="color:#FF0000">';
                                                    str += " " + get.translation(target) + " ";
                                                    str += score + "张";
                                                    if (score == lose) str += "</span>";
                                                });
                                                return str;
                                            },
                                        },
                                        trigger: { global: "useCard1" },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            var storage = player.storage["old_guimou_0"];
                                            if (!storage[0].includes(trigger.player)) {
                                                storage[0].push(trigger.player);
                                                storage[1].push(0);
                                            }
                                            storage[1][storage[0].indexOf(trigger.player)]++;
                                        },
                                    },
                                    1: {
                                        charlotte: true,
                                        onremove: true,
                                        init(player, skill) {
                                            if (!player.storage[skill]) {
                                                player.storage[skill] = [[], []];
                                                var targets = game.filterPlayer(i => i !== player).sortBySeat(player);
                                                targets.forEach(target => {
                                                    player.storage[skill][0].push(target);
                                                    player.storage[skill][1].push(0);
                                                });
                                            }
                                        },
                                        mark: true,
                                        intro: {
                                            markcount: storage => 0,
                                            content(storage, player) {
                                                var str = "当前弃置牌数排行榜";
                                                var lose = storage[1].slice().sort((a, b) => a - b)[0];
                                                storage[0].forEach(target => {
                                                    str += "<br><li>";
                                                    var score = storage[1][storage[0].indexOf(target)];
                                                    if (score == lose) str += '<span class="texiaotext" style="color:#FF0000">';
                                                    str += " " + get.translation(target) + " ";
                                                    str += score + "张";
                                                    if (score == lose) str += "</span>";
                                                });
                                                return str;
                                            },
                                        },
                                        trigger: { global: ["loseAfter", "loseAsyncAfter"] },
                                        filter(event, player) {
                                            return event.type == "discard" && game.hasPlayer(target => event.getl(target).cards2.length);
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            var storage = player.storage["old_guimou_1"];
                                            var targets = game.filterPlayer(target => trigger.getl(target).cards2.length);
                                            targets.forEach(target => {
                                                if (!storage[0].includes(target)) {
                                                    storage[0].push(target);
                                                    storage[1].push(0);
                                                }
                                                storage[1][storage[0].indexOf(target)] += trigger.getl(target).cards2.length;
                                            });
                                        },
                                    },
                                    2: {
                                        charlotte: true,
                                        onremove: true,
                                        init(player, skill) {
                                            if (!player.storage[skill]) {
                                                player.storage[skill] = [[], []];
                                                var targets = game.filterPlayer(i => i !== player).sortBySeat(player);
                                                targets.forEach(target => {
                                                    player.storage[skill][0].push(target);
                                                    player.storage[skill][1].push(0);
                                                });
                                            }
                                        },
                                        mark: true,
                                        intro: {
                                            markcount: storage => 0,
                                            content(storage, player) {
                                                var str = "当前得到牌数排行榜";
                                                var lose = storage[1].slice().sort((a, b) => a - b)[0];
                                                storage[0].forEach(target => {
                                                    str += "<br><li>";
                                                    var score = storage[1][storage[0].indexOf(target)];
                                                    if (score == lose) str += '<span class="texiaotext" style="color:#FF0000">';
                                                    str += " " + get.translation(target) + " ";
                                                    str += score + "张";
                                                    if (score == lose) str += "</span>";
                                                });
                                                return str;
                                            },
                                        },
                                        trigger: { global: ["gainAfter", "loseAsyncAfter"] },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            var storage = player.storage["old_guimou_2"];
                                            var targets = game.filterPlayer(target => trigger.getg(target).length);
                                            targets.forEach(target => {
                                                if (!storage[0].includes(target)) {
                                                    storage[0].push(target);
                                                    storage[1].push(0);
                                                }
                                                storage[1][storage[0].indexOf(target)] += trigger.getg(target).length;
                                            });
                                        },
                                    },
                                },
                            },
                            //杨阜
                            oldx_jiebing: {
                                audio: "jiebing",
                                trigger: {
                                    player: "damageEnd",
                                },
                                direct: true,
                                forced: true,
                                filter(event, player) {
                                    return game.hasPlayer(current => {
                                        return current != event.source && current != player && current.countGainableCards(player, "he");
                                    });
                                },
                                content() {
                                    "step 0";
                                    player
                                        .chooseTarget("借兵：选择一名其他角色", get.skillInfoTranslation("oldx_jiebing"), true, (card, player, target) => {
                                            return player != target && target != _status.event.getTrigger().source && target.countGainableCards(player, "he");
                                        })
                                        .set("ai", target => get.effect(target, { name: "shunshou_copy2" }, player, player) /** (target.countCards("he")>1?1.5:1)*/);
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("oldx_jiebing", target);
                                        if (target.ai.shown > 0) player.addExpose(0.15);
                                        var cards = target.getGainableCards(player, "he").randomGets(2);
                                        event.cards = cards;
                                        player.gain(target, cards, "give", "bySelf");
                                        player.showCards(cards, "借兵");
                                    } else event.finish();
                                    "step 2";
                                    for (var card of cards) {
                                        if (get.type(card) == "equip" && player.hasUseTarget(card) && get.owner(card) == player) {
                                            player.chooseUseTarget(card, true);
                                        }
                                    }
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, "damage")) {
                                                if (player.hasSkillTag("jueqing", false, target)) return [1, -2];
                                                if (player != target && !player.getFriends().length) return;
                                                if (
                                                    game.hasPlayer(current => {
                                                        return current != player && get.attitude(player, current) > 0 && current.countGainableCards(target, "he") > 0;
                                                    })
                                                )
                                                    return [1, 1];
                                            }
                                        },
                                    },
                                },
                            },
                            old_hannan: {
                                audio: "hannan",
                                enable: "phaseUse",
                                usable: 1,
                                filter(event, player) {
                                    return !player.hasSkillTag("noCompareSource");
                                },
                                filterTarget(card, player, target) {
                                    return player.canCompare(target);
                                },
                                content() {
                                    "step 0";
                                    player.chooseToCompare(target);
                                    "step 1";
                                    if (!result.tie) {
                                        var players = [player, target];
                                        if (result.bool) players.reverse();
                                        players[1].line(players[0], "thunder");
                                        players[0].damage(players[1], 2);
                                    }
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        target(player, target) {
                                            var hs = player.getCards("h").sort(function (a, b) {
                                                return get.number(b) - get.number(a);
                                            });
                                            var ts = target.getCards("h").sort(function (a, b) {
                                                return get.number(b) - get.number(a);
                                            });
                                            if (!hs.length || !ts.length) return 0;
                                            if (get.number(hs[0]) > get.number(ts[0]) || get.number(hs[0]) - ts.length >= 9 + Math.min(2, player.hp / 2)) return get.sgnAttitude(player, target) * get.damageEffect(target, player, player);
                                            return 0;
                                        },
                                    },
                                },
                            },
                            //李昭焦伯
                            old_mbzuoyou: {
                                audio: "mbzuoyou",
                                enable: "phaseUse",
                                usable: 1,
                                zhuanhuanji: true,
                                filterTarget(card, player, target) {
                                    if (player.storage.mbzuoyou) return target.countCards("he");
                                    return true;
                                },
                                async content(event, trigger, player) {
                                    const storage = player.storage.old_mbzuoyou,
                                        target = event.target;
                                    if (event.name === "old_mbzuoyou") player.changeZhuanhuanji("old_mbzuoyou");
                                    if (!storage) {
                                        await target.draw(3);
                                        await target.chooseToDiscard(2, true, "h");
                                    } else {
                                        await target.changeHujia(1, null, true);
                                    }
                                },
                                mark: true,
                                marktext: "☯",
                                intro: {
                                    content(storage, player) {
                                        if (!storage) return "转换技。出牌阶段限一次，你可以令一名角色摸三张牌，然后其弃置两张手牌。";
                                        return "转换技。出牌阶段限一次，你可以令一名角色获得1点护甲。";
                                    },
                                },
                                ai: {
                                    order(item, player) {
                                        if (
                                            player.storage.old_mbzuoyou &&
                                            game.hasPlayer(current => {
                                                return current !== player && get.effect(current, "old_mbzuoyou", player, player) > 0;
                                            })
                                        )
                                            return get.order({ name: "zengbin" }) + 0.1;
                                        return 2;
                                    },
                                    result: {
                                        target(player, target) {
                                            let eff = 0;
                                            if (player.storage.old_mbzuoyou) eff = target.hujia < 5 ? 1 : 0;
                                            else eff = 1;
                                            if (target === player && player.hasSkill("old_mbshishou")) eff /= 10;
                                            return eff;
                                        },
                                    },
                                },
                            },
                            old_mbshishou: {
                                audio: "mbshishou",
                                trigger: { player: "useSkillAfter" },
                                filter(event, player) {
                                    return event.skill === "old_mbzuoyou" && !event.targets.includes(player);
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    await lib.skill.old_mbzuoyou.content(
                                        {
                                            target: player,
                                        },
                                        {},
                                        player
                                    );
                                },
                                ai: {
                                    combo: "old_mbzuoyou",
                                },
                            },
                            //手杀王双
                            old_shanxie: {
                                audio: "shanxie",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget(card, player, target) {
                                    return target != player && target.getEquip(1);
                                },
                                selectTarget: [0, 1],
                                content() {
                                    "step 0";
                                    if (!target) {
                                        var card = get.cardPile2(function (card) {
                                            return get.subtype(card) == "equip1";
                                        });
                                        if (card) player.gain(card, "gain2");
                                        event.finish();
                                    } else {
                                        var card = target.getEquip(1);
                                        if (card) {
                                            event.card = card;
                                            player.gain(card, target, "give");
                                        } else event.finish();
                                    }
                                    "step 1";
                                    if (player.getCards("h").includes(card) && get.type(card, null, player) == "equip" && player.hasUseTarget(card)) player.chooseUseTarget(card, true, "nopopup");
                                    "step 2";
                                    var hs = target.getCards("h", function (card) {
                                        return target.canUse(get.autoViewAs({ name: "sha" }, [card]), player, false);
                                    });
                                    if (hs.length) {
                                        if (hs.length == 1) event._result = { bool: true, cards: hs };
                                        else
                                            target
                                                .chooseCard("h", true, "将一张牌当做【杀】对" + get.translation(player) + "使用", function (card) {
                                                    return _status.event.cards.includes(card);
                                                })
                                                .set("cards", hs)
                                                .set("ai", function (card) {
                                                    return get.effect(_status.event.getParent().player, get.autoViewAs({ name: "sha" }, [card]), _status.event.player);
                                                });
                                    } else event.finish();
                                    "step 3";
                                    if (result.bool) target.useCard({ name: "sha" }, result.cards, player, false);
                                },
                                ai: {
                                    order: 9,
                                    result: { player: 1 },
                                },
                                group: ["old_shanxie_exclude", "old_shanxie_shan"],
                                subSkill: {
                                    exclude: {
                                        trigger: { global: "useCard" },
                                        forced: true,
                                        locked: false,
                                        filter(event, player) {
                                            if (event.card.name != "shan" || event.getParent(2).player != player) return false;
                                            var num = get.number(event.card);
                                            return !num || num <= player.getAttackRange() * 2;
                                        },
                                        logTarget: "player",
                                        content() {
                                            trigger.all_excluded = true;
                                        },
                                        sub: true,
                                    },
                                    shan: {
                                        trigger: { player: "useCardToPlayered" },
                                        filter(event, player) {
                                            return event.target.isAlive() && event.card.name == "sha";
                                        },
                                        silent: true,
                                        content() {
                                            trigger.target.addTempSkill("old_shanxie_banned");
                                            trigger.target.storage.old_shanxie_banned = {
                                                card: trigger.card,
                                                num: player.getAttackRange() * 2,
                                            };
                                        },
                                        sub: true,
                                    },
                                    banned: {
                                        init(player) {
                                            player.storage.old_shanxie_banned = {};
                                        },
                                        onremove(player) {
                                            delete player.storage.old_shanxie_banned;
                                        },
                                        trigger: { global: "useCardEnd" },
                                        filter(event, player) {
                                            return event.card == player.storage.old_shanxie_banned.card;
                                        },
                                        silent: true,
                                        content() {
                                            player.removeSkill("old_shanxie_banned");
                                        },
                                        ai: {
                                            effect: {
                                                player(card, player, target) {
                                                    if (get.name(card) == "shan") {
                                                        let num = get.number(card);
                                                        if (!num || num <= player.storage.old_shanxie_banned.num) return "zeroplayertarget";
                                                    }
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //手杀吴景
                            old_liubing: {
                                trigger: { player: "useCard1" },
                                forced: true,
                                filter(event, player) {
                                    return (
                                        event.card.name == "sha" &&
                                        event.cards.length == 1 &&
                                        player
                                            .getHistory("useCard", function (evt) {
                                                return evt.card.name == "sha" && evt.cards.length == 1;
                                            })
                                            .indexOf(event) == 0
                                    );
                                },
                                content() {
                                    game.log(player, "将", trigger.card, "的花色改为", "#y♦");
                                    trigger.card.suit = "diamond";
                                    trigger.card.color = "red";
                                },
                                group: "old_liubing_gain",
                                subSkill: {
                                    gain: {
                                        trigger: { global: "useCardAfter" },
                                        forced: true,
                                        audio: "liubing",
                                        filter(event, player) {
                                            return (
                                                event.player != player &&
                                                event.card.isCard &&
                                                event.card.name == "sha" &&
                                                get.color(event.card) == "black" &&
                                                event.cards.filterInD().length > 0 &&
                                                event.player.isPhaseUsing() &&
                                                !event.player.hasHistory("sourceDamage", function (evt) {
                                                    return evt.card == event.card;
                                                })
                                            );
                                        },
                                        logTarget: "player",
                                        content() {
                                            player.gain(trigger.cards.filterInD(), "gain2");
                                        },
                                    },
                                },
                            },
                            //手杀桥公
                            old_yizhu: {
                                audio: "yizhu",
                                trigger: { player: "phaseJieshuBegin" },
                                forced: true,
                                locked: false,
                                content() {
                                    "step 0";
                                    player.draw(2);
                                    "step 1";
                                    var hs = player.getCards("he");
                                    if (!hs.length) event.finish();
                                    else if (hs.length <= 2) event._result = { bool: true, cards: hs };
                                    else player.chooseCard("he", true, 2, "选择两张牌洗入牌堆");
                                    "step 2";
                                    if (result.bool) {
                                        player.$throw(result.cards.length, 1000);
                                        player.lose(result.cards, ui.cardPile).insert_index = function () {
                                            return ui.cardPile.childNodes[get.rand(0, game.players.length * 2 - 2)];
                                        };
                                        player.markAuto("old_yizhu", result.cards);
                                    } else event.finish();
                                    "step 3";
                                    game.updateRoundNumber();
                                    game.delayx();
                                },
                                intro: {
                                    mark(dialog, content, player) {
                                        if (player == game.me || player.isUnderControl()) dialog.addAuto(content);
                                        else {
                                            var names = [];
                                            for (var i of content) names.add(i.name);
                                            return get.translation(names);
                                        }
                                    },
                                },
                                group: ["old_yizhu_use", "old_yizhu_discard"],
                                subSkill: {
                                    use: {
                                        audio: "yizhu",
                                        trigger: { global: "useCardToPlayer" },
                                        filter(event, player) {
                                            return (
                                                player.storage.old_yizhu &&
                                                player.storage.old_yizhu.length &&
                                                event.player != player &&
                                                event.targets.length == 1 &&
                                                event.cards.filter(function (i) {
                                                    return player.storage.old_yizhu.contains(i);
                                                }).length > 0
                                            );
                                        },
                                        logTarget: "player",
                                        check(event, player) {
                                            return get.effect(event.targets[0], event.card, event.player, player) < 0;
                                        },
                                        prompt2(event, player) {
                                            return "令" + get.translation(event.card) + "无效并可重新使用";
                                        },
                                        content() {
                                            trigger.cancel();
                                            trigger.targets.length = 0;
                                            trigger.getParent().triggeredTargets1.length = 0;
                                            var list = trigger.cards.filter(function (i) {
                                                return player.storage.old_yizhu.contains(i);
                                            });
                                            player.unmarkAuto("old_yizhu", list);
                                            game.delayx();
                                            player.chooseUseTarget(trigger.card, trigger.cards, false, "nothrow");
                                        },
                                    },
                                    discard: {
                                        trigger: {
                                            global: ["loseAfter", "cardsDiscardAfter"],
                                        },
                                        forced: true,
                                        locked: false,
                                        filter(event, player) {
                                            return (
                                                player.storage.old_yizhu &&
                                                player.storage.old_yizhu.length &&
                                                (event.name != "lose" || event.position == ui.discardPile) &&
                                                event.cards.filter(function (i) {
                                                    return player.storage.old_yizhu.contains(i);
                                                }).length > 0
                                            );
                                        },
                                        content() {
                                            var list = trigger.cards.filter(function (i) {
                                                return player.storage.old_yizhu.contains(i);
                                            });
                                            player.unmarkAuto("old_yizhu", list);
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            old_gonghuan: {
                                audio: "gonghuan",
                                forceaudio: true,
                                trigger: { global: "damageBegin4" },
                                usable: 1,
                                forced: true,
                                logTarget: "player",
                                filter(event, player) {
                                    return (
                                        event.player.hp < player.hp &&
                                        player.hasMark("luanchou") &&
                                        event.player.hasMark("luanchou") &&
                                        game.hasPlayer(function (current) {
                                            return current.hasSkill("luanchou");
                                        })
                                    );
                                },
                                content() {
                                    trigger._old_gonghuan_player = trigger.player;
                                    trigger.player = player;
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target) {
                                            if (_status.luanchou_judging) return;
                                            _status.luanchou_judging = true;
                                            if (get.tag(card, "damage") && target.hasMark("luanchou")) {
                                                var other = game.findPlayer(function (current) {
                                                    return current != target && current.hasMark("luanchou") && current.hp > target.hp && (!current.storage.counttrigger || !current.storage.counttrigger.old_gonghuan);
                                                });
                                                if (!other) {
                                                    delete _status.luanchou_judging;
                                                    return;
                                                }
                                                var eff = [0, 0, 0, get.damageEffect(other, player, target, get.nature(card))];
                                                delete _status.luanchou_judging;
                                                return eff;
                                            }
                                        },
                                    },
                                },
                                subSkill: {
                                    clear: {
                                        trigger: { player: "damageEnd" },
                                        forced: true,
                                        popup: false,
                                        filter(event, player) {
                                            return event._old_gonghuan_player && player.hp == event._old_gonghuan_player.hp;
                                        },
                                        content() {
                                            player.removeMark("luanchou", player.countMark("luanchou"));
                                            trigger._old_gonghuan_player.removeMark("luanchou", trigger._old_gonghuan_player.countMark("luanchou"));
                                        },
                                    },
                                },
                            },
                            //手杀周不疑
                            old_mbhuiyao: {
                                audio: "mbhuiyao",
                                enable: "phaseUse",
                                usable: 1,
                                // filterTarget:lib.filter.notMe,
                                content() {
                                    "step 0";
                                    player.damage("nosource");
                                    "step 1";
                                    if (game.countPlayer() < 2) event.finish();
                                    if (game.countPlayer() == 2)
                                        event._result = {
                                            bool: true,
                                            targets: [game.findPlayer(i => i != player), player],
                                        };
                                    else
                                        player
                                            .chooseTarget(
                                                `慧夭：请选择两名角色`,
                                                `令不为你的第一名角色视为对第二名角色造成过1点伤害。`,
                                                (card, player, target) => {
                                                    if (!ui.selected.targets.length) return player != target;
                                                    return true;
                                                },
                                                2,
                                                true
                                            )
                                            .set("multitarget", true)
                                            .set("targetprompt", ["伤害来源", "受伤角色"])
                                            .set("ai", target => {
                                                return target == get.event("aiTargets")[ui.selected.targets.length] ? 10 : 0;
                                            })
                                            .set("aiTargets", lib.skill.old_mbhuiyao.getUnrealDamageTargets(player, [game.filterPlayer(i => i != player), game.filterPlayer()], true));
                                    "step 2";
                                    if (result.bool) {
                                        var targets = result.targets;
                                        player.line2(targets, "green");
                                        game.delaye();
                                        targets[1].damage(targets[0], "unreal");
                                    }
                                },
                                getUnrealDamageTargets: (player, lists, forced) => {
                                    const targets = [null, null];
                                    let sourceList, targetList;
                                    if (lists.length == 2 && lists.every(l => Array.isArray(l))) {
                                        sourceList = lists[0];
                                        targetList = lists[1];
                                    } else {
                                        sourceList = lists.slice();
                                        targetList = lists.slice();
                                    }
                                    const list = targetList
                                        .map(current => {
                                            const _hp = current.hp,
                                                _maxhp = current.maxHp;
                                            current.hp = 100;
                                            current.maxHp = 100;
                                            const att = -get.sgnAttitude(player, current);
                                            let val = get.damageEffect(current, player, current) * att;
                                            current.getSkills(null, false, false).forEach(skill => {
                                                const info = get.info(skill);
                                                if (info && info.ai && (info.ai.maixie || info.ai.maixie_hp || info.ai.maixie_defend)) val = Math[val > 0 ? "max" : "min"](val > 0 ? 0.1 : -0.1, val + 2 * att);
                                            });
                                            const eff = 100 / val + 15;
                                            current.hp = _hp;
                                            current.maxHp = _maxhp;
                                            return [current, eff];
                                        })
                                        .sort((a, b) => b[1] - a[1])[0];
                                    if (list[1] < 0 && !forced) return targets;
                                    const targetx = list[0];
                                    targets[1] = targetx;
                                    const list2 = sourceList
                                        .filter(i => i != targetx)
                                        .map(current => {
                                            const _hp = targetx.hp,
                                                _maxhp = targetx.maxHp;
                                            targetx.hp = 100;
                                            targetx.maxHp = 100;
                                            const att = -get.sgnAttitude(player, current);
                                            const eff = get.damageEffect(targetx, current, current) * att;
                                            targetx.hp = _hp;
                                            targetx.maxHp = _maxhp;
                                            return [current, eff];
                                        })
                                        .sort((a, b) => b[1] - a[1])[0];
                                    if (!list2) return targets;
                                    targets[0] = list2[0];
                                    return targets;
                                },
                                ai: {
                                    order: 6,
                                    result: {
                                        player(player) {
                                            if (player.getHp() + player.countCards("hs", card => player.canSaveCard(card, player)) <= 1) return 0;
                                            var limit = 25;
                                            var quesong = player.hasSkill("old_mbquesong") && !player.getStat().damaged;
                                            if (quesong) {
                                                limit -= 7.5;
                                            }
                                            if (
                                                quesong &&
                                                game.hasPlayer(target => {
                                                    var att = get.attitude(player, target);
                                                    if (att < 0) return false;
                                                    return (
                                                        att *
                                                        Math.sqrt(
                                                            Math.max(
                                                                1,
                                                                [1, 2, 3, 4].reduce((p, c) => p + target.countEmptySlot(c), 0)
                                                            )
                                                        ) >=
                                                        10 || target.getHp() <= 2
                                                    );
                                                })
                                            )
                                                return 1;
                                            if (
                                                !quesong &&
                                                game.hasPlayer(target => {
                                                    if (target == player) return false;
                                                    var _hp = target.hp,
                                                        _maxhp = target.maxHp;
                                                    target.hp = 100;
                                                    target.maxHp = 100;
                                                    var att = -get.sgnAttitude(player, target);
                                                    var val = get.damageEffect(target, player, target) * att;
                                                    target.getSkills(null, false, false).forEach(skill => {
                                                        var info = get.info(skill);
                                                        if (info && info.ai && (info.ai.maixie || info.ai.maixie_hp || info.ai.maixie_defend)) val = Math[val > 0 ? "max" : "min"](val > 0 ? 0.1 : -0.1, val + 2 * att);
                                                    });
                                                    var eff = 100 / val;
                                                    target.hp = _hp;
                                                    target.maxHp = _maxhp;
                                                    if (eff < limit) return false;
                                                    return true;
                                                })
                                            )
                                                return 1;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            old_mbquesong: {
                                audio: "mbquesong",
                                trigger: {
                                    global: "phaseJieshuBegin",
                                },
                                filter(event, player) {
                                    return player.getHistory("damage").length;
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseTarget(get.prompt2("old_mbquesong")).set("ai", target => {
                                        var player = _status.event.player;
                                        if (get.attitude(player, target) <= 0) return 0;
                                        var len = lib.skill.old_mbquesong.getNum(target),
                                            hp = target.getHp();
                                        return len + target.isTurnedOver() * 2 + (1.5 * Math.min(4, target.getDamagedHp())) / (hp + 1);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill("old_mbquesong", target);
                                        var len = lib.skill.old_mbquesong.getNum(target);
                                        if (target.isHealthy()) event._result = { index: 0 };
                                        else {
                                            target
                                                .chooseControl()
                                                .set("choiceList", ["摸" + get.cnNumber(len) + "张牌并复原武将牌", "回复1点体力"])
                                                .set("prompt", "雀颂：请选择一项")
                                                .set("ai", () => {
                                                    var player = _status.event.player;
                                                    var len = _status.event.len;
                                                    return get.effect(player, { name: "draw" }, player, player) * len >= get.recoverEffect(player, player, player) ? 0 : 1;
                                                })
                                                .set("len", len);
                                        }
                                    } else event.finish();
                                    "step 2";
                                    if (result.index == 1) {
                                        target.recover();
                                        event.finish();
                                    } else target.draw(Math.max(lib.skill.old_mbquesong.getNum(target), 1));
                                    "step 3";
                                    target.link(false);
                                    "step 4";
                                    target.turnOver(false);
                                },
                                getNum(player) {
                                    return 5 - player.countCards("e");
                                },
                                ai: {
                                    expose: 0.2,
                                    maixie: true,
                                    skillTagFilter(player, tag) {
                                        if (player.getStat().damaged) return false;
                                    },
                                },
                            },
                            //SP毌丘俭
                            old_mbcuizhen: {
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event, player) {
                                    return (
                                        (event.name != "phase" || game.phaseNumber == 0) &&
                                        game.hasPlayer(current => {
                                            return current !== player && current.hasEnabledSlot(1);
                                        })
                                    );
                                },
                                async cost(event, trigger, player) {
                                    const num = 3;
                                    event.result = await player
                                        .chooseTarget(get.prompt("old_mbcuizhen"), "废除至多" + get.cnNumber(num) + "名其他角色的武器栏", [1, num], (card, player, target) => {
                                            return target !== player && target.hasEnabledSlot(1);
                                        })
                                        .set("ai", target => {
                                            const player = get.event("player");
                                            return (1 - get.attitude(player, target)) * Math.sqrt(get.distance(player, target));
                                        })
                                        .forResult();
                                },
                                group: ["old_mbcuizhen_inphase", "old_mbcuizhen_draw"],
                                async content(event, trigger, player) {
                                    const targets = event.targets.slice().sortBySeat();
                                    for (const target of targets) {
                                        if (target.identityShown) {
                                            if (get.mode() != "identity" || player.identity != "nei") player.addExpose(0.3);
                                        }
                                        await target.disableEquip(1);
                                    }
                                    await game.delay();
                                },
                                subSkill: {
                                    inphase: {
                                        audio: "mbcuizhen",
                                        trigger: {
                                            player: "useCardToPlayered",
                                        },
                                        filter(event, player) {
                                            if (!player.isPhaseUsing()) return false;
                                            if (!get.tag(event.card, "damage")) return false;
                                            const target = event.target;
                                            return target !== player && target.countCards("h") >= target.getHp() && target.hasEnabledSlot(1);
                                        },
                                        prompt2: "废除其的武器栏",
                                        logTarget: "target",
                                        check(event, player) {
                                            return get.attitude(player, event.target) <= 0;
                                        },
                                        async content(event, trigger, player) {
                                            await trigger.target.disableEquip(1);
                                            await game.delayx();
                                        },
                                    },
                                    draw: {
                                        audio: "mbcuizhen",
                                        trigger: { player: "phaseDrawBegin2" },
                                        forced: true,
                                        locked: false,
                                        filter(event, player) {
                                            return !event.numFixed;
                                        },
                                        async content(event, trigger, player) {
                                            trigger.num += Math.min(
                                                4,
                                                game.countPlayer(current => {
                                                    return current.countDisabledSlot(1);
                                                }) + 1
                                            );
                                        },
                                    },
                                },
                            },
                            //王经
                            old_mbjiejian: {
                                audio: "mbjiejian",
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                filter(event, player) {
                                    return player.countCards("h");
                                },
                                async cost(event, trigger, player) {
                                    if (_status.connectMode)
                                        game.broadcastAll(function () {
                                            _status.noclearcountdown = true;
                                        });
                                    const give_map = {};
                                    let used = [];
                                    do {
                                        const result = await player
                                            .chooseCardTarget({
                                                filterCard(card) {
                                                    return get.itemtype(card) == "card" && !card.hasGaintag("old_mbjiejian_tag");
                                                },
                                                filterTarget: lib.filter.notMe,
                                                selectCard: [1, Infinity],
                                                prompt: used.length ? "是否继续分配手牌？" : get.prompt("old_mbjiejian"),
                                                prompt2: "请选择要分配的卡牌和目标",
                                                ai1(card) {
                                                    if (!ui.selected.cards.length) return 8 - get.value(card);
                                                    return 0;
                                                },
                                                ai2(target) {
                                                    let player = _status.event.player,
                                                        card = ui.selected.cards[0];
                                                    let val = get.value(card),
                                                        att = get.attitude(player, target);
                                                    if (val <= 4) {
                                                        if (get.event("used").includes(target)) return 0;
                                                        return 1 / target.getUseValue(card);
                                                    }
                                                    return att * (target.getUseValue(card) + 4);
                                                },
                                            })
                                            .set("used", used)
                                            .forResult();
                                        if (result.bool && result.targets.length) {
                                            const id = result.targets[0].playerid,
                                                map = give_map;
                                            if (!map[id]) map[id] = [];
                                            map[id].addArray(result.cards);
                                            player.addGaintag(result.cards, "old_mbjiejian_tag");
                                            used.addArray(result.targets);
                                        } else break;
                                    } while (player.countCards("h"));
                                    if (_status.connectMode) {
                                        game.broadcastAll(function () {
                                            delete _status.noclearcountdown;
                                            game.stopCountChoose();
                                        });
                                    }
                                    const list = [],
                                        targets = [];
                                    for (const i in give_map) {
                                        const source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, "green");
                                        if (player !== source && (get.mode() !== "identity" || player.identity !== "nei")) player.addExpose(0.2);
                                        targets.push(source);
                                        list.push([source, give_map[i]]);
                                    }
                                    event.result = {
                                        bool: list.length > 0,
                                        targets: targets,
                                        cost_data: list,
                                    };
                                },
                                logAudio: () => 1,
                                async content(event, trigger, player) {
                                    const list = event.cost_data;
                                    await game
                                        .loseAsync({
                                            gain_list: list,
                                            player: player,
                                            cards: list.map(i => i[1]).flat(),
                                            giver: player,
                                            animate: "giveAuto",
                                        })
                                        .setContent("gaincardMultiple");
                                    for (let target of event.targets) {
                                        let num = target.hp - target.countMark("old_mbjiejian_mark");
                                        target.addMark("old_mbjiejian_mark", num, false);
                                    }
                                },
                                group: ["old_mbjiejian_liuli", "old_mbjiejian_remove"],
                                subSkill: {
                                    liuli: {
                                        audio: "mbjiejian2.mp3",
                                        trigger: {
                                            global: "useCardToTarget",
                                        },
                                        filter(event, player) {
                                            if (get.type(event.card) == "equip") return false;
                                            if (!event.targets || event.targets.length != 1) return false;
                                            if (!event.targets[0].hasMark("old_mbjiejian_mark")) return false;
                                            return true;
                                        },
                                        prompt2: "将此牌转移给自己",
                                        check(event, player) {
                                            return get.effect(player, event.card, event.player, player) >= get.effect(event.targets[0], event.card, event.player, player);
                                        },
                                        logTarget: "target",
                                        async content(event, trigger, player) {
                                            const evt = trigger.getParent();
                                            evt.triggeredTargets2.removeArray(event.targets);
                                            evt.targets.removeArray(event.targets);
                                            if (lib.filter.targetEnabled2(trigger.card, trigger.player, player)) evt.targets.push(player);
                                            await player.draw();
                                        },
                                    },
                                    remove: {
                                        audio: "mbjiejian3.mp3",
                                        trigger: {
                                            global: "phaseEnd",
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            return event.player.hasMark("old_mbjiejian_mark");
                                        },
                                        logTarget: "player",
                                        async content(event, trigger, player) {
                                            const target = event.targets[0],
                                                num = target.countMark("old_mbjiejian_mark");
                                            target.removeMark("old_mbjiejian_mark", num, false);
                                            if (target.hp >= num) await player.draw(2);
                                        },
                                    },
                                    mark: {
                                        intro: {
                                            content: "获得“节谏”时的体力值：$",
                                        },
                                    },
                                },
                            },

                            //李遗
                            old_jiaohua: {
                                onremove: true,
                                audio: "twjiaohua",
                                enable: "phaseUse",
                                usable: 4,
                                chooseButton: {
                                    dialog(event, player) {
                                        return ui.create.dialog("###教化###选择一种牌的类型，令一名角色从牌堆获得此类型的一张牌");
                                    },
                                    chooseControl(event, player) {
                                        var list = ["basic", "trick", "equip"].filter(type => !player.getStorage("old_jiaohua").includes(type));
                                        list.push("cancel2");
                                        return list;
                                    },
                                    check(event, player) {
                                        var list = ["trick", "equip", "basic"].filter(type => !player.getStorage("old_jiaohua").includes(type));
                                        return list[0];
                                    },
                                    backup(result, player) {
                                        return {
                                            type: result.control,
                                            audio: "twjiaohua",
                                            filterCard: () => false,
                                            selectCard: -1,
                                            filterTarget: true,
                                            content() {
                                                "step 0";
                                                var type = lib.skill.old_jiaohua_backup.type;
                                                var card = get.cardPile2(card => get.type2(card) == type);
                                                if (card) target.gain(card, "gain2");
                                                else game.log("但牌堆里已经没有", "#y" + get.translation(type) + "牌", "了！");
                                                "step 1";
                                                player.markAuto("old_jiaohua", [lib.skill.old_jiaohua_backup.type]);
                                                "step 2";
                                                if (!["basic", "trick", "equip"].some(type => !player.getStorage("old_jiaohua").includes(type))) {
                                                    player.popup("教化");
                                                    player.unmarkAuto("old_jiaohua", player.getStorage("old_jiaohua"));
                                                    game.log(player, "清空了", "#g【教化】", "记录");
                                                }
                                            },
                                            ai: {
                                                result: { target: 1 },
                                            },
                                        };
                                    },
                                    prompt(result, player) {
                                        return "令一名角色从牌堆中获得一张" + get.translation(result.control) + "牌";
                                    },
                                },
                                ai: {
                                    order: 7,
                                    result: { player: 1 },
                                },
                                intro: { content: "已记录$牌" },
                            },
                            //谋黄忠
                            old_sbliegong: {
                                audio: "sbliegong",
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (num > 0 && (card.name === "sha" || get.tag(card, "draw"))) return num + 6;
                                    },
                                    targetInRange(card, player, target) {
                                        if (card.name == "sha" && typeof get.number(card) == "number") {
                                            if (get.distance(player, target) <= get.number(card)) return true;
                                        }
                                    },
                                },
                                trigger: { player: "useCardToPlayered" },
                                filter(event, player) {
                                    return !event.getParent()._old_sbliegong_player && event.targets.length == 1 && event.card.name == "sha" && player.getStorage("old_sbliegong").length > 0;
                                },
                                prompt2(event, player) {
                                    let str = "",
                                        storage = player.getStorage("old_sbliegong");
                                    if (storage.length > 1) {
                                        str += "亮出牌堆顶的" + get.cnNumber(storage.length - 1) + "张牌并增加伤害；且";
                                    }
                                    str += "令" + get.translation(event.target) + "不能使用花色为";
                                    for (let i = 0; i < storage.length; i++) {
                                        str += get.translation(storage[i]);
                                    }
                                    str += "的牌响应" + get.translation(event.card);
                                    return str;
                                },
                                logTarget: "target",
                                locked: false,
                                check(event, player) {
                                    const target = event.target;
                                    if (get.attitude(player, target) > 0) return false;
                                    if (
                                        target.hasSkillTag("filterDamage", null, {
                                            player: player,
                                            card: event.card,
                                        })
                                    )
                                        return false;
                                    const storage = player.getStorage("old_sbliegong");
                                    if (storage.length >= 4) return true;
                                    if (storage.length < 3) return false;
                                    if (target.hasShan()) return storage.includes("heart") && storage.includes("diamond");
                                    return true;
                                },
                                content() {
                                    const storage = player.getStorage("old_sbliegong").slice(0);
                                    const num = storage.length - 1;
                                    const evt = trigger.getParent();
                                    if (num > 0) {
                                        if (typeof evt.baseDamage != "number") evt.baseDamage = 1;
                                        const cards = get.cards(num);
                                        player.showCards(cards.slice(0), get.translation(player) + "发动了【烈弓】");
                                        while (cards.length > 0) {
                                            const card = cards.pop();
                                            if (storage.includes(get.suit(card, false))) evt.baseDamage++;
                                            //ui.cardPile.insertBefore(card,ui.cardPile.firstChild);
                                        }
                                        //game.updateRoundNumber();
                                    }
                                    evt._old_sbliegong_player = player;
                                    player.addTempSkill("old_sbliegong_clear");
                                    const target = trigger.target;
                                    target.addTempSkill("old_sbliegong_block");
                                    if (!target.storage.old_sbliegong_block) target.storage.old_sbliegong_block = [];
                                    target.storage.old_sbliegong_block.push([evt.card, storage]);
                                    lib.skill.old_sbliegong.updateBlocker(target);
                                },
                                updateBlocker(player) {
                                    const list = [],
                                        storage = player.storage.old_sbliegong_block;
                                    if (storage?.length) {
                                        for (const i of storage) list.addArray(i[1]);
                                    }
                                    player.storage.old_sbliegong_blocker = list;
                                },
                                ai: {
                                    threaten: 3.5,
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg?.card?.name == "sha") {
                                            const storage = player.getStorage("old_sbliegong");
                                            if (storage.length < 3 || !storage.includes("heart") || !storage.includes("diamond")) return false;
                                            const target = arg.target;
                                            if (target.hasSkill("bagua_skill") || target.hasSkill("bazhen") || target.hasSkill("rw_bagua_skill")) return false;
                                            return true;
                                        }
                                        return false;
                                    },
                                },
                                intro: {
                                    content: "已记录花色：$",
                                    onunmark: true,
                                },
                                group: "old_sbliegong_count",
                                subSkill: {
                                    clear: {
                                        trigger: { player: "useCardAfter" },
                                        forced: true,
                                        charlotte: true,
                                        popup: false,
                                        filter(event, player) {
                                            return event._old_sbliegong_player == player;
                                        },
                                        content() {
                                            player.unmarkSkill("old_sbliegong");
                                            player.removeTip("old_sbliegong");
                                        },
                                    },
                                    block: {
                                        mod: {
                                            cardEnabled(card, player) {
                                                if (!player.storage.old_sbliegong_blocker) return;
                                                const suit = get.suit(card);
                                                if (suit == "none") return;
                                                let evt = _status.event;
                                                if (evt.name != "chooseToUse") evt = evt.getParent("chooseToUse");
                                                if (!evt || !evt.respondTo || evt.respondTo[1].name != "sha") return;
                                                if (player.storage.old_sbliegong_blocker.includes(suit)) return false;
                                            },
                                        },
                                        trigger: {
                                            player: ["damageBefore", "damageCancelled", "damageZero"],
                                            target: ["shaMiss", "useCardToExcluded", "useCardToEnd"],
                                            global: ["useCardEnd"],
                                        },
                                        forced: true,
                                        firstDo: true,
                                        charlotte: true,
                                        popup: false,
                                        onremove(player) {
                                            delete player.storage.old_sbliegong_block;
                                            delete player.storage.old_sbliegong_blocker;
                                        },
                                        filter(event, player) {
                                            const evt = event.getParent("useCard", true, true);
                                            if (evt && evt.effectedCount < evt.effectCount) return false;
                                            if (!event.card || !player.storage.old_sbliegong_block) return false;
                                            return player.storage.old_sbliegong_block.some(i => i[0] == event.card);
                                        },
                                        content() {
                                            const storage = player.storage.old_sbliegong_block;
                                            for (let i = 0; i < storage.length; i++) {
                                                if (storage[i][0] == trigger.card) {
                                                    storage.splice(i--, 1);
                                                }
                                            }
                                            if (!storage.length) player.removeSkill(event.name);
                                            else lib.skill.old_sbliegong.updateBlocker(player);
                                        },
                                    },
                                    count: {
                                        trigger: {
                                            player: "useCard",
                                            target: "useCardToTargeted",
                                        },
                                        forced: true,
                                        locked: false,
                                        popup: false,
                                        filter(event, player, name) {
                                            if (name != "useCard" && player == event.player) return false;
                                            const suit = get.suit(event.card);
                                            if (!lib.suit.includes(suit)) return false;
                                            if (player.storage.old_sbliegong?.includes(suit)) return false;
                                            return true;
                                        },
                                        content() {
                                            player.markAuto("old_sbliegong", [get.suit(trigger.card)]);
                                            player.storage.old_sbliegong.sort((a, b) => lib.suit.indexOf(b) - lib.suit.indexOf(a));
                                            player.addTip("old_sbliegong", get.translation("old_sbliegong") + player.getStorage("old_sbliegong").reduce((str, suit) => str + get.translation(suit), ""));
                                        },
                                    },
                                },
                            },
                            //谋黄月英
                            old_sbqicai: {
                                mod: {
                                    targetInRange(card, player, target) {
                                        if (get.type2(card) == "trick") return true;
                                    },
                                },
                                locked: false,
                                getLimit: 3,
                                audio: "sbqicai",
                                enable: "phaseUse",
                                onChooseToUse(event) {
                                    if (!event.old_sbqicai && !game.online) {
                                        const player = get.player();
                                        const cards = Array.from(ui.discardPile.childNodes).filter(card => lib.skill.old_sbqicai.filterCardx(card, player));
                                        event.set("old_sbqicai", cards);
                                    }
                                },
                                filter(event, player) {
                                    return player.countCards("h", card => lib.skill.old_sbqicai.filterCardx(card, player)) || (event.old_sbqicai && event.old_sbqicai.length);
                                },
                                filterCardx(card, player) {
                                    if (player.getStorage("old_sbqicai").includes(card.name)) return false;
                                    return get.type(card) == "equip" && game.hasPlayer(target => target != player && target.hasEmptySlot(get.subtype(card)));
                                },
                                usable: 1,
                                chooseButton: {
                                    dialog(event, player) {
                                        const list1 = player.getCards("h", card => lib.skill.old_sbqicai.filterCardx(card, player));
                                        const list2 = event.old_sbqicai;
                                        var dialog = ui.create.dialog('###奇才###<div class="text center">请选择一张装备牌置入一名其他角色的装备区</div>');
                                        if (list1.length) {
                                            dialog.add('<div class="text center">手牌区</div>');
                                            dialog.add(list1);
                                        }
                                        if (list2.length) {
                                            dialog.add('<div class="text center">弃牌堆</div>');
                                            dialog.add(list2);
                                            if (list1.length) dialog.classList.add("fullheight");
                                        }
                                        return dialog;
                                    },
                                    check(button) {
                                        var player = _status.event.player;
                                        var num = get.value(button.link);
                                        if (!game.hasPlayer(target => target != player && target.hasEmptySlot(get.subtype(button.link)) && get.attitude(player, target) > 0)) num = 1 / (get.value(button.link) || 0.5);
                                        if (get.owner(button.link)) return num;
                                        return num * 5;
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: "sbqicai",
                                            card: links[0],
                                            filterCard(card, player) {
                                                var cardx = lib.skill.old_sbqicai_backup.card;
                                                if (get.owner(cardx)) return card == cardx;
                                                return false;
                                            },
                                            selectCard: -1,
                                            filterTarget(card, player, target) {
                                                return target != player && target.canEquip(lib.skill.old_sbqicai_backup.card);
                                            },
                                            check: () => 1,
                                            discard: false,
                                            lose: false,
                                            prepare(cards, player, targets) {
                                                if (cards && cards.length) player.$give(cards, targets[0], false);
                                            },
                                            content() {
                                                if (!cards || !cards.length) {
                                                    cards = [lib.skill.old_sbqicai_backup.card];
                                                    target.$gain2(cards);
                                                    game.delayx();
                                                }
                                                target.equip(cards[0]);
                                                player.addSkill("old_sbqicai_gain");
                                                lib.skill.old_sbqicai.updateCounter(player, target, 0);
                                            },
                                            ai: {
                                                result: {
                                                    target(player, target) {
                                                        var att = get.attitude(player, target);
                                                        if (att > 0) return 1;
                                                        if (att < 0) return -3;
                                                        return 0;
                                                    },
                                                },
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        return "请选择置入" + get.translation(links) + "的角色";
                                    },
                                },
                                updateCounter(player, target, num) {
                                    const skill = `old_sbqicai_${player.playerid}`;
                                    game.broadcastAll(lib.skill.old_sbqicai.initSkill, skill);
                                    if (!target.hasSkill(skill)) target.addSkill(skill);
                                    if (num == 0) target.clearMark(skill, false);
                                    else if (num > 0) target.addMark(skill, num, false);
                                    if (target.countMark(skill) >= lib.skill.old_sbqicai.getLimit) target.removeSkill(skill);
                                    if (!_status.postReconnect.old_sbqicai) {
                                        _status.postReconnect.old_sbqicai = [lib.skill.old_sbqicai.initSkill, []];
                                    }
                                    _status.postReconnect.old_sbqicai[1].add(skill);
                                },
                                initSkill: skill => {
                                    if (!lib.skill[skill]) {
                                        lib.skill[skill] = {
                                            onremove: true,
                                            mark: true,
                                            marktext: "奇",
                                            intro: {
                                                markcount(storage) {
                                                    return (storage || 0).toString();
                                                },
                                                content(storage) {
                                                    return "已被掠夺" + get.cnNumber(storage || 0) + "张普通锦囊牌";
                                                },
                                            },
                                        };
                                        lib.translate[skill] = "奇才";
                                        lib.translate[skill + "_bg"] = "奇";
                                    }
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        player(player) {
                                            if (!game.hasPlayer(target => target != player && target.hasEmptySlot(2) && get.attitude(player, target) != 0)) return 0;
                                            return 1;
                                        },
                                    },
                                },
                                marktext: "才",
                                intro: { content: "已使用$发动过此技能" },
                                subSkill: {
                                    gain: {
                                        audio: "sbqicai",
                                        trigger: { global: ["gainAfter", "loseAsyncAfter"] },
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                if (!event.getg(current).length || !current.hasSkill("old_sbqicai_" + player.playerid)) return false;
                                                if (current.countMark("old_sbqicai_" + player.playerid) >= lib.skill.old_sbqicai.getLimit) return false;
                                                return event.getg(current).some(card => get.type(card) == "trick" && lib.filter.canBeGained(card, current, player));
                                            });
                                        },
                                        forced: true,
                                        direct: true,
                                        charlotte: true,
                                        content() {
                                            "step 0";
                                            if (!event.checkedTargets) event.checkedTargets = [];
                                            var target = game.findPlayer(function (current) {
                                                if (!trigger.getg(current).length || !current.hasSkill("old_sbqicai_" + player.playerid)) return false;
                                                if (event.checkedTargets.includes(current)) return false;
                                                if (current.countMark("old_sbqicai_" + player.playerid) >= lib.skill.old_sbqicai.getLimit) return false;
                                                return trigger.getg(current).some(card => get.type(card) == "trick" && lib.filter.canBeGained(card, current, player));
                                            });
                                            if (!target) {
                                                event.finish();
                                                return;
                                            }
                                            event.target = target;
                                            player.logSkill("old_sbqicai_gain", target);
                                            event.checkedTargets.add(target);
                                            var cards = trigger.getg(target).filter(card => get.type(card) == "trick" && lib.filter.canBeGained(card, target, player));
                                            if (cards.length <= lib.skill.old_sbqicai.getLimit - target.countMark("old_sbqicai_" + player.playerid)) event._result = { bool: true, links: cards };
                                            else {
                                                var num = lib.skill.old_sbqicai.getLimit - target.countMark("old_sbqicai_" + player.playerid);
                                                target
                                                    .chooseButton(["奇才：将其中" + get.cnNumber(num) + "张牌交给" + get.translation(player), cards], num, true)
                                                    .set("ai", function (button) {
                                                        return get.value(button.link) * get.sgn(_status.event.att);
                                                    })
                                                    .set("att", get.attitude(target, player));
                                            }
                                            "step 1";
                                            if (result.bool) {
                                                game.delaye(0.5);
                                                target.give(result.links, player);
                                                lib.skill.old_sbqicai.updateCounter(player, target, result.links.length);
                                            }
                                            event.goto(0);
                                        },
                                    },
                                },
                            },
                            //谋公孙瓒
                            old_sbqiaomeng: {
                                audio: "sbqiaomeng",
                                trigger: {
                                    source: "damageSource",
                                },
                                filter(event, player) {
                                    if (!event.card || event.card.name !== "sha") return false;
                                    if (!player.hasSkill("sbyicong", null, false, false)) return false;
                                    if (player.countCharge(true)) return true;
                                    if (event.player.isIn() && event.player.countDiscardableCards(player, "hej")) return true;
                                    return false;
                                },
                                async cost(event, trigger, player) {
                                    const list = ["cancel2"];
                                    const choiceList = [`弃置${get.translation(trigger.player)}区域里的一张牌，你摸两张牌`, `获得4点蓄力值`];
                                    if (player.countCharge(true)) {
                                        list.unshift("蓄力");
                                    } else {
                                        choiceList[1] = `<span style="opacity:0.5">${choiceList[1]}</span>`;
                                    }
                                    if (trigger.player.isIn() && trigger.player.countDiscardableCards(player, "hej")) {
                                        list.unshift("弃牌");
                                    } else {
                                        choiceList[0] = `<span style="opacity:0.5">${choiceList[0]}</span>`;
                                    }
                                    const result = await player
                                        .chooseControl(list)
                                        .set("prompt", get.prompt("old_sbqiaomeng"))
                                        .set("choiceList", choiceList)
                                        .set("ai", () => {
                                            return get.event("choice");
                                        })
                                        .set(
                                            "choice",
                                            (() => {
                                                const eff = get.effect(trigger.player, { name: "guohe" }, player, player);
                                                if (list.length == 2) {
                                                    if (!list.includes("弃牌")) return "蓄力";
                                                    if (eff >= 0) return "弃牌";
                                                    return "cancel2";
                                                }
                                                if (player.countCharge() >= 2 && eff >= 0) return "弃牌";
                                                return "蓄力";
                                            })()
                                        )
                                        .forResult();
                                    if (result.control !== "cancel2") {
                                        event.result = {
                                            bool: true,
                                            cost_data: {
                                                control: result.control,
                                            },
                                        };
                                    }
                                },
                                async content(event, trigger, player) {
                                    const { control } = event.cost_data;
                                    if (control === "弃牌") {
                                        player.line(trigger.player);
                                        await player.discardPlayerCard(trigger.player, "hej", true);
                                        await player.draw(2);
                                    } else {
                                        player.addCharge(4);
                                    }
                                },
                                ai: {
                                    combo: "sbyicong",
                                },
                            },

                            //谋孙权
                            old_sbzhiheng: {
                                audio: "sbzhiheng",
                                locked: false,
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (num <= 0 || get.itemtype(card) !== "card" || get.type(card) !== "equip") return num;
                                        let eq = player.getEquip(get.subtype(card));
                                        if (eq && get.equipValue(card) - get.equipValue(eq) < Math.max(1.2, 6 - player.hp)) return 0;
                                    },
                                },
                                enable: "phaseUse",
                                usable: 1,
                                position: "he",
                                filterCard: lib.filter.cardDiscardable,
                                discard: false,
                                lose: false,
                                delay: false,
                                selectCard: [1, Infinity],
                                prompt(event) {
                                    var count = _status.event.player.countMark("old_sbtongye");
                                    var str = "出牌阶段限一次。你可以弃置任意张牌并摸等量的牌，若你以此法弃置的牌包括你所有手牌，则你多摸" + get.cnNumber(count + 1) + "张牌。";
                                    return str;
                                },
                                check(card) {
                                    var player = _status.event.player;
                                    if (
                                        get.position(card) == "h" &&
                                        !player.countCards("h", "du") &&
                                        (player.hp > 2 ||
                                            !player.countCards("h", function (card) {
                                                return get.value(card) >= 8;
                                            }))
                                    ) {
                                        return 1;
                                    }
                                    return 6 - get.value(card);
                                },
                                content() {
                                    "step 0";
                                    player.discard(cards);
                                    event.num = 1;
                                    var hs = player.getCards("h");
                                    if (!hs.length) event.num = 0;
                                    for (var i = 0; i < hs.length; i++) {
                                        if (!cards.includes(hs[i])) {
                                            event.num = 0;
                                            break;
                                        }
                                    }
                                    "step 1";
                                    var all = event.num;
                                    player.draw((all ? 1 + player.countMark("old_sbtongye") : 0) + cards.length);
                                },
                                ai: {
                                    order(item, player) {
                                        if (player.hasCard(i => get.value(i) > Math.max(6, 9 - player.hp), "he")) return 1;
                                        return 10;
                                    },
                                    result: {
                                        player: 1,
                                    },
                                    nokeep: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (tag === "nokeep") return (!arg || (arg && arg.card && get.name(arg.card) === "tao")) && player.isPhaseUsing() && !player.getStat().skill.old_sbzhiheng && player.hasCard(card => get.name(card) !== "tao", "h");
                                    },
                                    threaten: 1.56,
                                },
                            },
                            old_sbtongye: {
                                audio: "sbtongye",
                                trigger: { player: "phaseJieshuBegin" },
                                forced: true,
                                onremove: true,
                                content() {
                                    "step 0";
                                    player
                                        .chooseControl("变化", "不变")
                                        .set("prompt", "统业：猜测场上装备数是否于你下回合准备阶段前发生变化")
                                        .set("ai", () => {
                                            let player = _status.event.player;
                                            if (game.countPlayer() > 3) return "变化";
                                            if (
                                                game.countPlayer(function (current) {
                                                    return current.hasCard({ type: "equip" }, "e");
                                                }) < game.countPlayer()
                                            )
                                                return "变化";
                                            if (
                                                game.countPlayer() == 2 &&
                                                game.countPlayer(function (current) {
                                                    if (current != player) return current.countCards("e", { type: "equip" }) + current.countDisabledSlot();
                                                }) >= 5
                                            )
                                                return "不变";
                                            if (Math.random() < 0.3) return "变化";
                                            return "不变";
                                        });
                                    "step 1";
                                    if (result.control == "变化") {
                                        player.addSkill("old_sbtongye_change", 1);
                                        player.chat("变！");
                                    } else {
                                        player.addSkill("old_sbtongye_nochange", 1);
                                        player.chat("不变！");
                                    }
                                    var num = game
                                        .filterPlayer()
                                        .map(i => i.countCards("e"))
                                        .reduce((p, c) => p + c, 0);
                                    player.removeMark("old_sbtongye_count", player.countMark("old_sbtongye_count"), false);
                                    if (num > 0) player.addMark("old_sbtongye_count", num, false);
                                    player.addSkill("old_sbtongye_settle");
                                },
                                marktext: "业",
                                intro: {
                                    name: "统业",
                                    name2: "业",
                                    content: "mark",
                                },
                                ai: {
                                    combo: "sbzhiheng",
                                },
                                subSkill: {
                                    broadcast: {
                                        trigger: {
                                            global: ["loseAfter", "equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                        },
                                        charlotte: true,
                                        silent: true,
                                        filter(event, player) {
                                            var num = 0;
                                            game.countPlayer(function (current) {
                                                var evt = event.getl(current);
                                                if (evt && evt.es) num += evt.es.length;
                                            });
                                            if (event.name == "equip") num--;
                                            return num != 0;
                                        },
                                        content() {
                                            if (player.hasSkill("old_sbtongye_change")) player.markSkill("old_sbtongye_change");
                                            if (player.hasSkill("old_sbtongye_nochange")) player.markSkill("old_sbtongye_nochange");
                                        },
                                    },
                                    settle: {
                                        audio: "sbtongye",
                                        init(player) {
                                            player.addSkill("old_sbtongye_broadcast");
                                        },
                                        trigger: { player: "phaseZhunbeiBegin" },
                                        forced: true,
                                        charlotte: true,
                                        filter(event, player) {
                                            return player.hasSkill("old_sbtongye_change") || player.hasSkill("old_sbtongye_nochange");
                                        },
                                        content() {
                                            var delta =
                                                game
                                                    .filterPlayer()
                                                    .map(i => i.countCards("e"))
                                                    .reduce((p, c) => p + c, 0) - player.countMark("old_sbtongye_count");
                                            if ((player.hasSkill("old_sbtongye_change") && delta != 0) || (player.hasSkill("old_sbtongye_nochange") && delta == 0)) {
                                                game.log(player, "猜测", "#g正确");
                                                if (player.countMark("old_sbtongye") < 4) player.addMark("old_sbtongye", 1);
                                            } else {
                                                game.log(player, "猜测", "#y错误");
                                                player.removeMark("old_sbtongye", 1);
                                            }
                                            player.removeSkill("old_sbtongye_change");
                                            player.removeSkill("old_sbtongye_nochange");
                                            player.removeSkill("old_sbtongye_settle");
                                            player.removeSkill("old_sbtongye_broadcast");
                                        },
                                    },
                                    change: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "变",
                                        intro: {
                                            markcount(storage, player) {
                                                return (
                                                    game
                                                        .filterPlayer()
                                                        .map(i => i.countCards("e"))
                                                        .reduce((p, c) => p + c, 0) - player.countMark("old_sbtongye_count")
                                                );
                                            },
                                            mark(dialog, storage, player) {
                                                dialog.addText(get.translation(player) + "猜测场上装备数发生变化");
                                                var delta =
                                                    game
                                                        .filterPlayer()
                                                        .map(i => i.countCards("e"))
                                                        .reduce((p, c) => p + c, 0) - player.countMark("old_sbtongye_count");
                                                if (delta == 0) dialog.addText("(当前未发生变化)");
                                                else dialog.addText("(当前已" + (delta > 0 ? "增加" : "减少") + get.cnNumber(Math.abs(delta)) + "张装备牌)");
                                            },
                                        },
                                    },
                                    nochange: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: '<span style="text-decoration:line-through;">变</span>',
                                        intro: {
                                            markcount(storage, player) {
                                                return (
                                                    game
                                                        .filterPlayer()
                                                        .map(i => i.countCards("e"))
                                                        .reduce((p, c) => p + c, 0) - player.countMark("old_sbtongye_count")
                                                );
                                            },
                                            mark(dialog, storage, player) {
                                                dialog.addText(get.translation(player) + "猜测场上装备数不发生变化");
                                                var delta =
                                                    game
                                                        .filterPlayer()
                                                        .map(i => i.countCards("e"))
                                                        .reduce((p, c) => p + c, 0) - player.countMark("old_sbtongye_count");
                                                if (delta == 0) dialog.addText("(当前未发生变化)");
                                                else dialog.addText("(当前已" + (delta > 0 ? "增加" : "减少") + get.cnNumber(Math.abs(delta)) + "张装备牌)");
                                            },
                                        },
                                    },
                                },
                            },
                            //谋甘宁
                            old_sbqixi: {
                                init() {
                                    lib.card.guohe.storage = lib.card.guohe.content;
                                },
                                audio: "sbqixi",
                                enable: "chooseToUse",
                                filterCard(card) {
                                    return get.color(card) == "black";
                                },
                                position: "hes",
                                viewAs: { name: "guohe" },
                                viewAsFilter(player) {
                                    if (!player.countCards("hes", { color: "black" })) return false;
                                },
                                prompt: "将一张黑色牌当作【过河拆桥】使用",
                                check(card) {
                                    if (card.name == "guohe") return 0;
                                    return 6 - get.value(card);
                                },
                                group: "old_sbqixi_guohe",
                                contentx() {
                                    if (target.countCards("hej")) target.discard(target.getCards("hej"));
                                },
                                subSkill: {
                                    guohe: {
                                        audio: "sbqixi",
                                        trigger: { player: "useCard" },
                                        filter(event, player) {
                                            return event.card.name == "guohe" && event.card.isCard && event.cards.length == 1;
                                        },
                                        prompt2: "强化【过河拆桥】的效果",
                                        check(event, player) {
                                            var target = event.targets[0];
                                            return get.attitude(player, target) <= 0;
                                        },
                                        content() {
                                            player.addTempSkill("old_sbqixi_reguohe", "useCardAfter");
                                        },
                                    },
                                    reguohe: {
                                        charlotte: true,
                                        init() {
                                            lib.card.guohe.content = lib.skill.old_qixi.contentx;
                                        },
                                        onremove() {
                                            lib.card.guohe.content = lib.card.guohe.storage;
                                        },
                                    },
                                },
                            },
                            old_sbfenwei: {
                                unique: true,
                                mark: true,
                                limited: true,
                                audio: "sbfenwei",
                                trigger: { global: "useCardToPlayered" },
                                filter(event, player) {
                                    if (event.getParent().triggeredTargets3.length > 1) return false;
                                    if (get.type(event.card) != "trick") return false;
                                    if (get.info(event.card).multitarget) return false;
                                    if (event.targets.length < 2) return false;
                                    return true;
                                },
                                direct: true,
                                skillAnimation: true,
                                animationColor: "wood",
                                content() {
                                    "step 0";
                                    player
                                        .chooseTarget(get.prompt("old_sbfenwei"), "令" + get.translation(trigger.card) + "对任意名角色无效", [1, trigger.targets.length], function (card, player, target) {
                                            return _status.event.targets.includes(target);
                                        })
                                        .set("ai", function (target) {
                                            var trigger = _status.event.getTrigger();
                                            return -get.effect(target, trigger.card, trigger.player, _status.event.player);
                                        })
                                        .set("targets", trigger.targets);
                                    "step 1";
                                    if (result.bool) {
                                        player.logSkill("old_sbfenwei", result.targets);
                                        player.awakenSkill("old_sbfenwei");
                                        trigger.getParent().excluded.addArray(result.targets);
                                        event.num = Math.min(4, result.targets.length);
                                    } else event.finish();
                                    "step 2";
                                    var cards = [];
                                    for (var i = 0; i < num; i++) {
                                        var card = get.cardPile2(function (card) {
                                            return !cards.includes(card) && card.name == "guohe";
                                        });
                                        if (card) cards.push(card);
                                        else break;
                                    }
                                    if (cards.length) player.gain(cards, "gain2");
                                },
                            },
                            //谋小乔
                            old_sbtianxiang: {
                                audio: "sbtianxiang",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return player.countCards("he", card => lib.skill.old_sbtianxiang.filterCard(card, player)) && game.hasPlayer(target => lib.skill.old_sbtianxiang.filterTarget(null, player, target));
                                },
                                filterCard(card, player) {
                                    return get.color(card, player) == "red";
                                },
                                filterTarget(card, player, target) {
                                    return target != player && !target.getSkills().some(skill => skill.indexOf("old_sbtianxiang_") == 0);
                                },
                                discard: false,
                                lose: false,
                                delay: 0,
                                usable: 3,
                                prompt: "将一张红色牌交给一名角色并令其获得此花色的“天香”标记",
                                content() {
                                    player.give(cards, target);
                                    var suit = get.suit(cards[0], player);
                                    target.addSkill("old_sbtianxiang_" + suit);
                                },
                                ai: {
                                    order: 5,
                                    result: { target: -1 },
                                },
                                group: ["old_sbtianxiang_draw", "old_sbtianxiang_effect"],
                                subSkill: {
                                    heart: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "♥︎",
                                        intro: { content: "伤害转移术" },
                                    },
                                    diamond: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "♦︎",
                                        intro: { content: "掳掠大法" },
                                    },
                                    draw: {
                                        audio: "sbtianxiang",
                                        trigger: { player: "phaseZhunbeiBegin" },
                                        filter(event, player) {
                                            return game.hasPlayer(target => target.getSkills().some(skill => skill.indexOf("old_sbtianxiang_") == 0));
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            var num = 0;
                                            game.countPlayer(target => {
                                                var skills = target.getSkills().filter(skill => skill.indexOf("old_sbtianxiang_") == 0);
                                                target.removeSkill(skills);
                                                num += skills.length;
                                            });
                                            num += 3;
                                            player.draw(num);
                                        },
                                    },
                                    effect: {
                                        trigger: { player: "damageBegin3" },
                                        filter(event, player) {
                                            return game.hasPlayer(target => target.getSkills().some(skill => skill.indexOf("old_sbtianxiang_") == 0));
                                        },
                                        direct: true,
                                        content() {
                                            "step 0";
                                            player
                                                .chooseTarget(get.prompt("old_sbtianxiang"), "移去一名角色的“天香”标记并执行相应效果", function (card, player, target) {
                                                    return target.getSkills().some(skill => skill.indexOf("old_sbtianxiang_") == 0);
                                                })
                                                .set("ai", target => {
                                                    var player = _status.event.player;
                                                    return -get.attitude(player, target) * target.getSkills().filter(skill => skill.indexOf("old_sbtianxiang_") == 0).length;
                                                });
                                            "step 1";
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                event.target = target;
                                                player.logSkill("old_sbtianxiang", target);
                                                var skills = target.getSkills().filter(skill => skill.indexOf("old_sbtianxiang_") == 0);
                                                target.removeSkill(skills);
                                                if (skills.includes("old_sbtianxiang_heart")) {
                                                    target.damage(trigger.source ? trigger.source : "nosource");
                                                    trigger.cancel();
                                                }
                                                if (skills.includes("old_sbtianxiang_diamond")) {
                                                    var cards = target.getCards("he");
                                                    if (!cards.length) event.finish();
                                                    else if (cards.length <= 2) event._result = { bool: true, cards: cards };
                                                    else target.chooseCard("he", 2, "天香：交给" + get.translation(player) + "两张牌", true);
                                                } else event.finish();
                                            } else event.finish();
                                            "step 2";
                                            if (result.bool) player.gain(result.cards, target, "giveAuto");
                                        },
                                    },
                                },
                            },
                            //谋大乔
                            old_sbguose: {
                                audio: "sbguose",
                                enable: "phaseUse",
                                usable: 4,
                                discard: false,
                                lose: false,
                                delay: false,
                                filter(event, player) {
                                    return player.hasCard(card => get.suit(card) == "diamond", "hes") || game.hasPlayer(current => current.hasJudge("lebu"));
                                },
                                position: "hes",
                                filterCard(card, player) {
                                    if (get.suit(card) != "diamond") return false;
                                    var mod = game.checkMod(ui.selected.cards[0], player, "unchanged", "cardEnabled2", player);
                                    if (!mod) return false;
                                    return true;
                                },
                                selectCard: [0, 1],
                                filterTarget(card, player, target) {
                                    if (!ui.selected.cards.length) {
                                        if (target.hasJudge("lebu")) return true;
                                        return false;
                                    }
                                    if (player == target) return false;
                                    return player.canUse(get.autoViewAs({ name: "lebu" }, ui.selected.cards), target);
                                },
                                complexSelect: true,
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                content() {
                                    "step 0";
                                    if (target.hasJudge("lebu")) {
                                        target.discard(target.getJudge("lebu"));
                                    } else {
                                        player.useCard({ name: "lebu" }, target, cards).audio = false;
                                    }
                                    "step 1";
                                    player.draw(2);
                                    player.chooseToDiscard("h", true);
                                },
                                ai: {
                                    result: {
                                        target(player, target) {
                                            if (target.hasJudge("lebu")) return -get.effect(target, { name: "lebu" }, player, target);
                                            return get.effect(target, { name: "lebu" }, player, target);
                                        },
                                    },
                                    order: 9,
                                },
                            },
                            //谋孙策
                            old_sbhunzi: {
                                audio: "sbhunzi",
                                trigger: { player: "dyingAfter" },
                                juexingji: true,
                                forced: true,
                                skillAnimation: true,
                                animationColor: "wood",
                                derivation: ["sbyingzi", "gzyinghun"],
                                content() {
                                    "step 0";
                                    player.awakenSkill("old_sbhunzi");
                                    player.loseMaxHp();
                                    "step 1";
                                    player.changeHujia(2, null, true);
                                    "step 2";
                                    player.draw(3);
                                    "step 3";
                                    player.addSkills(["sbyingzi", "gzyinghun"]);
                                },
                                ai: {
                                    threaten(player, target) {
                                        if (target.hp == 1) return 2;
                                        return 0.5;
                                    },
                                    maixie: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (!target.hasFriend() || target.hp > 1) return;
                                            if (get.tag(card, "damage") == 1 && ((target.hasZhuSkill("sbzhiba") && game.countPlayer(current => current != target && current.group == "wu")) || player.countCards("hs", card => player.canSaveCard(card, target)) + target.countCards("hs", card => target.canSaveCard(card, target)) > 0) && !target.isTurnedOver() && _status.currentPhase != target && get.distance(_status.currentPhase, target, "absolute") <= 3) return [0.5, 1];
                                        },
                                    },
                                },
                            },
                            //初版谋诸葛亮
                            old_sbhuoji: {
                                audio: "sbhuoji",
                                dutySkill: true,
                                derivation: ["old_sbguanxing", "old_sbkongcheng"],
                                group: ["old_sbhuoji_fire", "old_sbhuoji_achieve", "old_sbhuoji_fail", "old_sbhuoji_mark"],
                                subSkill: {
                                    fire: {
                                        audio: "sbhuoji1",
                                        enable: "phaseUse",
                                        filterTarget: lib.filter.notMe,
                                        prompt: "选择一名其他角色，对其与其势力相同的所有其他角色各造成1点火属性伤害",
                                        usable: 1,
                                        line: "fire",
                                        content() {
                                            "step 0";
                                            target.damage("fire");
                                            "step 1";
                                            var targets = game.filterPlayer(current => {
                                                if (current == player || current == target) return false;
                                                return current.group == target.group;
                                            });
                                            if (targets.length) {
                                                game.delayx();
                                                player.line(targets, "fire");
                                                targets.forEach(i => i.damage("fire"));
                                            }
                                        },
                                        ai: {
                                            order: 7,
                                            fireAttack: true,
                                            result: {
                                                target(player, target) {
                                                    var att = get.attitude(player, target);
                                                    return (
                                                        get.sgn(att) *
                                                        game
                                                            .filterPlayer(current => {
                                                                if (current == player) return false;
                                                                return current.group == target.group;
                                                            })
                                                            .reduce((num, current) => num + get.damageEffect(current, player, player, "fire"), 0)
                                                    );
                                                },
                                            },
                                        },
                                    },
                                    achieve: {
                                        audio: "sbhuoji2",
                                        trigger: { player: "phaseZhunbeiBegin" },
                                        filter(event, player) {
                                            return player.getAllHistory("sourceDamage", evt => evt.hasNature("fire") && evt.player != player).reduce((num, evt) => num + evt.num, 0) >= game.players.length + game.dead.length;
                                        },
                                        forced: true,
                                        locked: false,
                                        skillAnimation: true,
                                        animationColor: "fire",
                                        async content(event, trigger, player) {
                                            player.awakenSkill("old_sbhuoji");
                                            game.log(player, "成功完成使命");
                                            if (get.character(player.name1)[3].includes("old_sbhuoji")) {
                                                player.reinitCharacter(player.name1, "old_sb_zhugeliang", false);
                                            } else if (player.name2 && get.character(player.name2)[3].includes("old_sbhuoji")) {
                                                player.reinitCharacter(player.name2, "old_sb_zhugeliang", false);
                                            } else {
                                                player.changeSKills(["old_sbguanxing", "old_sbkongcheng"], ["old_sbhuoji", "old_sbkanpo"]);
                                            }
                                        },
                                    },
                                    fail: {
                                        audio: "sbhuoji3",
                                        trigger: { player: "dying" },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.awakenSkill("old_sbhuoji");
                                            game.log(player, "使命失败");
                                        },
                                    },
                                    mark: {
                                        charlotte: true,
                                        trigger: { source: "damage" },
                                        filter(event, player) {
                                            return event.hasNature("fire");
                                        },
                                        firstDo: true,
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.addTempSkill("old_sbhuoji_count", { player: ["old_sbhuoji_achieveBegin", "old_sbhuoji_failBegin"] });
                                            player.storage.old_sbhuoji_count = player.getAllHistory("sourceDamage", evt => evt.hasNature("fire") && evt.player != player).reduce((num, evt) => num + evt.num, 0);
                                            player.markSkill("old_sbhuoji_count");
                                        },
                                    },
                                    count: {
                                        charlotte: true,
                                        intro: { content: "本局游戏已造成过#点火属性伤害" },
                                    },
                                },
                            },
                            old_sbkanpo: {
                                audio: "sbkanpo",
                                trigger: { global: "roundStart" },
                                forced: true,
                                locked: false,
                                get getNumber() {
                                    return 3;
                                },
                                *content(event, map) {
                                    var player = map.player;
                                    var storage = player.getStorage("old_sbkanpo").slice();
                                    if (storage.length) {
                                        player.unmarkAuto("old_sbkanpo", storage);
                                    }
                                    const list = get.inpileVCardList(info => {
                                        if (info[2] == "sha" && info[3]) return false;
                                        return info[0] != "equip";
                                    });
                                    const func = () => {
                                        const event = get.event();
                                        const controls = [
                                            link => {
                                                const evt = get.event();
                                                if (evt.dialog && evt.dialog.buttons) {
                                                    for (let i = 0; i < evt.dialog.buttons.length; i++) {
                                                        const button = evt.dialog.buttons[i];
                                                        button.classList.remove("selectable");
                                                        button.classList.remove("selected");
                                                        const counterNode = button.querySelector(".caption");
                                                        if (counterNode) {
                                                            counterNode.childNodes[0].innerHTML = ``;
                                                        }
                                                    }
                                                    ui.selected.buttons.length = 0;
                                                    game.check();
                                                }
                                                return;
                                            },
                                        ];
                                        event.controls = ["清除选择", "cancel2"].map(control => {
                                            return ui.create.control(controls.concat(control == "清除选择" ? [control, "stayleft"] : control));
                                        });
                                    };
                                    if (event.isMine()) func();
                                    else if (event.isOnline()) event.player.send(func);
                                    var result = yield player
                                        .chooseButton(["看破：是否记录三个牌名？", [list, "vcard"]], [1, 3], true)
                                        .set("ai", function (button) {
                                            switch (button.link[2]) {
                                                case "wuxie":
                                                    return 5 + Math.random();
                                                case "sha":
                                                    return 5 + Math.random();
                                                case "tao":
                                                    return 4 + Math.random();
                                                case "jiu":
                                                    return 3 + Math.random();
                                                case "lebu":
                                                    return 3 + Math.random();
                                                case "shan":
                                                    return 4.5 + Math.random();
                                                case "wuzhong":
                                                    return 4 + Math.random();
                                                case "shunshou":
                                                    return 2.7 + Math.random();
                                                case "nanman":
                                                    return 2 + Math.random();
                                                case "wanjian":
                                                    return 1.6 + Math.random();
                                                default:
                                                    return 1.5 + Math.random();
                                            }
                                        })
                                        .set("filterButton", button => {
                                            return !_status.event.names.includes(button.link[2]);
                                        })
                                        .set("names", storage)
                                        .set("custom", {
                                            add: {
                                                confirm(bool) {
                                                    if (bool != true) return;
                                                    const event = get.event().parent;
                                                    if (event.controls) event.controls.forEach(i => i.close());
                                                    if (ui.confirm) ui.confirm.close();
                                                    game.uncheck();
                                                },
                                                button() {
                                                    if (ui.selected.buttons.length) return;
                                                    const event = get.event();
                                                    if (event.dialog && event.dialog.buttons) {
                                                        for (let i = 0; i < event.dialog.buttons.length; i++) {
                                                            const button = event.dialog.buttons[i];
                                                            const counterNode = button.querySelector(".caption");
                                                            if (counterNode) {
                                                                counterNode.childNodes[0].innerHTML = ``;
                                                            }
                                                        }
                                                    }
                                                    if (!ui.selected.buttons.length) {
                                                        const evt = event.parent;
                                                        if (evt.controls) evt.controls[0].classList.add("disabled");
                                                    }
                                                },
                                            },
                                            replace: {
                                                button(button) {
                                                    const event = get.event();
                                                    if (!event.isMine()) return;
                                                    if (button.classList.contains("selectable") == false) return;
                                                    if (ui.selected.buttons.length >= lib.skill.old_sbkanpo.getNumber) return false;
                                                    button.classList.add("selected");
                                                    ui.selected.buttons.push(button);
                                                    let counterNode = button.querySelector(".caption");
                                                    const count = ui.selected.buttons.filter(i => i == button).length;
                                                    if (counterNode) {
                                                        counterNode = counterNode.childNodes[0];
                                                        counterNode.innerHTML = `×${count}`;
                                                    } else {
                                                        counterNode = ui.create.caption(`<span style="font-size:24px; font-family:xinwei; text-shadow:#FFF 0 0 4px, #FFF 0 0 4px, rgba(74,29,1,1) 0 0 3px;">×${count}</span>`, button);
                                                        counterNode.style.right = "5px";
                                                        counterNode.style.bottom = "2px";
                                                    }
                                                    const evt = event.parent;
                                                    if (evt.controls) evt.controls[0].classList.remove("disabled");
                                                    game.check();
                                                },
                                            },
                                        });
                                    if (result.bool) {
                                        var names = result.links.map(link => link[2]);
                                        player.setStorage("old_sbkanpo", names);
                                        player.markSkill("old_sbkanpo");
                                    }
                                },
                                marktext: "破",
                                intro: {
                                    markcount(storage, player) {
                                        if (player.isUnderControl(true)) return storage.length;
                                        return "?";
                                    },
                                    mark(dialog, content, player) {
                                        if (player.isUnderControl(true)) {
                                            const storage = player.getStorage("old_sbkanpo");
                                            dialog.addText("当前记录牌名：");
                                            dialog.addSmall([storage, "vcard"]);
                                        } else {
                                            return `${get.translation(player)}记录了一些牌名`;
                                        }
                                    },
                                },
                                group: "old_sbkanpo_kanpo",
                                subSkill: {
                                    kanpo: {
                                        audio: "sbkanpo",
                                        trigger: { global: "useCard" },
                                        filter(event, player) {
                                            return event.player != player && player.getStorage("old_sbkanpo").includes(event.card.name);
                                        },
                                        prompt2(event, player) {
                                            return "移除" + get.translation(event.card.name) + "的记录，令" + get.translation(event.card) + "无效";
                                        },
                                        check(event, player) {
                                            var effect = 0;
                                            if (event.card.name == "wuxie" || event.card.name == "shan") {
                                                if (get.attitude(player, event.player) < -1) effect = -1;
                                            } else if (event.targets && event.targets.length) {
                                                for (var i = 0; i < event.targets.length; i++) {
                                                    effect += get.effect(event.targets[i], event.card, event.player, player);
                                                }
                                            }
                                            if (effect < 0) {
                                                if (event.card.name == "sha") {
                                                    var target = event.targets[0];
                                                    if (target == player) return !player.countCards("h", "shan");
                                                    else return target.hp == 1 || (target.countCards("h") <= 2 && target.hp <= 2);
                                                } else return true;
                                            }
                                            return false;
                                        },
                                        logTarget: "player",
                                        content() {
                                            player.unmarkAuto("old_sbkanpo", [trigger.card.name]);
                                            trigger.targets.length = 0;
                                            trigger.all_excluded = true;
                                        },
                                    },
                                },
                            },
                            old_sbguanxing: {
                                audio: "sbguanxing",
                                trigger: { player: ["phaseZhunbeiBegin", "phaseJieshuBegin"] },
                                filter(event, player) {
                                    return event.name == "phaseZhunbei" || (player.hasSkill("old_sbguanxing_on") && player.countCards("s", card => card.hasGaintag("old_sbguanxing")));
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    "step 0";
                                    if (trigger.name == "phaseJieshu") {
                                        event.goto(2);
                                        return;
                                    }
                                    var cards = player.getCards("s", card => card.hasGaintag("old_sbguanxing"));
                                    if (cards.length) player.loseToDiscardpile(cards);
                                    var bool = player.getAllHistory("useSkill", evt => evt.skill == "old_sbguanxing").length > 1;
                                    event.num = Math.min(7, bool ? cards.length + 1 : 7);
                                    "step 1";
                                    var cards2 = get.cards(num);
                                    player.$gain2(cards2, false);
                                    game.log(player, "将", cards2, "置于了武将牌上");
                                    player.loseToSpecial(cards2, "old_sbguanxing").visible = true;
                                    player.markSkill("old_sbguanxing");
                                    "step 2";
                                    var cards = player.getCards("s", card => card.hasGaintag("old_sbguanxing"));
                                    if (cards.length) {
                                        player
                                            .chooseToMove()
                                            .set("list", [["你的“星”", cards], ["牌堆顶"]])
                                            .set("prompt", "观星：点击将牌移动到牌堆顶")
                                            .set("processAI", function (list) {
                                                var cards = list[0][1].slice(),
                                                    player = _status.event.player;
                                                var name = _status.event.getTrigger().name;
                                                var target = name == "phaseZhunbei" ? player : player.getNext();
                                                var judges = target.getCards("j");
                                                var top = [],
                                                    att = get.sgn(get.attitude(player, target));
                                                if (judges.length && att != 0 && (target != player || !player.hasWuxie())) {
                                                    for (var i = 0; i < judges.length; i++) {
                                                        var judge = (card, num) => get.judge(card) * num;
                                                        cards.sort((a, b) => judge(b, att) - judge(a, att));
                                                        if (judge(cards[0], att) < 0) break;
                                                        else top.unshift(cards.shift());
                                                    }
                                                }
                                                return [cards, top];
                                            })
                                            .set("filterOk", function (moved) {
                                                return moved[1].length;
                                            });
                                    } else event._result = { bool: false };
                                    "step 3";
                                    if (result.bool) {
                                        var cards = result.moved[1];
                                        player.loseToDiscardpile(cards, ui.cardPile, "insert").log = false;
                                        game.log(player, "将", cards, "置于了牌堆顶");
                                    } else if (trigger.name == "phaseZhunbei") player.addTempSkill("old_sbguanxing_on");
                                },
                                group: "old_sbguanxing_unmark",
                                subSkill: {
                                    on: { charlotte: true },
                                    unmark: {
                                        trigger: { player: "loseAfter" },
                                        filter(event, player) {
                                            if (!event.ss || !event.ss.length) return false;
                                            return !player.countCards("s", card => card.hasGaintag("old_sbguanxing"));
                                        },
                                        charlotte: true,
                                        forced: true,
                                        silent: true,
                                        content() {
                                            player.unmarkSkill("old_sbguanxing");
                                        },
                                    },
                                },
                                marktext: "星",
                                intro: {
                                    mark(dialog, storage, player) {
                                        var cards = player.getCards("s", card => card.hasGaintag("old_sbguanxing"));
                                        if (!cards || !cards.length) return;
                                        dialog.addAuto(cards);
                                    },
                                    markcount(storage, player) {
                                        return player.countCards("s", card => card.hasGaintag("old_sbguanxing"));
                                    },
                                    onunmark(storage, player) {
                                        var cards = player.getCards("s", card => card.hasGaintag("old_sbguanxing"));
                                        if (cards.length) player.loseToDiscardpile(cards);
                                    },
                                },
                                mod: {
                                    aiOrder(player, card, num) {
                                        var cards = player.getCards("s", card => card.hasGaintag("old_sbguanxing"));
                                        if (get.itemtype(card) == "card" && card.hasGaintag("old_sbguanxing")) return num + (cards.length > 1 ? 0.5 : -0.0001);
                                    },
                                },
                            },
                            old_sbkongcheng: {
                                audio: "sbkongcheng",
                                trigger: { player: ["damageBegin3", "damageBegin4"] },
                                filter(event, player, name) {
                                    if (!player.hasSkill("old_sbguanxing")) return false;
                                    const num = player.countCards("s", card => card.hasGaintag("old_sbguanxing"));
                                    if (name == "damageBegin3" && !num) return true;
                                    if (name == "damageBegin4" && num) return true;
                                    return false;
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    var num = player.countCards("s", card => card.hasGaintag("old_sbguanxing"));
                                    if (!num && event.triggername == "damageBegin3") {
                                        trigger.increase("num");
                                    } else if (num && event.triggername == "damageBegin4") {
                                        player
                                            .judge(function (result) {
                                                if (get.number(result) <= get.player().countCards("s", card => card.hasGaintag("old_sbguanxing"))) return 2;
                                                return -1;
                                            })
                                            .set("judge2", result => result.bool)
                                            .set("callback", function () {
                                                if (event.judgeResult.number <= player.countCards("s", card => card.hasGaintag("old_sbguanxing"))) {
                                                    event.getParent("old_sbkongcheng").getTrigger().decrease("num");
                                                }
                                            });
                                    }
                                },
                            },
                            //二版谋诸葛亮
                            oldx_sbhuoji: {
                                audio: "sbhuoji",
                                dutySkill: true,
                                derivation: ["oldx_sbguanxing", "oldx_sbkongcheng"],
                                group: ["oldx_sbhuoji_fire", "oldx_sbhuoji_achieve", "oldx_sbhuoji_fail", "oldx_sbhuoji_mark"],
                                subSkill: {
                                    fire: {
                                        audio: "sbhuoji1",
                                        enable: "phaseUse",
                                        filterTarget: lib.filter.notMe,
                                        prompt: "选择一名其他角色，对其与其势力相同的所有其他角色各造成1点火属性伤害",
                                        usable: 1,
                                        line: "fire",
                                        content() {
                                            "step 0";
                                            target.damage("fire");
                                            "step 1";
                                            var targets = game.filterPlayer(current => {
                                                if (current == player || current == target) return false;
                                                return current.group == target.group;
                                            });
                                            if (targets.length) {
                                                game.delayx();
                                                player.line(targets, "fire");
                                                targets.forEach(i => i.damage("fire"));
                                            }
                                        },
                                        ai: {
                                            order: 7,
                                            fireAttack: true,
                                            result: {
                                                target(player, target) {
                                                    var att = get.attitude(player, target);
                                                    return (
                                                        get.sgn(att) *
                                                        game
                                                            .filterPlayer(current => {
                                                                if (current == player) return false;
                                                                return current.group == target.group;
                                                            })
                                                            .reduce((num, current) => num + get.damageEffect(current, player, player, "fire"), 0)
                                                    );
                                                },
                                            },
                                        },
                                    },
                                    achieve: {
                                        audio: "sbhuoji2",
                                        trigger: { player: "phaseZhunbeiBegin" },
                                        filter(event, player) {
                                            return player.getAllHistory("sourceDamage", evt => evt.hasNature("fire") && evt.player != player).reduce((num, evt) => num + evt.num, 0) >= game.players.length + game.dead.length;
                                        },
                                        forced: true,
                                        locked: false,
                                        skillAnimation: true,
                                        animationColor: "fire",
                                        async content(event, trigger, player) {
                                            player.awakenSkill("oldx_sbhuoji");
                                            game.log(player, "成功完成使命");
                                            player.changeSkin("oldx_sbhuoji", "oldx_sb_zhugeliang");
                                            player.changeSkills(["oldx_sbguanxing", "oldx_sbkongcheng"], ["oldx_sbhuoji", "oldx_sbkanpo"]);
                                        },
                                    },
                                    fail: {
                                        audio: "sbhuoji3",
                                        trigger: { player: "dying" },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.awakenSkill("oldx_sbhuoji");
                                            game.log(player, "使命失败");
                                        },
                                    },
                                    mark: {
                                        charlotte: true,
                                        trigger: { source: "damage" },
                                        filter(event, player) {
                                            return event.hasNature("fire");
                                        },
                                        firstDo: true,
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.addTempSkill("oldx_sbhuoji_count", { player: ["oldx_sbhuoji_achieveBegin", "oldx_sbhuoji_failBegin"] });
                                            player.storage.oldx_sbhuoji_count = player.getAllHistory("sourceDamage", evt => evt.hasNature("fire") && evt.player != player).reduce((num, evt) => num + evt.num, 0);
                                            player.markSkill("oldx_sbhuoji_count");
                                        },
                                    },
                                    count: {
                                        charlotte: true,
                                        intro: { content: "本局游戏已造成过#点火属性伤害" },
                                    },
                                },
                            },
                            oldx_sbhuoji1: { audio: true },
                            oldx_sbhuoji2: { audio: true },
                            oldx_sbhuoji3: { audio: true },
                            oldx_sbkanpo: {
                                init(player) {
                                    if (!player.storage.oldx_sbkanpo) {
                                        player.storage.oldx_sbkanpo = [10, [], []];
                                        player.markSkill("oldx_sbkanpo");
                                    }
                                },
                                audio: "sbkanpo",
                                trigger: { global: "roundStart" },
                                filter(event, player) {
                                    var storage = player.storage.oldx_sbkanpo;
                                    return storage[0] || storage[1].length;
                                },
                                forced: true,
                                locked: false,
                                *content(event, map) {
                                    var player = map.player,
                                        storage = player.storage.oldx_sbkanpo;
                                    var sum = storage[0];
                                    storage[1] = [];
                                    player.markSkill("oldx_sbkanpo");
                                    if (!sum) return;
                                    const list = get.inpileVCardList(info => {
                                        if (info[2] == "sha" && info[3]) return false;
                                        return info[0] != "equip";
                                    });
                                    const func = () => {
                                        const event = get.event();
                                        const controls = [
                                            link => {
                                                const evt = get.event();
                                                if (evt.dialog && evt.dialog.buttons) {
                                                    for (let i = 0; i < evt.dialog.buttons.length; i++) {
                                                        const button = evt.dialog.buttons[i];
                                                        button.classList.remove("selectable");
                                                        button.classList.remove("selected");
                                                        const counterNode = button.querySelector(".caption");
                                                        if (counterNode) {
                                                            counterNode.childNodes[0].innerHTML = ``;
                                                        }
                                                    }
                                                    ui.selected.buttons.length = 0;
                                                    game.check();
                                                }
                                                return;
                                            },
                                        ];
                                        event.controls = [ui.create.control(controls.concat(["清除选择", "stayleft"]))];
                                    };
                                    if (event.isMine()) func();
                                    else if (event.isOnline()) event.player.send(func);
                                    var result = yield player
                                        .chooseButton(["看破：是否记录至多" + get.cnNumber(sum) + "个牌名？", [list, "vcard"]], [1, sum], false)
                                        .set("ai", function (button) {
                                            if (ui.selected.buttons.length >= Math.max(3, game.countPlayer() / 2)) return 0;
                                            switch (button.link[2]) {
                                                case "wuxie":
                                                    return 5 + Math.random();
                                                case "sha":
                                                    return 5 + Math.random();
                                                case "tao":
                                                    return 4 + Math.random();
                                                case "jiu":
                                                    return 3 + Math.random();
                                                case "lebu":
                                                    return 3 + Math.random();
                                                case "shan":
                                                    return 4.5 + Math.random();
                                                case "wuzhong":
                                                    return 4 + Math.random();
                                                case "shunshou":
                                                    return 2.7 + Math.random();
                                                case "nanman":
                                                    return 2 + Math.random();
                                                case "wanjian":
                                                    return 1.6 + Math.random();
                                                default:
                                                    return 1.5 + Math.random();
                                            }
                                        })
                                        .set("filterButton", button => {
                                            return !_status.event.names.includes(button.link[2]);
                                        })
                                        .set("names", storage[2])
                                        .set("custom", {
                                            add: {
                                                confirm(bool) {
                                                    if (bool != true) return;
                                                    const event = get.event().parent;
                                                    if (event.controls) event.controls.forEach(i => i.close());
                                                    if (ui.confirm) ui.confirm.close();
                                                    game.uncheck();
                                                },
                                                button() {
                                                    if (ui.selected.buttons.length) return;
                                                    const event = get.event();
                                                    if (event.dialog && event.dialog.buttons) {
                                                        for (let i = 0; i < event.dialog.buttons.length; i++) {
                                                            const button = event.dialog.buttons[i];
                                                            const counterNode = button.querySelector(".caption");
                                                            if (counterNode) {
                                                                counterNode.childNodes[0].innerHTML = ``;
                                                            }
                                                        }
                                                    }
                                                    if (!ui.selected.buttons.length) {
                                                        const evt = event.parent;
                                                        if (evt.controls) evt.controls[0].classList.add("disabled");
                                                    }
                                                },
                                            },
                                            replace: {
                                                button(button) {
                                                    const event = get.event(),
                                                        sum = event.sum;
                                                    if (!event.isMine()) return;
                                                    if (button.classList.contains("selectable") == false) return;
                                                    if (ui.selected.buttons.length >= sum) return false;
                                                    button.classList.add("selected");
                                                    ui.selected.buttons.push(button);
                                                    let counterNode = button.querySelector(".caption");
                                                    const count = ui.selected.buttons.filter(i => i == button).length;
                                                    if (counterNode) {
                                                        counterNode = counterNode.childNodes[0];
                                                        counterNode.innerHTML = `×${count}`;
                                                    } else {
                                                        counterNode = ui.create.caption(`<span style="font-size:24px; font-family:xinwei; text-shadow:#FFF 0 0 4px, #FFF 0 0 4px, rgba(74,29,1,1) 0 0 3px;">×${count}</span>`, button);
                                                        counterNode.style.right = "5px";
                                                        counterNode.style.bottom = "2px";
                                                    }
                                                    const evt = event.parent;
                                                    if (evt.controls) evt.controls[0].classList.remove("disabled");
                                                    game.check();
                                                },
                                            },
                                        })
                                        .set("sum", sum);
                                    if (result.bool) {
                                        var names = result.links.map(link => link[2]);
                                        storage[0] -= names.length;
                                        storage[1] = names;
                                        storage[2] = names;
                                    } else storage[2] = [];
                                    player.markSkill("oldx_sbkanpo");
                                },
                                marktext: "破",
                                intro: {
                                    markcount(storage) {
                                        return storage[1].length;
                                    },
                                    mark(dialog, content, player) {
                                        const storage = player.getStorage("oldx_sbkanpo");
                                        const sum = storage[0];
                                        const names = storage[1];
                                        dialog.addText("剩余可记录" + sum + "次牌名");
                                        if (player.isUnderControl(true) && names.length) {
                                            dialog.addText("当前记录牌名：");
                                            dialog.addSmall([names, "vcard"]);
                                        }
                                    },
                                },
                                group: "oldx_sbkanpo_kanpo",
                                subSkill: {
                                    kanpo: {
                                        audio: "sbkanpo",
                                        trigger: { global: "useCard" },
                                        filter(event, player) {
                                            return event.player != player && player.storage.oldx_sbkanpo[1].includes(event.card.name);
                                        },
                                        prompt2(event, player) {
                                            return "移除" + get.translation(event.card.name) + "的记录，令" + get.translation(event.card) + "无效";
                                        },
                                        check(event, player) {
                                            var effect = 0;
                                            if (event.card.name == "wuxie" || event.card.name == "shan") {
                                                if (get.attitude(player, event.player) < -1) effect = -1;
                                            } else if (event.targets && event.targets.length) {
                                                for (var i = 0; i < event.targets.length; i++) {
                                                    effect += get.effect(event.targets[i], event.card, event.player, player);
                                                }
                                            }
                                            if (effect < 0) {
                                                if (event.card.name == "sha") {
                                                    var target = event.targets[0];
                                                    if (target == player) return !player.countCards("h", "shan");
                                                    else return target.hp == 1 || (target.countCards("h") <= 2 && target.hp <= 2);
                                                } else return true;
                                            }
                                            return false;
                                        },
                                        logTarget: "player",
                                        content() {
                                            player.storage.oldx_sbkanpo[1].remove(trigger.card.name);
                                            player.markSkill("oldx_sbkanpo");
                                            trigger.targets.length = 0;
                                            trigger.all_excluded = true;
                                            player.draw();
                                        },
                                    },
                                },
                            },
                            oldx_sbguanxing: {
                                audio: "sbguanxing",
                                trigger: { player: ["phaseZhunbeiBegin", "phaseJieshuBegin"] },
                                filter(event, player) {
                                    var bool = player.hasCard(card => card.hasGaintag("oldx_sbguanxing"), "s");
                                    if (event.name == "phaseZhunbei") {
                                        return bool || 7 - lib.skill.oldx_sbguanxing.getNum * player.countMark("oldx_sbguanxingx") > 0;
                                    }
                                    return bool && player.hasSkill("oldx_sbguanxing_on");
                                },
                                forced: true,
                                locked: false,
                                content() {
                                    "step 0";
                                    if (trigger.name == "phaseJieshu") {
                                        event.goto(2);
                                        return;
                                    }
                                    player.addMark("oldx_sbguanxingx", 1, false);
                                    var cards = player.getCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                    if (cards.length) player.loseToDiscardpile(cards);
                                    var num = player.countMark("oldx_sbguanxingx") - 1;
                                    event.num = Math.max(0, 7 - lib.skill.oldx_sbguanxing.getNum * num);
                                    "step 1";
                                    if (num) {
                                        var cards2 = get.cards(num);
                                        player.$gain2(cards2, false);
                                        game.log(player, "将", cards2, "置于了武将牌上");
                                        player.loseToSpecial(cards2, "oldx_sbguanxing").visible = true;
                                        player.markSkill("oldx_sbguanxing");
                                    }
                                    "step 2";
                                    var cards = player.getCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                    if (cards.length) {
                                        player
                                            .chooseToMove()
                                            .set("list", [["你的“星”", cards], ["牌堆顶"]])
                                            .set("prompt", "观星：点击将牌移动到牌堆顶")
                                            .set("processAI", function (list) {
                                                var cards = list[0][1].slice(),
                                                    player = _status.event.player;
                                                var name = _status.event.getTrigger().name;
                                                var target = name == "phaseZhunbei" ? player : player.getNext();
                                                var judges = target.getCards("j");
                                                var top = [],
                                                    att = get.sgn(get.attitude(player, target));
                                                if (judges.length && att != 0 && (target != player || !player.hasWuxie())) {
                                                    for (var i = 0; i < judges.length; i++) {
                                                        var judge = (card, num) => get.judge(card) * num;
                                                        cards.sort((a, b) => judge(b, att) - judge(a, att));
                                                        if (judge(cards[0], att) < 0) break;
                                                        else top.unshift(cards.shift());
                                                    }
                                                }
                                                return [cards, top];
                                            })
                                            .set("filterOk", function (moved) {
                                                return moved[1].length;
                                            });
                                    } else event._result = { bool: false };
                                    "step 3";
                                    if (result.bool) {
                                        var cards = result.moved[1];
                                        player.loseToDiscardpile(cards, ui.cardPile, "insert").log = false;
                                        game.log(player, "将", cards, "置于了牌堆顶");
                                    } else if (trigger.name == "phaseZhunbei") player.addTempSkill("oldx_sbguanxing_on");
                                },
                                getNum: 2,
                                group: "oldx_sbguanxing_unmark",
                                subSkill: {
                                    on: { charlotte: true },
                                    unmark: {
                                        trigger: { player: "loseAfter" },
                                        filter(event, player) {
                                            if (!event.ss || !event.ss.length) return false;
                                            return !player.countCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                        },
                                        charlotte: true,
                                        forced: true,
                                        silent: true,
                                        content() {
                                            player.unmarkSkill("oldx_sbguanxing");
                                        },
                                    },
                                },
                                marktext: "星",
                                intro: {
                                    mark(dialog, storage, player) {
                                        var cards = player.getCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                        if (!cards || !cards.length) return;
                                        dialog.addAuto(cards);
                                    },
                                    markcount(storage, player) {
                                        return player.countCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                    },
                                    onunmark(storage, player) {
                                        var cards = player.getCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                        if (cards.length) player.loseToDiscardpile(cards);
                                    },
                                },
                                mod: {
                                    aiOrder(player, card, num) {
                                        var cards = player.getCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                        if (get.itemtype(card) == "card" && card.hasGaintag("oldx_sbguanxing")) return num + (cards.length > 1 ? 0.5 : -0.0001);
                                    },
                                },
                            },
                            oldx_sbkongcheng: {
                                audio: "sbkongcheng",
                                trigger: { player: ["damageBegin3", "damageBegin4"] },
                                filter(event, player, name) {
                                    if (!player.hasSkill("oldx_sbguanxing")) return false;
                                    const num = player.countCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                    if (name == "damageBegin3" && !num) return true;
                                    if (name == "damageBegin4" && num) return true;
                                    return false;
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    var num = player.countCards("s", card => card.hasGaintag("oldx_sbguanxing"));
                                    if (!num && event.triggername == "damageBegin3") {
                                        trigger.increase("num");
                                    } else if (num && event.triggername == "damageBegin4") {
                                        player
                                            .judge(function (result) {
                                                if (get.number(result) <= get.player().countCards("s", card => card.hasGaintag("oldx_sbguanxing"))) return 2;
                                                return -1;
                                            })
                                            .set("judge2", result => result.bool)
                                            .set("callback", function () {
                                                if (event.judgeResult.number <= player.countCards("s", card => card.hasGaintag("oldx_sbguanxing"))) {
                                                    event.getParent("oldx_sbkongcheng").getTrigger().decrease("num");
                                                }
                                            });
                                    }
                                },
                            },
                            //谋孟获
                            old_sbzaiqi: {
                                audio: "sbzaiqi",
                                trigger: {
                                    player: "phaseDiscardEnd",
                                },
                                chargeSkill: 7,
                                filter(event, player) {
                                    return player.countCharge();
                                },
                                group: "old_sbzaiqi_backflow",
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseTarget(get.prompt("old_sbzaiqi"), "选择任意名角色并消耗等量蓄力值，令这些角色选择一项：1.令你摸一张牌；2.弃置一张牌，然后你回复1点体力", [1, player.countMark("charge")]).set("ai", function (target) {
                                        var player = _status.event.player;
                                        var att = get.attitude(player, target);
                                        return 3 - get.sgn(att) + Math.abs(att / 1000);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var targets = result.targets;
                                        targets.sortBySeat();
                                        event.targets = targets;
                                        player.logSkill("old_sbzaiqi", targets);
                                        player.removeCharge(targets.length);
                                    } else event.finish();
                                    "step 2";
                                    var target = targets.shift();
                                    event.target = target;
                                    if (!target.countCards("he")) event._result = { bool: false };
                                    else
                                        target
                                            .chooseToDiscard(get.translation(player) + "对你发动了【再起】", "是否弃置一张牌令其回复1点体力？或者点击“取消”，令该角色摸一张牌。", "he")
                                            .set("ai", card => {
                                                var eff = _status.event.eff,
                                                    att = _status.event.att;
                                                if ((eff > 0 && att > 0) || (eff <= 0 && att < 0)) return 5.5 - get.value(card);
                                                return 0;
                                            })
                                            .set("eff", get.recoverEffect(player, player, target))
                                            .set("att", get.attitude(target, player));
                                    "step 3";
                                    target.line(player);
                                    if (result.bool) {
                                        player.recover();
                                    } else {
                                        player.draw();
                                    }
                                    game.delayex();
                                    if (targets.length) event.goto(2);
                                },
                                subSkill: {
                                    backflow: {
                                        audio: "sbzaiqi",
                                        trigger: {
                                            player: "enterGame",
                                            source: "damageSource",
                                            global: "phaseBefore",
                                        },
                                        usable: 1,
                                        filter(event, player) {
                                            if (event.name == "damage") return true;
                                            return event.name != "phase" || game.phaseNumber == 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addCharge(trigger.name == "damage" ? 1 : 3);
                                        },
                                    },
                                },
                            },
                            //谋祝融
                            old_sbjuxiang: {
                                audio: "sbjuxiang",
                                trigger: {
                                    player: "phaseJieshuBegin",
                                },
                                forced: true,
                                direct: true,
                                filter(event, player) {
                                    return !player.hasHistory("useCard", evt => evt.card.name == "nanman") && (!_status.old_sbjuxiang_nanman || _status.old_sbjuxiang_nanman.length);
                                },
                                group: ["old_sbjuxiang_cancel", "old_sbjuxiang_gain"],
                                content() {
                                    "step 0";
                                    if (!_status.old_sbjuxiang_nanman) {
                                        _status.old_sbjuxiang_nanman = [
                                            { name: "nanman", number: 7, suit: "spade" },
                                            { name: "nanman", number: 9, suit: "spade" },
                                            { name: "nanman", number: 11, suit: "spade" },
                                            { name: "nanman", number: 13, suit: "spade" },
                                            { name: "nanman", number: 7, suit: "club" },
                                            { name: "nanman", number: 9, suit: "club" },
                                            { name: "nanman", number: 11, suit: "club" },
                                            { name: "nanman", number: 13, suit: "club" },
                                        ];
                                        game.broadcastAll(function () {
                                            if (!lib.inpile.includes("nanman")) lib.inpile.add("nanman");
                                        });
                                    }
                                    player.chooseTarget("请选择【巨象】的目标", "将游戏外的随机一张【南蛮入侵】交给一名角色（剩余" + get.cnNumber(_status.old_sbjuxiang_nanman.length) + "张）", true).set("ai", target => {
                                        var player = _status.event.player;
                                        return Math.max(0, target.getUseValue({ name: "nanman" })) * get.attitude(player, target) * (target == player ? 0.5 : 1);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_sbjuxiang", target);
                                        if (!_status.old_sbjuxiang_nanman.length) return;
                                        var info = _status.old_sbjuxiang_nanman.randomRemove();
                                        var card = game.createCard2(info);
                                        target.gain(card, "gain2").giver = player;
                                    }
                                },
                                ai: {
                                    expose: 0.05,
                                    effect: {
                                        target(card) {
                                            if (card.name == "nanman") return [0, 1, 0, 0];
                                        },
                                    },
                                },
                                subSkill: {
                                    cancel: {
                                        audio: "sbjuxiang",
                                        trigger: { target: "useCardToBefore" },
                                        forced: true,
                                        priority: 15,
                                        filter(event, player) {
                                            return event.card.name == "nanman";
                                        },
                                        content() {
                                            trigger.cancel();
                                        },
                                    },
                                    gain: {
                                        audio: "sbjuxiang",
                                        trigger: { global: "useCardAfter" },
                                        forced: true,
                                        filter(event, player) {
                                            return event.card.name == "nanman" && event.player != player && event.cards.filterInD().length;
                                        },
                                        content() {
                                            player.gain(trigger.cards.filterInD(), "gain2");
                                        },
                                    },
                                },
                            },
                            //关羽
                            //矢
                            old_sbwusheng: {
                                audio: "sbwusheng",
                                trigger: { player: "phaseUseBegin" },
                                filter(event, player) {
                                    return game.hasPlayer(target => target != player && !target.isZhu2());
                                },
                                direct: true,
                                *content(event, map) {
                                    var player = map.player;
                                    var result = yield player
                                        .chooseTarget(get.prompt("old_sbwusheng"), "选择一名非主公的其他角色，本阶段对其使用【杀】无距离和次数限制，使用【杀】指定其为目标后摸一张牌，对其使用五张【杀】后不能对其使用【杀】", (card, player, target) => {
                                            return target != player && !target.isZhu2();
                                        })
                                        .set("ai", target => {
                                            var player = _status.event.player;
                                            return get.effect(target, { name: "sha" }, player, player);
                                        });
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_sbwusheng", target);
                                        if (get.mode() !== "identity" || player.identity !== "nei") player.addExpose(0.25);
                                        player.addTempSkill("old_sbwusheng_effect", { player: "phaseUseAfter" });
                                        player.storage.old_sbwusheng_effect[target.playerid] = 0;
                                    }
                                },
                                group: "old_sbwusheng_wusheng",
                                subSkill: {
                                    wusheng: {
                                        audio: "sbwusheng",
                                        enable: ["chooseToUse", "chooseToRespond"],
                                        hiddenCard(player, name) {
                                            return name == "sha" && player.countCards("hs");
                                        },
                                        filter(event, player) {
                                            return event.filterCard(get.autoViewAs({ name: "sha" }, "unsure"), player, event) || lib.inpile_nature.some(nature => event.filterCard(get.autoViewAs({ name: "sha", nature }, "unsure"), player, event));
                                        },
                                        chooseButton: {
                                            dialog(event, player) {
                                                var list = [];
                                                if (event.filterCard({ name: "sha" }, player, event)) list.push(["基本", "", "sha"]);
                                                for (var j of lib.inpile_nature) {
                                                    if (event.filterCard({ name: "sha", nature: j }, player, event)) list.push(["基本", "", "sha", j]);
                                                }
                                                var dialog = ui.create.dialog("武圣", [list, "vcard"], "hidden");
                                                dialog.direct = true;
                                                return dialog;
                                            },
                                            check(button) {
                                                var player = _status.event.player;
                                                var card = { name: button.link[2], nature: button.link[3] };
                                                if (
                                                    _status.event.getParent().type == "phase" &&
                                                    game.hasPlayer(function (current) {
                                                        return player.canUse(card, current) && get.effect(current, card, player, player) > 0;
                                                    })
                                                ) {
                                                    switch (button.link[2]) {
                                                        case "sha":
                                                            if (button.link[3] == "fire") return 2.95;
                                                            else if (button.link[3] == "thunder" || button.link[3] == "ice") return 2.92;
                                                            else return 2.9;
                                                    }
                                                }
                                                return 1 + Math.random();
                                            },
                                            backup(links, player) {
                                                return {
                                                    audio: "sbwusheng",
                                                    filterCard: true,
                                                    check(card) {
                                                        return 6 - get.value(card);
                                                    },
                                                    viewAs: { name: links[0][2], nature: links[0][3] },
                                                    position: "hs",
                                                    popname: true,
                                                };
                                            },
                                            prompt(links, player) {
                                                return "将一张手牌当作" + get.translation(links[0][3] || "") + "【" + get.translation(links[0][2]) + "】" + (_status.event.name == "chooseToUse" ? "使用" : "打出");
                                            },
                                        },
                                        ai: {
                                            respondSha: true,
                                            fireAttack: true,
                                            skillTagFilter(player, tag) {
                                                if (!player.countCards("hs")) return false;
                                            },
                                            order(item, player) {
                                                if (player && _status.event.type == "phase") {
                                                    var max = 0;
                                                    if (lib.inpile_nature.some(i => player.getUseValue({ name: "sha", nature: i }) > 0)) {
                                                        var temp = get.order({ name: "sha" });
                                                        if (temp > max) max = temp;
                                                    }
                                                    if (max > 0) max += 0.3;
                                                    return max;
                                                }
                                                return 4;
                                            },
                                            result: { player: 1 },
                                        },
                                    },
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        init(player) {
                                            if (!player.storage.old_sbwusheng_effect) player.storage.old_sbwusheng_effect = {};
                                        },
                                        mod: {
                                            targetInRange(card, player, target) {
                                                if (card.name == "sha" && typeof player.storage.old_sbwusheng_effect[target.playerid] == "number") return true;
                                            },
                                            cardUsableTarget(card, player, target) {
                                                if (card.name !== "sha" || typeof player.storage.old_sbwusheng_effect[target.playerid] !== "number") return;
                                                return player.storage.old_sbwusheng_effect[target.playerid] < 5;
                                            },
                                            playerEnabled(card, player, target) {
                                                if (card.name != "sha" || typeof player.storage.old_sbwusheng_effect[target.playerid] != "number") return;
                                                if (player.storage.old_sbwusheng_effect[target.playerid] >= 5) return false;
                                            },
                                        },
                                        audio: "sbwusheng",
                                        trigger: { player: ["useCardToPlayered", "useCardAfter"] },
                                        filter(event, player) {
                                            if (event.card.name != "sha") return false;
                                            if (event.name == "useCard") return event.targets.some(target => typeof player.storage.old_sbwusheng_effect[target.playerid] == "number");
                                            return typeof player.storage.old_sbwusheng_effect[event.target.playerid] == "number";
                                        },
                                        direct: true,
                                        content() {
                                            if (trigger.name == "useCard") {
                                                var targets = trigger.targets.filter(target => typeof player.storage.old_sbwusheng_effect[target.playerid] == "number");
                                                targets.forEach(target => player.storage.old_sbwusheng_effect[target.playerid]++);
                                            } else {
                                                player.logSkill("old_sbwusheng_effect", trigger.target);
                                                player.draw();
                                            }
                                        },
                                    },
                                },
                                ai: { threaten: 114514 },
                            },
                            //谋赵云
                            old_sblongdan: {
                                audio: "sblongdan",
                                enable: ["chooseToUse", "chooseToRespond"],
                                chargeSkill: 4,
                                filter(event, player) {
                                    if (event.type == "wuxie" || !player.countCharge()) return false;
                                    var marked = player.hasSkill("old_sblongdan_mark", null, null, false);
                                    for (var name of lib.inpile) {
                                        if (!marked && name != "sha" && name != "shan") continue;
                                        if (get.type(name) != "basic") continue;
                                        if (player.hasCard(lib.skill.old_sblongdan.getFilter(name, player), "hs")) {
                                            if (event.filterCard(get.autoViewAs({ name }, "unsure"), player, event)) return true;
                                            if (marked && name == "sha") {
                                                for (var nature of lib.inpile_nature) {
                                                    if (event.filterCard(get.autoViewAs({ name, nature }, "unsure"), player, event)) return true;
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        var marked = player.hasSkill("old_sblongdan_mark", null, null, false);
                                        for (var name of lib.inpile) {
                                            if (!marked && name != "sha" && name != "shan") continue;
                                            if (get.type(name) != "basic") continue;
                                            if (player.hasCard(lib.skill.old_sblongdan.getFilter(name, player), "hs")) {
                                                if (event.filterCard(get.autoViewAs({ name }, "unsure"), player, event)) list.push(["基本", "", name]);
                                                if (marked && name == "sha") {
                                                    for (var nature of lib.inpile_nature) {
                                                        if (event.filterCard(get.autoViewAs({ name, nature }, "unsure"), player, event)) list.push(["基本", "", name, nature]);
                                                    }
                                                }
                                            }
                                        }
                                        return ui.create.dialog("龙胆", [list, "vcard"], "hidden");
                                    },
                                    check(button) {
                                        if (_status.event.getParent().type != "phase") return 1;
                                        var player = _status.event.player,
                                            card = { name: button.link[2], nature: button.link[3] };
                                        if (card.name == "jiu" && Math.min(player.countMark("charge"), player.countCards("h", { type: "basic" })) < 2) return 0;
                                        return player.getUseValue(card, null, true);
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: "sblongdan",
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                            },
                                            filterCard: lib.skill.old_sblongdan.getFilter(links[0][2], player),
                                            position: "he",
                                            popname: true,
                                            check(card) {
                                                return 6 / Math.max(1, get.value(card));
                                            },
                                            precontent() {
                                                player.removeCharge();
                                                player.addTempSkill("old_sblongdan_draw");
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        var marked = player.hasSkill("old_sblongdan_mark", null, null, false);
                                        var card = {
                                            name: links[0][2],
                                            nature: links[0][3],
                                            isCard: true,
                                        };
                                        if (marked) return "将一张基本牌当做" + get.translation(card) + "使用";
                                        return "将一张" + (card.name == "sha" ? "闪" : "杀") + "当做" + get.translation(card) + "使用";
                                    },
                                },
                                hiddenCard(player, name) {
                                    if (get.type(name) != "basic" || !player.countCharge()) return false;
                                    var marked = player.hasSkill("old_sblongdan_mark", null, null, false);
                                    if (!marked && name != "sha" && name != "shan") return false;
                                    return player.hasCard(lib.skill.old_sblongdan.getFilter(name, player), "hs");
                                },
                                ai: {
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag) {
                                        return lib.skill.old_sblongdan.hiddenCard(player, tag == "respondSha" ? "sha" : "shan");
                                    },
                                    order: 9,
                                    result: {
                                        player(player) {
                                            if (_status.event.dying) return get.attitude(player, _status.event.dying);
                                            return 1;
                                        },
                                    },
                                },
                                getFilter(name, player) {
                                    if (!player.hasSkill("old_sblongdan_mark", null, null, false)) {
                                        if (name == "sha") return { name: "shan" };
                                        if (name == "shan") return { name: "sha" };
                                        return () => false;
                                    }
                                    return { type: "basic" };
                                },
                                group: "old_sblongdan_charge",
                                onremove(player) {
                                    player.removeSkill("old_sblongdan_mark");
                                },
                                subSkill: {
                                    backup: { audio: "sblongdan" },
                                    mark: { charlotte: true },
                                    draw: {
                                        charlotte: true,
                                        trigger: { player: ["useCardAfter", "respondAfter"] },
                                        forced: true,
                                        popup: false,
                                        filter(event, player) {
                                            return event.skill == "old_sblongdan_backup";
                                        },
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    charge: {
                                        audio: "sblongdan",
                                        trigger: {
                                            global: ["phaseBefore", "phaseEnd"],
                                            player: "enterGame",
                                        },
                                        forced: true,
                                        filter(event, player, name) {
                                            if (!player.countCharge(true)) return false;
                                            return name != "phaseBefore" || game.phaseNumber == 0;
                                        },
                                        content() {
                                            player.addCharge();
                                        },
                                    },
                                },
                            },
                            old_sbjizhu: {
                                audio: "sbjizhu",
                                trigger: { player: "phaseZhunbeiBegin" },
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseTarget(lib.filter.notMe, get.prompt("old_sbjizhu"), "和一名其他角色进行“协力”").set("ai", function (target) {
                                        return get.threaten(target) * Math.sqrt(1 + target.countCards("h")) * (target.isTurnedOver() || target.hasJudge("lebu") ? 0.1 : 1);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_sbjizhu", target);
                                        player.chooseCooperationFor(target, "old_sbjizhu").set("ai", function (button) {
                                            var base = 0;
                                            switch (button.link) {
                                                case "cooperation_damage":
                                                    base = 0.1;
                                                    break;
                                                case "cooperation_draw":
                                                    base = 0.6;
                                                    break;
                                                case "cooperation_discard":
                                                    base = 0.1;
                                                    break;
                                                case "cooperation_use":
                                                    base = 0.6;
                                                    break;
                                            }
                                            return base + Math.random();
                                        });
                                        player.addAdditionalSkill("cooperation", "old_sbjizhu_effect");
                                    } else event.finish();
                                    "step 2";
                                    game.delayx();
                                },
                                subSkill: {
                                    effect: {
                                        audio: "sbjizhu",
                                        charlotte: true,
                                        trigger: { global: "phaseJieshuBegin" },
                                        forced: true,
                                        logTarget: "player",
                                        filter(event, player) {
                                            return player.checkCooperationStatus(event.player, "old_sbjizhu") && player.hasSkill("old_sblongdan", null, null, false);
                                        },
                                        content() {
                                            game.log(player, "和", trigger.player, "的协力成功");
                                            player.addTempSkill("old_sblongdan_mark", { player: "phaseJieshuBegin" });
                                            game.delayx();
                                        },
                                    },
                                },
                                derivation: "old_sblongdan_shabi",
                                ai: {
                                    combo: "old_sblongdan",
                                },
                            },
                            //法正
                            old_sbxuanhuo: {
                                audio: "sbxuanhuo",
                                enable: "phaseUse",
                                usable: 1,
                                group: "old_sbxuanhuo_rob",
                                filterTarget(card, player, target) {
                                    return !target.hasMark("old_sbxuanhuo_mark") && player != target;
                                },
                                filterCard: true,
                                position: "he",
                                discard: false,
                                lose: false,
                                delay: false,
                                onremove(player) {
                                    delete player.storage.old_sbxuanhuo;
                                    player.unmarkSkill("old_sbxuanhuo");
                                },
                                check(card) {
                                    return 6.5 - get.value(card);
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0],
                                        cards = event.cards;
                                    await player.give(cards, target);
                                    if (player.storage[event.name] && player.storage[event.name][target.playerid]) delete player.storage[event.name][target.playerid];
                                    target.addMark(event.name + "_mark");
                                    var history = target.getAllHistory("lose");
                                    if (history.length) {
                                        history[history.length - 1][event.name + "_mark"] = true;
                                    }
                                },
                                getNum(current, skill, mark) {
                                    var num = 0;
                                    var history = current.getAllHistory("lose");
                                    if (history.length) {
                                        for (var i = history.length - 1; i >= 0; i--) {
                                            var evt = history[i];
                                            if (evt[mark]) break;
                                            if (typeof skill == "string") {
                                                if (evt.getParent(2).name == skill || evt.getParent(3).name == skill) num += evt.cards2.length;
                                            } else {
                                                var evtx = evt.getParent(),
                                                    player = skill;
                                                if (evtx.name == "gain") {
                                                    var cards = evtx.cards;
                                                    if (evtx.player == player && cards.length > 0) num += cards.length;
                                                } else if (evtx.name == "loseAsync") {
                                                    if (evtx.type != "gain" || evtx.giver) return false;
                                                    var cards = evtx.getl(current).cards2;
                                                    var cardsx = evtx.getg(player);
                                                    if (cardsx.length > 0) num += cardsx.length;
                                                }
                                            }
                                        }
                                    }
                                    return num;
                                },
                                ai: {
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            return -Math.sqrt(Math.max(target.hp, 1));
                                        },
                                    },
                                },
                                marktext: "惑",
                                intro: {
                                    content(storage, player) {
                                        if (!storage || get.is.empty(storage)) return "未得到过牌";
                                        var map = _status.connectMode ? lib.playerOL : game.playerMap;
                                        var str = "已得到";
                                        for (var i in storage) {
                                            str += get.translation(map[i]) + "的" + get.cnNumber(storage[i]) + "张牌、";
                                        }
                                        return str.slice(0, -1);
                                    },
                                },
                                subSkill: {
                                    mark: {
                                        marktext: "眩",
                                        intro: {
                                            name: "眩惑",
                                            name2: "眩",
                                            markcount: () => 0,
                                            content: "已获得“眩”标记",
                                        },
                                    },
                                    rob: {
                                        audio: "old_sbxuanhuo",
                                        trigger: {
                                            global: ["gainAfter", "loseAsyncAfter"],
                                        },
                                        filter(event, player, name, target) {
                                            const evt = event.getParent("phaseDraw");
                                            if (evt && evt.name == "phaseDraw") return false;
                                            if (!event.getg(target).length || !target.hasMark("old_sbxuanhuo_mark")) return false;
                                            if (evt && evt.player == target) return false;
                                            if (lib.skill.old_sbxuanhuo.getNum(target, "old_sbxuanhuo_rob", "old_sbxuanhuo_mark") >= 5) return false;
                                            return target.hasCard(card => lib.filter.canBeGained(card, target, player), "he");
                                        },
                                        getIndex(event, player) {
                                            const evt = event.getParent("phaseDraw");
                                            if (evt && evt.name == "phaseDraw") return false;
                                            return game
                                                .filterPlayer(current => {
                                                    if (!event.getg(current).length || !current.hasMark("old_sbxuanhuo_mark")) return false;
                                                    if (evt && evt.player == current) return false;
                                                    if (lib.skill.old_sbxuanhuo.getNum(current, "old_sbxuanhuo_rob", "old_sbxuanhuo_mark") >= 5) return false;
                                                    return current.hasCard(card => lib.filter.canBeGained(card, current, player), "he");
                                                })
                                                .sortBySeat();
                                        },
                                        logTarget(event, player, triggername, target) {
                                            return target;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            const target = event.targets[0],
                                                hs = target.getCards("h", card => lib.filter.canBeGained(card, target, player));
                                            if (hs.length) {
                                                await player.gain(hs.randomGet(), target, "giveAuto");
                                                if (!player.storage.old_sbxuanhuo) player.storage.old_sbxuanhuo = {};
                                                player.storage.old_sbxuanhuo[target.playerid] = lib.skill.old_sbxuanhuo.getNum(target, "old_sbxuanhuo_rob", "old_sbxuanhuo_mark");
                                                player.markSkill("old_sbxuanhuo");
                                            }
                                        },
                                    },
                                },
                            },
                            old_sbenyuan: {
                                audio: "sbenyuan",
                                forced: true,
                                direct: true,
                                trigger: { player: "phaseZhunbeiBegin" },
                                filter(event, player) {
                                    return game.hasPlayer(current => current.hasMark("old_sbxuanhuo_mark"));
                                },
                                content() {
                                    "step 0";
                                    var targets = game.filterPlayer(current => current.hasMark("old_sbxuanhuo_mark"));
                                    event.targets = targets;
                                    "step 1";
                                    var target = targets.shift();
                                    event.target = target;
                                    player.logSkill("old_sbenyuan", target);
                                    target.removeMark("old_sbxuanhuo_mark", target.countMark("old_sbxuanhuo_mark"));
                                    game.players.forEach(current => {
                                        var storage = current.storage.old_sbxuanhuo;
                                        if (storage && storage[target.playerid]) delete storage[target.playerid];
                                        if (storage && get.is.empty(storage)) {
                                            delete current.storage.old_sbxuanhuo;
                                            current.unmarkSkill("old_sbxuanhuo");
                                        }
                                    });
                                    var num = lib.skill.old_sbxuanhuo.getNum(target, player);
                                    if (num >= 3) {
                                        var cards = player.getCards("he");
                                        if (!cards.length) event._result = { bool: false };
                                        else if (cards.length <= 3) event._result = { bool: true, cards: cards };
                                        else player.chooseCard("恩怨：交给" + get.translation(target) + "两张牌", true, 2, "he");
                                    } else {
                                        target.loseHp();
                                        player.recover();
                                        event.goto(3);
                                    }
                                    "step 2";
                                    if (result.bool) player.give(result.cards, target);
                                    "step 3";
                                    if (targets.length) event.goto(1);
                                },
                                ai: {
                                    combo: "old_sbxuanhuo",
                                },
                            },
                            //谋徐晃
                            old_sbduanliang: {
                                audio: "sbduanliang",
                                enable: "phaseUse",
                                usable: 2,
                                logAudio: () => 1,
                                filterTarget: lib.filter.notMe,
                                content() {
                                    "step 0";
                                    player
                                        .chooseToDuiben(target)
                                        .set("title", "谋弈")
                                        .set("namelist", ["固守城池", "突出重围", "围城断粮", "擂鼓进军"])
                                        .set("translationList", [`以防止${get.translation(player)}通过此技能对你使用【决斗】`, `以防止${get.translation(player)}通过此技能对你使用【兵粮寸断】`, `若成功，将牌堆顶的牌当做【兵粮寸断】对${get.translation(target)}使用`, `若成功，视为对${get.translation(target)}使用【决斗】`])
                                        .set("ai", button => {
                                            var source = _status.event.getParent().player,
                                                target = _status.event.getParent().target;
                                            if (get.effect(target, { name: "juedou" }, source, source) >= 10 && button.link[2] == "db_def2" && Math.random() < 0.5) return 10;
                                            return 1 + Math.random();
                                        });
                                    "step 1";
                                    if (result.bool) {
                                        if (result.player == "db_def1") {
                                            if (target.hasJudge("bingliang")) player.gainPlayerCard(target, "he", true);
                                            else {
                                                if (ui.cardPile.childNodes.length > 0) {
                                                    if (player.canUse(get.autoViewAs({ name: "bingliang" }, [ui.cardPile.firstChild]), target, false)) {
                                                        player.useCard({ name: "bingliang" }, target, get.cards());
                                                    }
                                                }
                                            }
                                        } else {
                                            var card = { name: "juedou", isCard: true };
                                            if (player.canUse(card, target)) player.useCard(card, target);
                                        }
                                    }
                                },
                                ai: {
                                    threaten: 1.2,
                                    order: 5.5,
                                    result: {
                                        player: 1,
                                        target: -1,
                                    },
                                },
                                subSkill: {
                                    true1: {
                                        audio: "sbduanliang",
                                        logAudio: () => "sbduanliang2.mp3",
                                    },
                                    true2: {
                                        audio: "sbduanliang",
                                        logAudio: () => "sbduanliang3.mp3",
                                    },
                                    false: {
                                        audio: "sbduanliang",
                                        logAudio: () => "sbduanliang4.mp3",
                                    },
                                },
                            },
                            //谋袁绍
                            old_sbluanji: {
                                audio: "sbluanji",
                                enable: "phaseUse",
                                trigger: { global: "respond" },
                                viewAs: { name: "wanjian" },
                                forced: true,
                                locked: false,
                                filter(event, player) {
                                    if (event.name == "chooseToUse") return player.countCards("hs") > 1 && !player.hasSkill("old_sbluanji_used");
                                    var evt = event.getParent(2);
                                    return evt.name == "wanjian" && evt.getParent().player == player && event.player != player;
                                },
                                filterCard: true,
                                selectCard: 2,
                                position: "hs",
                                prompt: "将两张手牌当【万箭齐发】使用",
                                check(card) {
                                    var player = _status.event.player;
                                    var targets = game.filterPlayer(function (current) {
                                        return player.canUse("wanjian", current);
                                    });
                                    var num = 0;
                                    for (var i = 0; i < targets.length; i++) {
                                        var eff = get.sgn(get.effect(targets[i], { name: "wanjian" }, player, player));
                                        if (targets[i].hp == 1) {
                                            eff *= 1.5;
                                        }
                                        if (get.attitude(player, targets[i]) == 0 || targets[i].group == "qun") {
                                            eff += 0.5;
                                        }
                                        num += eff;
                                    }
                                    if (!player.needsToDiscard(-1)) {
                                        if (targets.length >= 7) {
                                            if (num < 1) return 0;
                                        } else if (targets.length >= 5) {
                                            if (num < 0.5) return 0;
                                        }
                                    }
                                    return 6 - get.value(card);
                                },
                                content() {
                                    player.draw();
                                },
                                precontent() {
                                    player.addTempSkill("old_sbluanji_used", "phaseUseAfter");
                                },
                                ai: {
                                    threaten: 1.6,
                                },
                                subSkill: { used: { charlotte: true } },
                            },
                            old_sbxueyi: {
                                audio: "sbxueyi",
                                trigger: { player: "useCardToTargeted" },
                                filter(event, player) {
                                    return player.hasZhuSkill("old_sbxueyi") && event.target != player && event.target.group == "qun";
                                },
                                zhuSkill: true,
                                forced: true,
                                logTarget: "target",
                                content() {
                                    player.draw();
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        if (player.hasZhuSkill("old_sbxueyi")) {
                                            return num + 2 * game.countPlayer(current => player != current && current.group == "qun");
                                        }
                                    },
                                },
                                ai: {
                                    effect: {
                                        player_use(card, player, target) {
                                            if (player != target && target && target.group == "qun" && player.hasZhuSkill("old_sbxueyi") && player.countSkill("old_sbxueyi") < 2) return [1, 0.6];
                                        },
                                    },
                                },
                            },
                            //谋张角
                            old_sbleiji: {
                                audio: "sbleiji",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return player.countMark("old_sbguidao") >= 4;
                                },
                                filterTarget: lib.filter.notMe,
                                content() {
                                    player.removeMark("old_sbguidao", 4);
                                    target.damage("thunder");
                                },
                                ai: {
                                    combo: "old_sbguidao",
                                    order: 9,
                                    result: {
                                        target(player, target) {
                                            return get.damageEffect(target, player, target, "thunder");
                                        },
                                    },
                                },
                            },
                            old_sbguidao: {
                                audio: "sbguidao",
                                trigger: {
                                    global: ["phaseBefore", "damageEnd"],
                                    player: "enterGame",
                                },
                                forced: true,
                                locked: false,
                                group: "old_sbguidao_defend",
                                filter(event, player) {
                                    if (player.hasSkill("old_sbguidao_banned") || player.countMark("old_sbguidao") >= 8) return false;
                                    if (event.name == "damage") return event.hasNature() && !player.hasSkill("old_sbguidao_forbid");
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                content() {
                                    var num = 2;
                                    if (trigger.name != "damage") num += 2;
                                    num = Math.min(8 - player.countMark("old_sbguidao"), num);
                                    player.addMark("old_sbguidao", num);
                                },
                                marktext: "兵",
                                intro: {
                                    name: "道兵",
                                    name2: "道兵",
                                    content: "共有$枚“道兵”",
                                },
                                subSkill: {
                                    defend: {
                                        audio: "sbguidao",
                                        trigger: { player: "damageBegin4" },
                                        filter(event, player) {
                                            return player.countMark("old_sbguidao") >= 2;
                                        },
                                        prompt2: "弃2枚“道兵”，防止伤害",
                                        check(event, player) {
                                            return event.num >= 2 || player.hp <= event.num;
                                        },
                                        content() {
                                            trigger.cancel();
                                            player.removeMark("old_sbguidao", 2);
                                            if (player != _status.currentPhase) {
                                                player.addTempSkill("old_sbguidao_banned", { player: "phaseBegin" });
                                            }
                                        },
                                    },
                                    banned: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: '<span style="text-decoration: line-through;">道</span>',
                                        intro: { content: "孩子们，我不能获得道兵了" },
                                    },
                                },
                            },
                            old_sbhuangtian: {
                                audio: "sbhuangtian",
                                trigger: {
                                    player: "phaseBegin",
                                },
                                forced: true,
                                zhuSkill: true,
                                group: "old_sbhuangtian_mark",
                                filter(event, player) {
                                    if (player.phaseNumber > 1 || game.phaseNumber > 1) return false;
                                    if (!player.hasZhuSkill("old_sbhuangtian")) return false;
                                    return (
                                        !game.hasPlayer(function (current) {
                                            return current.countCards("hej", "taipingyaoshu");
                                        }) &&
                                        !Array.from(ui.cardPile.childNodes)
                                            .concat(Array.from(ui.discardPile.childNodes))
                                            .concat(Array.from(ui.ordering.childNodes))
                                            .map(i => i.name)
                                            .includes("taipingyaoshu")
                                    );
                                },
                                content() {
                                    "step 0";
                                    if (!lib.inpile.includes("taipingyaoshu")) {
                                        lib.inpile.push("taipingyaoshu");
                                    }
                                    event.card = game.createCard2("taipingyaoshu", "heart", 3);
                                    "step 1";
                                    if (card) player.equip(card);
                                },
                                subSkill: {
                                    mark: {
                                        audio: "sbhuangtiang",
                                        trigger: { global: "damageSource" },
                                        forced: true,
                                        zhuSkill: true,
                                        filter(event, player) {
                                            if (!player.hasZhuSkill("old_sbhuangtian") || !player.hasSkill("old_sbguidao", null, false, false)) return false;
                                            if (!event.source || player == event.source || event.source.group != "qun") return false;
                                            if (player.hasSkill("old_sbguidao") && player.countMark("old_sbguidao") >= 8) return false;
                                            if (player.countMark("old_sbhuangtian_count") >= 4) return false;
                                            return true;
                                        },
                                        content() {
                                            var num = Math.min(8 - player.countMark("old_sbhuangtian_count"), 2);
                                            player.addMark("old_sbguidao", num);
                                            player.addTempSkill("old_sbhuangtian_count", "roundStart");
                                            player.addMark("old_sbhuangtian_count", num, false);
                                        },
                                    },
                                    count: { onremove: true },
                                },
                            },
                            //谋韩当
                            old_sbjiefan: {
                                audio: "sbjiefan",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget: true,
                                async content(event, trigger, player) {
                                    const { target } = event;
                                    const targets = game.filterPlayer(current => {
                                        return current.inRange(target);
                                    });
                                    const count = targets.length + 2;
                                    if (count <= 2) {
                                        target.chat("没人打得到我喔！");
                                        return;
                                    }
                                    const controls = ["选项一", "选项二", "背水！"];
                                    const control = await target
                                        .chooseControl(controls)
                                        .set("choiceList", [`令所有攻击范围内含有你的角色依次弃置两张牌（${get.translation(targets)}）`, `你摸等同于攻击范围内含有你的角色数+2的牌（${get.cnNumber(count)}张牌）`, `背水！令${get.translation(player)}的〖解烦〗失效直到其杀死一名角色，然后你依次执行上述所有选项`])
                                        .set("ai", () => {
                                            return get.event("choice");
                                        })
                                        .set(
                                            "choice",
                                            (() => {
                                                const eff1 = targets
                                                    .map(current => {
                                                        let position = "h";
                                                        if (!current.countCards("h")) position += "e";
                                                        return get.effect(current, { name: "guohe_copy", position }, target, target);
                                                    })
                                                    .reduce((p, c) => p + c, 0);
                                                const eff2 = (get.effect(target, { name: "wuzhong" }, target) * count) / 2;
                                                if (
                                                    game.hasPlayer(current => {
                                                        const att1 = get.attitude(player, current),
                                                            att2 = get.attitude(target, current);
                                                        if (att1 < 0 && att2 < 0) {
                                                            return current.getHp() <= 1;
                                                        }
                                                        return false;
                                                    }) &&
                                                    eff1 > 15 &&
                                                    eff2 > 0
                                                )
                                                    return "背水！";
                                                if (eff1 > 3 * eff2) return "选项一";
                                                return "选项二";
                                            })()
                                        )
                                        .forResultControl();
                                    game.log(target, "选择了", "#g" + control);
                                    if (control === "背水！") {
                                        player.tempBanSkill("old_sbjiefan", { source: "die" });
                                    }
                                    if (control !== "选项二") {
                                        for (const current of targets) {
                                            target.line(current, "thunder");
                                            await current.chooseToDiscard("解烦：请弃置一张牌", "he", true);
                                        }
                                    }
                                    if (control !== "选项一") {
                                        await target.draw(count);
                                    }
                                },
                                ai: {
                                    order: 8,
                                    result: {
                                        target(player, target) {
                                            const targets = game.filterPlayer(current => {
                                                return current.inRange(target);
                                            });
                                            return Math.min(2, targets.length) / 2;
                                        },
                                    },
                                },
                            },
                            //谋曹丕
                            old_sbxingshang: {
                                getLimit: 9,
                                getList: [
                                    {
                                        cost: 2,
                                        prompt: () => "令一名角色复原武将牌",
                                        filter: () => game.hasPlayer(target => target.isLinked() || target.isTurnedOver()),
                                        filterTarget: (card, player, target) => target.isLinked() || target.isTurnedOver(),
                                        async content(player, target) {
                                            if (target.isLinked()) await target.link(false);
                                            if (target.isTurnedOver()) await target.turnOver(false);
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    let res = 0;
                                                    if (target.isLinked()) res = 0.3;
                                                    if (target.isTurnedOver()) res += 3.5 * get.threaten(target, player);
                                                    return res;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 2,
                                        prompt: () => "令一名角色摸" + get.cnNumber(Math.min(5, Math.max(2, game.dead.length))) + "张牌",
                                        filter: () => true,
                                        filterTarget: true,
                                        async content(player, target) {
                                            await target.draw(Math.min(5, Math.max(2, game.dead.length)));
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return Math.min(5, Math.max(2, game.dead.length));
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 5,
                                        prompt: () => "令一名体力上限小于10的角色回复1点体力，增加1点体力上限，随机恢复一个废除的装备栏",
                                        filter: () => game.hasPlayer(target => target.maxHp < 10),
                                        filterTarget: true,
                                        async content(player, target) {
                                            await target.recover();
                                            await target.gainMaxHp();
                                            let list = Array.from({ length: 13 }).map((_, i) => "equip" + parseFloat(i + 1));
                                            list = list.filter(i => target.hasDisabledSlot(i));
                                            if (list.length) await target.enableEquip(list.randomGet());
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    let res = 0.2;
                                                    if (target.isHealthy()) res += 0.4;
                                                    if (
                                                        Array.from({ length: 5 })
                                                            .map((_, i) => "equip" + parseFloat(i + 1))
                                                            .some(i => target.hasDisabledSlot(i))
                                                    )
                                                        res += 0.3;
                                                    return res + get.recoverEffect(target, target, target) / 16;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 5,
                                        prompt: () => "获得一名已阵亡角色的武将牌上的所有技能，然后失去〖行殇〗〖放逐〗〖颂威〗",
                                        filter: () => game.dead.some(target => target.getStockSkills(true, true).some(i => get.info(i) && !get.info(i).charlotte)),
                                        filterTarget(card, player, target) {
                                            if (!target.isDead()) return false;
                                            return target.getStockSkills(true, true).some(i => get.info(i) && !get.info(i).charlotte);
                                        },
                                        deadTarget: true,
                                        async content(player, target) {
                                            await player.changeSkills(
                                                target.getStockSkills(true, true).filter(i => get.info(i) && !get.info(i).charlotte),
                                                ["old_sbxingshang", "old_sbfangzhu", "old_sbsongwei"]
                                            );
                                        },
                                        ai: {
                                            result: {
                                                player(player, target) {
                                                    return ["name", "name1", "name2"].reduce((sum, name) => {
                                                        if (!target[name] || !lib.character[target[name]] || (name == "name1" && target.name1 == target.name)) return sum;
                                                        return sum + get.rank(target[name], true);
                                                    }, 0);
                                                },
                                            },
                                        },
                                    },
                                ],
                                marktext: "颂",
                                intro: {
                                    name: "颂",
                                    content: "mark",
                                },
                                audio: "ext:凌梦自用/audio/skill:2",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return get.info("old_sbxingshang").getList.some(effect => {
                                        return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                    });
                                },
                                usable: 2,
                                chooseButton: {
                                    dialog() {
                                        let dialog = ui.create.dialog("行殇：请选择一项", "hidden");
                                        const list = get.info("old_sbxingshang").getList.slice();
                                        dialog.add([
                                            list.map(effect => {
                                                return [effect, "移去" + effect.cost + "个“颂”标记，" + effect.prompt()];
                                            }),
                                            "textbutton",
                                        ]);
                                        return dialog;
                                    },
                                    filter(button, player) {
                                        const effect = button.link;
                                        return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                    },
                                    check(button) {
                                        const player = get.event().player,
                                            effect = button.link;
                                        return Math.max(
                                            ...game
                                                .filterPlayer(target => {
                                                    const filterTarget = effect.filterTarget;
                                                    if (!filterTarget) return target == player;
                                                    if (typeof filterTarget == "function") return filterTarget(null, player, target);
                                                    return true;
                                                })
                                                .map(target => {
                                                    game.broadcastAll(effect => (lib.skill["old_sbxingshang_aiSkill"].ai = effect.ai), effect);
                                                    return get.effect(target, "old_sbxingshang_aiSkill", player, player);
                                                })
                                        );
                                    },
                                    backup(links, player) {
                                        const effect = links[0];
                                        return {
                                            effect: effect,
                                            audio: "ext:凌梦自用/audio/skill:2",
                                            filterCard: () => false,
                                            selectCard: -1,
                                            filterTarget: effect.filterTarget,
                                            deadTarget: effect.deadTarget,
                                            async content(event, trigger, player) {
                                                const target = event.targets[0],
                                                    effect = lib.skill.old_sbxingshang_backup.effect;
                                                player.removeMark("old_sbxingshang", effect.cost);
                                                await effect.content(player, target);
                                            },
                                            ai: effect.ai,
                                        };
                                    },
                                    prompt(links, player) {
                                        const effect = links[0],
                                            str = "###行殇###";
                                        return str + '<div class="text center">' + "移去" + effect.cost + "个“颂”标记，" + effect.prompt() + "</div>";
                                    },
                                },
                                ai: {
                                    order: 6.5,
                                    result: {
                                        player(player) {
                                            const list = get.info("old_sbxingshang").getList.filter(effect => {
                                                return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                            });
                                            return Math.max(
                                                ...list.map(effect => {
                                                    return Math.max(
                                                        ...game
                                                            .filterPlayer(target => {
                                                                const filterTarget = effect.filterTarget;
                                                                if (!filterTarget) return target == player;
                                                                if (typeof filterTarget == "function") return filterTarget(null, player, target);
                                                                return true;
                                                            })
                                                            .map(target => {
                                                                game.broadcastAll(effect => (lib.skill["old_sbxingshang_aiSkill"].ai = effect.ai), effect);
                                                                return get.effect(target, "old_sbxingshang_aiSkill", player, player);
                                                            })
                                                    );
                                                })
                                            );
                                        },
                                    },
                                },
                                group: "old_sbxingshang_gain",
                                subSkill: {
                                    aiSkill: {},
                                    backup: {},
                                    gain: {
                                        audio: "old_sbxingshang",
                                        trigger: { global: ["die", "damageEnd"] },
                                        filter(event, player) {
                                            if (player.countMark("old_sbxingshang") >= get.info("old_sbxingshang").getLimit) return false;
                                            return event.name == "die" || !player.getHistory("custom", evt => evt.old_sbxingshang).length;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            player.addMark("old_sbxingshang", Math.min(2, get.info("old_sbxingshang").getLimit - player.countMark("old_sbxingshang")));
                                            if (trigger.name == "damage") player.getHistory("custom").push({ old_sbxingshang: true });
                                        },
                                    },
                                },
                            },
                            old_sbfangzhu: {
                                getList: [
                                    {
                                        cost: 1,
                                        prompt: () => "令一名其他角色于手牌中只能使用基本牌直到其回合结束",
                                        filter: player => game.hasPlayer(target => target != player && !target.getStorage("old_sbfangzhu_ban").includes("basic")),
                                        filterTarget: (card, player, target) => target != player && !target.getStorage("old_sbfangzhu_ban").includes("basic"),
                                        async content(player, target) {
                                            target.addTempSkill("old_sbfangzhu_ban", { player: "phaseEnd" });
                                            target.markAuto("old_sbfangzhu_ban", ["basic"]);
                                            lib.skill.old_sbfangzhu_ban.init(target, "old_sbfangzhu_ban");
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return -(target.countCards("hs") + 2) / 3;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 2,
                                        prompt: () => "令一名其他角色于手牌中只能使用锦囊牌直到其回合结束",
                                        filter: player => game.hasPlayer(target => target != player && !target.getStorage("old_sbfangzhu_ban").includes("trick")),
                                        filterTarget: (card, player, target) => target != player && !target.getStorage("old_sbfangzhu_ban").includes("trick"),
                                        async content(player, target) {
                                            target.addTempSkill("old_sbfangzhu_ban", { player: "phaseEnd" });
                                            target.markAuto("old_sbfangzhu_ban", ["trick"]);
                                            lib.skill.old_sbfangzhu_ban.init(target, "old_sbfangzhu_ban");
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return -(target.countCards("hs") + 2) / 2;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 3,
                                        prompt: () => "令一名其他角色于手牌中只能使用装备牌直到其回合结束",
                                        filter: player => get.mode() != "doudizhu" && game.hasPlayer(target => target != player && !target.getStorage("old_sbfangzhu_ban").includes("equip")),
                                        filterTarget: (card, player, target) => target != player && !target.getStorage("old_sbfangzhu_ban").includes("equip"),
                                        async content(player, target) {
                                            target.addTempSkill("old_sbfangzhu_ban", { player: "phaseEnd" });
                                            target.markAuto("old_sbfangzhu_ban", ["equip"]);
                                            lib.skill.old_sbfangzhu_ban.init(target, "old_sbfangzhu_ban");
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return -target.countCards("hs") - 2;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 2,
                                        prompt: () => "令一名其他角色的非Charlotte技能失效直到其回合结束",
                                        filter: player => get.mode() != "doudizhu" && game.hasPlayer(target => target != player),
                                        filterTarget: lib.filter.notMe,
                                        async content(player, target) {
                                            target.addTempSkill("old_sbfangzhu_baiban", { player: "phaseEnd" });
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return -target.getSkills(null, false).filter(i => get.info(i) && !get.info(i).charlotte).length * get.threaten(target, player);
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 2,
                                        prompt: () => "令一名其他角色不能响应除其外的角色使用的牌直到其回合结束",
                                        filter: player => game.hasPlayer(target => target != player && !target.hasSkill("old_sbfangzhu_kill")),
                                        filterTarget: lib.filter.notMe,
                                        async content(player, target) {
                                            target.addTempSkill("old_sbfangzhu_kill", { player: "phaseEnd" });
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return -(target.countCards("hs") + 2) / target.hp;
                                                },
                                            },
                                        },
                                    },
                                    {
                                        cost: 3,
                                        prompt: () => "令一名其他角色将武将牌翻面",
                                        filter: player => get.mode() != "doudizhu" && game.hasPlayer(target => target != player),
                                        filterTarget: lib.filter.notMe,
                                        async content(player, target) {
                                            await target.turnOver();
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    return target.isTurnedOver() ? 3.5 : -3.5;
                                                },
                                            },
                                        },
                                    },
                                ],
                                audio: "ext:凌梦自用/audio/skill:2",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return get.info("old_sbfangzhu").getList.some(effect => {
                                        return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                    });
                                },
                                usable: 1,
                                chooseButton: {
                                    dialog() {
                                        let dialog = ui.create.dialog("放逐：请选择一项", "hidden");
                                        const list = get.info("old_sbfangzhu").getList.slice();
                                        dialog.add([
                                            list.map(effect => {
                                                return [effect, "移去" + effect.cost + "个“颂”标记，" + effect.prompt()];
                                            }),
                                            "textbutton",
                                        ]);
                                        return dialog;
                                    },
                                    filter(button, player) {
                                        const effect = button.link;
                                        return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                    },
                                    check(button) {
                                        const player = get.event().player,
                                            effect = button.link;
                                        return Math.max(
                                            ...game
                                                .filterPlayer(target => {
                                                    const filterTarget = effect.filterTarget;
                                                    if (!filterTarget) return target == player;
                                                    if (typeof filterTarget == "function") return filterTarget(null, player, target);
                                                    return true;
                                                })
                                                .map(target => {
                                                    game.broadcastAll(effect => (lib.skill["old_sbxingshang_aiSkill"].ai = effect.ai), effect);
                                                    return get.effect(target, "old_sbxingshang_aiSkill", player, player);
                                                })
                                        );
                                    },
                                    backup(links, player) {
                                        const effect = links[0];
                                        return {
                                            effect: effect,
                                            audio: "old_sbfangzhu",
                                            filterCard: () => false,
                                            selectCard: -1,
                                            filterTarget: effect.filterTarget,
                                            async content(event, trigger, player) {
                                                const target = event.targets[0],
                                                    effect = lib.skill.old_sbfangzhu_backup.effect;
                                                player.removeMark("old_sbxingshang", effect.cost);
                                                await effect.content(player, target);
                                            },
                                            ai: effect.ai,
                                        };
                                    },
                                    prompt(links, player) {
                                        const effect = links[0],
                                            str = "###放逐###";
                                        return str + '<div class="text center">' + "移去" + effect.cost + "个“颂”标记，" + effect.prompt() + "</div>";
                                    },
                                },
                                ai: {
                                    combo: "old_sbxingshang",
                                    order: 7,
                                    result: {
                                        player(player) {
                                            const list = get.info("old_sbfangzhu").getList.filter(effect => {
                                                return player.countMark("old_sbxingshang") >= effect.cost && effect.filter(player);
                                            });
                                            return Math.max(
                                                ...list.map(effect => {
                                                    return Math.max(
                                                        ...game
                                                            .filterPlayer(target => {
                                                                const filterTarget = effect.filterTarget;
                                                                if (!filterTarget) return target == player;
                                                                if (typeof filterTarget == "function") return filterTarget(null, player, target);
                                                                return true;
                                                            })
                                                            .map(target => {
                                                                game.broadcastAll(effect => (lib.skill["old_sbxingshang_aiSkill"].ai = effect.ai), effect);
                                                                return get.effect(target, "old_sbxingshang_aiSkill", player, player);
                                                            })
                                                    );
                                                })
                                            );
                                        },
                                    },
                                },
                                subSkill: {
                                    backup: {},
                                    baiban: {
                                        init(player, skill) {
                                            player.addSkillBlocker(skill);
                                            player.addTip(skill, "放逐 技能失效");
                                        },
                                        onremove(player, skill) {
                                            player.removeSkillBlocker(skill);
                                            player.removeTip(skill);
                                        },
                                        inherit: "baiban",
                                        marktext: "逐",
                                    },
                                    kill: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "禁",
                                        intro: { content: "不能响应其他角色使用的牌" },
                                        trigger: { global: "useCard1" },
                                        filter(event, player) {
                                            return event.player != player;
                                        },
                                        forced: true,
                                        popup: false,
                                        async content(event, trigger, player) {
                                            trigger.directHit.add(player);
                                        },
                                        init(player, skill) {
                                            player.addTip(skill, "放逐 无法响应");
                                        },
                                        onremove(player, skill) {
                                            player.removeTip(skill);
                                        },
                                    },
                                    ban: {
                                        charlotte: true,
                                        mark: true,
                                        marktext: "禁",
                                        intro: {
                                            markcount: () => 0,
                                            content(storage) {
                                                if (storage.length > 1) return "不能使用手牌";
                                                return "于手牌中只能使用" + get.translation(storage[0]) + "牌";
                                            },
                                        },
                                        init(player, skill) {
                                            let storage = player.getStorage(skill);
                                            if (storage.length) {
                                                player.addTip(skill, "放逐 限" + (storage.length === 1 ? get.translation(storage[0])[0] : "手牌"));
                                            }
                                        },
                                        onremove(player, skill) {
                                            player.removeTip(skill);
                                            delete player.storage[skill];
                                        },
                                        mod: {
                                            cardEnabled(card, player) {
                                                const storage = player.getStorage("old_sbfangzhu_ban");
                                                const hs = player.getCards("h"),
                                                    cards = [card];
                                                if (Array.isArray(card.cards)) cards.addArray(card.cards);
                                                if (cards.containsSome(...hs) && (storage.length > 1 || !storage.includes(get.type2(card)))) return false;
                                            },
                                            cardSavable(card, player) {
                                                const storage = player.getStorage("old_sbfangzhu_ban");
                                                const hs = player.getCards("h"),
                                                    cards = [card];
                                                if (Array.isArray(card.cards)) cards.addArray(card.cards);
                                                if (cards.containsSome(...hs) && (storage.length > 1 || !storage.includes(get.type2(card)))) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            old_sbsongwei: {
                                audio: "ext:凌梦自用/audio/skill:2",
                                trigger: { player: "phaseUseBegin" },
                                filter(event, player) {
                                    if (player.countMark("old_sbxingshang") >= get.info("old_sbxingshang").getLimit) return false;
                                    return game.hasPlayer(target => target.group == "wei" && target != player);
                                },
                                zhuSkill: true,
                                forced: true,
                                locked: false,
                                async content(event, trigger, player) {
                                    player.addMark("old_sbxingshang", Math.min(get.info("old_sbxingshang").getLimit - player.countMark("old_sbxingshang"), 2 * game.countPlayer(target => target.group == "wei" && target != player)));
                                },
                                group: "old_sbsongwei_delete",
                                subSkill: {
                                    delete: {
                                        audio: "old_sbsongwei",
                                        enable: "phaseUse",
                                        filter(event, player) {
                                            if (player.storage.old_sbsongwei_delete) return false;
                                            return game.hasPlayer(target => lib.skill.old_sbsongwei.subSkill.delete.filterTarget(null, player, target));
                                        },
                                        filterTarget(card, player, target) {
                                            return target != player && target.group == "wei" && target.getStockSkills(false, true).length;
                                        },
                                        skillAnimation: true,
                                        animationColor: "thunder",
                                        async content(event, trigger, player) {
                                            player.storage.old_sbsongwei_delete = true;
                                            player.awakenSkill("old_sbsongwei_delete");
                                            event.target.removeSkills(event.target.getStockSkills(false, true));
                                        },
                                        ai: {
                                            order: 13,
                                            result: {
                                                target(player, target) {
                                                    return -target.getStockSkills(false, true).length;
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //谋贾诩
                            old_sbwansha: {
                                audio: "sbwansha",
                                trigger: {
                                    global: "dying",
                                },
                                filter(event, player) {
                                    const position = player.storage.old_sbwansha ? "hej" : "h";
                                    return event.player.countCards(position);
                                },
                                check(event, player) {
                                    return get.attitude(player, event.player) <= 0;
                                },
                                logTarget: "player",
                                async content(event, trigger, player) {
                                    const target = trigger.player,
                                        position = player.storage.old_sbwansha ? "hej" : "h";
                                    const bool1 = player.storage.old_sbwansha,
                                        num = bool1 ? 3 : 2,
                                        prompt = `选择其中〇至${get.cnNumber(num)}张牌`;
                                    let cards = await player.choosePlayerCard(target, position, [0, num], true, prompt).set("visible", true).forResultCards();
                                    let result = await target
                                        .chooseControl()
                                        .set("choiceList", [`令${get.translation(player)}将${player === target ? get.translation(cards) : "其选择的牌"}分配给其他角色`, `弃置所有未被${get.translation(player)}选择的牌`])
                                        .set("ai", () => {
                                            return get.event("goon") ? 0 : 1;
                                        })
                                        .set(
                                            "goon",
                                            (function () {
                                                const att = get.sgnAttitude(target, player),
                                                    hs = target.countCards(position);
                                                if (att > 0 || hs > 5) return true;
                                                if (hs < 2) return false;
                                                let num;
                                                if (att === 0) {
                                                    num = Math.min(hs, 2);
                                                    return hs > 2 * num;
                                                }
                                                num = Math.min(hs, 0.5 + 1.2 * Math.random());
                                                return hs > 3 * num;
                                            })()
                                        )
                                        .forResult();
                                    if (result.index === 0 && cards.length) {
                                        if (_status.connectMode) game.broadcastAll(() => (_status.noclearcountdown = true));
                                        let given_map = {};
                                        while (cards.length) {
                                            let result;
                                            if (cards.length == 1) result = { bool: true, links: cards.slice() };
                                            else {
                                                result = await player
                                                    .chooseCardButton("完杀：请选择要分配的牌", cards, [1, cards.length], true)
                                                    .set("ai", button => {
                                                        if (!ui.selected.buttons.length) return get.buttonValue(button);
                                                        return 0;
                                                    })
                                                    .forResult();
                                            }
                                            const gives = result.links;
                                            const result2 = await player
                                                .chooseTarget("选择获得" + get.translation(gives) + "的角色", true, (card, player, target) => {
                                                    return target != get.event().getTrigger().player;
                                                })
                                                .set("ai", target => {
                                                    return get.attitude(get.event("player"), target) * get.sgn(get.sgn(get.event("goon")) + 0.5);
                                                })
                                                .set(
                                                    "goon",
                                                    gives.reduce((sum, card) => sum + get.value(card), 0)
                                                )
                                                .forResult();
                                            if (result2.bool) {
                                                cards.removeArray(gives);
                                                const id = result2.targets[0].playerid;
                                                if (!given_map[id]) given_map[id] = [];
                                                given_map[id].addArray(gives);
                                            }
                                        }
                                        if (_status.connectMode) game.broadcastAll(() => delete _status.noclearcountdown);
                                        let list = [];
                                        for (const i in given_map) {
                                            const source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                            player.line(source, "green");
                                            game.log(source, "获得了", given_map[i]);
                                            list.push([source, given_map[i]]);
                                        }
                                        await game
                                            .loseAsync({
                                                gain_list: list,
                                                giver: player,
                                                animate: "gain2",
                                            })
                                            .setContent("gaincardMultiple");
                                    } else if (result.index) {
                                        const discard = target.getCards(position).removeArray(cards);
                                        if (discard.length) await target.discard(discard);
                                    }
                                },
                                global: "old_sbwansha_global",
                                subSkill: {
                                    global: {
                                        mod: {
                                            cardEnabled(card, player) {
                                                var source = _status.currentPhase;
                                                if (card.name == "tao" && source && source != player && source.hasSkill("old_sbwansha") && !player.isDying()) return false;
                                            },
                                            cardSavable(card, player) {
                                                var source = _status.currentPhase;
                                                if (card.name == "tao" && source && source != player && source.hasSkill("old_sbwansha") && !player.isDying()) return false;
                                            },
                                        },
                                    },
                                },
                            },
                            old_sbluanwu: {
                                audio: "sbluanwu",
                                logAudio: () => 2,
                                unique: true,
                                enable: "phaseUse",
                                limited: true,
                                skillAnimation: "epic",
                                animationColor: "thunder",
                                filterTarget(card, player, target) {
                                    return target !== player;
                                },
                                selectTarget: -1,
                                multitarget: true,
                                multiline: true,
                                contentBefore() {
                                    player.addTempSkill("old_sbluanwu_add");
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    const currented = [player];
                                    let current = player.next;
                                    do {
                                        currented.push(current);
                                        current.addTempClass("target");
                                        const bool = await current
                                            .chooseToUse(
                                                "乱武：对除" + get.translation(player) + "以外的一名其他角色使用一张杀或失去1点体力",
                                                function (card) {
                                                    if (get.name(card) !== "sha") return false;
                                                    return lib.filter.cardEnabled.apply(this, arguments);
                                                },
                                                function (card, player, target) {
                                                    if (target === player || target === get.event("jx")) return false;
                                                    const dist = get.distance(player, target);
                                                    if (dist > 1) {
                                                        if (
                                                            game.hasPlayer(function (current) {
                                                                return current != player && get.distance(player, current) < dist;
                                                            })
                                                        ) {
                                                            return false;
                                                        }
                                                    }
                                                    return lib.filter.filterTarget.apply(this, arguments);
                                                }
                                            )
                                            .set("jx", player)
                                            .set("ai2", function () {
                                                return get.effect_use.apply(this, arguments) + 0.01;
                                            })
                                            .set("addCount", false)
                                            .forResultBool();
                                        if (!bool) await current.loseHp();
                                        current = current.next;
                                    } while (!currented.includes(current) && !void (await game.delay(0.5)));
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        player(player) {
                                            if (lib.config.mode === "identity" && game.zhu.isZhu && player.identity === "fan") {
                                                if (game.zhu.hp === 1 && game.zhu.countCards("h") <= 2) return 1;
                                            }
                                            const players = game.filterPlayer(cur => cur !== player);
                                            let num = 0;
                                            for (let i = 0; i < players.length; i++) {
                                                let att = get.sgnAttitude(player, players[i]);
                                                if (players[i].hp <= 3) {
                                                    const hs = players[i].countCards("hs");
                                                    if (hs === 0) num += att / players[i].hp;
                                                    else if (hs === 1) num += att / 2 / players[i].hp;
                                                    else if (hs === 2) num += att / 4 / players[i].hp;
                                                }
                                                if (players[i].hp === 1) num += att * 1.5;
                                            }
                                            if (player.hp === 1) {
                                                return -num;
                                            }
                                            return -game.players.length / 4 - num;
                                        },
                                    },
                                },
                                subSkill: {
                                    add: {
                                        audio: ["sbluanwu3.mp3", "sbluanwu4.mp3"],
                                        trigger: {
                                            global: "loseHpEnd",
                                        },
                                        filter(event, player) {
                                            if (event.getParent().name != "old_sbluanwu") return false;
                                            return ["old_sbwansha", "old_sbweimu"].some(skill => player.hasSkill(skill, null, null, false) && !player.storage[skill]);
                                        },
                                        async cost(event, trigger, player) {
                                            const choices = [],
                                                list = ["old_sbwansha", "old_sbweimu"];
                                            const choiceList = ["修改【完杀】", "修改【帷幕】"];
                                            for (let i = 0; i < 2; i++) {
                                                if (!player.hasSkill(list[i], null, null, false) || player.storage[list[i]]) {
                                                    choiceList[i] = '<span style="opacity:0.5;">' + choiceList[i] + "</span>";
                                                } else choices.push(`选项${get.cnNumber(i + 1, true)}`);
                                            }
                                            const control = await player
                                                .chooseControl(choices, "cancel2")
                                                .set("choiceList", choiceList)
                                                .set("prompt", get.prompt(event.name.slice(0, -5)))
                                                .set("ai", () => {
                                                    const choices = get.event().controls.slice().remove("cancel2");
                                                    return choices.randomGet();
                                                })
                                                .forResultControl();
                                            event.result = {
                                                bool: control != "cancel2",
                                                cost_data: control,
                                            };
                                        },
                                        async content(event, trigger, player) {
                                            const list = ["old_sbwansha", "old_sbweimu"],
                                                index = ["选项一", "选项二"].indexOf(event.cost_data);
                                            player.storage[list[index]] = true;
                                        },
                                    },
                                },
                                derivation: ["old_sbwansha_rewrite", "old_sbweimu_rewrite"],
                            },
                            old_sbwansha_rewrite: {
                                nopop: true,
                            },
                            old_sbweimu_rewrite: {
                                nopop: true,
                            },
                            old_sbweimu: {
                                audio: "sbweimu",
                                trigger: {
                                    player: "addJudgeBefore",
                                    target: "useCardToTarget",
                                    global: "roundStart",
                                },
                                logAudio: index => (typeof index === "number" ? "sbweimu" + index + ".mp3" : 4),
                                filter(event, player) {
                                    if (event.name == "useCardToTarget") return get.type(event.card, null, false) == "trick" && get.color(event.card) == "black";
                                    if (event.name == "addJudge") return get.color(event.card) == "black";
                                    if (!player.storage.old_sbweimu || game.roundNumber < 2) return false;
                                    let num = 0;
                                    game.countPlayer2(current => {
                                        if (player == current) return false;
                                        num += current.getRoundHistory("useCard", evt => evt.targets?.includes(player), 1).length;
                                    });
                                    return num <= 2 && Array.from(ui.discardPile.childNodes).some(card => get.info("old_sbweimu").filterCardx(card));
                                },
                                filterCardx(card) {
                                    return get.subtype(card) == "equip2" || (get.type(card) == "trick" && get.color(card) == "black");
                                },
                                forced: true,
                                popup: false,
                                async content(event, trigger, player) {
                                    if (trigger.name == "useCardToTarget" || trigger.name == "addJudge") player.logSkill("old_sbweimu", null, null, null, [get.rand(1, 2)]);
                                    else player.logSkill("old_sbweimu", null, null, null, [get.rand(3, 4)]);
                                    if (trigger.name == "useCardToTarget") {
                                        trigger.targets.remove(player);
                                        trigger.getParent().triggeredTargets2.remove(player);
                                        trigger.untrigger();
                                    } else if (trigger.name == "addJudge") {
                                        trigger.cancel();
                                        const owner = get.owner(trigger.card);
                                        if (owner?.getCards("hej").includes(trigger.card)) await owner.lose(trigger.card, ui.discardPile);
                                        else await game.cardsDiscard(trigger.card);
                                        game.log(trigger.card, "进入了弃牌堆");
                                    } else {
                                        const cards = Array.from(ui.discardPile.childNodes).filter(card => get.info("old_sbweimu").filterCardx(card));
                                        await player.gain(cards.randomGet(), "gain2");
                                    }
                                },
                                ai: {
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.type(card, "trick") == "trick" && get.color(card) == "black") return "zeroplayertarget";
                                        },
                                    },
                                },
                            },
                            //谋诸葛瑾
                            old_sbhuanshi: {
                                audio: "sbhuanshi",
                                trigger: { global: "judge" },
                                filter(event, player) {
                                    return player.countCards("hs") + player.hp > 0;
                                },
                                async cost(event, trigger, player) {
                                    let cardsx = get.cards(player.hp, true).map(card => {
                                        var cardx = ui.create.card();
                                        cardx.init(get.cardInfo(card));
                                        cardx._cardid = card.cardid;
                                        cardx.preCard = card;
                                        return cardx;
                                    });
                                    if (cardsx.length) player.directgains(cardsx, null, "old_sbhuanshi_tag");
                                    let {
                                        result: { bool, cards },
                                    } = await player
                                        .chooseCard(get.translation(trigger.player) + "的" + (trigger.judgestr || "") + "判定为" + get.translation(trigger.player.judging[0]) + "，" + get.prompt("old_sbhuanshi"), "hs", card => {
                                            const player = _status.event.player;
                                            const mod2 = game.checkMod(card, player, "unchanged", "cardEnabled2", player);
                                            if (mod2 != "unchanged") return mod2;
                                            const mod = game.checkMod(card, player, "unchanged", "cardRespondable", player);
                                            if (mod != "unchanged") return mod;
                                            return true;
                                        })
                                        .set("ai", card => {
                                            const trigger = _status.event.getTrigger();
                                            const player = _status.event.player;
                                            const judging = _status.event.judging;
                                            const result = trigger.judge(card) - trigger.judge(judging);
                                            const attitude = get.attitude(player, trigger.player);
                                            if (attitude == 0 || result == 0) return 0;
                                            if (get.event("pile").includes(card)) return attitude > 0 ? result : -result;
                                            if (attitude > 0) {
                                                return result - get.value(card) * 0.3;
                                            } else {
                                                return -result - get.value(card) * 0.3;
                                            }
                                        })
                                        .set("judging", trigger.player.judging[0])
                                        .set("pile", cardsx);

                                    cardsx = player.getCards("s", card => card.hasGaintag("old_sbhuanshi_tag"));
                                    if (cardsx.length) {
                                        if (cards) {
                                            cards = cards.map(card => {
                                                if (cardsx.includes(card)) return card.preCard;
                                                return card;
                                            });
                                        }
                                        if (player.isOnline2()) {
                                            player.send(
                                                function (cards, player) {
                                                    cards.forEach(i => i.delete());
                                                    if (player == game.me) ui.updatehl();
                                                },
                                                cardsx,
                                                player
                                            );
                                        }
                                        cardsx.forEach(i => i.delete());
                                        if (player == game.me) ui.updatehl();
                                    }

                                    event.result = {
                                        bool: bool,
                                        cards: cards,
                                        skill_popup: false,
                                    };
                                },
                                async content(event, trigger, player) {
                                    const cards = event.cards;
                                    await player.respond(cards, "old_sbhuanshi", "highlight", "noOrdering");
                                    if (trigger.player.judging[0].clone) {
                                        trigger.player.judging[0].clone.classList.remove("thrownhighlight");
                                        game.broadcast(function (card) {
                                            if (card.clone) {
                                                card.clone.classList.remove("thrownhighlight");
                                            }
                                        }, trigger.player.judging[0]);
                                        game.addVideo("deletenode", player, get.cardsInfo([trigger.player.judging[0].clone]));
                                    }
                                    game.cardsDiscard(trigger.player.judging[0]);
                                    trigger.player.judging[0] = cards[0];
                                    trigger.orderingCards.addArray(cards);
                                    game.log(trigger.player, "的判定牌改为", cards[0]);
                                    await game.delay(2);
                                },
                                locked: false,
                                mod: {
                                    cardRespondable(card, player) {
                                        if (!card.preCard) return;
                                        return _status.event?.getParent()?.name == "old_sbhuanshi_cost";
                                    },
                                },
                                ai: {
                                    rejudge: true,
                                    tag: {
                                        rejudge: 1,
                                    },
                                },
                            },
                            old_sbhongyuan: {
                                audio: "sbhongyuan",
                                trigger: {
                                    global: ["loseAfter", "equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                },
                                chargeSkill: 4,
                                getIndex(event, player) {
                                    if (!player.countCharge()) return [];
                                    let list = [];
                                    if (event.getg && event.getg(player)?.length > 1) list.push([player, "gain"]);
                                    if (!event.getl) return list;
                                    for (let target of game.players) {
                                        let evt = event.getl(target);
                                        if (!evt || !evt.cards2 || !evt.cards2.length) continue;
                                    }
                                    return game
                                        .filterPlayer(current => {
                                            if (current == player) return event.getg && event.getg(player)?.length > 1;
                                            if (!event.getl) return false;
                                            let evt = event.getl(current);
                                            if (!evt || !evt.cards2) return false;
                                            return evt.cards2.length > 1;
                                        })
                                        .sortBySeat();
                                },
                                filter(event, player) {
                                    return player.countCharge();
                                },
                                async cost(event, trigger, player) {
                                    const target = event.indexedData;
                                    if (target == player) {
                                        event.result = await player
                                            .chooseTarget([1, 2], get.prompt("old_sbhongyuan"), "令至多两名角色各摸一张牌")
                                            .set("ai", target => {
                                                const player = get.player();
                                                return get.effect(target, { name: "draw" }, player, player);
                                            })
                                            .forResult();
                                        event.result.cost_data = "gain";
                                    } else {
                                        event.result = await player
                                            .chooseBool(get.prompt("old_sbhongyuan", target), "令其摸两张牌")
                                            .set("choice", get.effect(target, { name: "draw" }, player, player) > 0)
                                            .forResult();
                                        event.result.targets = [target];
                                        event.result.cost_data = "lose";
                                    }
                                },
                                async content(event, trigger, player) {
                                    player.removeCharge();
                                    if (event.cost_data == "gain") {
                                        const targets = event.targets;
                                        await game.asyncDraw(targets);
                                    } else {
                                        const target = event.targets[0];
                                        await target.draw(2);
                                    }
                                },
                                group: "old_sbhongyuan_init",
                                subSkill: {
                                    init: {
                                        audio: "sbhongyuan",
                                        trigger: {
                                            player: "enterGame",
                                            global: "phaseBefore",
                                        },
                                        filter(event, player) {
                                            return event.name != "phase" || game.phaseNumber == 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            player.addCharge();
                                        },
                                    },
                                },
                                ai: {
                                    combo: "old_sbmingzhe",
                                },
                            },
                            old_sbmingzhe: {
                                audio: "sbmingzhe",
                                trigger: {
                                    player: "loseAfter",
                                    global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                },
                                locked: true,
                                filter(event, player) {
                                    if (player == _status.currentPhase) return false;
                                    if (player.countMark("old_sbmingzhe_used") >= 3) return false;
                                    var evt = event.getl(player);
                                    return evt.cards2?.length;
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player
                                        .chooseTarget(get.prompt2("old_sbmingzhe"), true)
                                        .set("ai", target => {
                                            const player = get.player();
                                            let eff = get.effect(target, { name: "draw" }, player, player);
                                            if (target.countCharge(true) > 0) eff *= 2.1;
                                            return eff;
                                        })
                                        .forResult();
                                },
                                async content(event, trigger, player) {
                                    player.addTempSkill("old_sbmingzhe_used", "roundStart");
                                    player.addMark("old_sbmingzhe_used", 1, false);
                                    const target = event.targets[0];
                                    const cards = trigger.getl(player).cards2;
                                    if (target.countCharge(true)) target.addCharge();
                                    if (cards.some(card => get.type(card) != "basic")) await target.draw();
                                },
                                ai: {
                                    effect: {
                                        player(card, player, target) {
                                            if (player === _status.currentPhase || player.countMark("old_sbmingzhe_used") >= 2) return;
                                            if (typeof card === "object" && get.position(card) === "h") return [1, 1];
                                        },
                                        target(card, player, target) {
                                            if (target === _status.currentPhase || target.countMark("old_sbmingzhe_used") >= 2) return;
                                            if (get.tag(card, "lose") || get.tag(card, "discard")) return [1, 1];
                                        },
                                    },
                                },
                                subSkill: {
                                    used: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                            },
                            //谋张辽
                            old_sbtuxi: {
                                audio: "sbtuxi",
                                trigger: {
                                    player: "gainAfter",
                                    global: "loseAsyncAfter",
                                },
                                filter(event, player) {
                                    if (player != _status.currentPhase || event.getParent("old_sbtuxi").player == player) return false;
                                    return event.getg(player).length;
                                },
                                usable: 3,
                                async cost(event, trigger, player) {
                                    const cards = trigger.getg(player).filter(i => get.owner(i) == player);
                                    event.result = await player
                                        .chooseCard(get.prompt(event.name.slice(0, -5)), "将本次获得的任意张牌置于弃牌堆，然后获得至多等量名其他角色的各一张手牌", card => get.event().cards.includes(card), [1, cards.length])
                                        .set("ai", card => {
                                            const player = get.player();
                                            const targets = game.filterPlayer(current => player != current && current.countGainableCards(player, "h") && get.effect(current, { name: "shunshou_copy2" }, player, player) > 0);
                                            if (ui.selected.cards.length > targets.length) return 0;
                                            return 6.5 - get.value(card);
                                        })
                                        .set("cards", cards)
                                        .forResult();
                                },
                                async content(event, trigger, player) {
                                    const { cards } = event,
                                        num = cards.length;
                                    await player.loseToDiscardpile(cards);
                                    if (!game.hasPlayer(current => player != current && current.countGainableCards(player, "h"))) return;
                                    const {
                                        result: { bool, targets },
                                    } = await player
                                        .chooseTarget(
                                            `获得至多${get.cnNumber(num)}名其他角色的各一张手牌`,
                                            (card, player, target) => {
                                                return player != target && target.countGainableCards(player, "h");
                                            },
                                            [1, num],
                                            true
                                        )
                                        .set("ai", target => {
                                            const player = get.player();
                                            return get.effect(target, { name: "shunshou_copy2" }, player, player);
                                        });
                                    if (bool) await player.gainMultiple(targets.sortBySeat());
                                },
                            },
                            old_sbdengfeng: {
                                audio: "sbdengfeng",
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                filter(event, player) {
                                    return game.hasPlayer(current => player != current);
                                },
                                async cost(event, trigger, player) {
                                    const skillName = event.name.slice(0, -5);
                                    const targets = await player
                                        .chooseTarget(lib.filter.notMe, get.prompt2(skillName))
                                        .set("ai", target => {
                                            const player = get.player();
                                            const att = get.attitude(player, target);
                                            const es = target.getCards("e");
                                            if ((es.some(card => get.equipValue(card, target) <= 4) && att > 0) || (es.some(card => get.equipValue(card, target) > 7) && att < 0)) return 10;
                                            return 1;
                                        })
                                        .forResultTargets();
                                    if (!targets || !targets.length) return;
                                    const target = targets[0];
                                    const list = [];
                                    if (target.countCards("e")) list.push("选项一");
                                    list.push("选项二");
                                    list.push("背水！");
                                    list.push("cancel2");
                                    const control = await await player
                                        .chooseControl(list)
                                        .set("choiceList", [`令${get.translation(target)}获得其装备区的至多两张牌`, `获得牌堆中的一张【杀】`, "背水！失去1点体力并执行所有选项"])
                                        .set("prompt", get.prompt(skillName, target))
                                        .set("ai", () => {
                                            const { player, target } = get.event();
                                            const att = get.attitude(player, target);
                                            const es = target.getCards("e");
                                            const bool1 = (es.some(card => get.equipValue(card, target) <= 4) && att > 0) || (es.some(card => get.equipValue(card, target) > 7) && att < 0);
                                            const bool2 = !player.countCards("hs", { name: "sha" }) || player.hasSkill("old_sbtuxi");
                                            if (bool1 && bool2 && (player.getHp() > 2 || get.effect(player, { name: "losehp" }, player, player) > 0)) return "背水！";
                                            if (bool1) return "选项一";
                                            if (bool2) return "选项二";
                                            return "cancel2";
                                        })
                                        .set("target", target)
                                        .forResultControl();
                                    event.result = {
                                        bool: control != "cancel2",
                                        targets: targets,
                                        cost_data: control,
                                    };
                                },
                                async content(event, trigger, player) {
                                    const {
                                        cost_data: control,
                                        targets: [target],
                                    } = event;
                                    if (control == "背水！") await player.loseHp();
                                    if (["选项一", "背水！"].includes(control) && target.countCards("e")) {
                                        const cards = await player.choosePlayerCard(target, true, "e", [1, 2], `选择${get.translation(target)}至多两张装备牌令其获得之`).forResultCards();
                                        if (cards?.length) await target.gain(cards, "gain2");
                                    }
                                    if (["选项二", "背水！"].includes(control)) {
                                        const card = get.cardPile2(card => card.name == "sha");
                                        if (card) await player.gain(card, "gain2");
                                    }
                                },
                            },
                            //谋郭嘉
                            old_sbyiji: {
                                audio: "sbyiji",
                                trigger: { player: ["damageEnd", "dying"] },
                                filter(event, player, name) {
                                    if (event.name == "damage") return event.num > 0;
                                    const history = game.getAllGlobalHistory();
                                    for (let i = history.length - 1; i >= 0; i--) {
                                        const evt = history[i]["everything"];
                                        for (let j = evt.length - 1; j >= 0; j--) {
                                            if (evt[j].name == "dying" && evt[j].player == player && evt[j] != event) return false;
                                        }
                                        if (history[i].isRound) break;
                                    }
                                    return true;
                                },
                                frequent: true,
                                async content(event, trigger, player) {
                                    const mode = get.mode(),
                                        name = trigger.name,
                                        //yiji = mode === "identity" || (mode === "doudizhu" && name === "dying");
                                        yiji = false;
                                    //let num = name === "damage" || !["identity", "doudizhu"].includes(mode) ? 2 : 1;
                                    let num = 2;
                                    const next = player.draw(num);
                                    if (yiji) next.gaintag = ["old_sbyiji"];
                                    await next;
                                    if (!game.hasPlayer(target => target != player) || !player.hasCard(card => !yiji || card.hasGaintag("old_sbyiji"), "h")) return;
                                    if (_status.connectMode) game.broadcastAll(() => (_status.noclearcountdown = true));
                                    let given_map = [];
                                    while (
                                        num > 0 &&
                                        player.hasCard(card => {
                                            if (card.hasGaintag("olsujian_given")) return false;
                                            return !yiji || card.hasGaintag("old_sbyiji");
                                        }, "h")
                                    ) {
                                        const {
                                            result: { bool, cards, targets },
                                        } = await player.chooseCardTarget({
                                            filterCard(card, player) {
                                                if (card.hasGaintag("olsujian_given")) return false;
                                                return !get.event().yiji || card.hasGaintag("old_sbyiji");
                                            },
                                            selectCard: [1, num],
                                            filterTarget: lib.filter.notMe,
                                            prompt: "遗计：请选择要分配的卡牌和目标",
                                            prompt2: "（还可分配" + num + "张）",
                                            ai1(card) {
                                                return !ui.selected.cards.length && card.name == "du" ? 1 : 0;
                                            },
                                            ai2(target) {
                                                const player = get.event("player");
                                                const card = ui.selected.cards[0];
                                                if (card) return get.value(card, target) * get.attitude(player, target);
                                                return 0;
                                            },
                                            yiji: yiji,
                                            position: "eh".slice(-1 + (name === "dying")), //三若为，怎么若都为构思
                                        });
                                        if (bool) {
                                            num -= cards.length;
                                            const target = targets[0];
                                            if (given_map.some(i => i[0] == target)) {
                                                given_map[given_map.indexOf(given_map.find(i => i[0] == target))][1].addArray(cards);
                                            } else given_map.push([target, cards]);
                                            player.addGaintag(cards, "olsujian_given");
                                        } else break;
                                    }
                                    if (_status.connectMode) {
                                        game.broadcastAll(() => {
                                            delete _status.noclearcountdown;
                                            game.stopCountChoose();
                                        });
                                    }
                                    if (yiji) player.removeGaintag("old_sbyiji");
                                    if (given_map.length) {
                                        await game
                                            .loseAsync({
                                                gain_list: given_map,
                                                player: player,
                                                cards: given_map.slice().map(list => list[1]),
                                                giver: player,
                                                animate: "giveAuto",
                                            })
                                            .setContent("gaincardMultiple");
                                    }
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, "damage")) {
                                                if (player.hasSkillTag("jueqing", false, target)) return [1, -2];
                                                if (!target.hasFriend()) return;
                                                if (target.hp >= 4) return [1, 2];
                                                if (target.hp == 3) return [1, 1.5];
                                                if (target.hp == 2) return [1, 0.5];
                                            }
                                        },
                                    },
                                },
                            },
                            //谋高顺
                            old_sbxianzhen: {
                                audio: "sbxianzhen",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget(card, player, target) {
                                    // if (get.mode() === "identity" && target.getHp() >= player.getHp()) return false;
                                    return target !== player;
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    player.addTempSkill("old_sbxianzhen_attack", "phaseUseAfter");
                                    player.markAuto("old_sbxianzhen_attack", target);
                                },
                                ai: {
                                    expose: 0.2,
                                    order(item, player) {
                                        return get.order({ name: "sha" }) + 1;
                                    },
                                    result: {
                                        target(player, target) {
                                            if (
                                                !player.countCards("hs", card => {
                                                    return get.name(card) === "sha" && player.canUse(card, target, false);
                                                })
                                            )
                                                return -0.1;
                                            if (target.countCards("h") === 1 && player.canCompare(target)) return -2;
                                            return -1.5;
                                        },
                                    },
                                },
                                subSkill: {
                                    attack: {
                                        audio: "sbxianzhen",
                                        trigger: { player: "useCardToPlayered" },
                                        filter(event, player) {
                                            if (event.card.name !== "sha") return false;
                                            return player.getStorage("old_sbxianzhen_attack").includes(event.target) && event.target.isIn() && player.canCompare(event.target);
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        logTarget: "target",
                                        check(event, player) {
                                            return get.attitude(player, event.target) < 0;
                                        },
                                        prompt(event, player) {
                                            return `陷阵：是否与${get.translation(event.target)}拼点？`;
                                        },
                                        prompt2(event, player) {
                                            const target = event.target,
                                                card = event.card;
                                            return `若你赢，${get.translation(card)}无视防具且不计入次数，且若你本回合未以此法造成过伤害，你对其造成1点伤害；<br>若其拼点牌为【杀】，则你获得之；<br>若其拼点牌为其最后的手牌，则${get.translation(card)}对其造成伤害时，此伤害+1。`;
                                        },
                                        group: "old_sbxianzhen_record",
                                        async content(event, trigger, player) {
                                            const target = trigger.target,
                                                card = trigger.card;
                                            const next = player.chooseToCompare(target);
                                            let result = await next.forResult();
                                            if (result.bool) {
                                                target.addTempSkill("qinggang2");
                                                target.storage.qinggang2.add(card);
                                                if (trigger.addCount !== false) {
                                                    trigger.addCount = false;
                                                    const stat = player.getStat("card");
                                                    if (stat[card.name] && stat[card.name] > 0) stat[card.name]--;
                                                }
                                                game.log(card, "无视防具且不计入次数限制");
                                                if (!player.storage.old_sbxianzhen_damaged) {
                                                    player.storage.old_sbxianzhen_damaged = (player.storage.old_sbxianzhen_damaged || 0) + 1;
                                                    player.when("phaseAfter").then(() => {
                                                        delete player.storage.old_sbxianzhen_damaged;
                                                    });
                                                }
                                                if (player.storage.old_sbxianzhen_damaged <= 2) {
                                                    await target.damage();
                                                    await game.delayx();
                                                }
                                            }
                                            const toGain = [];
                                            for (const lose_list of next.lose_list) {
                                                let [comparer, cards] = lose_list;
                                                if (!Array.isArray(cards)) cards = [cards];
                                                if (comparer === player) continue;
                                                for (const card of cards) {
                                                    if (get.name(card, comparer) == "sha" && get.position(card, true) == "d") {
                                                        toGain.push(card);
                                                    }
                                                }
                                            }
                                            if (toGain.length) await player.gain(toGain, "gain2");
                                            if (player.getStorage("old_sbxianzhen_recorded").includes(target)) {
                                                const id = target.playerid;
                                                const map = trigger.getParent().customArgs;
                                                if (!map[id]) map[id] = {};
                                                if (typeof map[id].extraDamage != "number") {
                                                    map[id].extraDamage = 0;
                                                }
                                                map[id].extraDamage++;
                                                game.log(card, "对", target, "造成的伤害+1");
                                            }
                                        },
                                        intro: {
                                            content: "本阶段对$使用牌无距离限制，且使用杀指定其为目标后可以与其拼点",
                                        },
                                        mod: {
                                            targetInRange(card, player, target) {
                                                if (player.getStorage("old_sbxianzhen_attack").includes(target)) return true;
                                            },
                                        },
                                    },
                                    record: {
                                        trigger: {
                                            global: "loseAsyncEnd",
                                        },
                                        charlotte: true,
                                        silent: true,
                                        filter(event, player) {
                                            if (event.getParent(2).name !== "old_sbxianzhen_attack") return false;
                                            return game.hasPlayer(current => {
                                                if (current.countCards("h")) return false;
                                                const evt = event.getl(current);
                                                return evt && evt.hs && evt.hs.length;
                                            });
                                        },
                                        async content(event, trigger, player) {
                                            const targets = [];
                                            game.countPlayer(current => {
                                                if (current.countCards("h")) return false;
                                                const evt = trigger.getl(current);
                                                if (evt && evt.hs && evt.hs.length) targets.add(current);
                                            });
                                            if (!player.storage.old_sbxianzhen_recorded) {
                                                player.when("old_sbxianzhen_attackAfter").then(() => {
                                                    delete player.storage.old_sbxianzhen_recorded;
                                                });
                                            }
                                            player.markAuto("old_sbxianzhen_recorded", targets);
                                        },
                                    },
                                },
                            },
                            //谋陆逊
                            old_sblianying: {
                                audio: "sblianying",
                                trigger: {
                                    global: "phaseEnd",
                                },
                                filter(event, player) {
                                    if (player == event.player) return false;
                                    return true;
                                },
                                frequent: true,
                                async content(event, trigger, player) {
                                    let num = 0;
                                    num++;
                                    player.getHistory("lose", evt => {
                                        if (evt.cards2) num += evt.cards2.length;
                                    });
                                    num = Math.min(5, num);
                                    const { cards } = await game.cardsGotoOrdering(get.cards(num));
                                    if (!cards.length) return;
                                    do {
                                        const {
                                            result: { bool, links },
                                        } =
                                            cards.length == 1
                                                ? { result: { links: cards.slice(0), bool: true } }
                                                : await player.chooseCardButton("连营：请选择要分配的牌", true, cards, [1, cards.length]).set("ai", () => {
                                                    if (ui.selected.buttons.length == 0) return 1;
                                                    return 0;
                                                });
                                        if (!bool) return;
                                        cards.removeArray(links);
                                        const togive = links.slice(0);
                                        const {
                                            result: { targets },
                                        } = await player
                                            .chooseTarget("选择一名角色获得" + get.translation(links), true)
                                            .set("ai", target => {
                                                const att = get.attitude(_status.event.player, target);
                                                if (_status.event.enemy) {
                                                    return -att;
                                                } else if (att > 0) {
                                                    return att / (1 + target.countCards("h"));
                                                } else {
                                                    return att / 100;
                                                }
                                            })
                                            .set("enemy", get.value(togive[0], player, "raw") < 0);
                                        if (targets.length) await targets[0].gain(togive, "gain2");
                                    } while (cards.length > 0);
                                },
                            },

                            //族荀采
                            oldx_clanlieshi: {
                                audio: "clanlieshi",
                                enable: "phaseUse",
                                content() {
                                    "step 0";
                                    var choice = [];
                                    var list = ["受到1点火属性伤害并废除判定区", "弃置所有【闪】", "弃置所有【杀】"];
                                    for (var i = 1; i <= 3; i++) {
                                        if (i == 2 && !player.countCards("h", { name: "shan" })) list[i - 1] = '<span style="opacity:0.5">' + list[i - 1] + "</span>";
                                        else if (i == 3 && !player.countCards("h", { name: "sha" })) list[i - 1] = '<span style="opacity:0.5">' + list[i - 1] + "</span>";
                                        else choice.push("选项" + get.cnNumber(i, true));
                                    }
                                    if (choice.length)
                                        player
                                            .chooseControl(choice)
                                            .set("choiceList", list)
                                            .set("ai", function () {
                                                if (choice.length == 1) return choice[0];
                                                var player = _status.event.player;
                                                if (get.damageEffect(player, player, player, "fire") > 0) return "选项一";
                                                return choice[choice.length - 1];
                                            })
                                            .set("prompt", "烈誓：请选择一项执行，然后选择一名其他角色执行另一项");
                                    else event.finish();
                                    "step 1";
                                    var num = result.control;
                                    event.num = num;
                                    game.log(player, "选择执行", "#g【烈誓】", "的" + result.control);
                                    switch (num) {
                                        case "选项一":
                                            player.damage(1, "fire");
                                            if (!player.storage._disableJudge) player.disableJudge();
                                            break;
                                        case "选项二":
                                            player.discard(player.getCards("h", { name: "shan" }));
                                            break;
                                        case "选项三":
                                            player.discard(player.getCards("h", { name: "sha" }));
                                            break;
                                    }
                                    "step 2";
                                    if (!player.isIn() || game.countPlayer() < 2) event.finish();
                                    else
                                        player
                                            .chooseTarget("请选择一名其他角色，执行【烈誓】的剩余选项", lib.filter.notMe, true)
                                            .set("ai", function (target) {
                                                var player = _status.event.player;
                                                var choice = [],
                                                    att = get.attitude(player, target);
                                                for (var i = 1; i <= 3; i++) {
                                                    if ("选项" + get.cnNumber(i, true) == _status.event.control) continue;
                                                    else if (i == 2 && !target.countCards("h", { name: "shan" })) continue;
                                                    else if (i == 3 && !target.countCards("h", { name: "sha" })) continue;
                                                    else choice.push("选项" + get.cnNumber(i, true));
                                                }
                                                if (!choice.length) return -1 / Infinity;
                                                if (choice.length == 1) {
                                                    if (choice[0] == "选项一") return -att * 3;
                                                    return -att * 2;
                                                }
                                                return -att;
                                            })
                                            .set("control", num);
                                    "step 3";
                                    if (!result.bool) {
                                        event.finish();
                                        return;
                                    }
                                    player.addExpose(0.3);
                                    var target = result.targets[0];
                                    event.target = target;
                                    player.line(target);
                                    var choice = [];
                                    var list = ["受到1点火属性伤害并废除判定区", "弃置所有【闪】", "弃置所有【杀】"];
                                    for (var i = 1; i <= 3; i++) {
                                        if ("选项" + get.cnNumber(i, true) == num) list[i - 1] = '<span style="opacity:0.5">' + list[i - 1] + "</span>";
                                        else if (i == 2 && !target.countCards("h", { name: "shan" })) list[i - 1] = '<span style="opacity:0.5">' + list[i - 1] + "</span>";
                                        else if (i == 3 && !target.countCards("h", { name: "sha" })) list[i - 1] = '<span style="opacity:0.5">' + list[i - 1] + "</span>";
                                        else choice.push("选项" + get.cnNumber(i, true));
                                    }
                                    if (choice.length)
                                        target
                                            .chooseControl(choice)
                                            .set("choiceList", list)
                                            .set("ai", function () {
                                                if (get.damageEffect(target, target, target, "fire") > 0) return "选项一";
                                                return choice[choice.length - 1];
                                            })
                                            .set("prompt", "烈誓：请选择一项执行");
                                    else event.finish();
                                    "step 4";
                                    game.log(target, "选择执行", "#g【烈誓】", "的" + result.control);
                                    switch (result.control) {
                                        case "选项一":
                                            target.damage(1, "fire");
                                            if (!target.storage._disableJudge) target.disableJudge();
                                            break;
                                        case "选项二":
                                            target.discard(target.getCards("h", { name: "shan" }));
                                            break;
                                        case "选项三":
                                            target.discard(target.getCards("h", { name: "sha" }));
                                            break;
                                    }
                                },
                                ai: {
                                    order: 1,
                                    nokeep: true,
                                    skillTagFilter(player) {
                                        if (!player.hasSkill("bolhuanyin")) return false;
                                    },
                                    result: {
                                        player(player) {
                                            var choice = [];
                                            for (var i = 1; i <= 3; i++) {
                                                if (i == 2 && !player.countCards("h", { name: "shan" })) continue;
                                                else if (i == 3 && !player.countCards("h", { name: "sha" })) continue;
                                                else choice.push("选项" + get.cnNumber(i, true));
                                            }
                                            var control = get.damageEffect(player, player, player, "fire") > 0 ? "选项一" : choice[choice.length - 1];
                                            if (choice[choice.length - 1] == "选项一" && player.hp + player.countCards("hs", { name: ["tao", "jiu"] }) < 2 && (player.identity == "zhu" || !player.hasFriend() || !player.hasSkill("bolhuanyin") || !player.countCards("h") >= 4)) return 0;
                                            if (
                                                game.hasPlayer(function (target) {
                                                    if (get.attitude(player, target) >= 0) return false;
                                                    var list = [];
                                                    for (var i = 1; i <= 3; i++) {
                                                        if ("选项" + get.cnNumber(i, true) == control) continue;
                                                        else if (i == 2 && !target.countCards("h", { name: "shan" })) continue;
                                                        else if (i == 3 && !target.countCards("h", { name: "sha" })) continue;
                                                        else list.push("选项" + get.cnNumber(i, true));
                                                    }
                                                    if (list.length) return 1;
                                                })
                                            )
                                                return 1;
                                            return 0;
                                        },
                                    },
                                },
                            },
                            oldx_clandianzhan: {
                                audio: "clandianzhan",
                                trigger: { player: "useCardAfter" },
                                filter(event, player) {
                                    return get.info("clandianzhan").filter(event, player);
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    if (trigger.targets && trigger.targets.length == 1) {
                                        player.line(trigger.targets[0]);
                                        if (!trigger.targets[0].isLinked()) trigger.targets[0].link();
                                    }
                                    "step 1";
                                    var cards = player.getCards("h", card => get.suit(card) == get.suit(trigger.card) && player.canRecast(card));
                                    if (cards.length) player.recast(cards);
                                },
                            },
                            //族钟会
                            old_clanyuzhi: {
                                mod: {
                                    aiOrder(player, card, num) {
                                        if (card.name == "tao") return num / 114514;
                                    },
                                },
                                audio: "clanyuzhi",
                                trigger: { global: "roundStart" },
                                direct: true,
                                locked: true,
                                content() {
                                    "step 0";
                                    player.unmarkSkill("old_clanyuzhi");
                                    var num1 = 0,
                                        num2 = 0,
                                        num3 = 0,
                                        bool = true;
                                    var history = player.actionHistory;
                                    for (var i = history.length - 2; i >= 0; i--) {
                                        for (var evt of history[i].gain) {
                                            if (evt.getParent().name == "draw" && evt.getParent(2).name == "old_clanyuzhi") {
                                                if (bool) num1 += evt.cards.length;
                                                else num2 += evt.cards.length;
                                            }
                                        }
                                        if (bool) num3 += history[i].useCard.length;
                                        if (history[i].isRound) {
                                            if (bool) bool = false;
                                            else break;
                                        }
                                    }
                                    event.num1 = num1;
                                    if ((num1 > 0 && num2 > 0 && num1 > num2) || num1 > num3) {
                                        player.logSkill("old_clanyuzhi");
                                        if (num2 > 0 && num1 > num2) game.log(player, "的野心已开始膨胀", "#y(" + num1 + "张>" + num2 + "张)");
                                        if (num1 > num3) game.log(player, "的行动未达到野心", "#y(" + num3 + "张<" + num1 + "张)");
                                        if (player.hasSkill("clanbaozu", null, false, false)) player.chooseBool("迂志：是否失去〖保族〗？", "若选择“否”，则你失去1点体力").set("choice", player.awakenedSkills.includes("clanbaozu"));
                                        else event._result = { bool: false };
                                    } else event.goto(2);
                                    "step 1";
                                    if (result.bool) {
                                        player.removeSkills("clanbaozu");
                                    } else player.loseHp();
                                    "step 2";
                                    if (!player.countCards("h")) event.finish();
                                    "step 3";
                                    player
                                        .chooseCard("迂志：请展示一张手牌", "摸此牌牌名字数的牌。下一轮开始时，若本轮你使用的牌数或上一轮你以此法摸的牌数小于此牌牌名字数，则你失去1点体力。", true, function (card, player) {
                                            var num = get.cardNameLength(card);
                                            return typeof num == "number" && num > 0;
                                        })
                                        .set("ai", function (card) {
                                            if (_status.event.dying && _status.event.num > 0 && get.cardNameLength(card) > _status.event.num) return 1 / get.cardNameLength(card); //怂
                                            return get.cardNameLength(card); //勇
                                        })
                                        .set("dying", player.hp + player.countCards("hs", { name: ["tao", "jiu"] }) < 1)
                                        .set("num", event.num1);
                                    "step 4";
                                    if (result.bool) {
                                        player.logSkill("old_clanyuzhi");
                                        player.showCards(result.cards, get.translation(player) + "发动了【迂志】");
                                        player.draw(get.cardNameLength(result.cards[0]));
                                        player.storage.old_clanyuzhi = get.cardNameLength(result.cards[0]);
                                        player.markSkill("old_clanyuzhi");
                                    }
                                },
                                ai: {
                                    threaten: 3,
                                    nokeep: true,
                                },
                                onremove: true,
                                intro: { content: "本轮野心：#张" },
                            },
                            old_clanxieshu: {
                                audio: "clanxieshu",
                                trigger: { player: "damageEnd", source: "damageSource" },
                                filter(event, player) {
                                    if (!event.card) return false;
                                    var num = get.cardNameLength(event.card);
                                    return typeof num == "number" && num > 0 && player.countCards("he") > 0;
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    var num = get.cardNameLength(trigger.card),
                                        str = "";
                                    if (player.getDamagedHp() > 0) str += "并摸" + get.cnNumber(player.getDamagedHp()) + "张牌";
                                    player
                                        .chooseToDiscard(get.prompt("old_clanxieshu"), "弃置" + get.cnNumber(num) + "张牌" + str, "he", num)
                                        .set("ai", function (card) {
                                            var player = _status.event.player;
                                            var num = _status.event.num;
                                            var num2 = player.getDamagedHp();
                                            if (num < num2) return 8 - get.value(card);
                                            if (num == num2 || num2 >= 2 + num - num2) return lib.skill.zhiheng.check(card);
                                            return 0;
                                        })
                                        .set("num", num).logSkill = "old_clanxieshu";
                                    "step 1";
                                    if (result.bool && player.getDamagedHp() > 0) player.draw(player.getDamagedHp());
                                },
                                ai: { threaten: 3 },
                            },
                            //韩融
                            old_fangzhen: {
                                audio: "clanfangzhen",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget(card, player, target) {
                                    return !target.isLinked();
                                },
                                async content(event, trigger, player) {
                                    let target = event.targets[0];
                                    player.line(target);
                                    target.link(true);
                                    let seatnum = target.getSeatNum();
                                    await player.drawTo(seatnum);
                                    await player.addMark("old_fangzhen", 1, false);
                                    if (target != player) {
                                        let { result } = await player.chooseCard("he", [1, Infinity], "是否交给" + get.translation(target) + "任意张牌？").set("ai", card => 0.1 - get.value(card));
                                        if (result.bool) {
                                            player.give(result.cards, target, "give");
                                        }
                                    }
                                    if (player.countMark("old_fangzhen") == seatnum) {
                                        player.turnOver();
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        player(player, target) {
                                            if (player.isTurnedOver() && target.getSeatNum() == player.countMark("old_fangzhen") + 1) return 5;
                                            else return target.countCards("h") - player.countCards("h");
                                        },
                                    },
                                },
                            },
                            old_liuju: {
                                audio: "clanliuju",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget(card, player, target) {
                                    return player.canCompare(target);
                                },
                                async content(event, trigger, player) {
                                    let target = event.targets[0];
                                    let { result } = await player.chooseToCompare(target).set("small", true);
                                    let flag = false;
                                    if (result.tie || !result.bool) flag = true;
                                    let distance = [get.distance(player, target), get.distance(target, player)];
                                    let cards = [];
                                    game.getGlobalHistory("cardMove", evt => {
                                        if (evt.getParent(2).name === "chooseToCompare" && evt.getParent(3) === event)
                                            cards.addArray(
                                                evt.cards.filter(i => {
                                                    return get.position(i, true) == "d" && get.type(i, null, false) != "basic";
                                                })
                                            );
                                    });
                                    while (cards.length) {
                                        let cardsx = cards.filter(i => get.position(i, true) == "d" && player.hasUseTarget(i));
                                        if (!cardsx.length) break;
                                        let { result } = await player
                                            .chooseButton(["留驹：是否使用其中的一张牌？", cardsx])
                                            .set("filterButton", button => {
                                                return _status.event.player.hasUseTarget(button.link);
                                            })
                                            .set("ai", button => {
                                                return _status.event.player.getUseValue(button.link) + 0.1;
                                            });
                                        if (result.bool) {
                                            let card = result.links[0];
                                            cards.remove(card);
                                            player.$gain2(card, false);
                                            game.delayx();
                                            await player.chooseUseTarget(true, card, false);
                                        } else break;
                                    }
                                    if (get.distance(player, target) != distance[0] || get.distance(target, player) != distance[1]) flag = true;
                                    if (flag) {
                                        let { result } = await player.chooseControl(["复原武将牌", "复原武将牌上一个技能", "cancel2"]).set(ai, function () {
                                            let player = _status.event.player;
                                            if (player.isTurnedOver()) return 0;
                                            else return 1;
                                        });
                                        if (result.index == 0) {
                                            if (player.isTurnedOver()) player.turnOver();
                                            player.link(false);
                                        } else if (result.index == 1) {
                                            let list = player.getStockSkills(true, true);
                                            if (!list.length) event.finish();
                                            let result2 = await player
                                                .chooseControl(list)
                                                .set("prompt", "请选择复原一个武将牌上的技能")
                                                .set("ai", function () {
                                                    for (let i = 0; i < list.length; i++) {
                                                        if (list[i] == "old_liuju") return i;
                                                        let translation = get.skillInfoTranslation(list[i], player);
                                                        if (get.plainText(translation).match(/“?出牌阶段限一次/g) || get.plainText(translation).match(/“?限定技/g)) return i;
                                                    }
                                                    return 0;
                                                })
                                                .forResult();
                                            let skill = list[result2.index];
                                            let suffixs = ["used", "round", "block", "blocker"];
                                            let info = get.info(skill);
                                            if (typeof info.usable == "number") {
                                                if (player.hasSkill("counttrigger") && player.storage.counttrigger[skill] && player.storage.counttrigger[skill] >= 1) {
                                                    delete player.storage.counttrigger[skill];
                                                }
                                                if (typeof get.skillCount(skill) == "number" && get.skillCount(skill) >= 1) {
                                                    delete player.getStat("skill")[skill];
                                                }
                                            }
                                            if (info.round && player.storage[skill + "_roundcount"]) {
                                                delete player.storage[skill + "_roundcount"];
                                            }
                                            if (player.storage[`temp_ban_${skill}`]) {
                                                delete player.storage[`temp_ban_${skill}`];
                                            }
                                            if (player.awakenedSkills.includes(skill)) {
                                                player.restoreSkill(skill);
                                            }
                                            for (let suffix of suffixs) {
                                                if (player.hasSkill(skill + "_" + suffix)) {
                                                    player.removeSkill(skill + "_" + suffix);
                                                }
                                            }
                                            let str = "【" + get.translation(skill) + "】";
                                            game.log(player, "重置了技能", "#g" + str.slice(0, -1));
                                        }
                                    }
                                },
                                ai: {
                                    order: 6,
                                    result: {
                                        target: -1,
                                    },
                                },
                            },
                            old_xumin: {
                                audio: "ext:凌梦自用/audio/skill:2",
                                old_olzhiyan2: { old_clan_hanshao: "old_xumin_old_clan_hanshao" },
                                limited: true,
                                clanSkill: true,
                                skillAnimation: true,
                                animationColor: "soil",
                                enable: "phaseUse",
                                selectTarget: [1, Infinity],
                                multitarget: true,
                                multiline: true,
                                filterTarget(crad, player, target) {
                                    return target.countCards("h") < player.countCards("h");
                                },
                                content() {
                                    "step 0";
                                    player.awakenSkill("old_xumin");
                                    player.turnOver();
                                    "step 1";
                                    var targets = targets.sortBySeat();
                                    var wugu = new lib.element.VCard({ name: "wugu" });
                                    var targety = targets.filter(target => player.canUse(wugu, target, false));
                                    player.useCard(wugu, targety, false);
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        target: 1,
                                        player(player, target) {
                                            if (
                                                game.countPlayer(function (target) {
                                                    return get.attitude(player, target) > 0 && player.countCards("h") > target.countCards("h") && player.canUse("wugu", target);
                                                }) >= 3
                                            )
                                                return 3;
                                            else return player.isTurnedOver() ? 1 : 0;
                                        },
                                    },
                                },
                            },
                            old_xumin_old_clan_hanshao: {
                                audio: "ext:凌梦自用/audio/skill:2",
                            },
                            //韩韶
                            old_huanjia: {
                                audio: "clanhuanjia",
                                usable: 1,
                                enable: "phaseUse",
                                filterTarget(card, player, target) {
                                    return player.canCompare(target);
                                },
                                async content(event, trigger, player) {
                                    const { result } = await player.chooseToCompare(event.target);
                                    if (!result.tie) {
                                        let winner = result.bool ? player : event.target;
                                        if (winner.sex == "male") {
                                            winner.addSkill("old_huanjia_eff");
                                        }
                                    }
                                },
                                ai: {
                                    result: { target: -1 },
                                    order: 6,
                                },
                                subSkill: {
                                    eff: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        intro: {
                                            content: "下次发动“出牌阶段限一次”的技能后重置之",
                                        },
                                        direct: true,
                                        trigger: {
                                            player: ["useSkill", "logSkill"],
                                        },
                                        filter(event, player) {
                                            if (event.type != "player") return false;
                                            var skill = event.sourceSkill || event.skill;
                                            var info = get.info(skill);
                                            if (info.charlotte) return false;
                                            var translation = get.skillInfoTranslation(skill, event.player);
                                            if (!translation) return false;
                                            var match = get.plainText(translation).match(/“?出牌阶段限一次/g);
                                            if (!match || match.every(value => value != "出牌阶段限一次")) return false;
                                            return true;
                                        },
                                        async content(event, trigger, player) {
                                            player.removeSkill("old_huanjia_eff");
                                            let skill = trigger.sourceSkill || trigger.skill;
                                            let suffixs = ["used", "round", "block", "blocker"];
                                            let info = get.info(skill);
                                            if (typeof info.usable == "number") {
                                                if (player.hasSkill("counttrigger") && player.storage.counttrigger[skill] && player.storage.counttrigger[skill] >= 1) {
                                                    delete player.storage.counttrigger[skill];
                                                }
                                                if (typeof get.skillCount(skill) == "number" && get.skillCount(skill) >= 1) {
                                                    delete player.getStat("skill")[skill];
                                                }
                                            }
                                            if (info.round && player.storage[skill + "_roundcount"]) {
                                                delete player.storage[skill + "_roundcount"];
                                            }
                                            if (player.storage[`temp_ban_${skill}`]) {
                                                delete player.storage[`temp_ban_${skill}`];
                                            }
                                            if (player.awakenedSkills.includes(skill)) {
                                                player.restoreSkill(skill);
                                            }
                                            for (let suffix of suffixs) {
                                                if (player.hasSkill(skill + "_" + suffix)) {
                                                    player.removeSkill(skill + "_" + suffix);
                                                }
                                            }
                                            let str = "【" + get.translation(skill) + "】";
                                            game.log(player, "重置了技能", "#g" + str.slice(0, -1));
                                        },
                                    },
                                },
                            },
                            old_lianhe: {
                                audio: "clanlianhe",
                                enable: "phaseUse",
                                usable: 1,
                                selectTarget: 2,
                                multitarget: true,
                                filterTarget(card, player, target) {
                                    return !target.isLinked();
                                },
                                async content(event, trigger, player) {
                                    let targetlist = event.targets.sortBySeat();
                                    player.line(event.targets);
                                    for (let i of targetlist) {
                                        i.link(true);
                                    }
                                    let list = [];
                                    for (let i of targetlist) {
                                        let result;
                                        if (!i.countGainableCards(player, "he")) {
                                            result = { index: 0 };
                                        } else {
                                            let translation = get.translation(player);
                                            result = await i
                                                .chooseControl()
                                                .set("prompt", "选择令" + translation + "执行一项：")
                                                .set("choiceList", ["令" + translation + "摸一张牌", "令" + translation + "获得你一张牌并翻面"])
                                                .set("ai", function () {
                                                    if (get.attitude(i, player) > 0) return 0;
                                                    else if (Math.random() > 0.5) return 0;
                                                    else return 1;
                                                })
                                                .forResult();
                                        }
                                        list.push([result.index, i]);
                                    }
                                    game.delay();
                                    if (list.length) {
                                        for (let i = 0; i < list.length; i++) {
                                            player.line(list[i][1]);
                                            if (list[i][0] == 0) {
                                                player.draw();
                                            } else {
                                                await player.gainPlayerCard(i, "he", true);
                                                player.turnOver();
                                            }
                                            list[i][1].addTempSkill("old_lianhe_eff", { player: "phaseUseAfter" });
                                            list[i][1].markAuto("old_lianhe_eff", [player]);
                                        }
                                    }
                                },
                                ai: {
                                    result: { player: 1 },
                                    order: 5,
                                },
                                isEmptyObjet(obj) {
                                    for (var key in obj) {
                                        return false;
                                    }
                                    return true;
                                },
                                subSkill: {
                                    eff: {
                                        charlotte: true,
                                        direct: true,
                                        trigger: { player: "phaseUseEnd" },
                                        filter(event, player) {
                                            for (var i of player.getStorage("old_lianhe_eff")) {
                                                if (i.isIn()) return true;
                                            }
                                            return false;
                                        },
                                        async content(event, trigger, player) {
                                            let targetlist = player
                                                .getStorage("old_lianhe_eff")
                                                .sortBySeat()
                                                .filter(i => i.isIn());
                                            for (let i of targetlist) {
                                                player.line(i);
                                                let num1 = 0;
                                                let history = player.getHistory("gain", function (evt) {
                                                    if (lib.skill.old_lianhe.isEmptyObjet(evt.getParent("phaseUse"))) return false;
                                                    else {
                                                        num1 += evt.cards.length;
                                                        return true;
                                                    }
                                                });
                                                let num = Math.min(5, num1);
                                                let totalIndex = 0;
                                                while (totalIndex <= num && i.isIn()) {
                                                    let translation = get.translation(i);
                                                    let result;
                                                    if (!player.countGainableCards(i, "he")) {
                                                        result = { index: 0 };
                                                    } else {
                                                        result = await player
                                                            .chooseControl()
                                                            .set("prompt", "选择令" + translation + "执行一项<br>当前序号和：" + totalIndex + "  本阶段获得牌数：" + num1)
                                                            .set("choiceList", ["令" + translation + "摸一张牌", "令" + translation + "获得你一张牌并翻面"])
                                                            .set("ai", function () {
                                                                let rest = num - totalIndex;
                                                                if (get.attitude(player, i) > 0) return 0;
                                                                else if (rest >= 3) return 0;
                                                                else return i.isTurnedOver() ? 0 : 1;
                                                            })
                                                            .forResult();
                                                    }
                                                    if (result.index == 1) {
                                                        await i.gainPlayerCard(player, "he", true);
                                                        i.turnOver();
                                                    } else i.draw();
                                                    totalIndex += result.index + 1;
                                                }
                                            }
                                        },
                                    },
                                },
                            },
                            //滕芳兰
                            old_luochong: {
                                audio: "luochong",
                                trigger: {
                                    player: ["phaseZhunbeiBegin", "damageEnd"],
                                },
                                direct: true,
                                filter(event, player) {
                                    var bool = false;
                                    for (var i = 0; i < 4; i++) {
                                        if (!player.storage.old_luochong[i] && !player.storage.old_luochong_round[i]) bool = true;
                                    }
                                    return bool;
                                },
                                init(player) {
                                    player.storage.old_luochong = [false, false, false, false];
                                    player.storage.old_luochong_round = [false, false, false, false];
                                },
                                onremove: true,
                                content() {
                                    "step 0";
                                    var list = [];
                                    var choiceList = ["令一名角色回复1点体力。", "令一名角色失去1点体力。", "弃置至多两名角色场上的各一张牌。", "摸两张牌，并可以将其分配给任意角色。"];
                                    for (var i = 0; i < 4; i++) {
                                        if (player.storage.old_luochong[i]) choiceList[i] += "（已移除）";
                                        else if (player.storage.old_luochong_round[i]) choiceList[i] += "（本轮已发动过）";
                                        else {
                                            if (
                                                i == 0 &&
                                                game.hasPlayer(function (current) {
                                                    return current.isDamaged();
                                                })
                                            )
                                                list.push("选项一");
                                            if (i == 1) list.push("选项二");
                                            if (
                                                i == 2 &&
                                                game.countPlayer(function (current) {
                                                    return current.countDiscardableCards(player, "ej") > 0;
                                                }) > 0
                                            )
                                                list.push("选项三");
                                            if (i == 3) list.push("选项四");
                                        }
                                    }
                                    list.push("cancel2");
                                    player
                                        .chooseControl(list)
                                        .set("prompt", get.prompt("old_luochong"))
                                        .set("choiceList", choiceList)
                                        .set("ai", function () {
                                            var player = _status.event.player;
                                            var list = _status.event.controls.slice(0);
                                            var gett = function (choice) {
                                                if (choice == "cancel2") return 0.1;
                                                switch (choice) {
                                                    case "选项一":
                                                        if (
                                                            game.hasPlayer(function (current) {
                                                                return get.recoverEffect(current, player, player);
                                                            })
                                                        )
                                                            return 4;
                                                        else return -1;
                                                    case "选项二":
                                                        return 5;
                                                    case "选项三":
                                                        if (
                                                            game.hasPlayer(function (target) {
                                                                return (
                                                                    6 -
                                                                    target
                                                                        .getCards("ej")
                                                                        .map(i => {
                                                                            var sign = get.sgnAttitude(_status.event.player, target);
                                                                            var val = 0;
                                                                            if (get.position(i) == "e") val = get.value(i, target);
                                                                            else {
                                                                                val = get.effect(player, { name: i.viewAs || i.name, cards: [i] }, target, target);
                                                                            }
                                                                            return sign * val;
                                                                        })
                                                                        .sort((a, b) => a - b)[0] >
                                                                    0
                                                                );
                                                            })
                                                        )
                                                            return 2;
                                                        else return -1;
                                                    case "选项四":
                                                        return 3;
                                                }
                                            };
                                            return list.sort(function (a, b) {
                                                return gett(b) - gett(a);
                                            })[0];
                                        });
                                    "step 1";
                                    if (result.control != "cancel2") {
                                        var index = ["选项一", "选项二", "选项三", "选项四"].indexOf(result.control);
                                        event.index = index;
                                        switch (index) {
                                            case 0:
                                                player
                                                    .chooseTarget("选择一名角色，令其回复1点体力", true, function (card, player, target) {
                                                        return target.isDamaged();
                                                    })
                                                    .set("ai", function (target) {
                                                        return get.attitude(_status.event.player, target);
                                                    });
                                                break;
                                            case 1:
                                                player.chooseTarget("选择一名角色，令其失去1点体力", true).set("ai", function (target) {
                                                    return -get.attitude(_status.event.player, target);
                                                });
                                                break;
                                            case 2:
                                                player
                                                    .chooseTarget("选择至多两名角色，弃置其场上各一张牌", true, [1, 2], function (card, player, target) {
                                                        return target.countDiscardableCards(player, "ej") > 0;
                                                    })
                                                    .set("ai", function (target) {
                                                        var player = _status.event.player;
                                                        var sign = get.sgnAttitude(_status.event.player, target);
                                                        return (
                                                            6 -
                                                            target
                                                                .getCards("ej")
                                                                .map(i => {
                                                                    var val = 0;
                                                                    if (get.position(i) == "e") val = get.value(i, target);
                                                                    else {
                                                                        val = get.effect(player, { name: i.viewAs || i.name, cards: [i] }, target, target);
                                                                    }
                                                                    return sign * val;
                                                                })
                                                                .sort((a, b) => a - b)[0]
                                                        );
                                                    });
                                                break;
                                            case 3:
                                                player.draw(2);
                                        }
                                    } else event.finish();
                                    "step 2";
                                    switch (event.index) {
                                        case 0:
                                            var target = result.targets[0];
                                            player.line(target, "green");
                                            target.recover();
                                            break;
                                        case 1:
                                            var target = result.targets[0];
                                            player.line(target, "green");
                                            target.loseHp();
                                            break;
                                        case 2:
                                            player.line(result.targets, "green");
                                            for (var target of result.targets) {
                                                player.discardPlayerCard(target, "ej", true);
                                            }
                                            break;
                                    }
                                    player.storage.old_luochong_round[event.index] = true;
                                    "step 3";
                                    if (event.index == 3) {
                                        var e1 = player.getHistory("gain", function (evt) {
                                            return evt.getParent(2) == event;
                                        })[0];
                                        event.cardsL = e1.cards;
                                        event.given_map = {};
                                        event.num = 2;
                                    } else event.finish();
                                    "step 4";
                                    player.chooseCardTarget({
                                        filterCard(card) {
                                            return get.itemtype(card) == "card" && !card.hasGaintag("old_luochong") && event.cardsL.contains(card);
                                        },
                                        filterTarget: lib.filter.notMe,
                                        selectCard: [1, event.num],
                                        prompt: "请选择要分配的卡牌和目标",
                                        ai1(card) {
                                            if (!ui.selected.cards.length) return 1;
                                            return 0;
                                        },
                                        ai2(target) {
                                            var player = _status.event.player,
                                                card = ui.selected.cards[0];
                                            var val = target.getUseValue(card);
                                            if (val > 0) return val * get.attitude(player, target) * 2;
                                            return get.value(card, target) * get.attitude(player, target);
                                        },
                                    });
                                    "step 5";
                                    if (result.bool) {
                                        var res = result.cards,
                                            target = result.targets[0].playerid;
                                        player.addGaintag(res, "old_luochong");
                                        event.num -= res.length;
                                        if (!event.given_map[target]) event.given_map[target] = [];
                                        event.given_map[target].addArray(res);
                                        if (event.num > 0) event.goto(4);
                                    } else if (event.num == 2) {
                                        event.finish();
                                    }
                                    "step 6";
                                    var map = [],
                                        cards = [];
                                    for (var i in event.given_map) {
                                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, "green");
                                        if (player !== source && (get.mode() !== "identity" || player.identity !== "nei")) player.addExpose(0.18);
                                        map.push([source, event.given_map[i]]);
                                        cards.addArray(event.given_map[i]);
                                    }
                                    game.loseAsync({
                                        gain_list: map,
                                        player: player,
                                        cards: cards,
                                        giver: player,
                                        animate: "giveAuto",
                                    }).setContent("gaincardMultiple");
                                },
                                group: ["old_luochong_round"],
                                subSkill: {
                                    round: {
                                        charlotte: true,
                                        direct: true,
                                        trigger: { global: "roundStart" },
                                        content() {
                                            player.storage.old_luochong_round = [false, false, false, false];
                                        },
                                    },
                                },
                                mark: true,
                                intro: {
                                    onunmark: true,
                                    content(storage, player) {
                                        var str1 = "本轮已发动过选项：";
                                        var str2 = "已移除选项：";
                                        var bool1 = false;
                                        var bool2 = false;
                                        var list = ["回血 ", "崩血 ", "弃牌 ", "摸牌 "];
                                        for (var i = 0; i < 4; i++) {
                                            if (player.storage.old_luochong_round[i]) {
                                                str1 += list[i];
                                                bool1 = true;
                                            }
                                            if (player.storage.old_luochong[i]) {
                                                str2 += list[i];
                                                bool2 = true;
                                            }
                                        }
                                        if (!bool1) str1 += "暂无";
                                        if (!bool2) str2 += "暂无";
                                        var str = str1 + "<br>" + str2;
                                        return str;
                                    },
                                },
                            },
                            old_aichen: {
                                audio: "aichen",
                                trigger: {
                                    player: "dying",
                                },
                                forced: true,
                                filter(event, player) {
                                    if (!player.hasSkill("old_luochong", null, null, false) || !player.storage.old_luochong) return false;
                                    var count = 0;
                                    for (var i of player.storage.old_luochong) {
                                        if (!i) count++;
                                    }
                                    return count > 1;
                                },
                                content() {
                                    "step 0";
                                    var num = 1 - player.hp;
                                    if (num > 0) player.recover(num);
                                    var list = [];
                                    var choiceList = ["令一名角色回复1点体力。", "令一名角色失去1点体力。", "弃置至多两名角色场上的各一张牌。", "摸两张牌，并可以将其分配给任意角色。"];
                                    for (var i = 0; i < 4; i++) {
                                        if (player.storage.old_luochong[i]) choiceList[i] += "（已移除）";
                                        else {
                                            if (i == 0) list.push("选项一");
                                            if (i == 1) list.push("选项二");
                                            if (i == 2) list.push("选项三");
                                            if (i == 3) list.push("选项四");
                                        }
                                    }
                                    player
                                        .chooseControl(list)
                                        .set("prompt", "哀尘：选择移去并执行一个【落宠】的选项")
                                        .set("choiceList", choiceList)
                                        .set("ai", function () {
                                            var controls = _status.event.controls.slice(0);
                                            var list = ["选项三", "选项四", "选项二", "选项一"];
                                            for (var i of list) {
                                                if (controls.contains(i)) return i;
                                            }
                                            return 0;
                                        });
                                    "step 1";
                                    var index = ["选项一", "选项二", "选项三", "选项四"].indexOf(result.control);
                                    event.index = index;
                                    game.log(player, "移去了", "#g【落宠】", "的", "#y" + ["回血", "崩血", "弃牌", "摸牌"][index], "选项");
                                    player.storage.old_luochong[index] = true;
                                    switch (index) {
                                        case 0:
                                            player
                                                .chooseTarget("选择一名角色，令其回复1点体力", true, function (card, player, target) {
                                                    return target.isDamaged();
                                                })
                                                .set("ai", function (target) {
                                                    return get.attitude(_status.event.player, target);
                                                });
                                            break;
                                        case 1:
                                            player.chooseTarget("选择一名角色，令其失去1点体力", true).set("ai", function (target) {
                                                return -get.attitude(_status.event.player, target);
                                            });
                                            break;
                                        case 2:
                                            player
                                                .chooseTarget("选择至多两名角色，弃置其场上各一张牌", true, [1, 2], function (card, player, target) {
                                                    return target.countDiscardableCards(player, "ej") > 0;
                                                })
                                                .set("ai", function (target) {
                                                    var player = _status.event.player;
                                                    var sign = get.sgnAttitude(_status.event.player, target);
                                                    return (
                                                        6 -
                                                        target
                                                            .getCards("ej")
                                                            .map(i => {
                                                                var val = 0;
                                                                if (get.position(i) == "e") val = get.value(i, target);
                                                                else {
                                                                    val = get.effect(player, { name: i.viewAs || i.name, cards: [i] }, target, target);
                                                                }
                                                                return sign * val;
                                                            })
                                                            .sort((a, b) => a - b)[0]
                                                    );
                                                });
                                            break;
                                        case 3:
                                            player.draw(2);
                                    }
                                    "step 2";
                                    switch (event.index) {
                                        case 0:
                                            var target = result.targets[0];
                                            target.recover();
                                            break;
                                        case 1:
                                            var target = result.targets[0];
                                            target.loseHp();
                                            break;
                                        case 2:
                                            for (var target of result.targets) {
                                                player.discardPlayerCard(target, "ej", true);
                                            }
                                            break;
                                    }
                                    "step 3";
                                    if (event.index == 3) {
                                        var e1 = player.getHistory("gain", function (evt) {
                                            return evt.getParent(2) == event;
                                        })[0];
                                        event.cardsL = e1.cards;
                                        event.given_map = {};
                                        event.num = 2;
                                    } else event.finish();
                                    "step 4";
                                    player.chooseCardTarget({
                                        filterCard(card) {
                                            return get.itemtype(card) == "card" && !card.hasGaintag("old_luochong") && event.cardsL.contains(card);
                                        },
                                        filterTarget: lib.filter.notMe,
                                        selectCard: [1, event.num],
                                        prompt: "请选择要分配的卡牌和目标",
                                        ai1(card) {
                                            if (!ui.selected.cards.length) return 1;
                                            return 0;
                                        },
                                        ai2(target) {
                                            var player = _status.event.player,
                                                card = ui.selected.cards[0];
                                            var val = target.getUseValue(card);
                                            if (val > 0) return val * get.attitude(player, target) * 2;
                                            return get.value(card, target) * get.attitude(player, target);
                                        },
                                    });
                                    "step 5";
                                    if (result.bool) {
                                        var res = result.cards,
                                            target = result.targets[0].playerid;
                                        player.addGaintag(res, "old_luochong");
                                        event.num -= res.length;
                                        if (!event.given_map[target]) event.given_map[target] = [];
                                        event.given_map[target].addArray(res);
                                        if (event.num > 0) event.goto(4);
                                    } else if (event.num == 2) {
                                        event.finish();
                                    }
                                    "step 6";
                                    var map = [],
                                        cards = [];
                                    for (var i in event.given_map) {
                                        var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, "green");
                                        if (player !== source && (get.mode() !== "identity" || player.identity !== "nei")) player.addExpose(0.18);
                                        map.push([source, event.given_map[i]]);
                                        cards.addArray(event.given_map[i]);
                                    }
                                    game.loseAsync({
                                        gain_list: map,
                                        player: player,
                                        cards: cards,
                                        giver: player,
                                        animate: "giveAuto",
                                    }).setContent("gaincardMultiple");
                                },
                            },
                            //邓忠
                            old_dzkanpo: {
                                audio: "dzkanpo",
                                trigger: {
                                    player: "useCardToPlayered",
                                },
                                filter(event, player) {
                                    if (player.countMark("old_dzkanpo_mark") >= player.hp) return false;
                                    return get.type(event.card) != "equip" && event.target.countCards("h") && player.isPhaseUsing();
                                },
                                check(event, player) {
                                    return get.attitude(player, event.target) < 0;
                                },
                                logTarget: "target",
                                content() {
                                    "step 0";
                                    player.addTempSkill("old_dzkanpo_mark", "phaseUseAfter");
                                    player.addMark("old_dzkanpo_mark", 1, false);
                                    player.viewHandcards(trigger.target);
                                    var list = [],
                                        choiceList = ["弃置" + get.translation(trigger.target) + "的一张牌，然后若弃置的牌的是能造成火焰伤害的牌，你摸一张牌", "重铸" + get.translation(trigger.target) + "手牌中的所有【杀】和【决斗】", "你与" + get.translation(trigger.target) + "互相对对方造成1点伤害"];
                                    list.push("选项一");
                                    if (trigger.target.countCards("h", { name: ["sha", "juedou"] })) list.push("选项二");
                                    else choiceList[1] = "<span style='opacity:0.5'>" + choiceList[1] + "</span>";
                                    if (!trigger.target.countCards("h", { name: "shan" })) list.push("选项三");
                                    else choiceList[2] = "<span style='opacity:0.5'>" + choiceList[2] + "</span>";
                                    player
                                        .chooseControl(list)
                                        .set("prompt", get.prompt("tspowei", target))
                                        .set("choiceList", choiceList)
                                        .set("ai", function () {
                                            var player = _status.event.player,
                                                target = _status.event.target;
                                            if (list.contains("选项三") && player.hp + player.countCards("hs", { name: "tao" }) > 2) return "选项三";
                                            if (list.contains("选项二") && target.countCards("h", { name: ["sha", "juedou"] }) > 1) return "选项二";
                                            return "选项一";
                                        })
                                        .set("target", trigger.target);
                                    "step 1";
                                    game.log(player, "选择了", "#y" + result.control);
                                    switch (result.control) {
                                        case "选项一":
                                            player.discardPlayerCard("he", trigger.target, "visible", true);
                                            break;
                                        case "选项二":
                                            var cards = trigger.target.getCards("h", { name: ["sha", "juedou"] });
                                            trigger.target.loseToDiscardpile(cards);
                                            trigger.target.draw(cards.length);
                                            event.finish();
                                            break;
                                        case "选项三":
                                            trigger.target.damage(player);
                                            player.damage(trigger.target);
                                            event.finish();
                                            break;
                                    }
                                    "step 2";
                                    if (result.bool && get.tag(result.cards[0], "fireDamage")) player.draw();
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        intro: {
                                            onunmark: true,
                                            content(storage, player) {
                                                return "本回合已发动过" + (storage || 0) + "次“勘破”。";
                                            },
                                        },
                                    },
                                },
                            },
                            old_dzgengzhan: {
                                getNum(name) {
                                    var num = 0;
                                    if (name == "litong") num = 1;
                                    else
                                        switch (game.getRarity(name)) {
                                            case "junk":
                                                num = 1;
                                                break;
                                            case "rare":
                                                num = 2;
                                                break;
                                            case "epic":
                                                num = 3;
                                                break;
                                            case "legend":
                                                num = 4;
                                                break;
                                        }
                                    return num;
                                },
                                getCharacter(list) {
                                    var listx = [],
                                        num = 0;
                                    for (var name of list) {
                                        var numx = lib.skill.old_dzgengzhan.getNum(name);
                                        if (numx > num) {
                                            num = numx;
                                            listx = [name];
                                        } else if (numx == num) listx.push(name);
                                    }
                                    return listx;
                                },
                                group: "old_dzgengzhan_jieming",
                                audio: "dzgengzhan",
                                trigger: { player: "dying" },
                                skillAnimation: true,
                                animationColor: "water",
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseTarget(get.prompt("old_dzgengzhan"), "令一名其他角色选择是否更换武将牌", lib.filter.notMe).set("ai", function (target) {
                                        var att = get.attitude(_status.event.player, target);
                                        var num = lib.skill.old_dzgengzhan.getNum(target.name);
                                        if (target.name2 != undefined) num = Math.min(num, lib.skill.old_dzgengzhan.getNum(target.name2));
                                        return att * (4 - num);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        var num = target.maxHp;
                                        event.num = num;
                                        player.logSkill("old_dzgengzhan", target);
                                        var list = [];
                                        for (var i = 0; i < _status.characterlist.length; i++) {
                                            if (lib.character[_status.characterlist[i]][1] == "wei") list.push(_status.characterlist[i]);
                                        }
                                        list = list.randomGets(5);
                                        var bolDialog = ["请选择替换的武将", [list, "character"]];
                                        target.chooseButton(bolDialog).set("ai", function (button) {
                                            var target = _status.event.player;
                                            var num = lib.skill.old_dzgengzhan.getNum(target.name);
                                            if (target.name2 != undefined) num = Math.min(num, lib.skill.old_dzgengzhan.getNum(target.name2));
                                            return lib.skill.old_dzgengzhan.getNum(button.link) - num;
                                        });
                                    } else event.finish();
                                    "step 2";
                                    if (result.bool) {
                                        event.character = result.links[0];
                                        if (target.name2 != undefined)
                                            target
                                                .chooseControl(target.name, target.name2)
                                                .set("prompt", "请选择要更换的武将牌")
                                                .set("ai", function () {
                                                    return lib.skill.old_dzgengzhan.getNum(target.name) < lib.skill.old_dzgengzhan.getNum(target.name2) ? target.name : target.name2;
                                                });
                                        else result.control = target.name;
                                    } else {
                                        target.chat("拒绝");
                                        game.log("但", target, "拒绝更换其武将牌");
                                        event.finish();
                                    }
                                    "step 3";
                                    if (result.control == target.name) target.changeGroup("wei", false);
                                    game.log(target, "将", "#g" + get.translation(result.control), "替换为了", "#g" + get.translation(event.character));
                                    target.reinit(result.control, event.character, false);
                                    target.maxHp = num;
                                    target.update();
                                },
                                subSkill: {
                                    jieming: {
                                        audio: "dzgengzhan",
                                        trigger: { player: "damageEnd" },
                                        filter(event, player) {
                                            return game.hasPlayer(function (current) {
                                                return current.countCards("h") < current.maxHp;
                                            });
                                        },
                                        direct: true,
                                        content() {
                                            "step 0";
                                            event.count = trigger.num;
                                            "step 1";
                                            event.count--;
                                            player
                                                .chooseTarget(get.prompt("old_dzgengzhan"), "令一名手牌数小于其体力上限的角色摸三张牌，然后其将手牌弃至其体力上限", function (card, player, target) {
                                                    return target.countCards("h") < target.maxHp;
                                                })
                                                .set("ai", function (target) {
                                                    var att = get.attitude(_status.event.player, target);
                                                    if (target.hasSkillTag("nogain")) att /= 6;
                                                    if (att > 2) return Math.min(5, target.maxHp) - target.countCards("h");
                                                    return att / 3;
                                                });
                                            "step 2";
                                            if (result.bool) {
                                                var target = result.targets[0];
                                                event.target = target;
                                                player.logSkill("old_dzgengzhan_jieming", target);
                                                target.draw(3);
                                            } else event.finish();
                                            "step 3";
                                            if (target.countCards("h") > target.maxHp) target.chooseToDiscard("h", target.countCards("h") - target.maxHp, true);
                                            if (
                                                event.count > 0 &&
                                                game.hasPlayer(function (current) {
                                                    return current.countCards("h") < current.maxHp;
                                                })
                                            )
                                                event.goto(1);
                                        },
                                        ai: {
                                            maixie: true,
                                            maixie_hp: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.tag(card, "damage") && target.hp > 1) {
                                                        if (player.hasSkillTag("jueqing", false, target)) return [1, -2];
                                                        var max = 0;
                                                        var players = game.filterPlayer();
                                                        for (var i = 0; i < players.length; i++) {
                                                            if (get.attitude(target, players[i]) > 0) {
                                                                max = Math.max(Math.min(5, players[i].hp) - players[i].countCards("h"), max);
                                                            }
                                                        }
                                                        switch (max) {
                                                            case 0:
                                                                return 2;
                                                            case 1:
                                                                return 1.5;
                                                            case 2:
                                                                return [1, 2];
                                                            default:
                                                                return [0, max];
                                                        }
                                                    }
                                                    if ((card.name == "tao" || card.name == "caoyao") && target.hp > 1 && target.countCards("h") <= target.hp) return [0, 0];
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //王衍
                            old_cihuang: {
                                audio: "cihuang",
                                trigger: {
                                    global: ["eventNeutralized", "shaMiss"],
                                },
                                direct: true,
                                filter(event, player) {
                                    if (event.player != _status.currentPhase || !event.targets || event.targets.length != 1 || event.type != "card" || !player.countCards("he")) return false;
                                    return lib.skill.old_cihuang.getList(player, event.player, true);
                                },
                                getList(player, target, bool) {
                                    var natures = lib.inpile_nature.slice(0);
                                    var tricks = [];
                                    for (var name of lib.inpile) {
                                        var info = lib.card[name];
                                        if (!info || info.type != "trick" || info.notarget || (info.selectTarget && info.selectTarget != 1 && (info.selectTarget != -1 || !info.toself))) continue;
                                        tricks.push(name);
                                    }
                                    var history = player.actionHistory;
                                    var HadUsenormalSha = false;
                                    for (var i = history.length - 1; i >= 0; i--) {
                                        var info = history[i];
                                        for (var evt of info.useCard) {
                                            if (evt.card.storage && evt.card.storage.old_cihuang) {
                                                var name = evt.card.name;
                                                if (name == "sha") {
                                                    if (evt.card.nature) natures.remove(evt.card.nature);
                                                    else HadUsenormalSha = true;
                                                } else tricks.remove(name);
                                            }
                                        }
                                        if (info.isRound) break;
                                    }
                                    var vcards = [];
                                    if (!HadUsenormalSha && player.canUse({ name: "sha", isCard: true }, target, false)) {
                                        vcards.push(["基本", "", "sha", ""]);
                                    }
                                    for (var i of natures) {
                                        if (
                                            player.canUse(
                                                {
                                                    name: "sha",
                                                    nature: i,
                                                    isCard: true,
                                                },
                                                target,
                                                false
                                            )
                                        ) {
                                            if (bool) return true;
                                            else vcards.push(["基本", "", "sha", i]);
                                        }
                                    }
                                    for (var i of tricks) {
                                        if (
                                            player.canUse(
                                                {
                                                    name: i,
                                                    isCard: true,
                                                },
                                                target,
                                                false
                                            )
                                        ) {
                                            if (bool) return true;
                                            else vcards.push(["锦囊", "", i]);
                                        }
                                    }
                                    if (bool) return false;
                                    return vcards;
                                },
                                content() {
                                    "step 0";
                                    var target = trigger.player;
                                    var list = lib.skill.old_cihuang.getList(player, target);
                                    if (_status.connectMode)
                                        game.broadcastAll(function () {
                                            _status.noclearcountdown = true;
                                        });
                                    player.chooseButton([get.prompt("old_cihuang", target), "<div class='text center'>选择一张牌并视为对" + get.translation(target) + "使用</div>", [list, "vcard"]]).set("ai", function (button) {
                                        var card = {
                                            name: button.link[2],
                                            nature: button.link[3],
                                            storage: { old_cihuang: true },
                                        },
                                            player = _status.event.player,
                                            target = _status.event.getTrigger().player;
                                        return get.effect(target, card, player, player);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        player.useCard(
                                            {
                                                name: result.links[0][2],
                                                nature: result.links[0][3],
                                                storage: { old_cihuang: true },
                                                isCard: true,
                                            },
                                            trigger.player,
                                            false,
                                            "old_cihuang"
                                        ).oncard = function (card, player) {
                                            _status.event.directHit.addArray(game.filterPlayer());
                                        };
                                    } else event._result = { bool: false };
                                    "step 2";
                                    if (_status.connectMode) {
                                        game.broadcastAll(function () {
                                            delete _status.noclearcountdown;
                                            game.stopCountChoose();
                                        });
                                    }
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        return arg && arg.card && arg.card.storage && arg.card.storage.old_cihuang;
                                    },
                                },
                            },
                            old_sanku: {
                                audio: "sanku",
                                trigger: {
                                    player: "dying",
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    player.loseMaxHp();
                                    "step 1";
                                    var num = player.maxHp - player.hp;
                                    if (num > 0) player.recover(num);
                                },
                                ai: {
                                    halfneg: true,
                                },
                            },
                            //陆郁生
                            old_olcangxin: {
                                audio: "olcangxin",
                                trigger: {
                                    player: "damageBegin4",
                                },
                                checkx(event, player) {
                                    var target = event.source;
                                    return get.damageEffect(player, target, player) <= 0;
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    var cards = get.bottomCards(3, true);
                                    player
                                        .chooseButton(["###藏心：请选择要弃置的牌###若以此法弃置了红桃牌，则防止此伤害", cards], [1, cards.length], true)
                                        .set("ai", function (button) {
                                            if (!_status.event.bool && get.suit(button.link, false) == "heart") return 0;
                                            if (get.suit(button.link, false) != "heart") return 1;
                                            const num = get.event().getTrigger().num;
                                            if (num > ui.selected.buttons.filter(but => get.suit(but.link, false) == "heart").length) return 1;
                                            return 0;
                                        })
                                        .set("bool", lib.skill.old_olcangxin.checkx(trigger, player));
                                    "step 1";
                                    if (result.bool) {
                                        player.$throw(result.links, 1000);
                                        game.cardsDiscard(result.links);
                                        const num = result.links.filter(card => get.suit(card, false) == "heart").length;
                                        if (num) trigger.cancel();
                                    } else event.finish();
                                    "step 2";
                                    game.delayx();
                                },
                                group: "old_olcangxin_yingzi",
                                subSkill: {
                                    yingzi: {
                                        audio: "olcangxin",
                                        trigger: {
                                            player: "phaseDrawBegin",
                                        },
                                        forced: true,
                                        content() {
                                            var cards = get.bottomCards(3, true);
                                            player.showCards(cards, get.translation(player) + "发动了【藏心】");
                                            var num = cards.filter(card => get.suit(card, false) == "heart").length;
                                            if (num) player.draw(num);
                                        },
                                    },
                                },
                            },
                            //ol胡金定
                            old_olchongshen: {
                                audio: "olchongshen",
                                locked: false,
                                enable: "chooseToUse",
                                filterCard(card) {
                                    return get.itemtype(card) == "card" && card.hasGaintag("old_olchongshen");
                                },
                                position: "h",
                                viewAs: {
                                    name: "shan",
                                },
                                viewAsFilter(player) {
                                    if (!player.countCards("h", card => card.hasGaintag("old_olchongshen") && get.color(card) == "red")) return false;
                                },
                                prompt: "将本轮得到的牌当作【闪】使用",
                                check(card) {
                                    return 7 - get.value(card);
                                },
                                ai: {
                                    order: 2,
                                    respondShan: true,
                                    skillTagFilter(player, tag, arg) {
                                        if (arg == "respond" || !player.countCards("h", card => _status.connectMode || (card.hasGaintag("old_olchongshen") && get.color(card) == "red"))) return false;
                                    },
                                    effect: {
                                        target(card, player, target, current) {
                                            if (get.tag(card, "respondShan") && current < 0) return 0.6;
                                        },
                                    },
                                    basic: {
                                        useful: (card, i) => {
                                            let player = _status.event.player,
                                                basic = [7, 5.1, 2],
                                                num = basic[Math.min(2, i)];
                                            if (player.hp > 2 && player.hasSkillTag("maixie")) num *= 0.57;
                                            if (player.hasSkillTag("freeShan", false, null, true) || player.getEquip("rewrite_renwang")) num *= 0.8;
                                            return num;
                                        },
                                        value: [7, 5.1, 2],
                                    },
                                    result: {
                                        player: 1,
                                    },
                                },
                                group: "old_olchongshen_mark",
                                mod: {
                                    aiValue(player, card, num) {
                                        if (get.name(card) != "shan" && get.itemtype(card) == "card" && (!card.hasGaintag("old_olchongshen") || get.color(card) != "red")) return;
                                        let cards = player.getCards("hs", card => get.name(card) == "shan" || card.hasGaintag("old_olchongshen"));
                                        cards.sort((a, b) => (get.name(b) == "shan" ? 1 : 2) - (get.name(a) == "shan" ? 1 : 2));
                                        const geti = () => {
                                            if (cards.includes(card)) return cards.indexOf(card);
                                            return cards.length;
                                        };
                                        if (get.name(card) == "shan") return Math.min(num, [6, 4, 3][Math.min(geti(), 2)]) * 0.6;
                                        return Math.max(num, [6.5, 4, 3][Math.min(geti(), 2)]);
                                    },
                                    aiUseful() {
                                        return lib.skill.old_olchongshen.mod.aiValue.apply(this, arguments);
                                    },
                                    ignoredHandcard(card, player) {
                                        if (card.hasGaintag("old_olchongshen")) return true;
                                    },
                                    cardDiscardable(card, player, name) {
                                        if (name == "phaseDiscard" && card.hasGaintag("old_olchongshen")) return false;
                                    },
                                },
                                init(player) {
                                    if (game.phaseNumber > 0) {
                                        const hs = player.getCards("h"),
                                            history = player.getAllHistory();
                                        let cards = [];
                                        for (let i = history.length - 1; i >= 0; i--) {
                                            for (const evt of history[i].gain) {
                                                cards.addArray(evt.cards);
                                            }
                                            if (history[i].isRound) break;
                                        }
                                        cards = cards.filter(i => hs.includes(i));
                                        if (cards.length) player.addGaintag(cards, "old_olchongshen");
                                    }
                                },
                                onremove(player) {
                                    player.removeGaintag("old_olchongshen");
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        trigger: {
                                            player: "gainBegin",
                                            global: "roundStart",
                                        },
                                        filter(event, player) {
                                            return event.name == "gain" || game.roundNumber > 1;
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            if (trigger.name == "gain") trigger.gaintag.add("old_olchongshen");
                                            else player.removeGaintag("old_olchongshen");
                                        },
                                    },
                                },
                            },
                            //ol费祎
                            old_hezhong: {
                                audio: "hezhong",
                                trigger: {
                                    player: "loseAfter",
                                    global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                },
                                filter(event, player) {
                                    if (player.countCards("h") != 1 || typeof get.number(player.getCards("h")[0], player) != "number") return false;
                                    if (player.hasSkill("old_hezhong_0") && player.hasSkill("old_hezhong_1")) return false;
                                    if (event.getg) return event.getg(player).length;
                                    var evt = event.getl(player);
                                    return evt && evt.player == player && evt.hs && evt.hs.length > 0;
                                },
                                prompt2(event, player) {
                                    var str = "展示最后一张手牌并摸一张牌";
                                    if (!player.hasSkill("old_hezhong_0") || !player.hasSkill("old_hezhong_0")) {
                                        str += "，然后令本回合使用点数";
                                        if (!player.hasSkill("old_hezhong_0")) str += "大于";
                                        if (!player.hasSkill("old_hezhong_0") && !player.hasSkill("old_hezhong_0")) str += "或";
                                        if (!player.hasSkill("old_hezhong_1")) str += "小于";
                                        str += get.number(player.getCards("h")[0], player);
                                        str += "的普通锦囊牌额外结算一次";
                                    }
                                    return str;
                                },
                                frequent: true,
                                content() {
                                    "step 0";
                                    player.showHandcards(get.translation(player) + "发动了【技能】");
                                    event.num = get.number(player.getCards("h")[0], player);
                                    "step 1";
                                    player.draw();
                                    "step 2";
                                    if (player.hasSkill("old_hezhong_0")) event._result = { index: 1 };
                                    else if (player.hasSkill("old_hezhong_1")) event._result = { index: 0 };
                                    else {
                                        player
                                            .chooseControl()
                                            .set("choiceList", ["本回合使用点数大于" + num + "的普通锦囊牌额外结算一次", "本回合使用点数小于" + num + "的普通锦囊牌额外结算一次"])
                                            .set("ai", () => {
                                                var player = _status.event.player;
                                                var num = _status.event.player;
                                                if (
                                                    player.getCards("h").reduce(function (num, card) {
                                                        return num + (get.number(card, player) || 0);
                                                    }, 0) >
                                                    num * 2
                                                )
                                                    return 0;
                                                return 1;
                                            })
                                            .set("num", num);
                                    }
                                    "step 3";
                                    var skill = "old_hezhong_" + result.index;
                                    player.addTempSkill(skill);
                                    player.markAuto(skill, [num]);
                                },
                                subSkill: {
                                    0: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: "＞",
                                        intro: {
                                            markcount: list => {
                                                var list2 = [1, 11, 12, 13];
                                                return list.reduce((str, num) => {
                                                    if (list2.includes(num)) return str + ["A", "J", "Q", "K"][list2.indexOf(num)];
                                                    return str + parseFloat(num);
                                                }, "");
                                            },
                                            content: "使用点数大于$的普通锦囊牌额外结算一次",
                                        },
                                        audio: "hezhong",
                                        trigger: { player: "useCard" },
                                        filter(event, player) {
                                            if (get.type(event.card) != "trick") return false;
                                            var num = get.number(event.card, player);
                                            return typeof num == "number" && player.getStorage("old_hezhong_0").some(numx => num > numx);
                                        },
                                        forced: true,
                                        content() {
                                            trigger.effectCount++;
                                            game.log(trigger.card, "额外结算一次");
                                        },
                                        ai: {
                                            effect: {
                                                player(card, player, target) {
                                                    if (card.name == "tiesuo") return "zerotarget";
                                                },
                                            },
                                        },
                                    },
                                    1: {
                                        charlotte: true,
                                        onremove: true,
                                        marktext: "<",
                                        intro: {
                                            markcount: list => {
                                                var list2 = [1, 11, 12, 13];
                                                return list.reduce((str, num) => {
                                                    if (list2.includes(num)) return str + ["A", "J", "Q", "K"][list2.indexOf(num)];
                                                    return str + parseFloat(num);
                                                }, "");
                                            },
                                            content: "使用点数小于$的普通锦囊牌额外结算一次",
                                        },
                                        audio: "hezhong",
                                        trigger: { player: "useCard" },
                                        filter(event, player) {
                                            if (get.type(event.card) != "trick") return false;
                                            var num = get.number(event.card, player);
                                            return typeof num == "number" && player.getStorage("old_hezhong_1").some(numx => num < numx);
                                        },
                                        forced: true,
                                        content() {
                                            trigger.effectCount++;
                                            game.log(trigger.card, "额外结算一次");
                                        },
                                        ai: {
                                            effect: {
                                                player(card, player, target) {
                                                    if (card.name == "tiesuo") return "zerotarget";
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            //OL彭羕
                            old_oltuishi: {
                                audio: "oltuishi",
                                mod: {
                                    wuxieJudgeEnabled: () => false,
                                    wuxieEnabled: () => false,
                                    cardEnabled: card => {
                                        if (card.name == "wuxie") return false;
                                    },
                                    targetInRange: card => {
                                        if (card.storage && card.storage.old_oltuishi) return true;
                                    },
                                    aiValue: (player, card, val) => {
                                        if (card.name == "wuxie") return 0;
                                        var num = get.number(card);
                                        if ([1, 11, 12, 13].includes(num)) return val * 1.1;
                                    },
                                    aiUseful: (player, card, val) => {
                                        if (card.name == "wuxie") return 0;
                                        var num = get.number(card);
                                        if ([1, 11, 12, 13].includes(num)) return val * 1.1;
                                    },
                                    aiOrder: (player, card, order) => {
                                        if (get.name(card) == "sha" && player.hasSkill("old_oltuishi_unlimit")) order += 9;
                                        var num = get.number(card);
                                        if ([1, 11, 12, 13].includes(num)) order += 3;
                                        return order;
                                    },
                                },
                                trigger: { player: "useCardAfter" },
                                forced: true,
                                filter(event) {
                                    const num = get.number(event.card);
                                    return [1, 11, 12, 13].includes(num);
                                },
                                content() {
                                    player.draw(2);
                                    player.addSkill("old_oltuishi_unlimit");
                                },
                                subSkill: {
                                    unlimit: {
                                        charlotte: true,
                                        mod: {
                                            cardUsable: () => Infinity,
                                            targetInRange: () => true,
                                        },
                                        trigger: { player: "useCard1" },
                                        forced: true,
                                        popup: false,
                                        silent: true,
                                        firstDo: true,
                                        content() {
                                            player.removeSkill("old_oltuishi_unlimit");
                                            var card = trigger.card;
                                            if (!card.storage) card.storage = {};
                                            card.storage.old_oltuishi = true;
                                            if (trigger.addCount !== false) {
                                                trigger.addCount = false;
                                                player.getStat("card")[card.name]--;
                                            }
                                        },
                                        mark: true,
                                        intro: { content: "使用的下一张牌无距离次数限制" },
                                    },
                                },
                            },
                            //ol界虞翻
                            old_olzongxuan: {
                                audio: "rezongxuan",
                                trigger: { global: ["loseAfter", "loseAsyncAfter"] },
                                filter(event, player) {
                                    if (event.type != "discard" || event.getlx === false) return false;
                                    return get.info("old_olzongxuan").getCards(event, player).length;
                                },
                                check(event, player) {
                                    if (event.getParent(3).name != "phaseDiscard") return false;
                                    const cards = get.info("old_olzongxuan").getCards(event, player);
                                    return game.hasPlayer(target => {
                                        if (cards.some(i => get.type(i, null, target) == "equip") && (get.attitude(player, target) > 0 || get.recoverEffect(target, player, player) > 0)) return true;
                                        if (cards.some(i => get.type(i, null, target) != "equip") && target.getHp() >= player.getHp() && get.effect(target, { name: "losehp" }, player, player) > 0) return true;
                                        return false;
                                    });
                                },
                                async content(event, trigger, player) {
                                    const {
                                        result: { bool, moved },
                                    } = await player
                                        .chooseToMove("纵玄：将任意张牌置于牌堆顶", true)
                                        .set("list", [["本次弃置的牌", get.info("old_olzongxuan").getCards(trigger, player)], ["牌堆顶"]])
                                        .set("filterOk", moved => moved[1].length)
                                        .set("processAI", list => {
                                            const player = get.event("player");
                                            const cards = list[0][1].slice(),
                                                cards2 = cards.filter(card => {
                                                    return game.hasPlayer(target => {
                                                        if (get.type(card, null, target) == "equip" && (get.attitude(player, target) > 0 || get.recoverEffect(target, player, player) > 0)) return true;
                                                        if (get.type(card, null, target) != "equip" && target.getHp() >= player.getHp() && get.effect(target, { name: "losehp" }, player, player) > 0) return true;
                                                        return false;
                                                    });
                                                }),
                                                cards3 = cards2.length ? cards2.randomGet() : cards.randomGet();
                                            return [[], [cards3]];
                                        });
                                    if (bool) {
                                        let cards = moved[1].slice();
                                        game.log(player, "将", cards, "置于了牌堆顶");
                                        while (cards.length) {
                                            ui.cardPile.insertBefore(cards.pop().fix(), ui.cardPile.firstChild);
                                        }
                                    }
                                },
                                getCards(event, player) {
                                    let cards = [];
                                    for (const target of [player, player.getPrevious()]) {
                                        const evt = event.getl(target);
                                        if (evt && evt.cards2 && evt.cards2.some(i => get.position(i) == "d")) cards.addArray(evt.cards2.filter(i => get.position(i) == "d"));
                                    }
                                    return cards;
                                },
                            },
                            old_olzhiyan: {
                                audio: "zhiyan",
                                old_olzhiyan: ["re_yufan"],
                                trigger: { global: "phaseJieshuBegin" },
                                filter(event, player) {
                                    return event.player == player || event.player == player.getPrevious();
                                },
                                direct: true,
                                async content(event, trigger, player) {
                                    const {
                                        result: { bool, targets },
                                    } = await player
                                        .chooseTarget(get.prompt2("old_olzhiyan"))
                                        .set("ai", target => {
                                            const player = get.event("player"),
                                                cards = get.event("cards");
                                            if (!cards.length) return 0;
                                            const card = cards[0],
                                                att = get.attitude(player, target);
                                            if (get.type(card, null, target) == "equip" && (get.attitude(player, target) > 0 || get.recoverEffect(target, player, player) > 0)) return get.recoverEffect(target, player, player) * 20 + att / 114514;
                                            if (get.type(card, null, target) != "equip") {
                                                if (target.getHp() !== player.getHp()) return get.effect(target, { name: "losehp" }, player, player) * 20 - att / 114514;
                                                return get.effect(target, { name: "draw" }, player, player);
                                            }
                                            return 0;
                                        })
                                        .set("cards", Array.from(ui.cardPile.childNodes || []) || []);
                                    if (bool) {
                                        const target = targets[0];
                                        player.logSkill("old_olzhiyan", target);
                                        const { result } = await target.draw("visible");
                                        if (result) {
                                            const card = result[0];
                                            if (get.type(card, null, target) == "equip") {
                                                if (target.getCards("h").includes(card) && target.hasUseTarget(card)) {
                                                    const {
                                                        result: { bool },
                                                    } = await target.chooseUseTarget(card, true, "nopopup");
                                                    if (bool) await target.recover();
                                                }
                                            } else if (target.getHp() !== player.getHp()) await target.loseHp();
                                        }
                                    }
                                },
                                ai: { expose: 0.2 },
                            },
                            //程普
                            // olchunlao: {
                            //     audio: "chunlao",
                            //     audioname: ["xin_chengpu"],
                            //     trigger: { global: ["loseAfter", "loseAsyncAfter"] },
                            //     filter(event, player) {
                            //         if (event.type != "discard" || event.getlx === false) return false;
                            //         return game.hasPlayer(target => {
                            //             if (![player.getPrevious(), player, player.getNext()].includes(target)) return false;
                            //             return event.getl(target)?.cards2?.some(i => i.name == "sha" && get.position(i) == "d");
                            //         });
                            //     },
                            //     forced: true,
                            //     locked: false,
                            //     content() {
                            //         player
                            //             .addToExpansion(
                            //                 game
                            //                     .filterPlayer(target => {
                            //                         if (![player.getPrevious(), player, player.getNext()].includes(target)) return false;
                            //                         return trigger.getl(target)?.cards2?.some(i => i.name == "sha" && get.position(i) == "d");
                            //                     })
                            //                     .map(target => {
                            //                         return trigger.getl(target).cards2.filter(i => i.name == "sha" && get.position(i) == "d");
                            //                     })
                            //                     .flat()
                            //                     .unique(),
                            //                 "gain2"
                            //             )
                            //             .gaintag.add("olchunlao");
                            //     },
                            //     ai: {
                            //         effect: {
                            //             player_use(card, player, target) {
                            //                 if (_status.currentPhase != player) return;
                            //                 if (card.name == "sha" && !player.getExpansions("olchunlao").length && target.hp > 1) {
                            //                     return "zeroplayertarget";
                            //                 }
                            //             },
                            //         },
                            //     },
                            //     intro: {
                            //         content: "expansion",
                            //         markcount: "expansion",
                            //     },
                            //     onremove(player, skill) {
                            //         var cards = player.getExpansions(skill);
                            //         if (cards.length) player.loseToDiscardpile(cards);
                            //     },
                            //     group: ["olchunlao_save", "olchunlao_gain"],
                            //     subSkill: {
                            //         save: {
                            //             inherit: "chunlao2",
                            //             filter(event, player) {
                            //                 return event.type == "dying" && event.dying && event.dying.hp <= 0 && player.getExpansions("olchunlao").length;
                            //             },
                            //             async content(event, trigger, player) {
                            //                 const target = event.targets[0];
                            //                 const {
                            //                     result: { bool, links },
                            //                 } = await player.chooseCardButton(get.translation("olchunlao"), player.getExpansions("olchunlao"), true);
                            //                 if (bool) {
                            //                     player.logSkill("olchunlao", target);
                            //                     await player.loseToDiscardpile(links);
                            //                     event.type = "dying";
                            //                     await target.useCard({ name: "jiu", isCard: true }, target);
                            //                 }
                            //             },
                            //             ai: {
                            //                 save: true,
                            //                 skillTagFilter(player) {
                            //                     return player.getExpansions("olchunlao").length;
                            //                 },
                            //                 order: 6,
                            //                 result: { target: 1 },
                            //             },
                            //         },
                            //         gain: {
                            //             audio: "chunlao",
                            //             audioname: ["xin_chengpu"],
                            //             trigger: { global: "loseHpEnd" },
                            //             filter(event, player) {
                            //                 return player.getExpansions("olchunlao").length;
                            //             },
                            //             async cost(event, trigger, player) {
                            //                 const cards = player.getExpansions("olchunlao");
                            //                 event.result = await player
                            //                     .chooseButton(["###" + get.prompt("olchunlao") + "###获得至多两张“醇”？", cards], [1, 2])
                            //                     .set("ai", button => {
                            //                         const player = get.event().player;
                            //                         return player.hasSha() ? 0 : get.value(button.link);
                            //                     })
                            //                     .forResult();
                            //                 if (event.result.bool) event.result.cards = event.result.links;
                            //             },
                            //             async content(event, trigger, player) {
                            //                 await player.gain(event.cards, player, "give");
                            //             },
                            //         },
                            //     },
                            // },
                            old_qiaoli: {
                                audio: "qiaoli",
                                enable: "phaseUse",
                                viewAs: {
                                    name: "juedou",
                                    old_qiaoli: true,
                                },
                                filterCard(card, player) {
                                    if (get.type(card) != "equip") return false;
                                    return true;
                                },
                                viewAsFilter(player) {
                                    return (
                                        player.isPhaseUsing() &&
                                        player.hasCard(function (card) {
                                            return lib.skill.old_qiaoli.filterCard(card, player);
                                        }, "hes")
                                    );
                                },
                                check(card) {
                                    if (get.position(card) == "e") return 7.5 - get.value(card);
                                    return 12 - _status.event.player.getUseValue(card);
                                },
                                position: "hes",
                                precontent() {
                                    player.addTempSkill("old_qiaoli_norespond");
                                    player.addTempSkill("old_qiaoli_effect");
                                },
                                ai: {
                                    directHit_ai: true,
                                    skillTagFilter(player, tag, arg) {
                                        return arg && arg.card && arg.card.name == "juedou" && _status.event.skill == "old_qiaoli";
                                    },
                                    wuxie(target, card, player, viewer, status) {
                                        if (player === game.me && get.attitude(viewer, player._trueMe || player) > 0) return 0;
                                        if (status * get.attitude(viewer, target) * get.effect(target, card, player, target) >= 0) return 0;
                                    },
                                    basic: {
                                        order: 5,
                                        useful: 1,
                                        value: 5.5,
                                    },
                                    result: {
                                        player(player, target, card) {
                                            if (
                                                player.hasSkillTag(
                                                    "directHit_ai",
                                                    true,
                                                    {
                                                        target: target,
                                                        card: card,
                                                    },
                                                    true
                                                )
                                            )
                                                return 0;
                                            if (get.damageEffect(target, player, target) >= 0) return 0;
                                            let pd = get.damageEffect(player, target, player),
                                                att = get.attitude(player, target);
                                            if (att > 0 && get.damageEffect(target, player, player) > pd) return 0;
                                            let ts = target.mayHaveSha(player, "respond", null, "count"),
                                                ps = player.mayHaveSha(
                                                    player,
                                                    "respond",
                                                    player.getCards("h", i => {
                                                        return card === i || (card.cards && card.cards.includes(i)) || ui.selected.cards.includes(i);
                                                    }),
                                                    "count"
                                                );
                                            if (ts < 1 && ts << 3 < Math.pow(player.hp, 2)) return 0;
                                            if (att > 0) {
                                                if (ts < 1) return 0;
                                                return -2;
                                            }
                                            if (ts - ps + Math.exp(0.8 - player.hp) < 1) return -ts;
                                            if (pd >= 0) return pd / get.attitude(player, player);
                                            return -2 - ts;
                                        },
                                        target(player, target, card) {
                                            if (
                                                player.hasSkillTag(
                                                    "directHit_ai",
                                                    true,
                                                    {
                                                        target: target,
                                                        card: card,
                                                    },
                                                    true
                                                )
                                            )
                                                return -2;
                                            let td = get.damageEffect(target, player, target);
                                            if (td >= 0) return td / get.attitude(target, target);
                                            let pd = get.damageEffect(player, target, player),
                                                att = get.attitude(player, target);
                                            if (att > 0 && get.damageEffect(target, player, player) > pd) return -2;
                                            let ts = target.mayHaveSha(player, "respond", null, "count"),
                                                ps = player.mayHaveSha(
                                                    player,
                                                    "respond",
                                                    player.getCards("h", i => {
                                                        return card === i || (card.cards && card.cards.includes(i)) || ui.selected.cards.includes(i);
                                                    }),
                                                    "count"
                                                );
                                            if (ts < 1) return -1.5;
                                            if (att > 0) return -2;
                                            if (ts - ps < 1) return -2 - ts;
                                            if (pd >= 0) return -1;
                                            return -ts;
                                        },
                                    },
                                    tag: {
                                        respond: 2,
                                        respondSha: 2,
                                        damage: 1,
                                    },
                                },
                                subSkill: {
                                    norespond: {
                                        charlotte: true,
                                        trigger: {
                                            player: "useCard1",
                                        },
                                        filter(event, player) {
                                            return event.card.old_qiaoli && get.subtype(event.cards[0]) != "equip1";
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            // player.addTempSkill("old_qiaoli_gain");
                                            trigger.directHit.addArray(game.players);
                                            game.log(trigger.card, "不可被响应");
                                        },
                                        sub: true,
                                        sourceSkill: "old_qiaoli",
                                        _priority: 0,
                                    },
                                    effect: {
                                        charlotte: true,
                                        trigger: {
                                            player: "useCardAfter",
                                        },
                                        filter(event, player) {
                                            return event.card && event.cards && event.card.old_qiaoli && get.subtype(event.cards[0]) == "equip1";
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            "step 0";
                                            var card = trigger.cards[0];
                                            var num = 1;
                                            var info = get.info(card, false);
                                            if (info && info.distance && typeof info.distance.attackFrom == "number") num -= info.distance.attackFrom;
                                            player.draw(num);
                                            "step 1";
                                            var cards = result;
                                            if (get.itemtype(cards) != "cards") {
                                                event.finish(5);
                                                return;
                                            }
                                            var hs = player.getCards("h");
                                            cards = cards.filter(function (card) {
                                                return hs.includes(card);
                                            });
                                            if (!cards.length) {
                                                event.finish(5);
                                                return;
                                            }
                                            event.cards = cards;
                                            if (_status.connectMode)
                                                game.broadcastAll(function () {
                                                    _status.noclearcountdown = true;
                                                });
                                            event.given_map = {};
                                            "step 2";
                                            player.chooseCardTarget({
                                                filterCard(card) {
                                                    return _status.event.cards.includes(card) && !card.hasGaintag("old_qiaoli_given");
                                                },
                                                cards: cards,
                                                filterTarget: lib.filter.notMe,
                                                selectCard: [1, cards.length],
                                                prompt: "是否将获得的牌分配给其他角色？",
                                                ai1(card) {
                                                    return -1;
                                                },
                                                ai2(target) {
                                                    return -1;
                                                },
                                            });
                                            "step 3";
                                            if (result.bool) {
                                                var res = result.cards,
                                                    target = result.targets[0].playerid;
                                                player.addGaintag(res, "old_qiaoli_given");
                                                cards.removeArray(res);
                                                if (!event.given_map[target]) event.given_map[target] = [];
                                                event.given_map[target].addArray(res);
                                                if (cards.length) event.goto(2);
                                            }
                                            "step 4";
                                            if (_status.connectMode) {
                                                game.broadcastAll(function () {
                                                    delete _status.noclearcountdown;
                                                });
                                                game.stopCountChoose();
                                            }
                                            for (var i in event.given_map) {
                                                var source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                                player.line(source, "green");
                                                source.gain(event.given_map[i], player, "giveAuto");
                                            }
                                            event.next.sort(function (a, b) {
                                                return lib.sort.seat(a.player, b.player);
                                            });
                                        },
                                        sourceSkill: "old_qiaoli",
                                    },
                                    // gain: {
                                    // 	charlotte: true,
                                    // 	audio: "qiaoli",
                                    // 	trigger: {
                                    // 		player: "phaseJieshuBegin",
                                    // 	},
                                    // 	forced: true,
                                    // 	content() {
                                    // 		var card = get.cardPile2(function (card) {
                                    // 			return get.type(card) == "equip";
                                    // 		});
                                    // 		if (card) player.gain(card, "gain2");
                                    // 	},
                                    // 	sourceSkill: "old_qiaoli",
                                    // },
                                },
                            },
                            old_qingliang: {
                                audio: "qingliang",
                                trigger: {
                                    target: "useCardToTarget",
                                },
                                filter(event, player) {
                                    var bool1 = get.type(event.card) == "basic";
                                    var bool2 = get.type(event.card) == "trick";
                                    if (!bool1 && !bool2) return false;
                                    return player != event.player && player.countCards("h") > 0;
                                },
                                usable: 1,
                                logTarget: "player",
                                check(event, player) {
                                    if (get.attitude(player, event.player) > 0 || event.player.hasSkillTag("nogain")) return true;
                                    var eff = get.effect(player, event.card, event.player, player);
                                    if (eff >= 0) return false;
                                    var suits = [],
                                        banned = [],
                                        hs = player.getCards("h");
                                    for (var i of hs) {
                                        var suit = get.suit(i, player);
                                        suits.add(suit);
                                        if (!lib.filter.cardDiscardable(i, player, "old_qingliang")) banned.add(suit);
                                    }
                                    suits.removeArray(banned);
                                    for (var i of suits) {
                                        var cards = player.getCards("h", function (card) {
                                            return get.suit(card, player) == i;
                                        });
                                        if (-eff / 2 - get.value(cards, player) > 0) return true;
                                    }
                                    return false;
                                },
                                content() {
                                    "step 0";
                                    player.showHandcards(get.translation(player) + "发动了【清靓】");
                                    "step 1";
                                    var suits = [],
                                        banned = [],
                                        hs = player.getCards("h");
                                    for (var i of hs) {
                                        var suit = get.suit(i, player);
                                        suits.add(suit);
                                        if (!lib.filter.cardDiscardable(i, player, "old_qingliang")) banned.add(suit);
                                    }
                                    if (suits.length > banned.length) {
                                        player
                                            .chooseControl()
                                            .set("choiceList", ["和" + get.translation(trigger.player) + "各摸一张牌", "弃置一种花色的所有手牌，令" + get.translation(trigger.card) + "对自己无效"])
                                            .set("ai", function () {
                                                var player = _status.event.player,
                                                    event = _status.event.getTrigger();
                                                if (get.attitude(player, event.player) > 0 || event.player.hasSkillTag("nogain")) return 0;
                                                return 1;
                                            });
                                        event.suits = suits;
                                        suits.removeArray(banned);
                                        suits.sort();
                                    } else {
                                        event._result = { index: 0 };
                                    }
                                    "step 2";
                                    if (result.index == 0) {
                                        var list = [player, trigger.player].sortBySeat();
                                        list[0].draw("nodelay");
                                        list[1].draw();
                                        event.finish();
                                    } else {
                                        if (event.suits.length == 1) event._result = { control: event.suits[0] };
                                        else
                                            player
                                                .chooseControl(event.suits)
                                                .set("prompt", "选择弃置一种花色的所有牌")
                                                .set("ai", function () {
                                                    var player = _status.event.player,
                                                        list = _status.event.controls.slice(0);
                                                    var gett = function (suit) {
                                                        var cards = player.getCards("h", function (card) {
                                                            return get.suit(card, player) == suit;
                                                        });
                                                        return get.value(cards);
                                                    };
                                                    return list.sort(function (b, a) {
                                                        return gett(b) - gett(a);
                                                    })[0];
                                                });
                                    }
                                    "step 3";
                                    var cards = player.getCards("h", function (card) {
                                        return get.suit(card) == result.control;
                                    });
                                    if (cards.length) player.discard(cards);
                                    trigger.targets.remove(player);
                                    trigger.getParent().triggeredTargets2.remove(player);
                                    trigger.untrigger();
                                },
                                _priority: 0,
                            },
                            //徐荣
                            old_xionghuo: {
                                audio: "xinfu_xionghuo",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return player.countMark("old_xionghuo") > 0;
                                },
                                filterTarget(card, player, target) {
                                    return player != target && !target.hasMark("old_xionghuo");
                                },
                                content() {
                                    player.removeMark("old_xionghuo", 1);
                                    target.addMark("old_xionghuo", 1);
                                },
                                ai: {
                                    order: 11,
                                    result: {
                                        target(player, target) {
                                            if (
                                                (player.countMark("old_xionghuo") >= 2 ||
                                                    !game.hasPlayer(function (current) {
                                                        return current != player && get.attitude(player, current) < 0 && current.hasMark("old_xionghuo");
                                                    })) &&
                                                player.countCards("h", function (card) {
                                                    return (
                                                        get.tag(card, "damage") &&
                                                        player.canUse(card, target, null, true) &&
                                                        player.getUseValue(card) > 0 &&
                                                        get.effect_use(target, card, player) > 0 &&
                                                        target.hasSkillTag("filterDamage", null, {
                                                            player: player,
                                                            card: card,
                                                        })
                                                    );
                                                })
                                            )
                                                return 3 / Math.max(1, target.hp);
                                            if (
                                                (!player.hasUnknown() &&
                                                    game.countPlayer(function (current) {
                                                        return get.attitude(player, current) < 0;
                                                    }) <= 1) ||
                                                player.countMark("old_xionghuo") >= 2
                                            ) {
                                                return -1;
                                            }
                                            return 0;
                                        },
                                    },
                                    effect: {
                                        player(card, player, target) {
                                            if (
                                                player != target &&
                                                get.tag(card, "damage") &&
                                                target &&
                                                target.hasMark("old_xionghuo") &&
                                                !target.hasSkillTag("filterDamage", null, {
                                                    player: player,
                                                    card: card,
                                                })
                                            )
                                                return [1, 0, 1, -2];
                                        },
                                    },
                                    threaten: 1.6,
                                },
                                marktext: "戾",
                                intro: {
                                    name: "暴戾",
                                    content: "mark",
                                },
                                group: ["old_xionghuo_init", "old_xionghuo_damage", "old_xionghuo_effect"],
                                subSkill: {
                                    init: {
                                        audio: "xinfu_xionghuo",
                                        trigger: {
                                            global: "phaseBefore",
                                            player: "enterGame",
                                        },
                                        filter(event, player) {
                                            return event.name != "phase" || game.phaseNumber == 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addMark("old_xionghuo", 3);
                                        },
                                    },
                                    damage: {
                                        audio: "xinfu_xionghuo",
                                        trigger: { source: "damageBegin1" },
                                        filter(event, player) {
                                            return event.player.countMark("old_xionghuo") > 0 && event.player != player;
                                        },
                                        forced: true,
                                        locked: false,
                                        logTarget: "player",
                                        content() {
                                            trigger.num++;
                                        },
                                    },
                                    effect: {
                                        audio: "xinfu_xionghuo",
                                        trigger: { global: "phaseUseBegin" },
                                        filter(event, player) {
                                            return event.player.countMark("old_xionghuo") > 0 && event.player != player;
                                        },
                                        line: false,
                                        forced: true,
                                        locked: false,
                                        logTarget: "player",
                                        content() {
                                            "step 0";
                                            trigger.player.removeMark("old_xionghuo", trigger.player.countMark("old_xionghuo"));
                                            "step 1";
                                            var num = get.rand(0, 2);
                                            switch (num) {
                                                case 0: {
                                                    player.line(trigger.player, "fire");
                                                    trigger.player.damage("fire");
                                                    trigger.player.addTempSkill("old_xionghuo_disable");
                                                    trigger.player.markAuto("old_xionghuo_disable", [player]);
                                                    break;
                                                }
                                                case 1: {
                                                    player.line(trigger.player, "water");
                                                    trigger.player.loseHp();
                                                    trigger.player.addMark("old_xionghuo_low", 1, false);
                                                    trigger.player.addTempSkill("old_xionghuo_low");
                                                    break;
                                                }
                                                case 2: {
                                                    player.line(trigger.player, "green");
                                                    var card1 = trigger.player.getCards("h").randomGet();
                                                    var card2 = trigger.player.getCards("e").randomGet();
                                                    var list = [];
                                                    if (card1) list.push(card1);
                                                    if (card2) list.push(card2);
                                                    if (list.length) player.gain(list, trigger.player, "giveAuto", "bySelf");
                                                    break;
                                                }
                                            }
                                            "step 2";
                                            game.delay();
                                        },
                                    },
                                    disable: {
                                        mod: {
                                            playerEnabled(card, player, target) {
                                                if (card.name == "sha" && player.getStorage("old_xionghuo_disable").includes(target)) return false;
                                            },
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: "禁",
                                        intro: { content: "不能对$使用【杀】" },
                                    },
                                    low: {
                                        mod: {
                                            maxHandcard(player, num) {
                                                return num - player.countMark("old_xionghuo_low");
                                            },
                                        },
                                        charlotte: true,
                                        onremove: true,
                                        mark: true,
                                        marktext: "减",
                                        intro: { content: "手牌上限-#" },
                                    },
                                },
                            },
                            old_shajue: {
                                audio: "xinfu_shajue",
                                trigger: { global: "dying" },
                                filter(event, player) {
                                    return event.player != player;
                                },
                                forced: true,
                                content() {
                                    player.addMark("old_xionghuo", 1);
                                    if (trigger.player.hp < 0 && get.itemtype(trigger.parent.cards) == "cards" && trigger.parent.cards.some(card => get.position(card, true) == "o")) {
                                        player.gain(
                                            trigger.parent.cards.filter(card => get.position(card, true) == "o"),
                                            "gain2"
                                        );
                                    }
                                },
                                ai: {
                                    combo: "old_xionghuo",
                                },
                            },
                            //牵招
                            old_olkuansai: {
                                audio: "olkuansai",
                                trigger: {
                                    global: "useCardToPlayered",
                                },
                                filter(event, player) {
                                    return event.isFirstTarget && event.targets.length > player.getHp();
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    player
                                        .chooseTarget(get.prompt("old_olkuansai"), "令其中一个目标选择一项：1.交给你一张牌；2.令你回复1点体力。", (card, player, target) => {
                                            return _status.event.targets.includes(target);
                                        })
                                        .set("targets", trigger.targets)
                                        .set("ai", target => {
                                            var player = _status.event.player;
                                            var att = get.attitude(player, target);
                                            if (att > 0) return 1;
                                            return (1 - att) / Math.sqrt(1 + target.countCards("he"));
                                        });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.logSkill("old_olkuansai", target);
                                        var position = "e";
                                        if (player != target) position += "h";
                                        var forced = player.isHealthy();
                                        var str = "请交给其一张牌" + (forced ? "" : "或点击“取消”令其回复1点体力") + "。";
                                        if (!target.countCards(position)) event._result = { bool: false };
                                        else
                                            target
                                                .chooseCard(get.translation(player) + "对你发动了【款塞】", str, position, forced)
                                                .set("ai", card => {
                                                    if (_status.event.recover) return 0;
                                                    var target = _status.event.player,
                                                        player = _status.event.getParent().player;
                                                    if (get.attitude(target, player) > 0) {
                                                        return get.value(card, target) - get.value(card, player);
                                                    }
                                                    if (get.tag(card, "recover")) return -1;
                                                    return 6.5 - get.value(card);
                                                })
                                                .set(
                                                    "recover",
                                                    (function () {
                                                        if (forced) return false;
                                                        var recoverEff = get.recoverEffect(player, target, target);
                                                        var att = get.attitude(target, player);
                                                        if (att < 0) {
                                                            if (recoverEff >= 0) return true;
                                                            if (
                                                                target.hasCard(card => {
                                                                    return (get.value(card) < 6.5 && !get.tag(card, "recover")) || get.value(card) <= 0.05;
                                                                }, position)
                                                            )
                                                                return false;
                                                        } else {
                                                            if (recoverEff > 0) return true;
                                                            if (
                                                                target.hasCard(card => {
                                                                    return get.value(card, target) < get.value(card, player);
                                                                }, position)
                                                            )
                                                                return false;
                                                        }
                                                        return true;
                                                    })()
                                                );
                                    } else {
                                        player.storage.counttrigger.old_olkuansai--;
                                        event.finish();
                                    }
                                    "step 2";
                                    if (result.bool) {
                                        target.give(result.cards, player);
                                    } else player.recover(target);
                                },
                            },
                            // 谋董卓
                            old_olguanbian: {
                                audio: "olguanbian",
                                trigger: {
                                    global: ["phaseBefore", "roundStart"],
                                    player: ["enterGame", "old_olxiongniAfter", "old_olfengshangAfter"],
                                },
                                filter(event, player, name) {
                                    if (name == "roundStart") return game.roundNumber == 2;
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    if (event.triggername == "roundStart" || ["old_olxiongni", "old_olfengshang"].includes(trigger.name)) await player.removeSkills(event.name);
                                    else player.addMark(event.name, game.players.length + game.dead.length, false);
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark("old_olguanbian");
                                    },
                                    globalFrom(from, to, current) {
                                        return current + from.countMark("old_olguanbian");
                                    },
                                    globalTo(from, to, current) {
                                        return current + to.countMark("old_olguanbian");
                                    },
                                },
                                intro: {
                                    content: "<li>手牌上限+#<br><li>计算与其他角色的距离+#<br><li>其他角色计算与你的距离+#",
                                },
                            },
                            old_olxiongni: {
                                audio: "olxiongni",
                                trigger: {
                                    player: "phaseUseBegin",
                                },
                                filter(event, player) {
                                    if (!game.hasPlayer(target => target != player)) return false;
                                    return player.countCards("he", card => _status.connectMode || lib.filter.cardDiscardable(card, player));
                                },
                                async cost(event, trigger, player) {
                                    const skillName = event.name.slice(0, -5);
                                    event.result = await player
                                        .chooseToDiscard(get.prompt2(skillName), "he")
                                        .set("ai", card => {
                                            const player = get.player();
                                            if (!game.hasPlayer(target => player != target && get.damageEffect(target, player, player) > 0)) return 0;
                                            if (get.suit(card, player) == "heart") return 8 - get.value(card);
                                            return 7.5 - get.value(card);
                                        })
                                        .set("logSkill", [skillName, get.info(skillName).logTarget(trigger, player)])
                                        .forResult();
                                },
                                popup: false,
                                logTarget: (event, player) => game.filterPlayer(target => target != player).sortBySeat(),
                                async content(event, trigger, player) {
                                    const suit = get.suit(event.cards[0]);
                                    for (const target of event.targets) {
                                        const bool = await target
                                            .chooseToDiscard(`弃置一张${get.translation(suit)}牌，否则${get.translation(player)}对你造成1点伤害`, "he", (card, player) => {
                                                return get.event("suit") == get.suit(card);
                                            })
                                            .set("ai", card => {
                                                const player = get.player(),
                                                    target = get.event().getParent().player;
                                                if (get.damageEffect(player, target, player) > 0) return 0;
                                                return 7.5 - get.value(card);
                                            })
                                            .set("suit", suit)
                                            .forResultBool();
                                        if (!bool) await target.damage();
                                    }
                                },
                            },
                            old_olfengshang: {
                                audio: "olfengshang",
                                getCards() {
                                    const cards = [];
                                    game.checkGlobalHistory("cardMove", evt => {
                                        if (evt.name != "cardsDiscard" && (evt.name != "lose" || evt.position != ui.discardPile)) return;
                                        cards.addArray(evt.cards.filterInD("d"));
                                    });
                                    return cards;
                                },
                                enable: "phaseUse",
                                trigger: {
                                    global: "dying",
                                },
                                filter(event, player) {
                                    const cards = event.name == "chooseToUse" ? event.old_olfengshang_cards || [] : get.info("old_olfengshang").getCards();
                                    if (!lib.suit.some(suit => cards.filter(card => get.suit(card) == suit).length > 1)) return false;
                                    return event.name != "chooseToUse" || !player.hasSkill("old_olfengshang_used", null, null, false);
                                },
                                onChooseToUse(event) {
                                    if (!game.online && !event.old_olfengshang_cards) {
                                        event.set("old_olfengshang_cards", get.info("old_olfengshang").getCards());
                                    }
                                },
                                async content(event, trigger, player) {
                                    if (!trigger) player.addTempSkill(event.name + "_used", "phaseUseAfter");
                                    if (_status.connectMode) game.broadcastAll(() => (_status.noclearcountdown = true));
                                    player.changeSkin({ characterName: "old_ol_sb_dongzhuo" }, "ol_sb_dongzhuo_shadow2");
                                    const given_map = {};
                                    event.given_map = given_map;
                                    const cards = !trigger ? event.getParent(2).old_olfengshang_cards : get.info(event.name).getCards();
                                    let result;
                                    while (Object.keys(given_map).length < 2 && cards.length) {
                                        if (cards.length > 1) {
                                            result = await player
                                                .chooseCardButton("封赏：请选择要分配的牌", cards, true)
                                                .set("filterButton", button => {
                                                    const { link } = button,
                                                        map = get.event().getParent().given_map;
                                                    if (!Object.values(map).flat().length) return get.event("cards").filter(card => get.suit(card) == get.suit(link)).length > 1;
                                                    return get.suit(link) == get.suit(Object.values(map).flat()[0]);
                                                })
                                                .set("ai", button => {
                                                    return get.buttonValue(button);
                                                })
                                                .set("cards", cards)
                                                .forResult();
                                        } else if (cards.length === 1) result = { bool: true, links: cards.slice(0) };
                                        else return;
                                        if (!result.bool) return;
                                        const toGive = result.links;
                                        result = await player
                                            .chooseTarget("选择获得" + get.translation(toGive) + "的角色", true, (card, player, target) => {
                                                return !get.event().getParent().given_map[target.playerid];
                                            })
                                            .set("ai", target => {
                                                const att = get.attitude(get.player(), target);
                                                if (get.event("toEnemy")) return Math.max(0.01, 100 - att);
                                                else if (att > 0) {
                                                    if (player.getUseValue({ name: "jiu" }) && player != target) return 10;
                                                    return Math.max(0.1, att / Math.sqrt(1 + target.countCards("h") + (get.event().getParent().given_map[target.playerid] || 0)));
                                                } else return Math.max(0.01, (100 + att) / 200);
                                            })
                                            .set("toEnemy", get.value(toGive[0], player, "raw") < 0)
                                            .forResult();
                                        if (result.bool) {
                                            cards.removeArray(toGive);
                                            const id = result.targets[0].playerid;
                                            if (!given_map[id]) given_map[id] = [];
                                            given_map[id].addArray(toGive);
                                        }
                                    }
                                    if (_status.connectMode) {
                                        game.broadcastAll(() => {
                                            delete _status.noclearcountdown;
                                            game.stopCountChoose();
                                        });
                                    }
                                    const gain_list = [];
                                    for (const i in given_map) {
                                        const source = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                                        player.line(source, "green");
                                        game.log(source, "获得了", given_map[i]);
                                        gain_list.push([source, given_map[i]]);
                                    }
                                    await game
                                        .loseAsync({
                                            gain_list,
                                            giver: player,
                                            animate: "gain2",
                                        })
                                        .setContent("gaincardMultiple");
                                    await game.delayx();
                                    if (!player.hasHistory("gain", evt => evt.getParent(2) == event) && player.hasUseTarget({ name: "jiu", isCard: true }, true, false)) {
                                        await player.chooseUseTarget({ name: "jiu", isCard: true }, true, false);
                                    }
                                },
                                ai: {
                                    order: 7,
                                    result: {
                                        player: 1,
                                    },
                                },
                                subSkill: {
                                    used: { charlotte: true },
                                },
                            },
                            old_olzhibin: {
                                audio: "olzhibin",
                                getNum(player) {
                                    let num = 0;
                                    game.countPlayer2(current => {
                                        if (current != player && current.group == "qun") {
                                            num += current.getAllHistory("useCard", evt => get.color(evt.card) == "black").length;
                                        }
                                    });
                                    return num;
                                },
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                filter(event, player) {
                                    const num = get.info("old_olzhibin").getNum(player);
                                    return get.info("old_olzhibin").filterx(player, num) || get.info("old_olzhibin").filtery(player, num) || get.info("old_olzhibin").filterz(player, num);
                                },
                                filterx(player, num) {
                                    return num >= 3 && !game.getAllGlobalHistory("everything", evt => evt.name == "gainMaxHp" && evt.player == player && evt.getParent().name == "old_olzhibin").length;
                                },
                                filtery(player, num) {
                                    return num >= 6 && !player.hasSkill("dcfencheng", null, null, false) && !game.getAllGlobalHistory("everything", evt => evt.name == "changeSkills" && evt.player == player && evt.getParent().name == "old_olzhibin" && evt.addSkill.includes("dcfencheng")).length;
                                },
                                filterz(player, num) {
                                    return num >= 9 && !player.hasSkill("benghuai", null, null, false) && !game.getAllGlobalHistory("everything", evt => evt.name == "changeSkills" && evt.player == player && evt.getParent().name == "old_olzhibin" && evt.addSkill.includes("benghuai")).length;
                                },
                                zhuSkill: true,
                                forced: true,
                                async content(event, trigger, player) {
                                    player.changeSkin({ characterName: "old_ol_sb_dongzhuo" }, "ol_sb_dongzhuo_shadow1");
                                    const skillName = event.name,
                                        num = get.info(skillName).getNum(player);
                                    if (get.info(skillName).filterx(player, num)) {
                                        await player.gainMaxHp();
                                        await player.recover();
                                    }
                                    if (get.info(skillName).filtery(player, num)) await player.addSkills("dcfencheng");
                                    if (get.info(skillName).filterz(player, num)) await player.addSkills("benghuai");
                                },
                                derivation: ["dcfencheng", "benghuai"],
                            },
                            //OL南华老仙
                            old_olhedao: {
                                audio: "olhedao",
                                trigger: {
                                    global: "phaseBefore",
                                    player: ["enterGame", "dying"],
                                },
                                filter(event, player) {
                                    if (event.name === "dying") return game.getAllGlobalHistory("everything", evt => evt.name === "dying" && evt.player === player).indexOf(event) === 0;
                                    return event.name !== "phase" || game.phaseNumber === 0;
                                },
                                forced: true,
                                content() {
                                    player.addMark(event.name, 1 + (trigger.name !== "dying"), false);
                                },
                                intro: { content: "至多拥有#册“天书”" },
                                //时机
                                tianshuTrigger: [
                                    //用牌相关
                                    {
                                        name: "当你使用牌后",
                                        effect: {
                                            trigger: { player: "useCardAfter" },
                                        },
                                    },
                                    {
                                        name: "当你使用或打出【闪】时",
                                        effect: {
                                            trigger: { player: "useCard" },
                                            filter(event, player) {
                                                return event.card.name === "shan";
                                            },
                                        },
                                    },
                                    {
                                        name: "当你成为【杀】的目标时",
                                        effect: {
                                            trigger: { target: "useCardToTarget" },
                                            filter(event, player) {
                                                return event.card.name === "sha";
                                            },
                                        },
                                    },
                                    {
                                        name: "当你成为普通锦囊牌的目标后",
                                        effect: {
                                            trigger: { target: "useCardToTargeted" },
                                            filter(event, player) {
                                                return get.type(event.card) === "trick";
                                            },
                                        },
                                    },
                                    {
                                        name: "其他角色对你使用牌后",
                                        effect: {
                                            trigger: { global: "useCardAfter" },
                                            filter(event, player) {
                                                return event.player !== player && event.targets?.includes(player);
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色使用【南蛮入侵】或【万箭齐发】后",
                                        effect: {
                                            trigger: { global: "useCardAfter" },
                                            filter(event, player) {
                                                return ["nanman", "wanjian"].includes(event.card?.name);
                                            },
                                        },
                                    },
                                    {
                                        name: "当你使用牌被抵消后",
                                        effect: {
                                            trigger: { player: ["eventNeutralized", "shaMiss"] },
                                            filter(event, player) {
                                                return event.type === "card";
                                            },
                                        },
                                    },
                                    //失去牌相关
                                    {
                                        name: "当你失去手牌后",
                                        effect: {
                                            trigger: {
                                                player: "loseAfter",
                                                global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                            },
                                            filter(event, player) {
                                                return event.getl?.(player)?.hs?.length;
                                            },
                                        },
                                    },
                                    {
                                        name: "当你失去装备牌后",
                                        effect: {
                                            trigger: {
                                                player: "loseAfter",
                                                global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                            },
                                            filter(event, player) {
                                                return event.getl?.(player)?.cards2?.some(i => get.type(i, null, player) === "equip");
                                            },
                                        },
                                    },
                                    {
                                        name: "当你于回合外失去红色牌后",
                                        effect: {
                                            trigger: {
                                                player: "loseAfter",
                                                global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                            },
                                            filter(event, player) {
                                                return _status.currentPhase !== player && event.getl?.(player)?.cards2?.some(i => get.color(i, player) === "red");
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色失去最后的手牌后",
                                        effect: {
                                            trigger: {
                                                global: ["loseAfter", "equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                            },
                                            filter(event, player) {
                                                return game.hasPlayer(target => !target.countCards("h") && event.getl?.(target)?.hs?.length);
                                            },
                                        },
                                    },
                                    //判定相关
                                    {
                                        name: "当一张判定牌生效前",
                                        effect: {
                                            trigger: { global: "judge" },
                                        },
                                    },
                                    {
                                        name: "当一张判定牌生效后",
                                        effect: {
                                            trigger: { global: "judgeAfter" },
                                        },
                                    },
                                    //阶段相关
                                    {
                                        name: "每轮开始时",
                                        effect: {
                                            trigger: { global: "roundStart" },
                                        },
                                    },
                                    {
                                        name: "准备阶段",
                                        effect: {
                                            trigger: { player: "phaseZhunbeiBegin" },
                                        },
                                    },
                                    {
                                        name: "摸牌阶段开始时",
                                        effect: {
                                            trigger: { player: "phaseDrawBegin" },
                                        },
                                    },
                                    {
                                        name: "出牌阶段开始时",
                                        effect: {
                                            trigger: { player: "phaseUseBegin" },
                                        },
                                    },
                                    {
                                        name: "弃牌阶段开始时",
                                        effect: {
                                            trigger: { player: "phaseDiscardBegin" },
                                        },
                                    },
                                    {
                                        name: "结束阶段",
                                        effect: {
                                            trigger: { player: "phaseJieshuBegin" },
                                        },
                                    },
                                    //伤害相关
                                    {
                                        name: "当你造成伤害后",
                                        effect: {
                                            trigger: { source: "damageSource" },
                                        },
                                    },
                                    {
                                        name: "当你受到伤害后",
                                        effect: {
                                            trigger: { player: "damageEnd" },
                                        },
                                    },
                                    {
                                        name: "当你的体力值变化后",
                                        effect: {
                                            trigger: { player: "changeHpEnd" },
                                            filter(event, player) {
                                                return event.num !== 0;
                                            },
                                        },
                                    },
                                    {
                                        name: "当你使用【杀】造成伤害后",
                                        effect: {
                                            trigger: { source: "damageSource" },
                                            filter(event, player) {
                                                return event.card?.name === "sha";
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色受到【杀】造成的伤害后",
                                        effect: {
                                            trigger: { global: "damageEnd" },
                                            filter(event, player) {
                                                return event.card?.name === "sha";
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色造成伤害时",
                                        effect: {
                                            trigger: { global: "damageBegin3" },
                                            filter(event, player) {
                                                return event.source?.isIn();
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色受到伤害时",
                                        effect: {
                                            trigger: { global: "damageBegin4" },
                                        },
                                    },
                                    {
                                        name: "一名角色受到属性伤害后",
                                        effect: {
                                            trigger: { global: "damageEnd" },
                                            filter(event, player) {
                                                return event.hasNature();
                                            },
                                        },
                                    },
                                    //其他
                                    {
                                        name: "一名角色进入濒死状态时",
                                        effect: {
                                            trigger: { global: "dying" },
                                        },
                                    },
                                    {
                                        name: "其他角色死亡后",
                                        effect: {
                                            trigger: { global: "dieAfter" },
                                            filter(event, player) {
                                                return event.player !== player;
                                            },
                                        },
                                    },
                                    {
                                        name: "一名角色进入连环状态后",
                                        effect: {
                                            trigger: { global: "linkAfter" },
                                            filter(event, player) {
                                                return event.player.isLinked();
                                            },
                                        },
                                    },
                                ],
                                //执行
                                tianshuContent: [
                                    {
                                        name: "你可以摸一张牌",
                                        effect: {
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.draw();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以弃置一名角色区域内的一张牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target.countCards("hej"));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), (card, player, target) => {
                                                        return target.countCards("hej");
                                                    })
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, { name: "guohe" }, player, player);
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.discardPlayerCard(event.targets[0], "hej", true);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以观看牌堆顶三张牌，然后将这些牌以任意顺序置于牌堆顶或牌堆底",
                                        effect: {
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.chooseToGuanxing(3);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以弃置任意张牌并摸等量张牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return (
                                                    0 +
                                                    player.hasCard(card => {
                                                        if (get.position(card) === "h" && _status.connectMode) return true;
                                                        return lib.filter.cardDiscardable(card, player);
                                                    }, "he")
                                                );
                                            },
                                            async cost(event, trigger, player) {
                                                const name = event.name.slice(0, -"_cost".length);
                                                event.result = await player.chooseToDiscard(get.prompt2(name), "he", [1, Infinity], "chooseonly").set("ai", lib.skill.zhiheng.check).set("logSkill", name).forResult();
                                            },
                                            popup: false,
                                            async content(event, trigger, player) {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                await player.discard(event.cards);
                                                await player.draw(event.cards.length);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以获得造成伤害的牌",
                                        filter: item => item.includes("伤害"),
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + (get.itemtype(event.cards) === "cards" && event.cards.someInD());
                                            },
                                            prompt2(event, player) {
                                                return "获得" + get.translation(event.cards.filterInD());
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.gain(trigger.cards.filterInD(), "gain2");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以视为使用一张无距离和次数限制的【杀】",
                                        effect: {
                                            getIndex(event, player) {
                                                const card = new lib.element.VCard({ name: "sha" });
                                                return 0 + player.hasUseTarget(card, false);
                                            },
                                            direct: true,
                                            async content(event, trigger, player) {
                                                const card = new lib.element.VCard({ name: "sha" });
                                                event.result = await player
                                                    .chooseUseTarget(get.prompt2(event.name), card, false, "nodistance")
                                                    .set("oncard", () => {
                                                        const event = _status.event.getParent(2);
                                                        lib.skill.old_olhedao.tianshuClear(event.name, event.player);
                                                    })
                                                    .set("logSkill", event.name)
                                                    .forResult();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以获得一名角色区域内的一张牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target.countCards("hej"));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), (card, player, target) => {
                                                        return target.countCards("hej");
                                                    })
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, { name: "shunshou" }, player, player);
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.gainPlayerCard(event.targets[0], "hej", true);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以回复1点体力",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + player.isDamaged();
                                            },
                                            check(event, player) {
                                                return get.recoverEffect(player, player, player) > 0;
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.recover();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以摸四张牌，然后弃置一张牌",
                                        effect: {
                                            async content(event, trigger, player) {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                await player.draw(4);
                                                await player.chooseToDiscard("he", true);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以将手牌摸至体力上限（至多摸五张）",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + (player.countCards("h") < player.maxHp);
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.drawTo(Math.min(player.maxHp, player.countCards("h") + 5));
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令一名角色的非锁定技失效直到其下个回合开始",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => !target.hasSkill("fengyin"));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), (card, player, target) => {
                                                        return !target.hasSkill("fengyin");
                                                    })
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return (
                                                            -get.sgn(get.attitude(player, target)) *
                                                            (target.getSkills(null, false, false).filter(skill => {
                                                                return !get.is.locked(skill);
                                                            }).length +
                                                                1) *
                                                            (target === _status.currentPhase ? 10 : 1)
                                                        );
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                const target = event.targets[0];
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                target.addTempSkill("fengyin", { player: "phaseBegin" });
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令一名角色摸两张牌并将武将牌翻面",
                                        effect: {
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)))
                                                    .set("ai", target => {
                                                        const player = get.player(),
                                                            draw = 2;
                                                        if (target.hasSkillTag("noturn")) return 0;
                                                        const att = get.attitude(player, target),
                                                            current = _status.currentPhase;
                                                        const dis = current ? get.distance(current, target, "absolute") : 1;
                                                        if (att == 0) return target.hasJudge("lebu") ? Math.random() / 3 : Math.sqrt(get.threaten(target)) / 5 + Math.random() / 2;
                                                        if (att > 0) {
                                                            if (target.isTurnedOver()) return att + draw;
                                                            if (current && target.getSeatNum() > current.getSeatNum()) return att + draw / 3;
                                                            return (10 * Math.sqrt(Math.max(0.01, get.threaten(target)))) / (3.5 - draw) + dis / (2 * game.countPlayer());
                                                        } else {
                                                            if (target.isTurnedOver()) return att - draw;
                                                            if (current && target.getSeatNum() <= current.getSeatNum()) return -att + draw / 3;
                                                            return (4.25 - draw) * 10 * Math.sqrt(Math.max(0.01, get.threaten(target))) + (2 * game.countPlayer()) / dis;
                                                        }
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                const target = event.targets[0];
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                target.draw(2);
                                                target.turnOver();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令此牌对你无效",
                                        filter: item => item.includes("你成为") && (item.includes("的目标时") || item.includes("的目标后")),
                                        effect: {
                                            prompt2(event, player) {
                                                return "令" + get.translation(event.card) + "对你无效";
                                            },
                                            check(event, player) {
                                                return get.effect(player, event.card, event.player, player) < 0;
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                trigger.getParent().excluded.add(player);
                                                game.log(trigger.card, "对", player, "无效");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令一名其他角色判定，若判定结果为黑桃，则其受到2点雷属性伤害",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target !== player);
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), lib.filter.notMe)
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        if (target.hasSkill("hongyan")) return 0;
                                                        return get.damageEffect(target, player, player, "thunder");
                                                    })
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                const target = event.targets[0];
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                const result = await target
                                                    .judge(card => {
                                                        return get.suit(card) === "spade" ? -4 : 0;
                                                    })
                                                    .set("judge2", result => (result.bool === false ? true : false))
                                                    .forResult();
                                                if (result.bool === false) await target.damage(2, "thunder");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以打出一张手牌替换此判定牌",
                                        filter: item => item.includes("判定牌生效前"),
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + Boolean(player.countCards("hs"));
                                            },
                                            async cost(event, trigger, player) {
                                                const {
                                                    result: { bool, cards },
                                                } = await player
                                                    .chooseCard(get.translation(trigger.player) + "的" + (trigger.judgestr || "") + "判定为" + get.translation(trigger.player.judging[0]) + "，" + get.prompt(event.name.slice(0, -"_cost".length)), "hs", card => {
                                                        const player = _status.event.player;
                                                        const mod2 = game.checkMod(card, player, "unchanged", "cardEnabled2", player);
                                                        if (mod2 != "unchanged") return mod2;
                                                        const mod = game.checkMod(card, player, "unchanged", "cardRespondable", player);
                                                        if (mod != "unchanged") return mod;
                                                        return true;
                                                    })
                                                    .set("ai", card => {
                                                        const trigger = _status.event.getTrigger();
                                                        const player = _status.event.player;
                                                        const judging = _status.event.judging;
                                                        const result = trigger.judge(card) - trigger.judge(judging);
                                                        const attitude = get.attitude(player, trigger.player);
                                                        if (attitude == 0 || result == 0) return 0;
                                                        if (attitude > 0) {
                                                            return result - get.value(card) / 2;
                                                        } else {
                                                            return -result - get.value(card) / 2;
                                                        }
                                                    })
                                                    .set("judging", trigger.player.judging[0]);
                                                if (bool) event.result = { bool, cost_data: { cards } };
                                            },
                                            popup: false,
                                            async content(event, trigger, player) {
                                                const chooseCardResultCards = event.cost_data.cards;
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                await player.respond(chooseCardResultCards, event.name, "highlight", "noOrdering");
                                                if (trigger.player.judging[0].clone) {
                                                    trigger.player.judging[0].clone.classList.remove("thrownhighlight");
                                                    game.broadcast(card => {
                                                        if (card.clone) card.clone.classList.remove("thrownhighlight");
                                                    }, trigger.player.judging[0]);
                                                    game.addVideo("deletenode", player, get.cardsInfo([trigger.player.judging[0].clone]));
                                                }
                                                player.$gain2(trigger.player.judging);
                                                await player.gain(trigger.player.judging);
                                                trigger.player.judging[0] = chooseCardResultCards[0];
                                                trigger.orderingCards.addArray(chooseCardResultCards);
                                                game.log(trigger.player, "的判定牌改为", chooseCardResultCards[0]);
                                                await game.delay(2);
                                            },
                                            ai: {
                                                rejudge: true,
                                                tag: { rejudge: 1 },
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以获得此判定牌",
                                        filter: item => item.includes("判定牌生效后"),
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + (get.position(event.result.card, true) === "o");
                                            },
                                            check(event, player) {
                                                return get.value(event.result.card) > 0;
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.gain(trigger.result.card, "gain2");
                                            },
                                        },
                                    },
                                    {
                                        name: "若你不是体力上限最高的角色，则你可以增加1点体力上限",
                                        filter: item => item.includes("判定牌生效后"),
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(t => t.maxHp > player.maxHp);
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.gainMaxHp();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以与一名已受伤角色拼点，若你赢，你获得其两张牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target.isDamaged() && player.canCompare(target));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), (card, player, target) => {
                                                        return target.isDamaged() && player.canCompare(target);
                                                    })
                                                    .set("ai", target => {
                                                        if (!get.event().goon) return 0;
                                                        const player = get.player();
                                                        return -get.attitude(player, target) * (1 + target.countCards("he"));
                                                    })
                                                    .set(
                                                        "goon",
                                                        player.hasCard(card => {
                                                            const val = get.value(card);
                                                            if (val < 0) return true;
                                                            if (val <= 5) return card.number >= 12;
                                                            if (val <= 6) return card.number >= 13;
                                                            return false;
                                                        }, "h")
                                                    )
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                const target = event.targets[0];
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                const result = await player.chooseToCompare(target).forResult();
                                                if (result.bool) await player.gainPlayerCard(target, 2, "he", true);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令至多两名角色各摸一张牌",
                                        effect: {
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), [1, 2])
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, { name: "draw" }, player, player);
                                                    })
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                const { targets } = event;
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                if (targets.length === 1) await targets[0].draw();
                                                else {
                                                    await game.asyncDraw(targets);
                                                    await game.delayx();
                                                }
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以令一名角色的手牌上限+2直到其回合结束",
                                        effect: {
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)))
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, { name: "draw" }, player, player) * (1 + target.countCards("h"));
                                                    })
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                const target = event.targets[0];
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                target.addTempSkill("old_olhedao_hand", { player: "phaseEnd" });
                                                target.addMark("old_olhedao_hand", 2, false);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以获得两张非基本牌",
                                        effect: {
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                let list = [];
                                                while (list.length < 2) {
                                                    const card = get.cardPile(card => get.type(card) !== "basic" && !list.includes(card));
                                                    if (card) list.push(card);
                                                    else break;
                                                }
                                                if (list.length) player.gain(list, "gain2");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以获得两张锦囊牌",
                                        effect: {
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                let list = [];
                                                while (list.length < 2) {
                                                    const card = get.cardPile(card => get.type2(card) === "trick" && !list.includes(card));
                                                    if (card) list.push(card);
                                                    else break;
                                                }
                                                if (list.length) player.gain(list, "gain2");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以摸三张牌并将武将牌翻面",
                                        effect: {
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.draw(3);
                                                player.turnOver();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可令你对一名角色使用牌无距离和次数限制直到回合结束",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => !player.getStorage("old_olhedao_effect").includes(target));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(get.prompt2(event.name.slice(0, -"_cost".length)), (card, player, target) => {
                                                        return !player.getStorage("old_olhedao_effect").includes(target);
                                                    })
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return 1145141919810 - get.attitude(player, target);
                                                    })
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.addTempSkill("old_olhedao_effect", { player: "phaseEnd" });
                                                player.markAuto("old_olhedao_effect", event.targets);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以弃置两张牌，令你与一名其他角色各回复1点体力",
                                        effect: {
                                            getIndex(event, player) {
                                                return (
                                                    0 +
                                                    (player.countCards("he", card => {
                                                        if (get.position(card) === "h" && _status.connectMode) return true;
                                                        return lib.filter.cardDiscardable(card, player);
                                                    }) >= 2 && game.hasPlayer(target => target !== player))
                                                );
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseCardTarget({
                                                        prompt: get.prompt2(event.name.slice(0, -"_cost".length)),
                                                        filterTarget(card, player, target) {
                                                            return !player.getStorage("old_olhedao_effect").includes(target);
                                                        },
                                                        filterCard: lib.filter.cardDiscardable,
                                                        selectCard: 2,
                                                        position: "he",
                                                        ai1(card) {
                                                            return 7 - get.value(card);
                                                        },
                                                        ai2(target) {
                                                            const player = get.player();
                                                            return get.recoverEffect(target, player, player) + get.recoverEffect(player, player, player);
                                                        },
                                                    })
                                                    .forResult();
                                            },
                                            async content(event, trigger, player) {
                                                const { targets, cards } = event,
                                                    [target] = targets;
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                await player.discard(cards);
                                                await player.recover();
                                                await target.recover();
                                            },
                                        },
                                    },
                                    {
                                        name: "你可令此伤害+1",
                                        filter: item => item.includes("伤害时"),
                                        effect: {
                                            logTarget: "player",
                                            check(event, player) {
                                                const target = event.player;
                                                return get.damageEffect(target, event.source, player) > 0 && !target.hasSkillTag("filterDamage", null, { player: event.source, card: event.card });
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                trigger.num++;
                                                game.log(trigger.player, "受到的伤害", "#y+1");
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以失去1点体力并摸三张牌",
                                        effect: {
                                            check(event, player) {
                                                return player.countCards("hs", card => player.canSaveCard(card, player)) + player.getHp() - 1 > 0;
                                            },
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                player.loseHp();
                                                player.draw(3);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以交换两名角色的手牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target.countCards("h"));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(
                                                        get.prompt2(event.name.slice(0, -"_cost".length)),
                                                        (card, player, target) => {
                                                            if (!ui.selected.targets.length) return true;
                                                            return target.countCards("h") + ui.selected.targets[0].countCards("h") > 0;
                                                        },
                                                        2
                                                    )
                                                    .set("complexTarget", true)
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, "dimeng", player, player);
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                const { targets } = event;
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                targets[0].swapHandcards(targets[1]);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以交换两名角色装备区的牌",
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + game.hasPlayer(target => target.countVCards("e"));
                                            },
                                            async cost(event, trigger, player) {
                                                event.result = await player
                                                    .chooseTarget(
                                                        get.prompt2(event.name.slice(0, -"_cost".length)),
                                                        (card, player, target) => {
                                                            if (!ui.selected.targets.length) return true;
                                                            return target.countVCards("e") + ui.selected.targets[0].countVCards("e") > 0;
                                                        },
                                                        2
                                                    )
                                                    .set("complexTarget", true)
                                                    .set("ai", target => {
                                                        const player = get.player();
                                                        return get.effect(target, "ganlu", player, player);
                                                    })
                                                    .forResult();
                                            },
                                            content() {
                                                const { targets } = event;
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                targets[0].swapEquip(targets[1]);
                                            },
                                        },
                                    },
                                    {
                                        name: "你可以防止此伤害，令伤害来源摸三张牌",
                                        filter: item => item.includes("伤害时"),
                                        effect: {
                                            getIndex(event, player) {
                                                return 0 + event.source?.isIn();
                                            },
                                            check(event, player) {
                                                if (get.attitude(player, event.player) > 0) return true;
                                                if (get.effect(event.source, { name: "draw" }, player, player) * 3 + event.num * get.damageEffect(player, event.source, player, event.nature) > 0) return true;
                                                return event.source.hasSkillTag("nogain");
                                            },
                                            logTarget: "source",
                                            content() {
                                                lib.skill.old_olhedao.tianshuClear(event.name, player);
                                                trigger.cancel();
                                                trigger.source.draw(3);
                                            },
                                        },
                                    },
                                ],
                                //清理
                                tianshuClear(skill, player, num = 1) {
                                    if (num > 0 && get.info(skill)?.nopop) {
                                        game.broadcastAll((player, skill) => {
                                            delete lib.skill[skill].nopop;
                                            lib.skill[skill].markimage = "image/card/tianshu1.png";
                                            if (player.marks[skill]) player.marks[skill].setBackgroundImage(lib.skill[skill].markimage);
                                        }, player, skill);
                                        player.update();
                                    }
                                    player.storage[skill][0] -= num;
                                    player[player.storage[skill][0] <= 0 ? "removeSkill" : "markSkill"](skill);
                                },
                                subSkill: {
                                    hand: {
                                        charlotte: true,
                                        onremove: true,
                                        markimage: "image/card/handcard.png",
                                        mod: { maxHandcard: (player, num) => num + player.countMark("old_olhedao_hand") },
                                        intro: { content: "手牌上限+#" },
                                    },
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            targetInRange(card, player, target) {
                                                if (player.getStorage("old_olhedao_effect").includes(target)) return true;
                                            },
                                            cardUsableTarget(card, player, target) {
                                                if (player.getStorage("old_olhedao_effect").includes(target)) return Infinity;
                                            },
                                        },
                                        intro: { content: "对$使用牌无距离和次数限制" },
                                    },
                                },
                                ai: {
                                    threaten: 4,
                                    combo: "old_olqingshu",
                                },
                            },
                            old_olqingshu: {
                                audio: "olqingshu",
                                trigger: {
                                    global: "phaseBefore",
                                    player: ["enterGame", "phaseZhunbeiBegin", "phaseJieshuBegin"],
                                },
                                filter(event, player) {
                                    return event.name !== "phase" || game.phaseNumber === 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const FromItems = lib.skill.old_olhedao.tianshuTrigger.slice();
                                    const froms = await player
                                        .chooseButton(["青书：请选择“天书”时机", [FromItems.randomGets(3).map(item => [item, item.name]), "textbutton"]], true)
                                        .set("ai", () => 1 + Math.random())
                                        .forResult("links");
                                    if (!froms?.length) return;
                                    const [from] = froms;
                                    const ToItems = lib.skill.old_olhedao.tianshuContent.filter(item => {
                                        return !item.filter || item.filter(from.name);
                                    });
                                    const tos = await player
                                        .chooseButton(['###青书：请选择“天书”效果###<div class="text center">' + from.name + "</div>", [ToItems.randomGets(3).map(item => [item, item.name]), "textbutton"]], true)
                                        .set("ai", () => 1 + Math.random())
                                        .forResult("links");
                                    if (!tos?.length) return;
                                    const [to] = tos;
                                    let skill;
                                    while (true) {
                                        skill = "old_olhedao_tianshu_" + Math.random().toString(36).slice(-8);
                                        if (!lib.skill[skill]) break;
                                    }
                                    game.broadcastAll(
                                        (skill, from, to) => {
                                            lib.skill[skill] = { nopop: true, old_olhedao: true, charlotte: true, onremove: true, ...from.effect, ...to.effect };
                                            lib.skill[skill].init = (player, skill) => (player.storage[skill] = player.storage[skill] || [0, skill]);
                                            lib.skill[skill].intro = {
                                                markcount: (storage = [0]) => storage[0],
                                                content(storage, player) {
                                                    const book = storage?.[1];
                                                    if (!book) return "查无此书";
                                                    return [
                                                        "此书还可使用" + storage[0] + "次",
                                                        (() => {
                                                            if (!player.isUnderControl(true) && get.info(book)?.nopop) return "此书仍是个秘密";
                                                            return lib.translate[book + "_info"];
                                                        })(),
                                                    ]
                                                        .map(str => "<li>" + str)
                                                        .join("<br>");
                                                },
                                            };
                                            lib.skill[skill].markimage = "image/card/tianshu2.png";
                                            lib.translate[skill] = "天书";
                                            lib.translate[skill + "_info"] = from.name + "，" + to.name + "。";
                                            game.finishSkill(skill);
                                        },
                                        skill,
                                        from,
                                        to
                                    );
                                    player.addSkill(skill);
                                    lib.skill.old_olhedao.tianshuClear(skill, player, -3);
                                    const skills = player.getSkills(null, false, false).filter(skill => get.info(skill)?.old_olhedao);
                                    const num = skills.length - Math.max(1, player.countMark("old_olhedao"));
                                    if (num > 0) {
                                        const result = await player
                                            .chooseButton(["青书：选择失去" + get.cnNumber(num) + "册多余的“天书”", [skills.map(item => [item, "（剩余" + player.storage[item][0] + "次）" + lib.translate[item + "_info"]]), "textbutton"]], true, num)
                                            .set("ai", () => 1 + Math.random())
                                            .forResult();
                                        if (result?.bool && result.links?.length) player.removeSkill(result.links);
                                    }
                                },
                                ai: {
                                    threaten: 4,
                                    combo: "old_olhedao",
                                },
                                derivation: "old_olhedao_faq",
                            },
                            old_olshoushu: {
                                audio: "lshoushu",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return (
                                        player.getSkills(null, false, false).some(skill => {
                                            return get.info(skill)?.old_olhedao && get.info(skill).nopop;
                                        }) && game.hasPlayer(target => target !== player)
                                    );
                                },
                                usable: 1,
                                filterTarget: lib.filter.notMe,
                                async content(event, trigger, player) {
                                    const { target } = event;
                                    const skills = player.getSkills(null, false, false).filter(skill => {
                                        return get.info(skill)?.olhedao && get.info(skill).nopop;
                                    });
                                    if (!skills.length) return;
                                    const result =
                                        skills.length > 1
                                            ? await player
                                                .chooseButton(["授术：请选择你要授予" + get.translation(target) + "的天书", [skills.map(item => [item, get.translation(item + "_info")]), "textbutton"]], true)
                                                .set("ai", () => 1 + Math.random())
                                                .forResult()
                                            : { bool: true, links: skills };
                                    if (result?.bool && result.links?.length) {
                                        const [skill] = result.links;
                                        player.removeSkill(skill);
                                        target.addSkill(skill);
                                        lib.skill.old_olhedao.tianshuClear(skill, target, -1);
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: { target: 1 },
                                    combo: "old_olhedao",
                                },
                            },
                            //谋邓艾
                            old_olsbjiewan: {
                                audio: "olsbjiewan",
                                enable: "phaseUse",
                                usable: 1,
                                content() {
                                    "step 0";
                                    player.loseMaxHp();
                                    var card = get.cardPile(function (card) {
                                        var type = get.type(card, false);
                                        if (type != "trick") return false;
                                        return get.tag(card, "damage") > 0;
                                    });
                                    if (card) player.gain(card, "gain2");
                                    "step 1";
                                    player
                                        .chooseCard("h", true, "解腕：请选择一张伤害类手牌，令此牌本回合造成伤害+1", function (card, player) {
                                            var type = get.type(card, false);
                                            if (type != "basic" && type != "trick") return false;
                                            return get.tag(card, "damage") > 0;
                                        })
                                        .set("ai", card => 6 - get.value(card));
                                    "step 2";
                                    if (result.bool) {
                                        player.addGaintag(result.cards, "old_olsbjiewan");
                                        player.addTempSkill("old_olsbjiewan_damage");
                                        player.addTempSkill("old_olsbjiewan_2");
                                    }
                                },
                                subSkill: {
                                    damage: {
                                        audio: "olsbjiewan",
                                        trigger: { player: "useCard" },
                                        forced: true,
                                        charlotte: true,
                                        filter(event, player) {
                                            return player.hasHistory("lose", evt => {
                                                if (evt.getParent() !== event) return false;
                                                return Object.values(evt.gaintag_map).some(tags => tags.includes("old_olsbjiewan"));
                                            });
                                        },
                                        content() {
                                            game.countPlayer(function (current) {
                                                current.addTempSkill("old_olsbjiewan_1");
                                            });
                                        },
                                    },
                                    1: {
                                        audio: "old_olsbjiewan",
                                        trigger: {
                                            player: "damageBegin4",
                                        },
                                        forced: true,
                                        charlotte: true,
                                        logTarget: "player",
                                        content() {
                                            trigger.num++;
                                            player.removeSkill("old_olsbjiewan_1");
                                        },
                                    },
                                    2: {
                                        trigger: {
                                            player: "useCardAfter",
                                        },
                                        forced: true,
                                        silent: true,
                                        popup: false,
                                        charlotte: true,
                                        filter(event, player) {
                                            return event.notLink();
                                        },
                                        content() {
                                            game.countPlayer(function (current) {
                                                current.removeSkill("old_olsbjiewan_1");
                                            });
                                        },
                                    },
                                },
                            },
                            olsbpixian: {
                                audio: 2,
                                trigger: {
                                    player: "phaseUseEnd",
                                },
                                filter(event, player) {
                                    return !player.isMaxHp();
                                },
                                forced: true,
                                content() {
                                    "step 0";
                                    var list = [];
                                    list.push("回复1点体力");
                                    list.push("增加1点体力上限");
                                    player.chooseControl(list, true).set("ai", function () {
                                        if (player.hp < player.maxHp) return "回复1点体力";
                                        return "增加一点体力上限";
                                    });
                                    "step 1";
                                    if (result.control == "回复1点体力") {
                                        player.recover();
                                    }
                                    "step 2";
                                    if (result.control == "增加1点体力上限") {
                                        player.gainMaxHp();
                                    }
                                },
                            },
                            //OL界王异
                            old_olzhenlie: {
                                audio: "olzhenlie",
                                inherit: "zhenlie",
                                async content(event, trigger, player) {
                                    const target = trigger.player;
                                    if (get.attitude(player, target) < 0 && target.countDiscardableCards(player, "he")) player.addTempSkill("zhenlie_lose");
                                    await player.loseHp();
                                    player.removeSkill("zhenlie_lose");
                                    trigger.getParent().excluded.add(player);
                                    if (!player.isIn()) return;
                                    const goon = target.hasCard(card => {
                                        if (get.position(card) == "h") return true;
                                        return lib.filter.canBeGained(card, player, target);
                                    }, "he");
                                    if (goon || player.isDamaged()) {
                                        let result;
                                        if (goon && player.isDamaged())
                                            result = await player
                                                .chooseControl()
                                                .set("choiceList", ["获得" + get.translation(target) + "的一张牌", "发动一次【秘计】"])
                                                .set("ai", () => {
                                                    const player = get.event("player"),
                                                        target = get.event().getTrigger().player;
                                                    return get.effect(target, { name: "shunshou_copy2" }, player, player) > get.effect(player, { name: "draw" }, player, player) * player.getDamagedHp() ? 0 : 1;
                                                })
                                                .forResult();
                                        else result = { index: goon ? 0 : 1 };
                                        if (result.index == 0) {
                                            await player.gainPlayerCard(target, "he", true);
                                        } else {
                                            let next = game.createEvent("zhenlie_olmiji");
                                            next.player = player;
                                            next.setContent(lib.skill.olmiji.content);
                                            await next;
                                        }
                                    }
                                },
                                audioname: ["re_wangyi"],
                                filter: function (event, player) {
                                    return event.player != player && event.card && (event.card.name == "sha" || get.type(event.card) == "trick");
                                },
                                logTarget: "player",
                                check: function (event, player) {
                                    if (event.getParent().excluded.includes(player)) return false;
                                    if (get.attitude(player, event.player) > 0 || (player.hp < 2 && !get.tag(event.card, "damage"))) return false;
                                    let evt = event.getParent(),
                                        directHit = (evt.nowuxie && get.type(event.card, "trick") === "trick") || (evt.directHit && evt.directHit.includes(player)) || (evt.customArgs && evt.customArgs.default && evt.customArgs.default.directHit2);
                                    if (get.tag(event.card, "respondSha")) {
                                        if (directHit || player.countCards("h", { name: "sha" }) === 0) return true;
                                    } else if (get.tag(event.card, "respondShan")) {
                                        if (directHit || player.countCards("h", { name: "shan" }) === 0) return true;
                                    } else if (get.tag(event.card, "damage")) {
                                        if (event.card.name === "huogong") return event.player.countCards("h") > 4 - player.hp - player.hujia;
                                        if (event.card.name === "shuiyanqijunx") return player.countCards("e") === 0;
                                        return true;
                                    } else if (player.hp > 2) {
                                        if (event.card.name === "shunshou" || (event.card.name === "zhujinqiyuan" && (event.card.yingbian || get.distance(event.player, player) < 0))) return true;
                                    }
                                    return false;
                                },
                                trigger: {
                                    target: "useCardToTargeted",
                                },
                                ai: {
                                    filterDamage: true,
                                    skillTagFilter: (player, tag, arg) => {
                                        return arg && arg.jiu == true;
                                    },
                                    effect: {
                                        target(card, player, target) {
                                            if (target.hp <= 0 && target.hasSkill("zhenlie_lose") && get.tag(card, "recover")) return [1, 1.2];
                                        },
                                    },
                                },
                            },
                            //OL薛灵芸
                            old_olsiqi: {
                                audio: "olsiqi",
                                trigger: { player: "damageEnd" },
                                filter(event, player) {
                                    const cardPile = Array.from(ui.cardPile.childNodes).reverse();
                                    return cardPile[0] && get.color(cardPile[0]) === "red";
                                },
                                async cost(event, trigger, player) {
                                    const cardPile = Array.from(ui.cardPile.childNodes).reverse();
                                    const redCards = [];
                                    for (const card of cardPile) {
                                        if (get.color(card) == "red") {
                                            redCards.push(card);
                                            if (redCards.length >= 5) break;
                                        } else break;
                                    }
                                    const { result } = await player
                                        .chooseNumbers(get.prompt2("old_olsiqi"), [{ prompt: "请选择你要亮出的牌数", min: 1, max: redCards.length }])
                                        .set("processAI", () => {
                                            return [get.event().maxNum];
                                        })
                                        .set("maxNum", redCards.length);
                                    if (result.bool) {
                                        const number = result.numbers[0];
                                        event.result = {
                                            bool: result.bool,
                                            cost_data: number,
                                        };
                                    }
                                },
                                async content(event, trigger, player) {
                                    const cardPile = Array.from(ui.cardPile.childNodes).reverse();
                                    const cards = [];
                                    const number = event.cost_data;
                                    for (const card of cardPile) {
                                        if (get.color(card) == "red") {
                                            cards.push(card);
                                            if (cards.length >= number) break;
                                        } else break;
                                    }
                                    await player.showCards(cards, get.translation(player) + "发动了【思泣】");
                                    while (cards.length) {
                                        if (
                                            cards.every(card => {
                                                const name = ["tao", "wuzhong"];
                                                if (name.includes(card.name) || get.type(card) == "equip") {
                                                    return !game.hasPlayer(target => lib.filter.targetEnabled2(card, player, target));
                                                }
                                                return true;
                                            })
                                        )
                                            break;
                                        const { result: result2 } = await player
                                            .chooseCardButton(cards, true, "思泣：请选择要使用的牌")
                                            .set("filterButton", button => {
                                                const card = button.link;
                                                if (["tao", "wuzhong"].includes(card.name) || get.type(card) == "equip") return game.hasPlayer(target => lib.filter.targetEnabled2(card, get.player(), target));
                                                return false;
                                            })
                                            .set("ai", button => {
                                                return get.player().getUseValue(button.link);
                                            });
                                        if (result2.bool) {
                                            const card = result2.links[0];
                                            game.broadcastAll(card => {
                                                lib.skill.old_olsiqi_backup.viewAs = card;
                                                lib.skill.old_olsiqi_backup.viewAs.cards = [card];
                                            }, card);
                                            const next = player.chooseToUse();
                                            next.set("openskilldialog", `思泣：是否使用${get.translation(card)}？`);
                                            next.set("forced", true);
                                            next.set("norestore", true);
                                            next.set("_backupevent", "old_olsiqi_backup");
                                            next.set("custom", {
                                                add: {},
                                                replace: { window() { } },
                                            });
                                            next.backup("old_olsiqi_backup");
                                            next.set("addCount", false);
                                            player
                                                .when("chooseToUseBegin")
                                                .filter(evt => evt === next)
                                                .then(() => (trigger.filterCard = () => false));
                                            const { result: result3 } = await next;
                                            if (result3.bool) {
                                                cards.remove(card);
                                                continue;
                                            }
                                        }
                                        break;
                                    }
                                    if (cards.length) {
                                        await game.cardsDiscard(cards);
                                        await player.draw(cards.length);
                                    }
                                },
                                mod: {
                                    selectTarget(card, player, range) {
                                        if (_status._old_olsiqi_check) return;
                                        const event = get.event();
                                        if (!event || event.name !== "chooseToUse" || event.getParent().name !== "old_olsiqi") return;
                                        _status._old_olsiqi_check = true;
                                        const bool = game.countPlayer(target => lib.filter.targetEnabled2(card, player, target)) > 1;
                                        delete _status._old_olsiqi_check;
                                        if (bool) {
                                            if (range[0] !== 1) range[0] = 1;
                                            if (range[1] !== 1) range[1] = 1;
                                        }
                                    },
                                    cardEnabled2(card, player) {
                                        if (_status._old_olsiqi_check) return;
                                        const event = get.event();
                                        if (!event || event.name !== "chooseToUse" || event.getParent().name !== "old_olsiqi") return;
                                        _status._old_olsiqi_check = true;
                                        const bool = game.hasPlayer(target => lib.filter.targetEnabled2(card, player, target));
                                        delete _status._old_olsiqi_check;
                                        if (bool) return true;
                                    },
                                    cardEnabled(card, player) {
                                        if (_status._old_olsiqi_check) return;
                                        const event = get.event();
                                        if (!event || event.name !== "chooseToUse" || event.getParent().name !== "old_olsiqi") return;
                                        _status._old_olsiqi_check = true;
                                        const bool = game.hasPlayer(target => lib.filter.targetEnabled2(card, player, target));
                                        delete _status._old_olsiqi_check;
                                        if (bool) return true;
                                    },
                                    playerEnabled(card, player, target) {
                                        if (_status._old_olsiqi_check) return;
                                        const event = get.event();
                                        if (!event || event.name !== "chooseToUse" || event.getParent().name !== "old_olsiqi") return;
                                        _status._old_olsiqi_check = true;
                                        const bool = lib.filter.targetEnabled2(card, player, target);
                                        delete _status._old_olsiqi_check;
                                        if (bool) return true;
                                    },
                                },
                                locked: false,
                                group: "old_olsiqi_lose",
                                subSkill: {
                                    backup: {
                                        filterCard: () => false,
                                        selectCard: -1,
                                        filterTarget: lib.filter.targetEnabled2,
                                        precontent() {
                                            delete event.result.skill;
                                            const name = event.result.card.name,
                                                cards = event.result.card.cards.slice(),
                                                rcard = cards[0];
                                            event.result.cards = cards;
                                            event.result.card = get.autoViewAs(rcard.name == name ? rcard : { name, isCard: true });
                                        },
                                    },
                                    lose: {
                                        audio: "olsiqi",
                                        trigger: {
                                            player: "loseAfter",
                                            global: ["loseAsyncAfter", "cardsDiscardAfter", "equipAfter", "addJudgeAfter", "addToExpansionAfter"],
                                        },
                                        filter(event, player) {
                                            return event.getd(player).some(i => get.color(i, player) === "red");
                                        },
                                        forced: true,
                                        locked: true,
                                        async content(event, trigger, player) {
                                            const list = trigger.getd(player).filter(i => get.color(i, player) === "red");
                                            await game.cardsGotoPile(list);
                                            game.log(player, "将", list, "置入了牌堆底");
                                        },
                                    },
                                },
                            },
                            //界徐庶
                            old_rezhuhai: {
                                audio: "rezhuhai",
                                trigger: {
                                    global: "phaseJieshuBegin",
                                },
                                direct: true,
                                filter(event, player) {
                                    return player != event.player && event.player.getHistory("sourceDamage").length > 0 && event.player.isIn() && (player.canUse("sha", event.player, false) || player.canUse("guohe", event.player));
                                },
                                content() {
                                    "step 0";
                                    var target = trigger.player;
                                    var choiceList = ["视为对其使用一张【杀】", "视为对其使用一张【过河拆桥】"];
                                    var choices = [];
                                    if (player.canUse("sha", target, false)) choices.push("选项一");
                                    else choiceList[0] = "<span style='opacity:0.5'>" + choiceList[0] + "</span>";
                                    if (player.canUse("guohe", target)) choices.push("选项二");
                                    else choiceList[1] = "<span style='opacity:0.5'>" + choiceList[1] + "</span>";
                                    choices.push("cancel2");
                                    player
                                        .chooseControl(choices)
                                        .set("choiceList", choiceList)
                                        .set("prompt", get.prompt("old_rezhuhai", target))
                                        .set("ai", function () {
                                            var choices = _status.event.controls;
                                            var eff1 = 0,
                                                eff2 = 0;
                                            var player = _status.event.player,
                                                target = _status.event.getTrigger().player;
                                            if (choices.contains("选项一")) eff1 = get.effect(target, { name: "sha" }, player, player);
                                            if (choices.contains("选项二")) eff2 = get.effect(target, { name: "guohe" }, player, player);
                                            if (eff1 > 0 && ((player.hasSkill("xsqianxin") && player.isDamaged()) || eff1 > eff2)) return "选项一";
                                            if (eff2 > 0) return "选项二";
                                            return "cancel2";
                                        });
                                    "step 1";
                                    if (result.control != "cancel2") {
                                        if (result.control == "选项一") {
                                            player.useCard({ name: "sha", isCard: true }, trigger.player, false, "old_rezhuhai");
                                        } else {
                                            player.useCard({ name: "guohe", isCard: true }, trigger.player, "old_rezhuhai");
                                            event.finish();
                                        }
                                    }
                                },
                            },
                            //乐綝
                            old_dcporui: {
                                audio: "dcporui",
                                trigger: {
                                    global: "phaseJieshuBegin",
                                },
                                filter(event, player) {
                                    if (player == event.player) return false;
                                    if (player.countMark("old_dcporui_round") >= 1) return false;
                                    return (
                                        game.hasPlayer(current => {
                                            if (current == player || current == event.player) return false;
                                            return current.hasHistory("lose", function (evt) {
                                                return evt.cards.length > 0;
                                            });
                                        }) &&
                                        (_status.connectMode || player.hasCard({ type: "basic" }, "h"))
                                    );
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    player.chooseCardTarget({
                                        prompt: get.prompt("old_dcporui"),
                                        prompt2: "弃置一张基本牌并选择一名本回合失去过牌的非当前回合的其他角色，你视为对其依次使用" + get.cnNumber(Math.max(0, player.hp) + 1) + "张【杀】",
                                        filterCard(card) {
                                            return get.type(card) == "basic";
                                        },
                                        selectCard: 1,
                                        position: "h",
                                        list: game.filterPlayer(current => {
                                            if (current == player || current == trigger.player) return false;
                                            return current.hasHistory("lose", function (evt) {
                                                return evt.cards.length > 0;
                                            });
                                        }),
                                        filterTarget(card, player, target) {
                                            return target.hasHistory("lose", function (evt) {
                                                return evt.cards.length > 0;
                                            });
                                        },
                                        ai1(card) {
                                            return 7 - get.value(card);
                                        },
                                        ai2(target) {
                                            return get.effect(target, { name: "sha" }, _status.event.player, _status.event.player);
                                        },
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0],
                                            cards = result.cards;
                                        event.target = target;
                                        player.logSkill("old_dcporui", target);
                                        player.discard(cards);
                                        event.num2 = Math.max(0, player.hp);
                                        event.num = Math.max(0, player.hp) + 1;
                                        player.addTempSkill("old_dcporui_round", "roundStart");
                                        player.addMark("old_dcporui_round", 1, false);
                                    } else event.finish();
                                    "step 2";
                                    var card = { name: "sha", isCard: true, storage: { old_dcporui: true } };
                                    if (player.canUse(card, target, false) && target.isIn()) {
                                        player.useCard(card, target);
                                        event.num--;
                                    } else event.goto(4);
                                    "step 3";
                                    if (event.num > 0) event.goto(2);
                                    "step 4";
                                    if (!player.hasMark("old_dcgonghu_damage")) {
                                        var cards = player.getCards("h");
                                        if (cards.length == 0) event._result = { bool: false };
                                        else if (cards.length <= event.num2) event._result = { bool: true, cards: cards };
                                        else player.chooseCard("破锐：交给" + get.translation(target) + get.cnNumber(event.num2) + "张手牌", true, event.num2);
                                    } else event.finish();
                                    "step 5";
                                    if (result.bool) {
                                        player.give(result.cards, target);
                                    }
                                    event.finish();
                                    "step 6";
                                    if (player.hasMark("old_dcgonghu_basic")) {
                                        if (
                                            !target.hasHistory("damage", evt => {
                                                return evt.card && evt.card.storage && evt.card.storage.old_dcporui && evt.getParent("old_dcporui") == event;
                                            })
                                        ) {
                                            player.recover();
                                        }
                                    }
                                },
                                subSkill: {
                                    round: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                                ai: {
                                    expose: 0.4,
                                    threaten: 3.8,
                                },
                            },
                            old_dcgonghu: {
                                audio: "dcgonghu",
                                trigger: {
                                    player: ["loseAfter", "damageEnd"],
                                    source: "damageSource",
                                    global: ["equipAfter", "addJudgeAfter", "gainAfter", "loseAsyncAfter", "addToExpansionAfter"],
                                },
                                forced: true,
                                filter(event, player) {
                                    if (!_status.currentPhase || _status.currentPhase == player) return false;
                                    if (event.name == "damage") {
                                        if (player.hasMark("old_dcgonghu_damage")) return false;
                                        return true;
                                    }
                                    if (player.hasMark("old_dcgonghu_basic")) return false;
                                    if (_status.currentPhase && _status.currentPhase == player) return false;
                                    var evt = event.getl(player);
                                    if (!evt || !evt.cards2 || !evt.cards2.some(i => get.type2(i, player) == "basic")) return false;
                                    return true;
                                },
                                group: ["old_dcgonghu_basic", "old_dcgonghu_trick"],
                                content() {
                                    player.addMark("old_dcgonghu_" + (trigger.name == "damage" ? "damage" : "basic"), 1, false);
                                },
                                mark: true,
                                intro: {
                                    onunmark: true,
                                    content(storage, player) {
                                        var str = "";
                                        if (!player.hasMark("old_dcgonghu_damage") && !player.hasMark("old_dcgonghu_basic")) return "";
                                        if (player.hasMark("old_dcgonghu_basic")) str += "已于回合外失去过基本牌，若“破锐”使用【杀】未造成伤害则回复一点体力。<br>";
                                        if (player.hasMark("old_dcgonghu_damage")) str += "已于回合外造成/受到过伤害，“破锐”使用【杀】后无需给牌。<br>";
                                        if (player.hasMark("old_dcgonghu_basic") && player.hasMark("old_dcgonghu_damage")) str += "已达成全部条件，使用红色基本牌不可被响应，红色锦囊牌可多指定一个目标。";

                                        return str;
                                    },
                                },
                                subSkill: {
                                    trick: {
                                        audio: "dcgonghu",
                                        trigger: {
                                            player: "useCard2",
                                        },
                                        direct: true,
                                        locked: true,
                                        filter(event, player) {
                                            if (!player.hasMark("old_dcgonghu_basic") || !player.hasMark("old_dcgonghu_damage")) return false;
                                            var card = event.card;
                                            if (get.color(card, false) != "red" || get.type(card, null, true) != "trick") return false;
                                            var info = get.info(card);
                                            if (info.allowMultiple == false) return false;
                                            if (event.targets && !info.multitarget) {
                                                if (
                                                    game.hasPlayer(function (current) {
                                                        return !event.targets.contains(current) && lib.filter.targetEnabled2(card, player, current);
                                                    })
                                                ) {
                                                    return true;
                                                }
                                            }
                                            return false;
                                        },
                                        content() {
                                            "step 0";
                                            var prompt2 = "为" + get.translation(trigger.card) + "增加一个目标";
                                            player
                                                .chooseTarget(get.prompt("old_dcgonghu_trick"), function (card, player, target) {
                                                    var player = _status.event.player;
                                                    return !_status.event.targets.contains(target) && lib.filter.targetEnabled2(_status.event.card, player, target);
                                                })
                                                .set("prompt2", prompt2)
                                                .set("ai", function (target) {
                                                    var trigger = _status.event.getTrigger();
                                                    var player = _status.event.player;
                                                    return get.effect(target, trigger.card, player, player);
                                                })
                                                .set("card", trigger.card)
                                                .set("targets", trigger.targets);
                                            "step 1";
                                            if (result.bool) {
                                                if (!event.isMine() && !event.isOnline()) game.delayx();
                                                event.targets = result.targets;
                                            } else {
                                                event.finish();
                                            }
                                            "step 2";
                                            if (event.targets) {
                                                player.logSkill("old_dcgonghu_trick", event.targets);
                                                trigger.targets.addArray(event.targets);
                                            }
                                        },
                                    },
                                    basic: {
                                        audio: "dcgonghu",
                                        trigger: {
                                            player: "useCard",
                                        },
                                        forced: true,
                                        filter(event, player) {
                                            if (!player.hasMark("old_dcgonghu_basic") || !player.hasMark("old_dcgonghu_damage")) return false;
                                            var card = event.card;
                                            return get.color(card, false) == "red" && get.type(card, null, false) == "basic";
                                        },
                                        content() {
                                            trigger.directHit.addArray(game.filterPlayer());
                                            game.log(trigger.card, "不可被响应");
                                        },
                                    },
                                },
                            },
                            //阮瑀
                            old_miaoxian: {
                                hiddenCard(player, name) {
                                    return get.type(name) == "trick" && !player.getStorage("old_miaoxian2").contains(name) && player.countCards("h", { color: "black" }) == 1;
                                },
                                enable: "chooseToUse",
                                filter(event, player) {
                                    var cards = player.getCards("h", { color: "black" });
                                    if (cards.length != 1) return false;
                                    var mod2 = game.checkMod(cards[0], player, "unchanged", "cardEnabled2", player);
                                    if (mod2 === false) return false;
                                    var storage = player.getStorage("old_miaoxian2");
                                    for (var i of lib.inpile) {
                                        if (
                                            !storage.contains(i) &&
                                            get.type(i) == "trick" &&
                                            event.filterCard(
                                                {
                                                    name: i,
                                                    cards: cards,
                                                },
                                                player,
                                                event
                                            )
                                        )
                                            return true;
                                    }
                                    return false;
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var cards = player.getCards("h", { color: "black" });
                                        var storage = player.getStorage("old_miaoxian2");
                                        var list = [];
                                        for (var i of lib.inpile) {
                                            if (
                                                !storage.contains(i) &&
                                                get.type(i) == "trick" &&
                                                event.filterCard(
                                                    {
                                                        name: i,
                                                        cards: cards,
                                                    },
                                                    player,
                                                    event
                                                )
                                            ) {
                                                list.push(["锦囊", "", i]);
                                            }
                                        }
                                        return ui.create.dialog("妙弦", [list, "vcard"], "hidden");
                                    },
                                    check(button) {
                                        var player = _status.event.player;
                                        return player.getUseValue({ name: button.link[2] }) + 1;
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: "miaoxian",
                                            popname: true,
                                            filterCard: { color: "black" },
                                            selectCard: -1,
                                            position: "h",
                                            viewAs: {
                                                name: links[0][2],
                                            },
                                            onuse(links, player) {
                                                if (!player.storage.old_miaoxian2) player.storage.old_miaoxian2 = [];
                                                player.storage.old_miaoxian2.add(links.card.name);
                                                player.addTempSkill("old_miaoxian2");
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        return "将" + get.translation(player.getCards("h", { color: "black" })[0]) + "当做" + get.translation(links[0][2]) + "使用";
                                    },
                                },
                                group: "old_miaoxian_use",
                                subfrequent: ["use"],
                                subSkill: {
                                    use: {
                                        audio: "miaoxian",
                                        trigger: { player: "loseAfter" },
                                        frequent: true,
                                        prompt: "是否发动【妙弦】摸一张牌？",
                                        filter(event, player) {
                                            var evt = event.getParent();
                                            if (evt.name != "useCard") return false;
                                            return event.hs && event.hs.length == 1 && event.cards && event.cards.length == 1 && get.color(event.hs[0], player) == "red" && !player.countCards("h", { color: "red" });
                                        },
                                        content() {
                                            player.draw();
                                        },
                                    },
                                    backup: {
                                        audio: "miaoxian",
                                    },
                                },
                                ai: {
                                    order: 12,
                                    result: {
                                        player: 1,
                                    },
                                },
                            },
                            old_miaoxian2: {
                                charlotte: true,
                            },
                            //柏灵筠
                            old_dclinghui: {
                                audio: "dclinghui",
                                trigger: {
                                    global: "phaseJieshuBegin",
                                },
                                filter(event, player) {
                                    return game.filterPlayer(play => play.getHistory("damage").length).length > 1;
                                },
                                check(event, player) {
                                    return true;
                                },
                                content() {
                                    "step 0";
                                    var cards = get.cards(3);
                                    event.cards = cards;
                                    game.cardsGotoOrdering(cards);
                                    player.chooseButton(["是否使用其中一张牌", cards], false).set("filterButton", button => {
                                        var player = _status.event.player;
                                        var card = button.link;
                                        var cardx = {
                                            name: get.name(card, get.owner(card)),
                                            nature: get.nature(card, get.owner(card)),
                                            cards: [card],
                                        };
                                        return player.hasUseTarget(cardx, null, false);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var card = result.links[0];
                                        cards.remove(card);
                                        var cardx = {
                                            name: get.name(card, get.owner(card)),
                                            nature: get.nature(card, get.owner(card)),
                                            cards: [card],
                                        };
                                        var next = player.chooseUseTarget(cardx, [card], true, false).set("oncard", card => {
                                            var owner = _status.event.getParent().owner;
                                            if (owner) owner.$throw(card.cards);
                                        });
                                        if (card.name != cardx.name || !get.is.sameNature(card, cardx)) next.viewAs = true;
                                    } else {
                                        while (cards.length) {
                                            var card = cards.pop();
                                            card.fix();
                                            ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                                        }
                                        game.updateRoundNumber();
                                        event.finish();
                                    }
                                    "step 2";
                                    player.gain(event.cards, "gain2");
                                },
                            },
                            oldx_dclinghui: {
                                audio: "dclinghui",
                                trigger: {
                                    global: "phaseJieshuBegin",
                                },
                                filter(event, player) {
                                    if (_status.currentPhase === player) return true;
                                    return game.getGlobalHistory("everything", evt => evt.name == "dying").length;
                                },
                                frequent: true,
                                async content(event, trigger, player) {
                                    let cards = get.cards(3);
                                    await game.cardsGotoOrdering(cards);
                                    const {
                                        result: { bool, links },
                                    } = await player
                                        .chooseButton(["灵慧：是否使用其中的一张牌并获得剩余牌？", cards])
                                        .set("filterButton", button => {
                                            return get.player().hasUseTarget(button.link);
                                        })
                                        .set("ai", button => {
                                            return get.event("player").getUseValue(button.link);
                                        });
                                    if (bool) {
                                        const card = links[0];
                                        cards.remove(card);
                                        player.$gain2(card, false);
                                        await game.asyncDelayx();
                                        await player.chooseUseTarget(true, card, false);
                                        cards = cards.filterInD();
                                        if (cards.length) {
                                            await player.gain(cards, "gain2");
                                        }
                                    }
                                },
                            },
                            old_dcyuxin: {
                                audio: "dcyuxin",
                                trigger: { global: "dying" },
                                check(event, player) {
                                    return get.attitude(event.player, player) > 0;
                                },
                                limited: true,
                                unique: true,
                                filter(event, player) {
                                    return event.player.hp <= 0;
                                },
                                skillAnimation: true,
                                animationColor: "thunder",
                                logTarget: "player",
                                content() {
                                    "step 0";
                                    player.awakenSkill("oldyuxin");
                                    var num = 1 - trigger.player.hp;
                                    if (num) trigger.player.recover(num);
                                    "step 1";
                                    if (trigger.player != player && trigger.player.hp != player.hp) {
                                        event.num1 = player.hp;
                                        event.num2 = trigger.player.hp;
                                        event.num3 = event.num1 - event.num2;
                                    } else event.finish();
                                    "step 2";
                                    player.hp = event.num2;
                                    player.update();
                                    if (trigger.player.isIn()) {
                                        trigger.player.hp = event.num1;
                                        trigger.player.update();
                                    }
                                    game.log(player, "和", trigger.player, "交换了体力值");
                                    "step 3";
                                    if (event.num3 > 0) player.draw(event.num3);
                                },
                            },
                            //刘理
                            old_dcfuli: {
                                audio: "dcfuli",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return (
                                        player.countDiscardableCards(player, "h") &&
                                        player.countCards("h", function (card) {
                                            return !player.storage.old_dcfuli.contains(get.type2(card));
                                        }) > 0
                                    );
                                },
                                init(player) {
                                    player.storage.old_dcfuli = [];
                                },
                                async content(event, trigger, player) {
                                    await player.showHandcards(get.translation(player) + "发动了【抚黎】");
                                    const getNum = type => {
                                        let num = ["basic", "trick", "equip"].indexOf(type);
                                        if (num === -1) num = 3;
                                        return num;
                                    };
                                    const types = player
                                        .getDiscardableCards(player, "h")
                                        .reduce((list, card) => {
                                            if (player.storage.old_dcfuli.contains(get.type2(card))) return list;
                                            else return list.add(get.type2(card));
                                        }, [])
                                        .sort((a, b) => getNum(a) - getNum(b));
                                    if (types.length) {
                                        const {
                                            result: { control },
                                        } = await player
                                            .chooseControl(types)
                                            .set("ai", () => {
                                                const player = get.event("player"),
                                                    types = get.event("controls").slice();
                                                const getNum = type => {
                                                    const cards = player.getDiscardableCards(player, "h").filter(card => get.type2(card) == type);
                                                    const countCards = (target, player, cards) => {
                                                        return target.countCards("h") - (target == player ? cards.length : 0);
                                                    };
                                                    const max = game
                                                        .findPlayer(target => {
                                                            return !game.hasPlayer(target2 => {
                                                                return countCards(target2, player, cards) > countCards(target, player, cards);
                                                            });
                                                        })
                                                        .countCards("h");
                                                    return (
                                                        Math.min(
                                                            max,
                                                            cards.reduce((sum, card) => sum + get.cardNameLength(card), 0)
                                                        ) / cards.length
                                                    );
                                                };
                                                return types.sort((a, b) => {
                                                    return getNum(b) - getNum(a);
                                                })[0];
                                            })
                                            .set("prompt", "弃置一种类别的所有手牌，然后摸这些牌的名字字数之和的牌");
                                        if (control) {
                                            player.storage.old_dcfuli.push(control);
                                            player.addTempSkill("old_dcfuli_mark");
                                            const cards = player.getDiscardableCards(player, "h").filter(card => get.type2(card) == control);
                                            await player.discard(cards);
                                            const max = game.findPlayer(target => target.isMaxHandcard()).countCards("h");
                                            const num = Math.min(
                                                max,
                                                cards.reduce((sum, card) => sum + get.cardNameLength(card), 0)
                                            );
                                            if (num) await player.draw(num);
                                            if (cards.some(card => card.name != "shandian" && get.tag(card, "damage"))) {
                                                const {
                                                    result: { bool, targets },
                                                } = await player.chooseTarget("抚黎：是否令一名角色的攻击范围-1直到你的下个回合开始？").set("ai", target => {
                                                    const player = get.event("player"),
                                                        num = target.getAttackRange();
                                                    return -get.sgn(get.attitude(player, target)) * (target.getAttackRange() + (num <= 0 ? -num + 0.5 : num));
                                                });
                                                if (bool) {
                                                    const target = targets[0];
                                                    player.line(target);
                                                    target.addSkill("old_dcfuli_range");
                                                    target.addMark("old_dcfuli_range", 1, false);
                                                    player
                                                        .when(["phaseBegin", "dieBegin"])
                                                        .then(() => {
                                                            target.removeMark("old_dcfuli_range", 1, false);
                                                            if (!target.hasMark("old_dcfuli_range")) target.removeSkill("old_dcfuli_range");
                                                        })
                                                        .vars({ target: target });
                                                }
                                            }
                                        }
                                    }
                                },
                                ai: {
                                    order: 1,
                                    result: {
                                        player(player) {
                                            const types = player.getDiscardableCards(player, "h").reduce((list, card) => {
                                                return list.add(get.type2(card));
                                            }, []);
                                            if (
                                                !types.some(type => {
                                                    const cards = player.getDiscardableCards(player, "h").filter(card => get.type2(card) == type);
                                                    const countCards = (target, player, cards) => {
                                                        return target.countCards("h") - (target == player ? cards.length : 0);
                                                    };
                                                    return !game
                                                        .filterPlayer(target => {
                                                            return !game.hasPlayer(target2 => {
                                                                return countCards(target2, player, cards) > countCards(target, player, cards);
                                                            });
                                                        })
                                                        .includes(player);
                                                })
                                            )
                                                return 0;
                                            return 1;
                                        },
                                    },
                                },
                                group: "old_dcfuli_clear",
                                subSkill: {
                                    clear: {
                                        charlotte: true,
                                        direct: true,
                                        trigger: { player: "phaseEnd" },
                                        content() {
                                            player.storage.old_dcfuli = [];
                                        },
                                    },
                                    range: {
                                        charlotte: true,
                                        onremove: true,
                                        mod: {
                                            attackRange(player, num) {
                                                return num - player.countMark("old_dcfuli_range");
                                            },
                                        },
                                        marktext: " - ",
                                        intro: {
                                            content: "攻击范围-#",
                                        },
                                    },
                                    mark: {
                                        mark: true,
                                        intro: {
                                            onunmark: true,
                                            content(storage, player) {
                                                var str = "本回合已弃置过的类型：";
                                                for (var i of player.storage.old_dcfuli) str += get.translation(i) + " ";
                                                return str;
                                            },
                                        },
                                    },
                                },
                            },
                            old_dcdehua: {
                                audio: "dcdehua",
                                trigger: { global: "roundStart" },
                                forced: true,
                                async content(event, trigger, player) {
                                    const list = lib.inpile.filter(name => {
                                        if (get.type(name) === "delay") return false;
                                        const card = new lib.element.VCard({ name: name });
                                        return get.tag(card, "damage") && player.hasUseTarget(card);
                                    });
                                    if (list.length) {
                                        const {
                                            result: { bool, links },
                                        } = await player.chooseButton(["###德化###<div class='text center'>视为使用一张仍可以使用的伤害类卡牌</div>", [list, "vcard"]], true).set("ai", button => {
                                            const name = button.link[2],
                                                player = get.player();
                                            let value = player.getUseValue({ name, isCard: true }, null, true);
                                            if (player.countCards("h", card => get.name(card) === name && player.hasUseTarget(card))) value /= 3;
                                            if (name === "sha") value /= 2;
                                            if (player.getStorage("old_dcdehua").includes("sha")) value = Math.max(0.1, value);
                                            return value;
                                        });
                                        if (bool) {
                                            const name = links[0][2],
                                                card = new lib.element.VCard({ name: name });
                                            await player.chooseUseTarget(card, true);
                                            player.markAuto("old_dcdehua", [name]);
                                        }
                                    }
                                    if (
                                        !lib.inpile.some(name => {
                                            if (get.type(name) === "delay") return false;
                                            const card = new lib.element.VCard({ name: name });
                                            return get.tag(card, "damage") && !player.getStorage("old_dcdehua").includes(name);
                                        })
                                    )
                                        player.removeSkillLog("old_dcdehua");
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.getStorage("old_dcdehua").length;
                                    },
                                    cardEnabled(card, player) {
                                        if (player.getStorage("old_dcdehua").includes(card.name) && (get.position(card) == "h" || (card.cards && card.cards.some(i => get.position(i) == "h")))) return false;
                                    },
                                    cardSavable(card, player) {
                                        if (player.getStorage("old_dcdehua").includes(card.name) && (get.position(card) == "h" || (card.cards && card.cards.some(i => get.position(i) == "h")))) return false;
                                    },
                                    aiValue(player, card) {
                                        if (player.getStorage("old_dcdehua").includes(get.name(card))) return 0;
                                    },
                                    aiUseful() {
                                        return lib.skill.old_dcdehua.old.aiValue.apply(this, arguments);
                                    },
                                },
                                intro: {
                                    content(storage) {
                                        return "<li>手牌上限+" + storage.length + "<br><li>不能从手牌中使用" + get.translation(storage);
                                    },
                                },
                            },
                            //乐祢衡
                            old_dcjigu: {
                                audio: "dcjigu",
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event, player) {
                                    return event.name != "phase" || game.phaseNumber == 0;
                                },
                                forced: true,
                                content() {
                                    const cards = player.getCards("h");
                                    player.addGaintag(cards, "old_dcjigu");
                                },
                                mod: {
                                    ignoredHandcard(card) {
                                        if (card.hasGaintag("old_dcjigu")) return true;
                                    },
                                    cardDiscardable(card, _, name) {
                                        if (name == "phaseDiscard" && card.hasGaintag("old_dcjigu")) return false;
                                    },
                                },
                                group: "old_dcjigu_temp",
                                subSkill: {
                                    temp: {
                                        audio: "dcjigu",
                                        trigger: {
                                            player: "damageEnd",
                                            source: "damageSource",
                                        },
                                        filter(event, player) {
                                            return player.countCards("e") == player.countCards("h", card => card.hasGaintag("old_dcjigu"));
                                        },
                                        prompt2(event, player) {
                                            return (
                                                "摸" +
                                                get.cnNumber(
                                                    Array.from({ length: 5 })
                                                        .map((_, i) => i + 1)
                                                        .reduce((sum, i) => sum + player.countEmptySlot(i), 0)
                                                ) +
                                                "张牌"
                                            );
                                        },
                                        content() {
                                            player.draw(
                                                Array.from({ length: 5 })
                                                    .map((_, i) => i + 1)
                                                    .reduce((sum, i) => sum + player.countEmptySlot(i), 0)
                                            );
                                        },
                                    },
                                },
                            },
                            //武诸葛
                            old_dcqingshi: {
                                audio: "dcqingshi",
                                trigger: {
                                    player: "useCard",
                                },
                                filter(event, player) {
                                    if (!player.isPhaseUsing() || player.hasSkill("old_dcqingshi_blocker")) return false;
                                    if (
                                        player.hasCard(card => {
                                            return get.name(card) == event.card.name;
                                        })
                                    )
                                        return true;
                                    return false;
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    var choices = [];
                                    var choiceList = ["令" + get.translation(trigger.card) + "对其中一个目标角色造成的伤害+1", "令任意名其他角色各摸一张牌", "摸" + get.translation(player.hp) + "张牌，然后【情势】于本回合失效"];
                                    if (trigger.targets && trigger.targets.length) choices.push("选项一");
                                    else choiceList[0] = "<span style='opacity:0.5'>" + choiceList[0] + "(无目标角色)</span>";
                                    if (game.countPlayer(i => i != player)) choices.push("选项二");
                                    else choiceList[1] = "<span style='opacity:0.5'>" + choiceList[1] + "</span>";
                                    if (player.hp > 0) choices.push("选项三");
                                    else choiceList[2] = "<span style='opacity:0.5'>" + choiceList[1] + "(体力值为0)</span>";
                                    player
                                        .chooseControl(choices, "cancel2")
                                        .set("choiceList", choiceList)
                                        .set("prompt", get.prompt("old_dcqingshi"))
                                        .set("ai", () => {
                                            return _status.event.choice;
                                        })
                                        .set(
                                            "choice",
                                            (() => {
                                                var choicesx = choices.slice();
                                                var cards = player.getCards("hs");
                                                var bool1 =
                                                    get.tag(trigger.card, "damage") &&
                                                    choicesx.includes("选项一") &&
                                                    trigger.targets.some(current => {
                                                        return get.attitude(player, current) < 0;
                                                    }),
                                                    bool2 = choicesx.includes("选项二");
                                                if (bool2)
                                                    bool2 = game.countPlayer(function (current) {
                                                        return player != current && get.attitude(player, current) > 0;
                                                    });
                                                else bool2 = 0;
                                                if (bool1 || bool2) {
                                                    for (var i = 0; i < cards.length; i++) {
                                                        var name = get.name(cards[i]);
                                                        if (player.getStorage("old_dcqingshi_clear").includes(name)) continue;
                                                        for (var j = i + 1; j < cards.length; j++) {
                                                            if (name === get.name(cards[j]) && get.position(cards[i]) + get.position(cards[j]) !== "ss" && player.hasValueTarget(cards[i])) {
                                                                choicesx.remove("选项三");
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                if (bool2 > 2) return "选项二";
                                                if (choicesx.includes("选项三")) return "选项三";
                                                if (bool2 === 2) return "选项二";
                                                if (bool1) return "选项一";
                                                if (bool2) return "选项二";
                                                return "cancel2";
                                            })()
                                        );
                                    "step 1";
                                    if (result.control != "cancel2") {
                                        player.logSkill("old_dcqingshi");
                                        game.log(player, "选择了", "#y" + result.control);
                                        var index = ["选项一", "选项二", "选项三"].indexOf(result.control) + 1;
                                        var next = game.createEvent("old_dcqingshi_after");
                                        next.player = player;
                                        next.card = trigger.card;
                                        next.setContent(lib.skill.old_dcqingshi["content" + index]);
                                    }
                                },
                                content1() {
                                    "step 0";
                                    player
                                        .chooseTarget("令" + get.translation(card) + "对其中一个目标造成的伤害+1", true, (card, player, target) => {
                                            return _status.event.targets.includes(target);
                                        })
                                        .set("ai", target => {
                                            return 2 - get.attitude(_status.event.player, target);
                                        })
                                        .set("targets", event.getParent().getTrigger().targets);
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.line(target);
                                        player.addTempSkill("old_dcqingshi_ex");
                                        if (!player.storage.old_dcqingshi_ex) player.storage.old_dcqingshi_ex = [];
                                        player.storage.old_dcqingshi_ex.push([target, card]);
                                    }
                                },
                                content2() {
                                    "step 0";
                                    player.chooseTarget("令任意名其他角色各摸一张牌", [1, Infinity], true, lib.filter.notMe).set("ai", target => {
                                        return get.attitude(_status.event.player, target);
                                    });
                                    "step 1";
                                    if (result.bool) {
                                        var targets = result.targets;
                                        targets.sortBySeat();
                                        player.line(targets);
                                        game.asyncDraw(targets);
                                        game.delayex();
                                    }
                                },
                                content3() {
                                    "step 0";
                                    player.draw(player.hp);
                                    player.addTempSkill("old_dcqingshi_blocker");
                                },
                                subSkill: {
                                    ex: {
                                        trigger: {
                                            source: "damageBegin1",
                                        },
                                        filter(event, player) {
                                            return (
                                                player.storage.old_dcqingshi_ex &&
                                                player.storage.old_dcqingshi_ex.some(info => {
                                                    return info[0] == event.player && info[1] == event.card;
                                                })
                                            );
                                        },
                                        forced: true,
                                        charlotte: true,
                                        popup: false,
                                        onremove: true,
                                        content() {
                                            trigger.num++;
                                            for (var i = 0; i < player.storage.old_dcqingshi_ex.length; i++) {
                                                if (player.storage.old_dcqingshi_ex[i][1] == trigger.card) player.storage.old_dcqingshi_ex.splice(i--, 1);
                                            }
                                        },
                                        sourceSkill: "old_dcqingshi",
                                    },
                                    clear: {
                                        onremove: true,
                                        charlotte: true,
                                        sourceSkill: "old_dcqingshi",
                                    },
                                    blocker: {
                                        charlotte: true,
                                        sourceSkill: "old_dcqingshi",
                                    },
                                },
                                ai: {
                                    threaten: 6,
                                },
                            },
                            old_dczhizhe: {
                                audio: "dczhizhe",
                                enable: "phaseUse",
                                limited: true,
                                filterCard: true,
                                position: "h",
                                discard: false,
                                lose: false,
                                delay: false,
                                skillAnimation: true,
                                animationColor: "metal",
                                check(card) {
                                    if (get.type(card) != "basic" && get.type(card) != "trick") return 0;
                                    return get.value(card) - 7.5;
                                },
                                content() {
                                    "step 0";
                                    var card = cards[0];
                                    player.awakenSkill("old_dczhizhe");
                                    var cardx = game.createCard2(card.name, card.suit, card.number, card.nature);
                                    player.gain(cardx).gaintag.add("old_dczhizhe");
                                    player.addSkill("old_dczhizhe_effect");
                                },
                                ai: {
                                    order: 15,
                                    result: {
                                        player: 1,
                                    },
                                },
                                subSkill: {
                                    effect: {
                                        mod: {
                                            aiOrder(player, card, num) {
                                                if (num > 0 && get.itemtype(card) === "card" && card.hasGaintag("old_dczhizhe")) return num + 0.16;
                                            },
                                            aiValue(player, card, num) {
                                                if (num > 0 && get.itemtype(card) === "card" && card.hasGaintag("old_dczhizhe")) return 2 * num;
                                            },
                                            aiUseful(player, card, num) {
                                                if (num > 0 && !player._old_dczhizhe_mod && get.itemtype(card) === "card" && card.hasGaintag("old_dczhizhe")) {
                                                    if (player.canIgnoreHandcard(card)) return Infinity;
                                                    player._old_dczhizhe_mod = true;
                                                    if (
                                                        player.hp < 3 &&
                                                        player.needsToDiscard(0, (i, player) => {
                                                            return !player.canIgnoreHandcard(i) && get.useful(i) > 6;
                                                        })
                                                    )
                                                        return num * 1.5;
                                                    return num * 10;
                                                }
                                            },
                                            ignoredHandcard(card, player) {
                                                if (card.hasGaintag("old_dczhizhe")) {
                                                    return true;
                                                }
                                            },
                                            cardDiscardable(card, player, name) {
                                                if (name == "phaseDiscard" && card.hasGaintag("old_dczhizhe")) {
                                                    return false;
                                                }
                                            },
                                        },
                                        trigger: { player: ["useCardAfter", "respondAfter"] },
                                        charlotte: true,
                                        forced: true,
                                        filter(event, player) {
                                            return player.hasHistory("lose", function (evt) {
                                                if (evt.getParent() != event) return false;
                                                for (var i in evt.gaintag_map) {
                                                    if (evt.gaintag_map[i].includes("old_dczhizhe")) {
                                                        if (
                                                            event.cards.some(card => {
                                                                return get.position(card, true) == "o" && card.cardid == i;
                                                            })
                                                        )
                                                            return true;
                                                    }
                                                }
                                                return false;
                                            });
                                        },
                                        content() {
                                            "step 0";
                                            var cards = [];
                                            player.getHistory("lose", function (evt) {
                                                if (evt.getParent() != trigger) return false;
                                                for (var i in evt.gaintag_map) {
                                                    if (evt.gaintag_map[i].includes("old_dczhizhe")) {
                                                        var cardsx = trigger.cards.filter(card => {
                                                            return get.position(card, true) == "o" && card.cardid == i;
                                                        });
                                                        if (cardsx.length) cards.addArray(cardsx);
                                                    }
                                                }
                                            });
                                            if (cards.length) {
                                                player.gain(cards, "gain2").gaintag.addArray(["old_dczhizhe", "old_dczhizhe_clear"]);
                                                player.addTempSkill("old_dczhizhe_clear");
                                            }
                                        },
                                    },
                                    clear: {
                                        charlotte: true,
                                        onremove(player) {
                                            player.removeGaintag("old_dczhizhe_clear");
                                        },
                                        mod: {
                                            cardEnabled2(card, player) {
                                                var cards = [];
                                                if (card.cards) cards.addArray(cards);
                                                if (get.itemtype(card) == "card") cards.push(card);
                                                for (var cardx of cards) {
                                                    if (cardx.hasGaintag("old_dczhizhe_clear")) return false;
                                                }
                                            },
                                            cardRespondable(card, player) {
                                                var cards = [];
                                                if (card.cards) cards.addArray(cards);
                                                if (get.itemtype(card) == "card") cards.push(card);
                                                for (var cardx of cards) {
                                                    if (cardx.hasGaintag("old_dczhizhe_clear")) return false;
                                                }
                                            },
                                            cardSavable(card, player) {
                                                var cards = [];
                                                if (card.cards) cards.addArray(cards);
                                                if (get.itemtype(card) == "card") cards.push(card);
                                                for (var cardx of cards) {
                                                    if (cardx.hasGaintag("old_dczhizhe_clear")) return false;
                                                }
                                            },
                                        },
                                    },
                                },
                            },
                            //武关羽
                            old_dcjuewu: {
                                audio: "dcjuewu",
                                enable: "chooseToUse",
                                filter(event, player) {
                                    if (
                                        !player.hasCard(card => {
                                            return _status.connectMode || get.number(card) === 2;
                                        }, "hes")
                                    )
                                        return false;
                                    for (const name of ["shuiyanqijuny"].concat(lib.inpile)) {
                                        const card = get.autoViewAs({ name }, "unsure");
                                        if (!get.tag(card, "damage")) continue;
                                        if (event.filterCard(card, player, event)) return true;
                                        if (name === "sha") {
                                            for (const nature of lib.inpile_nature) {
                                                card.nature = nature;
                                                if (event.filterCard(card, player, event)) return true;
                                            }
                                        }
                                    }
                                    return false;
                                },
                                hiddenCard(player, name) {
                                    if (!lib.inpile.includes(name)) return false;
                                    if (
                                        !player.hasCard(card => {
                                            return _status.connectMode || get.number(card) === 2;
                                        }, "hes")
                                    )
                                        return false;
                                    return get.tag({ name }, "damage");
                                },
                                group: "old_dcjuewu_inTwo",
                                chooseButton: {
                                    dialog(event, player) {
                                        let list = get.inpileVCardList(info => {
                                            return get.tag({ name: info[2] }, "damage");
                                        });
                                        if (!list.some(info => info[2] === "shuiyanqijuny")) list.add(["锦囊", "", "shuiyanqijuny"]);
                                        list = list.filter(info => {
                                            const name = info[2],
                                                nature = info[3];
                                            const card = get.autoViewAs({ name, nature }, "unsure");
                                            return event.filterCard(card, player, event);
                                        });
                                        return ui.create.dialog("绝武", [list, "vcard"]);
                                    },
                                    check(button) {
                                        if (get.event().getParent().type != "phase") return 1;
                                        const player = get.player();
                                        return player.getUseValue({
                                            name: button.link[2],
                                            nature: button.link[3],
                                        });
                                    },
                                    backup(links, player) {
                                        return {
                                            audio: "dcjuewu",
                                            filterCard(card, player) {
                                                return get.number(card) === 2;
                                            },
                                            position: "hes",
                                            check(card) {
                                                return 8 - get.value(card);
                                            },
                                            popname: true,
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        return "将一张点数为2的牌当" + (get.translation(links[0][3]) || "") + get.translation(links[0][2]) + "使用";
                                    },
                                },
                                subSkill: {
                                    backup: {},
                                    inTwo: {
                                        audio: "dcjuewu",
                                        trigger: {
                                            player: "gainAfter",
                                            global: "loseAsyncAfter",
                                        },
                                        filter(event, player) {
                                            const cards = event.getg(player);
                                            if (!cards.length) return false;
                                            return game.hasPlayer(current => {
                                                if (current === player) return false;
                                                const evt = event.getl(current);
                                                return evt && evt.hs.length + evt.es.length + evt.js.length > 0;
                                            });
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            player.addGaintag(trigger.getg(player), "old_dcjuewu_two");
                                            player.addSkill("old_dcjuewu_two");
                                        },
                                    },
                                    two: {
                                        charlotte: true,
                                        mod: {
                                            cardnumber(card) {
                                                if (card.hasGaintag("old_dcjuewu_two")) return 2;
                                            },
                                        },
                                    },
                                },
                                ai: {
                                    fireAttack: true,
                                    respondSha: true,
                                    skillTagFilter(player) {
                                        if (
                                            !player.hasCard(card => {
                                                return _status.connectMode || get.number(card) === 2;
                                            }, "hes")
                                        )
                                            return false;
                                    },
                                    order: 1,
                                    result: {
                                        player(player) {
                                            if (get.event("dying")) return get.attitude(player, get.event("dying"));
                                            return 1;
                                        },
                                    },
                                },
                            },
                            old_dcwuyou: {
                                audio: "dcwuyou",
                                global: "old_dcwuyou_g",
                                subSkill: {
                                    g: {
                                        audio: "dcwuyou",
                                        enable: "phaseUse",
                                        usable: 1,
                                        filter(event, player) {
                                            if (!player.countCards("h")) return false;
                                            return game.hasPlayer(current => {
                                                return current != player && current.hasSkill("old_dcwuyou");
                                            });
                                        },
                                        filterCard: true,
                                        filterTarget(card, player, target) {
                                            return target.hasSkill("old_dcwuyou");
                                        },
                                        selectTarget() {
                                            const count = game.countPlayer(current => {
                                                return current.hasSkill("old_dcwuyou");
                                            });
                                            return count > 1 ? 1 : -1;
                                        },
                                        check(card) {
                                            const player = get.player();
                                            const hasFriend = game.hasPlayer(current => {
                                                return current.hasSkill("old_dcwuyou") && get.attitude(player, current) > 0;
                                            });
                                            return (hasFriend ? 7 : 1) - get.value(card);
                                        },
                                        prompt() {
                                            const player = get.player(),
                                                list = game.filterPlayer(current => {
                                                    return current.hasSkill("old_dcwuyou");
                                                }),
                                                list2 = list.filter(current => current !== player);
                                            const moreThanOne = list.length > 1,
                                                includesMe = list.includes(player);
                                            let str = "选择一张手牌，";
                                            if (includesMe) str += `点击“确定”，${moreThanOne ? "或" : ""}`;
                                            if (moreThanOne || !includesMe) str += `将此牌交给${get.translation(list2)}${list2.length > 1 ? "中的一人" : ""}，`;
                                            str += "然后执行后续效果。";
                                            return str;
                                        },
                                        discard: false,
                                        lose: false,
                                        delay: false,
                                        async content(event, trigger, player) {
                                            const { target } = event;
                                            const isMe = target === player;
                                            let { cards } = event;
                                            if (!isMe) await player.give(cards, target);
                                            const names = lib.inpile.filter(name => {
                                                return get.type2(name) !== "equip";
                                            });
                                            if (names.includes("sha")) names.splice(names.indexOf("sha") + 1, 0, ...lib.inpile_nature.map(nature => ["sha", nature]));
                                            if (!names.includes("shuiyanqijuny")) names.add("shuiyanqijuny");
                                            const vcard = names.map(namex => {
                                                let name = namex,
                                                    nature;
                                                if (Array.isArray(namex)) [name, nature] = namex;
                                                const info = [get.type(name), "", name, nature];
                                                return info;
                                            });
                                            const links = await target
                                                .chooseButton(["选择一个牌名", [vcard, "vcard"]], true)
                                                .set("user", player)
                                                .set("ai", button => {
                                                    const player = get.player(),
                                                        user = get.event("user");
                                                    return user.getUseValue({ name: button.link[2], nature: button.link[3] }) * get.attitude(player, user);
                                                })
                                                .forResultLinks();
                                            if (!links || !links.length) return;
                                            const viewAs = { name: links[0][2], nature: links[0][3] };
                                            if (!isMe) {
                                                cards = await target
                                                    .chooseToGive(player)
                                                    .set("ai", card => {
                                                        const player = get.event("player"),
                                                            target = get.event().getParent().player;
                                                        if (get.attitude(player, target) <= 0) return 0;
                                                        return 6 - get.value(card);
                                                    })
                                                    .forResultCards();
                                            }
                                            if (!cards) return;
                                            const card = cards[0];
                                            if (player.getCards("h").includes(card)) {
                                                if (!player.storage.old_dcwuyou_transfer) player.storage.old_dcwuyou_transfer = {};
                                                player.storage.old_dcwuyou_transfer[card.cardid] = viewAs;
                                                player.addGaintag(cards, "old_dcwuyou_transfer");
                                                player.addSkill("old_dcwuyou_transfer");
                                            }
                                        },
                                        ai: {
                                            order: 10,
                                            result: {
                                                player(player, target) {
                                                    if (get.attitude(player, target) > 0) return 1;
                                                    return 0;
                                                },
                                                target: 0.5,
                                            },
                                        },
                                    },
                                    transfer: {
                                        trigger: {
                                            player: "useCard1",
                                        },
                                        forced: true,
                                        popup: false,
                                        charlotte: true,
                                        filter(event, player) {
                                            if (event.addCount === false) return false;
                                            return player.hasHistory("lose", evt => {
                                                if (evt.getParent() != event) return false;
                                                for (const i in evt.gaintag_map) {
                                                    if (evt.gaintag_map[i].includes("old_dcwuyou_transfer")) return true;
                                                }
                                                return false;
                                            });
                                        },
                                        async content(event, trigger, player) {
                                            trigger.addCount = false;
                                            // const stat = player.getStat().card,
                                            //     name = trigger.card.name;
                                            // if (typeof stat[name] === "number") stat[name]--;
                                        },
                                        mod: {
                                            cardname(card, player) {
                                                const map = player.storage.old_dcwuyou_transfer;
                                                if (map && map[card.cardid] && get.itemtype(card) == "card" && card.hasGaintag("old_dcwuyou_transfer")) return map[card.cardid].name;
                                            },
                                            cardnature(card, player) {
                                                const map = player.storage.old_dcwuyou_transfer;
                                                if (map && map[card.cardid] && get.itemtype(card) == "card" && card.hasGaintag("old_dcwuyou_transfer")) return map[card.cardid].nature || false;
                                            },
                                            // cardUsable(card) {
                                            //     if (!card.cards) return;
                                            //     if (card.cards.some(card => card.hasGaintag("old_dcwuyou_transfer"))) return Infinity;
                                            // },
                                        },
                                    },
                                },
                            },
                            old_dcyixian: {
                                audio: "dcyixian",
                                enable: "phaseUse",
                                limited: true,
                                skillAnimation: true,
                                animationColor: "metal",
                                multitarget: true,
                                multiline: true,
                                content() {
                                    "step 0";
                                    player.awakenSkill("old_dcyixian");
                                    event.targets = game.filterPlayer();
                                    event.targets.sortBySeat();
                                    event.gainSource = [];
                                    "step 1";
                                    var target = event.targets.shift();
                                    var cards = [];
                                    if (target == player) {
                                        cards.addArray(player.getGainableCards(player, "ej").filter(card => ["equip1", "equip2"].includes(get.subtype(card))));
                                        if (cards.length) event.gainSource.push([player, cards.length]);
                                    } else {
                                        cards.addArray(target.getGainableCards(player, "hej").filter(card => ["equip1", "equip2"].includes(get.subtype(card))));
                                        if (cards.length) event.gainSource.push([target, cards.length]);
                                    }
                                    if (cards.length) {
                                        player.gain(target, cards, "gain2");
                                        game.delayx(0.3);
                                    }
                                    if (event.targets.length) {
                                        event.redo();
                                    }
                                    "step 2";
                                    var pair = event.gainSource.shift();
                                    event.pair = pair;
                                    var list = ["摸牌"];
                                    if (pair[0].isDamaged()) list.push("回血");
                                    list.push("cancel2");
                                    player
                                        .chooseControl(list)
                                        .set("prompt", "请选择令" + get.translation(pair[0]) + "执行一项：")
                                        .set("ai", function () {
                                            if (get.attitude(_status.event.player, pair[0]) > 0) return "摸牌";
                                            else return "cancel2";
                                        });
                                    "step 3";
                                    if (result.control != "cancel2") {
                                        if (result.control == "摸牌") event.pair[0].draw(event.pair[1]);
                                        else event.pair[0].recover();
                                    }
                                    if (event.gainSource.length) event.goto(2);
                                },
                            },
                            //武皇甫嵩
                            old_dcchaozhen: {
                                audio: "dcchaozhen",
                                trigger: {
                                    player: ["phaseZhunbeiBegin", "dying"],
                                },
                                async cost(event, trigger, player) {
                                    const list = ["场上", "牌堆", "cancel2"];
                                    if (
                                        !game.hasPlayer(function (current) {
                                            return current.countCards("ej");
                                        })
                                    )
                                        list.remove("场上");
                                    const control = await player
                                        .chooseControl(list, () => {
                                            const player = _status.event.player;
                                            let cards = game
                                                .filterPlayer()
                                                .reduce((arr, current) => {
                                                    if (current.countCards("ej")) arr.addArray(current.getCards("ej"));
                                                    return arr;
                                                }, [])
                                                .sort((a, b) => get.number(a, false) - get.number(b, false));
                                            if (!cards.length) return "牌堆";
                                            if (player.hp < 1 && get.number(cards[0], false) > 1) return "牌堆";
                                            cards = cards.filter(card => get.number(card, false) == get.number(cards[0], false));
                                            let valueCards = cards.filter(card => {
                                                let owner = get.owner(card);
                                                if (!owner) return false;
                                                let att = get.attitude(player, owner);
                                                if (get.position(card) == "j" && (card.viewAs || card.name) == "jsrg_xumou") att *= -1;
                                                if (get.position(card) == "e" && get.equipValue(card, owner) > 0) att *= -1;
                                                return att > 0;
                                            });
                                            if (valueCards.length * 2 >= cards.length) return "场上";
                                            return "牌堆";
                                        })
                                        .set("prompt", get.prompt2("old_dcchaozhen"))
                                        .forResultControl();
                                    event.result = {
                                        bool: control != "cancel2",
                                        cost_data: control,
                                    };
                                },
                                async content(event, trigger, player) {
                                    const control = event.cost_data;
                                    var num = 1,
                                        card;

                                    if (control == "场上") {
                                        let cards = game
                                            .filterPlayer()
                                            .reduce((arr, current) => {
                                                if (current.countCards("ej")) arr.addArray(current.getCards("ej"));
                                                return arr;
                                            }, [])
                                            .sort((a, b) => get.number(a, false) - get.number(b, false));
                                        num = get.number(cards[0], false);
                                        card = cards.filter(card => get.number(card, false) == num).randomGet();
                                    } else {
                                        while (num < 14) {
                                            let cardx = get.cardPile2(card => get.number(card, false) == num);
                                            if (cardx) {
                                                card = cardx;
                                                break;
                                            } else num++;
                                        }
                                    }
                                    if (card) {
                                        await player.gain(card, get.owner(card) ? "give" : "gain2");
                                        if (num == 1) {
                                            await player.recover();
                                            player.tempBanSkill("old_dcchaozhen");
                                        }
                                    }
                                },
                            },
                            old_dclianjie: {
                                audio: "dclianjie",
                                trigger: {
                                    player: "useCardToPlayered",
                                },
                                locked: false,
                                filter(event, player) {
                                    if (
                                        !game.hasPlayer(current => {
                                            return current.countCards("h");
                                        }) ||
                                        !player.hasHistory("lose", evt => {
                                            if (evt.getParent() != event.getParent()) return false;
                                            return event.cards.some(card => (evt.hs || []).includes(card));
                                        })
                                    )
                                        return false;
                                    const num = get.number(event.card, player) || 0;
                                    if (
                                        player.countCards("h", card => {
                                            return get.number(card, player) < num;
                                        })
                                    )
                                        return false;
                                    return true; //return !player.getStorage("old_dclianjie_used").includes(num);
                                },
                                async cost(event, trigger, player) {
                                    event.result = await player
                                        .chooseTarget(get.prompt2(event.name.slice(0, -5)), (card, player, target) => {
                                            return target.countCards("h");
                                        })
                                        .set("drawed", player.getStorage("old_dclianjie_used").includes(get.number(trigger.card, player) || 0))
                                        .set("ai", target => {
                                            const player = get.player();
                                            const eff1 = get.effect(target, { name: "guohe_copy2" }, player, player);
                                            const eff2 = get.effect(target, { name: "draw" }, player, player);
                                            if (player == target && !get.event("drawed")) return eff2 * (1 + player.maxHp - player.countCards("h"));
                                            return eff1;
                                        })
                                        .forResult();
                                },
                                async content(event, trigger, player) {
                                    const target = event.targets[0];
                                    const cards = target.getCards("h"),
                                        minNumber = cards.map(card => get.number(card)).sort((a, b) => a - b)[0];
                                    const toLose = cards.filter(card => get.number(card) === minNumber);
                                    if (target != player || toLose.length <= 1) {
                                        await target.lose(toLose.randomGet(), ui.cardPile);
                                    } else {
                                        const result = await player
                                            .chooseCard("h", card => get.event("toLose")?.includes(card), true)
                                            .set("toLose", toLose)
                                            .set("ai", card => 10 - get.value(card))
                                            .forResult();
                                        if (result.bool) await player.lose(result.cards[0], ui.cardPile);
                                    }
                                    game.broadcastAll(function (player) {
                                        var cardx = ui.create.card();
                                        cardx.classList.add("infohidden");
                                        cardx.classList.add("infoflip");
                                        player.$throw(cardx, 1000, "nobroadcast");
                                    }, target);
                                    await game.delayx();
                                    const num = get.number(trigger.card, player) || 0;
                                    if (player.countCards("h") >= player.maxHp || player.getStorage("old_dclianjie_used").includes(num)) return;
                                    player.addTempSkill("old_dclianjie_used");
                                    player.markAuto("old_dclianjie_used", num);
                                    const result = await player.drawTo(player.maxHp).forResult();
                                    if (result) player.addGaintag(result, "old_dclianjie");
                                },
                                mod: {
                                    aiOrder(player, card, num) {
                                        var number = get.number(card, player);
                                        if (player.countCards("h") < player.maxHp) {
                                            return num + number / 10;
                                        } else if (!player.getStorage("old_dclianjie_used").includes(number)) {
                                            return num - 0.5;
                                        }
                                    },
                                },
                                subSkill: {
                                    used: {
                                        charlotte: true,
                                        onremove(player, skill) {
                                            delete player.storage[skill];
                                            player.removeGaintag("old_dclianjie");
                                        },
                                        mod: {
                                            targetInRange(card, player, target) {
                                                if (get.suit(card) == "unsure") return true;
                                                if (!card.cards) return;
                                                for (var i of card.cards) {
                                                    if (i.hasGaintag("old_dclianjie")) return true;
                                                }
                                            },
                                            cardUsable(card, player, num) {
                                                if (get.suit(card) == "unsure") return Infinity;
                                                if (!card.cards) return;
                                                for (var i of card.cards) {
                                                    if (i.hasGaintag("old_dclianjie")) return Infinity;
                                                }
                                            },
                                        },
                                        intro: {
                                            content: (storage, player) => `已摸点数：${get.translation(storage).replace("13", "K").replace("12", "Q").replace("11", "J").replace("1", "A")}`,
                                        },
                                    },
                                },
                            },
                            old_dcjiangxian: {
                                audio: "dcjiangxian",
                                enable: "phaseUse",
                                limited: true,
                                skillAnimation: true,
                                animationColor: "metal",
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    player.addTempSkill(event.name + "_effect");
                                    const evtx = event.getParent("phase", true, true);
                                    player
                                        .when({ global: "phaseAfter" })
                                        .filter((evt, player) => {
                                            return evt == evtx && ["old_dcchaozhen", "old_dclianjie"].some(skill => player.hasSkill(skill, null, null, false));
                                        })
                                        .step(async () => {
                                            const {
                                                result: { bool, links },
                                            } = await player
                                                .chooseButton(
                                                    [
                                                        "将贤：请选择一项",
                                                        [
                                                            [
                                                                ["old_dcchaozhen", "失去〖朝镇〗"],
                                                                ["old_dclianjie", "失去〖连捷〗"],
                                                            ],
                                                            "textbutton",
                                                        ],
                                                    ],
                                                    true
                                                )
                                                .set("filterButton", button => {
                                                    const player = get.player();
                                                    return player.hasSkill(button.link, null, null, false);
                                                })
                                                .set("ai", button => {
                                                    if (button.link == "old_dcchaozhen" && player.getHp() > 2) return 1.1;
                                                    return 1;
                                                });
                                            if (bool) await player.removeSkills(links);
                                        });
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        mark: true,
                                        intro: {
                                            content: "本回合因使用〖连捷〗摸的牌造成的伤害+X（X为你本回合造成伤害的次数且至多为5），回合结束后失去〖连捷〗或〖朝镇〗",
                                        },
                                        trigger: {
                                            source: "damageBegin1",
                                        },
                                        filter(event, player) {
                                            if (
                                                !player.hasHistory("lose", evt => {
                                                    let gaintag = false;
                                                    if (evt.getParent() != event.getParent("useCard")) return false;
                                                    for (var i in evt.gaintag_map) {
                                                        if (evt.gaintag_map[i].includes("old_dclianjie")) gaintag = true;
                                                    }
                                                    return gaintag && event.cards.some(card => (evt.hs || []).includes(card));
                                                })
                                            )
                                                return false;
                                            return player.getHistory("sourceDamage").length > 0;
                                        },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            trigger.num += Math.min(5, player.getHistory("sourceDamage").length);
                                        },
                                    },
                                },
                                ai: {
                                    order: 9,
                                    threaten: 2.9,
                                    result: {
                                        player(player) {
                                            if (!game.hasPlayer(current => get.attitude(player, current) < 0)) return 0;
                                            return player.countCards("h", card => card.hasGaintag("old_dclianjie") && player.hasUseTarget(card)) > 2 ? 4 : 0;
                                        },
                                    },
                                    combo: "old_dclianjie",
                                },
                            },
                            //神华佗
                            old_jingyu: {
                                audio: "jingyu",
                                trigger: {
                                    global: ["useSkill", "logSkillBegin", "useCard", "respond"],
                                },
                                filter(event, player) {
                                    if (["global", "equip"].includes(event.type)) return false;
                                    let skill = event.sourceSkill || event.skill;
                                    if (!skill || skill === "old_jingyu") return false;
                                    let info = get.info(skill);
                                    while (true) {
                                        if (!info || info.charlotte || info.equipSkill) return false;
                                        if (info && !info.sourceSkill) break;
                                        skill = info.sourceSkill;
                                        info = get.info(skill);
                                    }
                                    return !player.getStorage("old_jingyu_used").includes(skill);
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    if (!player.storage.old_jingyu_used) {
                                        player
                                            .when({ global: "phaseEnd" })
                                            .assign({
                                                firstDo: true,
                                            })
                                            .then(() => delete player.storage.old_jingyu_used);
                                    }
                                    let skill = trigger.sourceSkill || trigger.skill,
                                        info = get.info(skill);
                                    while (true) {
                                        if (info && !info.sourceSkill) break;
                                        skill = info.sourceSkill;
                                        info = get.info(skill);
                                    }
                                    player.markAuto("old_jingyu_used", skill);
                                    await player.draw();
                                },
                                ai: {
                                    threaten: 6,
                                },
                            },
                            //荀彧荀攸
                            old_zhinang: {
                                getMap() {
                                    if (!_status.old_zhinang_map) {
                                        _status.old_zhinang_map = {
                                            name: {},
                                            info: {},
                                        };
                                        let list;
                                        if (_status.connectMode) {
                                            list = get.charactersOL();
                                        } else {
                                            list = get.gainableCharacters();
                                        }
                                        list.forEach(name => {
                                            if (name !== "old_xunyuxunyou") {
                                                const skills = get.character(name, 3);
                                                skills.forEach(skill => {
                                                    const info = get.info(skill);
                                                    if (!info || (info.ai && info.ai.combo)) return;
                                                    if (skill in _status.old_zhinang_map) return;
                                                    if (get.translation(skill).includes("谋")) _status.old_zhinang_map.name[skill] = name;
                                                    const voices = game.parseSkillText(skill, name);
                                                    if (voices.some(data => data.includes("谋"))) {
                                                        _status.old_zhinang_map.info[skill] = name;
                                                    }
                                                });
                                            }
                                        });
                                    }
                                    return _status.old_zhinang_map;
                                },
                                trigger: {
                                    player: "useCardAfter",
                                },
                                filter(event, player) {
                                    return ["trick", "equip"].includes(get.type2(event.card));
                                },
                                frequent: true,
                                async content(event, trigger, player) {
                                    const map = lib.skill.old_zhinang.getMap(),
                                        type = get.type2(trigger.card) == "equip" ? "name" : "info",
                                        list = Object.keys(map[type]);
                                    if (list.length > 0) {
                                        const skill = list.randomGet(),
                                            voiceMap = game.parseSkillTextMap(skill, map[type][skill]);
                                        if (type == "info") {
                                            findaudio: for (let data of voiceMap) {
                                                if (!data.text) continue;
                                                if (data.text.includes("谋")) {
                                                    player.chat(data.text);
                                                    game.broadcastAll(file => game.playAudio(file), data.file);
                                                    break findaudio;
                                                }
                                            }
                                        } else player.flashAvatar("old_zhinang", map[type][skill]);
                                        player.popup(skill);
                                        await player.addSkills(skill);
                                    }
                                },
                            },
                            old_gouzhu: {
                                trigger: {
                                    player: ["useSkillAfter", "logSkill"],
                                },
                                filter(event, player) {
                                    if (["global", "equip"].includes(event.type)) return false;
                                    let skill = get.sourceSkillFor(event);
                                    if (!skill || skill == "old_gouzhu") return false;
                                    let info = get.info(skill);
                                    while (true) {
                                        if (!info || info.charlotte || info.equipSkill) return false;
                                        if (info && !info.sourceSkill) break;
                                        skill = info.sourceSkill;
                                        info = get.info(skill);
                                    }
                                    let list = get.skillCategoriesOf(skill, player);
                                    return list.length && list.some(item => item in lib.skill.old_gouzhu.effectMap);
                                },
                                frequent: true,
                                effectMap: {
                                    锁定技: async function () {
                                        let player = _status.event.player;
                                        if (player.isDamaged()) await player.recover();
                                    },
                                    觉醒技: async function () {
                                        let player = _status.event.player;
                                        let card = get.cardPile(card => get.type(card) == "basic");
                                        if (card) await player.gain(card, "gain2");
                                    },
                                    限定技: async function () {
                                        let player = _status.event.player;
                                        let target = game.filterPlayer(current => current != player).randomGet();
                                        if (target) {
                                            player.line(target, "green");
                                            await target.damage(player);
                                        }
                                    },
                                    转换技: async function () {
                                        let player = _status.event.player;
                                        player.addMark("old_gouzhu", 1, false);
                                        game.log(player, "手牌上限+1");
                                        await game.asyncDelay();
                                    },
                                    主公技: async function () {
                                        let player = _status.event.player;
                                        await player.gainMaxHp();
                                    },
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.countMark("old_gouzhu");
                                    },
                                },
                                intro: {
                                    content: "手牌上限+#",
                                },
                                locked: false,
                                onremove: true,
                                async content(event, trigger, player) {
                                    let skill = get.sourceSkillFor(trigger),
                                        info = get.info(skill);
                                    while (true) {
                                        if (info && !info.sourceSkill) break;
                                        skill = info.sourceSkill;
                                        info = get.info(skill);
                                    }
                                    let list = get.skillCategoriesOf(skill, player);
                                    for (const item of list) {
                                        if (item in lib.skill.old_gouzhu.effectMap) {
                                            const next = game.createEvent("old_gouzhu_effect", false);
                                            next.player = player;
                                            next.setContent(lib.skill.old_gouzhu.effectMap[item]);
                                            await next;
                                        }
                                    }
                                },
                            },
                            //诸葛京
                            old_dcpijian: {
                                audio: "dcpijian",
                                trigger: {
                                    player: "phaseEnd",
                                },
                                filter(event, player) {
                                    return player.getExpansions("dcyanzuo").length >= game.countPlayer();
                                },
                                locked: true,
                                async cost(event, trigger, player) {
                                    event.result = await player
                                        .chooseTarget(get.prompt2("old_dcpijian"))
                                        .set("ai", target => {
                                            const player = _status.event.player;
                                            return get.damageEffect(target, player, player);
                                        })
                                        .forResult();
                                },
                                async content(event, trigger, player) {
                                    await player.loseToDiscardpile(player.getExpansions("dcyanzuo"));
                                    const target = event.targets[0];
                                    await target.damage(2);
                                },
                                ai: {
                                    combo: "dcyanzuo",
                                },
                            },
                            //钟会
                            old_xinquanji: {
                                audio: "xinquanji",
                                trigger: {
                                    player: ["damageEnd"],
                                    global: ["gainAfter", "loseAsyncAfter"],
                                },
                                filter(event, player) {
                                    if (event.name == "damage") return true;
                                    if (event.name == "loseAsync") {
                                        if (event.type != "gain") return false;
                                        var cards = event.getl(player).cards2;
                                        return game.hasPlayer(function (current) {
                                            if (current == player) return false;
                                            var cardsx = event.getg(current);
                                            for (var i of cardsx) {
                                                if (cards.includes(i)) return true;
                                            }
                                            return false;
                                        });
                                    }
                                    if (player == event.player) return false;
                                    if (event.getParent().name == "gift") return false;
                                    var evt = event.getl(player);
                                    return evt && evt.cards2 && evt.cards2.length > 0;
                                },
                                frequent: true,
                                content() {
                                    "step 0";
                                    event.count = trigger.name == "damage" ? trigger.num : 1;
                                    "step 1";
                                    event.count--;
                                    player.draw();
                                    "step 2";
                                    var hs = player.getCards("h");
                                    if (hs.length) {
                                        if (hs.length == 1) event._result = { bool: true, cards: hs };
                                        else player.chooseCard("h", true, "选择一张手牌作为“权”");
                                    } else event.goto(4);
                                    "step 3";
                                    if (result.bool && result.cards && result.cards.length) {
                                        player.addToExpansion(result.cards, "giveAuto", player).gaintag.add("old_xinquanji");
                                    }
                                    "step 4";
                                    if (event.count > 0 && player.hasSkill(event.name) && !get.is.blocked(event.name, player)) {
                                        player.chooseBool(get.prompt2("old_xinquanji")).set("frequentSkill", event.name);
                                    } else event.finish();
                                    "step 5";
                                    if (result.bool) {
                                        player.logSkill("old_xinquanji");
                                        event.goto(1);
                                    }
                                },
                                locked: false,
                                onremove(player, skill) {
                                    var cards = player.getExpansions(skill);
                                    if (cards.length) player.loseToDiscardpile(cards);
                                },
                                intro: {
                                    content: "expansion",
                                    markcount: "expansion",
                                },
                                mod: {
                                    maxHandcard(player, num) {
                                        return num + player.getExpansions("old_xinquanji").length;
                                    },
                                },
                                ai: {
                                    maixie: true,
                                    maixie_hp: true,
                                    notemp: true,
                                    threaten: 0.8,
                                    effect: {
                                        target(card, player, target) {
                                            if (get.tag(card, "damage") && !target.storage.old_xinzili) {
                                                if (player.hasSkillTag("jueqing", false, target)) return [1, -2];
                                                if (!target.hasFriend()) return;
                                                if (target.hp >= 4) return [0.5, get.tag(card, "damage") * 2];
                                                if (!target.hasSkill("old_xinpaiyi") && target.hp > 1) return [0.5, get.tag(card, "damage") * 1.5];
                                                if (target.hp == 3) return [0.5, get.tag(card, "damage") * 1.5];
                                                if (target.hp == 2) return [1, get.tag(card, "damage") * 0.5];
                                            }
                                        },
                                    },
                                },
                            },
                            old_xinzili: {
                                derivation: "old_xinpaiyi",
                                audio: "xinzili",
                                trigger: { player: "phaseZhunbeiBegin" },
                                forced: true,
                                juexingji: true,
                                skillAnimation: true,
                                animationColor: "thunder",
                                filter(event, player) {
                                    return player.getExpansions("old_xinquanji").length > 2;
                                },
                                content() {
                                    player.awakenSkill("old_xinzili");
                                    player.recover();
                                    player.draw(2);
                                    player.loseMaxHp();
                                    player.addSkills("old_xinpaiyi");
                                },
                                ai: {
                                    combo: "old_xinquanji",
                                },
                            },
                            old_xinpaiyi: {
                                audio: "xinpaiyi",
                                enable: "phaseUse",
                                filter(event, player) {
                                    if (player.getStorage("old_xinpaiyi_used").length > 1) return false;
                                    return player.getExpansions("old_xinquanji").length > 0;
                                },
                                chooseButton: {
                                    check(button) {
                                        if (typeof button.link == "object") return 1;
                                        var player = _status.event.player,
                                            num = player.getExpansions("old_xinquanji").length - 1;
                                        if (button.link == 1) {
                                            if (
                                                game.countPlayer(function (current) {
                                                    return get.damageEffect(current, player, player) > 0;
                                                }) < num
                                            )
                                                return 0.5;
                                            return 2;
                                        }
                                        if (num < 2) return 0;
                                        return 1;
                                    },
                                    dialog(event, player) {
                                        var dialog = ui.create.dialog("权计", "hidden");
                                        var table = document.createElement("div");
                                        table.classList.add("add-setting");
                                        table.style.margin = "0";
                                        table.style.width = "100%";
                                        table.style.position = "relative";
                                        var list = ["摸牌", "造成伤害"];
                                        dialog.add([
                                            list.map((item, i) => {
                                                return [i, item];
                                            }),
                                            "tdnodes",
                                        ]);
                                        dialog.add(player.getExpansions("old_xinquanji"));
                                        return dialog;
                                    },
                                    select: 2,
                                    filter(button, player) {
                                        if (typeof button.link == "number" && player.getStorage("old_xinpaiyi_used").includes(button.link)) return false;
                                        if (ui.selected.buttons.length) return typeof ui.selected.buttons[0].link != typeof button.link;
                                        return true;
                                    },
                                    backup(links) {
                                        if (typeof links[0] == "object") links.reverse();
                                        var next = get.copy(lib.skill["old_xinpaiyi_backup" + links[0]]);
                                        next.card = links[1];
                                        return next;
                                    },
                                    prompt(links, player) {
                                        if (typeof links[0] == "object") links.reverse();
                                        var num = get.cnNumber(Math.max(1, player.getExpansions("old_xinquanji").length - 1)),
                                            card = get.translation(links[1]);
                                        if (links[0] == 0) return "移去" + card + "并令一名角色摸" + num + "张牌";
                                        return "移去" + card + "并对至多" + num + "名角色造成1点伤害";
                                    },
                                },
                                ai: {
                                    order: 1,
                                    result: { player: 1 },
                                    combo: "old_xinquanji",
                                },
                                subSkill: {
                                    used: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                    backup0: {
                                        audio: "xinpaiyi",
                                        filterCard: () => false,
                                        selectCard: -1,
                                        filterTarget: true,
                                        delay: false,
                                        content() {
                                            "step 0";
                                            player.addTempSkill("old_xinpaiyi_used", "phaseUseEnd");
                                            player.markAuto("old_xinpaiyi_used", [0]);
                                            var card = lib.skill.old_xinpaiyi_backup.card;
                                            player.loseToDiscardpile(card);
                                            "step 1";
                                            target.draw(Math.max(1, player.getExpansions("old_xinquanji").length));
                                        },
                                        ai: {
                                            result: {
                                                target(player, target) {
                                                    if (target.hasSkill("nogain")) return 0;
                                                    if (player == target && !player.needsToDiscard()) return 3;
                                                    return 1;
                                                },
                                            },
                                        },
                                    },
                                    backup1: {
                                        audio: "xinpaiyi",
                                        filterCard: () => false,
                                        selectCard: -1,
                                        filterTarget: true,
                                        delay: false,
                                        multitarget: true,
                                        multiline: true,
                                        selectTarget() {
                                            return [1, Math.max(1, _status.event.player.getExpansions("old_xinquanji").length - 1)];
                                        },
                                        content() {
                                            "step 0";
                                            targets.sortBySeat();
                                            player.addTempSkill("old_xinpaiyi_used", "phaseUseEnd");
                                            player.markAuto("old_xinpaiyi_used", [1]);
                                            var card = lib.skill.old_xinpaiyi_backup.card;
                                            player.loseToDiscardpile(card);
                                            "step 1";
                                            for (var i of targets) i.damage();
                                        },
                                        ai: {
                                            tag: {
                                                damage: 1,
                                            },
                                            result: {
                                                target: -1.5,
                                            },
                                        },
                                    },
                                },
                            },
                            //马钧
                            old_jingyi: {
                                audio: "jingyi",
                                trigger: { player: "equipAfter" },
                                forced: true,
                                filter(event, player) {
                                    return event.cards?.length > 0;
                                },
                                async content(event, trigger, player) {
                                    const num = player.countCards("e");
                                    if (num > 0) await player.draw(num);
                                    if (player.countCards("he") > 0) await player.chooseToDiscard(2, "he", true);
                                },
                            },
                            //星法正
                            old_staranji: {
                                audio: "staranji",
                                trigger: { global: "useCard" },
                                filter(event, player) {
                                    let history = [],
                                        suits = [];
                                    for (let i = player.actionHistory.length - 1; i >= 0; i--) {
                                        history.addArray(_status.globalHistory[i].everything.filter(evt => evt.name === "useCard"));
                                        if (_status.globalHistory[i].isRound) break;
                                    }
                                    const map = history.reduce((map, evt) => {
                                        const suit = get.suit(evt.card);
                                        if (!map[suit]) {
                                            map[suit] = 1;
                                            suits.add(suit);
                                        } else map[suit]++;
                                        return map;
                                    }, {}),
                                        min = Math.min(...suits.slice().map(suit => map[suit]));
                                    return map[get.suit(event.card)] === min;
                                },
                                forced: true,
                                logTarget: "player",
                                content() {
                                    player.draw();
                                },
                                ai: { threaten: 2 },
                            },
                            //庞凤衣
                            old_dcyitong: {
                                audio: "dcyitong",
                                trigger: {
                                    global: ["phaseBefore", "loseAfter", "loseAsyncAfter", "cardsDiscardAfter"],
                                    player: "enterGame",
                                },
                                filter(event, player, name) {
                                    const suits = player.getStorage("old_dcyitong");
                                    if (name === "phaseBefore" || name === "enterGame") {
                                        return suits.length < 4 && (event.name !== "phase" || game.phaseNumber === 0);
                                    }
                                    return suits.some(suit => {
                                        if (!event.getd?.().some(card => get.suit(card, false) === suit)) return false;
                                        return (
                                            game
                                                .getGlobalHistory("everything", evt => {
                                                    return evt.getd?.()?.some(card => get.suit(card, false) === suit);
                                                })
                                                .indexOf(event) === 0
                                        );
                                    });
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const name = event.triggername,
                                        storage = player.getStorage("old_dcyitong"),
                                        suits = lib.suit
                                            .filter(suit => {
                                                if (name === "phaseBefore" || name === "enterGame") return !storage.includes(suit);
                                                if (!storage.includes(suit) || !trigger.getd?.().some(card => get.suit(card, false) === suit)) return false;
                                                return (
                                                    game
                                                        .getGlobalHistory("everything", evt => {
                                                            return evt.getd?.()?.some(card => get.suit(card, false) === suit);
                                                        })
                                                        .indexOf(trigger) === 0
                                                );
                                            })
                                            .reverse();
                                    if (name === "phaseBefore" || name === "enterGame") {
                                        const result =
                                            suits.length > 1
                                                ? await player
                                                    .chooseControl(suits)
                                                    .set("ai", () => {
                                                        return get.event().controls.randomGet();
                                                    })
                                                    .set("prompt", "异瞳：请记录一个花色")
                                                    .forResult()
                                                : { control: suits[0] };
                                        const suit = result.control;
                                        if (suit) {
                                            player.markAuto("old_dcyitong", [suit]);
                                            player.addTip("old_dcyitong", get.translation("old_dcyitong") + player.getStorage("old_dcyitong").reduce((str, suit) => str + get.translation(suit), ""));
                                        }
                                    } else {
                                        let gains = [];
                                        for (const suitx of suits) {
                                            for (const suit of lib.suit.slice().reverse()) {
                                                if (suitx === suit) continue;
                                                const card = get.cardPile(card => get.suit(card) === suit && !gains.includes(card));
                                                if (card) gains.push(card);
                                            }
                                        }
                                        if (gains.length) await player.gain(gains, "gain2");
                                    }
                                },
                                onremove(player, skill) {
                                    delete player.storage[skill];
                                    player.removeTip(skill);
                                },
                                intro: { content: "已记录$花色" },
                            },
                            old_dcpeiniang: {
                                audio: "dcpeiniang",
                                mod: {
                                    cardUsable(card) {
                                        if (card?.storage?.old_dcpeiniang) return Infinity;
                                    },
                                },
                                enable: "chooseToUse",
                                filterCard(card, player) {
                                    return player.getStorage("old_dcyitong").includes(get.suit(card));
                                },
                                viewAs: {
                                    name: "jiu",
                                    storage: { old_dcpeiniang: true },
                                },
                                prompt() {
                                    const player = get.player();
                                    return "将" + player.getStorage("old_dcyitong").reduce((str, suit) => str + get.translation(suit), "") + "牌当作【酒】使用";
                                },
                                check(card, player) {
                                    return 0 + lib.skill.oljiuchi?.check?.(card, player);
                                },
                                precontent() {
                                    event.getParent().addCount = false;
                                },
                                position: "hes",
                                ai: {
                                    jiuOther: true,
                                    combo: "old_dcyitong",
                                },
                                trigger: { source: "recoverBegin" },
                                filter(event, player) {
                                    if (event.name === "chooseToUse") return player.hasCard(card => lib.skill.old_dcpeiniang.filterCard(card, player), "hes");
                                    return event.getParent()?.name === "jiu" && event.num + event.player.hp < 1;
                                },
                                forced: true,
                                locked: false,
                                logTarget: "player",
                                content() {
                                    trigger.num = 1 - trigger.player.hp;
                                },
                            },
                            //威孙权
                            old_dcwoheng: {
                                audio: "dcwoheng",
                                trigger: {
                                    player: "damageEnd",
                                },
                                enable: "phaseUse",
                                filterTarget: true,
                                mark: true,
                                intro: {
                                    markcount(_, player) {
                                        const num = player.countMark("old_dcwoheng_used");
                                        return num + 1;
                                    },
                                    content(storage, player) {
                                        const num = player.countMark("old_dcwoheng_used");
                                        return `令一名角色摸或弃置${num + 1}张牌`;
                                    },
                                },
                                prompt(event) {
                                    const { player } = event;
                                    const num = player.countMark("old_dcwoheng_used");
                                    return `斡衡：令一名角色摸或弃置${num + 1}张牌`;
                                },
                                async cost(event, trigger, player) {
                                    const num = player.countMark("old_dcwoheng_used");
                                    event.result = await player.chooseTarget(`斡衡：令一名角色摸或弃置${num + 1}张牌`).forResult();
                                },
                                async content(event, trigger, player) {
                                    player.addTempSkill("old_dcwoheng_used", { global: "roundStart" });
                                    player.addMark("old_dcwoheng_used");
                                    const num = player.countMark("old_dcwoheng_used");
                                    // player.addTip("old_dcwoheng", `斡衡：${num}`);
                                    const [target] = event.targets;
                                    const str1 = "摸" + get.cnNumber(num, true);
                                    const str2 = "弃" + get.cnNumber(num, true);
                                    const list = [str1];
                                    if (
                                        target.countCards("he", function (card) {
                                            return lib.filter.cardDiscardable(card, target);
                                        })
                                    ) {
                                        list.push(str2);
                                    }
                                    let directcontrol =
                                        str1 ==
                                        (await player
                                            .chooseControl(list, function (event, player) {
                                                return _status.event.choice;
                                            })
                                            .set("choice", get.attitude(player, target) > 0 ? str1 : str2)
                                            .forResultControl());
                                    if (directcontrol) {
                                        await target.draw(num);
                                    } else {
                                        await target.chooseToDiscard(num, true, "he");
                                    }
                                    if (target == player || player.countCards("h") !== target.countCards("h")) {
                                        player.tempBanSkill("old_dcwoheng");
                                    }
                                },
                                subSkill: {
                                    used: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                            },
                            old_dcjizheng: {
                                feedPigSkill: true,
                                zhuSkill: true,
                                unique: true,
                                audio: "dcyuhui",
                                global: "old_dcjizheng_global",
                                subSkill: {
                                    global: {
                                        audiol: "old_dcjizheng",
                                        enable: "phaseUse",
                                        discard: false,
                                        lose: false,
                                        delay: false,
                                        line: true,
                                        log: false,
                                        prepare: function (cards, player, targets) {
                                            targets[0].logSkill("old_dcjizheng");
                                        },
                                        prompt: function () {
                                            var player = _status.event.player;
                                            var list = game.filterPlayer(function (target) {
                                                return target != player && target.hasZhuSkill("old_dcjizheng", player);
                                            });
                                            var str = "将一张牌交给" + get.translation(list);
                                            if (list.length > 1) str += "中的一人";
                                            return str;
                                        },
                                        filter: function (event, player) {
                                            if (player.countCards("h", lib.skill.old_dcjizheng_global.filterCard) == 0) return false;
                                            return game.hasPlayer(function (target) {
                                                return target != player && target.hasZhuSkill("old_dcjizheng", player) && !target.hasSkill("old_dcjizheng_blocker");
                                            });
                                        },
                                        filterCard: function (card) {
                                            return true;
                                        },
                                        visible: true,
                                        filterTarget: function (card, player, target) {
                                            return target != player && target.hasZhuSkill("old_dcjizheng", player) && !target.hasSkill("old_dcjizheng_blocker");
                                        },
                                        async content(event, trigger, player) {
                                            const { cards, targets } = event;
                                            await player.give(cards, targets[0]);
                                            targets[0].addTempSkill("old_dcjizheng_blocker", "phaseUseEnd");
                                            if (player.group == "wu") {
                                                player.addTempSkill("old_dcjizheng_buff");
                                            } else {
                                                player.addTempSkill("old_dcjizheng_buff", { player: "useCardAfter" });
                                            }
                                        },
                                        ai: {
                                            expose: 0.3,
                                            order: 13,
                                            result: {
                                                player: 1,
                                                target: 5,
                                            },
                                        },
                                    },
                                    blocker: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                    buff: {
                                        charlotte: true,
                                        mod: {
                                            targetInRange: function (card, player) {
                                                return true;
                                            },
                                        },
                                    },
                                },
                            },
                            //TW霍峻
                            old_twjieyu: {
                                audio: "twjieyu",
                                trigger: { player: ["phaseJieshuBegin", "damageEnd"] },
                                filter(event, player) {
                                    if (event.name != "phaseJieshu") {
                                        var history = player.getHistory("damage");
                                        for (var i of history) {
                                            if (i == event) break;
                                            return false;
                                        }
                                        var all = player.actionHistory;
                                        for (var i = all.length - 2; i >= 0; i--) {
                                            if (all[i].damage.length) return false;
                                            if (all[i].isRound) break;
                                        }
                                    }
                                    return (
                                        player.countCards("h") > 0 &&
                                        !player.hasCard(function (card) {
                                            return !lib.filter.cardDiscardable(card, player, "old_twjieyu");
                                        }, "h")
                                    );
                                },
                                check(event, player) {
                                    var cards = [],
                                        names = [];
                                    for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                                        var card = ui.discardPile.childNodes[i];
                                        if (get.type(card, null, false) == "basic" && !names.includes(card.name)) {
                                            cards.push(card);
                                            names.push(card.name);
                                        }
                                    }
                                    if (!names.includes("shan") || !names.includes("tao")) return false;
                                    if (player.countCards("h", "shan") < 2 && player.countCards("h", "tao") < 1) return true;
                                    return false;
                                },
                                content() {
                                    "step 0";
                                    player.discard(player.getCards("h"));
                                    "step 1";
                                    var cards = [],
                                        names = [];
                                    for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                                        var card = ui.discardPile.childNodes[i];
                                        if (get.type(card, null, false) == "basic" && !names.includes(card.name)) {
                                            cards.push(card);
                                            names.push(card.name);
                                        }
                                    }
                                    if (cards.length) player.gain(cards, "gain2");
                                },
                            },
                            //TW郭淮
                            old_twjingce: {
                                marktext: "策",
                                intro: {
                                    name: "策",
                                    content: "mark",
                                },
                                audio: "twjingce",
                                trigger: { player: "useCardAfter" },
                                filter(event, player) {
                                    var evt = event.getParent("phaseUse");
                                    if (!evt || evt.player != player) return false;
                                    var history = player.getHistory("useCard", function (evtx) {
                                        return evtx.getParent("phaseUse") == evt;
                                    });
                                    return history && history.indexOf(event) == player.hp - 1;
                                },
                                frequent: true,
                                content() {
                                    "step 0";
                                    player.draw(player.hp);
                                    "step 1";
                                    if (
                                        player.getHistory("sourceDamage").length ||
                                        player.getHistory("gain", function (evt) {
                                            return evt.getParent("phaseUse") == trigger.getParent("phaseUse") && evt.getParent().name == "draw";
                                        }).length > 1
                                    )
                                        player.addMark("old_twjingce", 1);
                                },
                            },
                            old_yuzhang: {
                                audio: "yuzhang",
                                trigger: {
                                    player: "damageEnd",
                                },
                                filter(event, player) {
                                    return event.source && player.hasMark("old_twjingce");
                                },
                                direct: true,
                                content() {
                                    "step 0";
                                    var choiceList = ["令" + get.translation(trigger.source) + "本回合不能再使用或打出牌"];
                                    var num = trigger.source.hp;
                                    event.num = num;
                                    if (trigger.source.countCards("he")) choiceList.push("令" + get.translation(trigger.source) + "弃置" + get.cnNumber(num) + "张牌");
                                    player
                                        .chooseControl("cancel2")
                                        .set("prompt2", get.prompt2("old_yuzhang"))
                                        .set("choiceList", choiceList)
                                        .set("ai", function () {
                                            var player = _status.event.player,
                                                source = _status.event.source;
                                            if (get.attitude(player, source) >= 0) return "cancel2";
                                            if (source.hasSkillTag("noh") || source.hasSkillTag("noe") || source.countCards("h") >= 4) return 0;
                                            if (source.hp > 1 && source.countCards("he") > 1) return 1;
                                            return [0, 1].randomGet();
                                        })
                                        .set("source", trigger.source);
                                    "step 1";
                                    if (result.control != "cancel2") {
                                        player.logSkill("old_yuzhang", trigger.source);
                                        player.removeMark("old_twjingce", 1);
                                        if (result.index == 0) trigger.source.addTempSkill("old_yuzhang_dontuse");
                                        else trigger.source.chooseToDiscard("he", event.num, true);
                                    }
                                },
                                group: "old_yuzhang_skip",
                                subSkill: {
                                    skip: {
                                        audio: "yuzhang",
                                        trigger: {
                                            player: ["phaseZhunbeiBefore", "phaseJudgeBefore", "phaseDrawBefore", "phaseUseBefore", "phaseDiscardBefore", "phaseJieshuBefore"],
                                        },
                                        filter(event, player) {
                                            return player.hasMark("old_twjingce");
                                        },
                                        prompt2(event, player) {
                                            var str = "弃置一枚“策”并跳过";
                                            var list = lib.skill.old_yuzhang.subSkill.skip.trigger.player.slice();
                                            list = list.map(i => i.slice(0, -6));
                                            str += ["准备", "判定", "摸牌", "出牌", "弃牌", "结束"][list.indexOf(event.name)];
                                            str += "阶段";
                                            return str;
                                        },
                                        check(event, player) {
                                            if (event.name == "phaseDiscard") return player.needsToDiscard();
                                            if (event.name == "phaseJudge") return player.countCards("j");
                                            return false;
                                        },
                                        content() {
                                            player.removeMark("old_twjingce", 1);
                                            trigger.cancel();
                                        },
                                        sourceSkill: "old_yuzhang",
                                    },
                                    dontuse: {
                                        charlotte: true,
                                        mark: true,
                                        mod: {
                                            cardEnabled2(card) {
                                                return false;
                                            },
                                        },
                                        intro: {
                                            content: "不能使用或打出牌",
                                        },
                                        sourceSkill: "old_yuzhang",
                                    },
                                },
                                ai: {
                                    combo: "old_twjingce",
                                },
                            },
                            //全琮
                            old_zhenshan: {
                                audio: "zhenshan",
                                enable: ["chooseToUse", "chooseToRespond"],
                                filter(event, player) {
                                    if (event.type == "wuxie") return false;
                                    var nh = player.countCards("h");
                                    if (
                                        !game.hasPlayer(function (current) {
                                            return current != player && current.countCards("h") < nh;
                                        })
                                    ) {
                                        return false;
                                    }
                                    for (var i of lib.inpile) {
                                        if (get.type(i) != "basic") continue;
                                        var card = { name: i, isCard: true };
                                        if (event.filterCard(card, player, event)) return true;
                                        if (i == "sha") {
                                            for (var j of lib.inpile_nature) {
                                                card.nature = j;
                                                if (event.filterCard(card, player, event)) return true;
                                            }
                                        }
                                    }
                                    return false;
                                },
                                chooseButton: {
                                    dialog(event, player) {
                                        var list = [];
                                        for (var i of lib.inpile) {
                                            if (get.type(i) != "basic") continue;
                                            var card = { name: i, isCard: true };
                                            if (event.filterCard(card, player, event)) list.push(["基本", "", i]);
                                            if (i == "sha") {
                                                for (var j of lib.inpile_nature) {
                                                    card.nature = j;
                                                    if (event.filterCard(card, player, event)) list.push(["基本", "", i, j]);
                                                }
                                            }
                                        }
                                        return ui.create.dialog("振赡", [list, "vcard"], "hidden");
                                    },
                                    check(button) {
                                        var player = _status.event.player;
                                        var card = { name: button.link[2], nature: button.link[3] };
                                        if (card.name == "jiu") return 0;
                                        if (
                                            game.hasPlayer(function (current) {
                                                return get.effect(current, card, player, player) > 0;
                                            })
                                        ) {
                                            if (card.name == "sha") {
                                                var eff = player.getUseValue(card);
                                                if (eff > 0) return 2.9 + eff / 10;
                                                return 0;
                                            } else if (card.name == "tao" || card.name == "shan") {
                                                return 4;
                                            }
                                        }
                                        return 0;
                                    },
                                    backup(links, player) {
                                        return {
                                            filterCard() {
                                                return false;
                                            },
                                            viewAs: {
                                                name: links[0][2],
                                                nature: links[0][3],
                                                isCard: true,
                                            },
                                            selectCard: -1,
                                            precontent() {
                                                "step 0";
                                                player
                                                    .chooseTarget(
                                                        "选择一名手牌数小于你的角色交换手牌",
                                                        function (card, player, target) {
                                                            return target != player && target.countCards("h") < player.countCards("h");
                                                        },
                                                        true
                                                    )
                                                    .set("ai", function (target) {
                                                        return get.attitude(player, target) * Math.sqrt(target.countCards("h") + 1);
                                                    });
                                                "step 1";
                                                if (result.bool) {
                                                    player.logSkill("old_zhenshan", result.targets);
                                                    //player.addTempSkill("old_zhenshan_used");
                                                    player.swapHandcards(result.targets[0]);
                                                    delete event.result.skill;
                                                } else event.finish();
                                                "step 2";
                                                game.delayx();
                                            },
                                        };
                                    },
                                    prompt(links, player) {
                                        return "选择" + get.translation(links[0][3] || "") + "【" + get.translation(links[0][2]) + "】的目标";
                                    },
                                },
                                subSkill: {
                                    used: { charlotte: true },
                                },
                                ai: {
                                    order() {
                                        var player = _status.event.player;
                                        var event = _status.event;
                                        var nh = player.countCards("h");
                                        if (
                                            game.hasPlayer(function (current) {
                                                return get.attitude(player, current) > 0 && current.countCards("h") < nh;
                                            })
                                        ) {
                                            if (event.type == "dying") {
                                                if (event.filterCard({ name: "tao" }, player, event)) {
                                                    return 0.5;
                                                }
                                            } else {
                                                if (event.filterCard({ name: "tao" }, player, event) || event.filterCard({ name: "shan" }, player, event)) {
                                                    return 4;
                                                }
                                                if (event.filterCard({ name: "sha" }, player, event)) {
                                                    return 2.9;
                                                }
                                            }
                                        }
                                        return 0;
                                    },
                                    save: true,
                                    respondSha: true,
                                    respondShan: true,
                                    skillTagFilter(player, tag, arg) {
                                        //if (player.hasSkill("old_zhenshan_used")) return false;
                                        var nh = player.countCards("h");
                                        return game.hasPlayer(function (current) {
                                            return current != player && current.countCards("h") < nh;
                                        });
                                    },
                                    result: {
                                        player(player) {
                                            if (_status.event.type == "dying") {
                                                return get.attitude(player, _status.event.dying);
                                            } else {
                                                return 1;
                                            }
                                        },
                                    },
                                },
                            },
                            //TW鲍信
                            old_twmutao: {
                                audio: "twmutao",
                                enable: "phaseUse",
                                usable: 1,
                                filterTarget(card, player, target) {
                                    return target.countCards("h");
                                },
                                content() {
                                    "step 0";
                                    event.togive = target.getNext();
                                    if (event.togive == player) event.togive = player.getNext();
                                    var cards = target.getCards("h", { name: "sha" });
                                    if (!cards.length) {
                                        game.log("但", target, "没有", "#y杀", "！");
                                        event.finish();
                                    }
                                    "step 1";
                                    var cards = target.getCards("h", { name: "sha" }),
                                        card = cards.randomRemove(1)[0];
                                    target.give(card, event.togive);
                                    if (cards.length) {
                                        event.togive = event.togive.getNext();
                                        if (event.togive == player) event.togive = player.getNext();
                                        event.redo();
                                    }
                                    "step 2";
                                    target.line(event.togive);
                                    event.togive.damage(Math.min(3, event.togive.countCards("h", { name: "sha" })), target);
                                },
                                ai: {
                                    order: 10,
                                    result: {
                                        target(player, target) {
                                            var num = 0,
                                                numx = target.countCards("h", { name: "sha" }),
                                                targetx = target;
                                            for (var i = 0; i < numx; i++) {
                                                targetx = targetx.next;
                                                if (targetx == player) targetx = targetx.next;
                                            }
                                            var att1 = get.attitude(player, target),
                                                att2 = get.attitude(player, targetx);
                                            if (att1 > 0 && att2 < 0) num = 0.25;
                                            if (att1 < 0 && att2 < 0) num = 4;
                                            return att1 * num * numx * (targetx.countCards("h", { name: "sha" }) + 1);
                                        },
                                    },
                                },
                            },
                            //TW张曼成
                            old_twbudao: {
                                audio: "twbudao",
                                trigger: {
                                    player: "phaseZhunbeiBegin",
                                },
                                derivation: ["twzhouhu", "twharvestinori", "twzuhuo"],
                                limited: true,
                                skillAnimation: true,
                                animationColor: "metal",
                                check(event, player) {
                                    return !player.hasUnknown() || !player.hasFriend();
                                },
                                skillValue: {
                                    twzhouhu: target => (Math.random() < 0.6 ? 0.1 : 1),
                                    twzuhuo: (target, player) => (get.damageEffect(target, player, player) > 0 ? 0.1 : 1),
                                    twharvestinori: target => 0.9 + Math.random() / 5,
                                    twhuangjin: target => Math.random() / 5,
                                    twguimen: target => Math.sqrt(Math.min(3, target.countCards("he", { suit: "spade" }))) * 0.09,
                                    twzhouzu: target => {
                                        var rand = Math.random();
                                        if (rand < 0.8) return 1 - Math.sqrt(0.8 - rand);
                                        return 1;
                                    },
                                    twdidao: (target, player) => {
                                        if (
                                            [target, player].some(current =>
                                                current.getSkills().some(skill => {
                                                    var info = get.info(skill);
                                                    if (!info || !info.ai || !info.ai.rejudge) return false;
                                                    return true;
                                                })
                                            )
                                        ) {
                                            return 0.05;
                                        }
                                        return 0.85 + Math.random() / 5;
                                    },
                                },
                                content() {
                                    "step 0";
                                    player.awakenSkill("old_twbudao");
                                    player.loseMaxHp();
                                    player.recover();
                                    var skills = lib.skill.old_twbudao.derivation,
                                        map = lib.skill.old_twbudao.skillValue;
                                    skills = skills.randomGets(3);
                                    var target = game.filterPlayer().sort((a, b) => get.attitude(player, b) - get.attitude(player, a))[0];
                                    if (player.identity == "nei" || get.attitude(player, target) < 6) target = player;
                                    player
                                        .chooseControl(skills)
                                        .set(
                                            "choiceList",
                                            skills.map(function (i) {
                                                return "<div class='skill'>【" + get.translation(lib.translate[i + "_ab"] || get.translation(i).slice(0, 2)) + "】</div><div>" + get.skillInfoTranslation(i, player) + "</div>";
                                            })
                                        )
                                        .set("displayIndex", false)
                                        .set("prompt", "布道：选择获得一个技能")
                                        .set("ai", () => {
                                            return _status.event.choice;
                                        })
                                        .set("choice", skills.sort((a, b) => (map[b](target, player) || 0.5) - (map[a](target, player) || 0.5))[0]);
                                    "step 1";
                                    var skill = result.control;
                                    player.addSkills(skill);
                                    event.old_twbudao_skill = skill;
                                    player.chooseTarget(lib.filter.notMe, "是否令一名其他角色也获得【" + get.translation(skill) + "】？").set("ai", function (target) {
                                        var player = _status.event.player;
                                        if (player.identity == "nei") return 0;
                                        return get.attitude(player, target);
                                    });
                                    "step 2";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        event.target = target;
                                        player.line(target, "green");
                                        target.addSkills(event.old_twbudao_skill);
                                        var cards = target.getCards("he");
                                        if (!cards.length) event.finish();
                                        else if (cards.length == 1) event._result = { bool: true, cards: cards };
                                        else target.chooseCard("he", true, "交给" + get.translation(player) + "一张牌作为学费");
                                    } else event.finish();
                                    "step 3";
                                    if (result.bool) target.give(result.cards, player);
                                },
                                mark: true,
                                intro: {
                                    content: "limited",
                                },
                                init: (player, skill) => (player.storage[skill] = false),
                            },
                            //牛辅董翓
                            old_twjuntun: {
                                audio: "twjuntun",
                                trigger: {
                                    global: ["phaseBefore", "dyingAfter"],
                                    player: "enterGame",
                                },
                                init(player) {
                                    lib.skill.baonvezhi.change(player, 0);
                                },
                                direct: true,
                                derivation: ["old_twxiongjun", "baonvezhi_faq"],
                                group: "old_twjuntun_extra",
                                filter(event, player) {
                                    return (
                                        (event.name != "phase" || game.phaseNumber == 0) &&
                                        game.hasPlayer(current => {
                                            return !current.hasSkill("old_twxiongjun");
                                        })
                                    );
                                },
                                content() {
                                    "step 0";
                                    player
                                        .chooseTarget(get.prompt("old_twjuntun"), "令一名角色获得【凶军】", (card, player, target) => {
                                            return !target.hasSkill("old_twxiongjun");
                                        })
                                        .set("ai", target => get.attitude(player, target) - 2);
                                    "step 1";
                                    if (result.bool) {
                                        var target = result.targets[0];
                                        player.logSkill("old_twjuntun", target);
                                        target.addSkills("old_twxiongjun");
                                        if (target != player) player.addExpose(0.25);
                                    }
                                },
                                subSkill: {
                                    extra: {
                                        audio: "twjuntun",
                                        trigger: { global: "damageSource" },
                                        forced: true,
                                        locked: false,
                                        filter(event, player) {
                                            return event.source && event.source.hasSkill("old_twxiongjun") && event.source != player;
                                        },
                                        logTarget: "source",
                                        content() {
                                            lib.skill.baonvezhi.change(player, trigger.num);
                                        },
                                    },
                                },
                            },
                            old_twxiongjun: {
                                audio: "twxiongjun",
                                init(player) {
                                    lib.skill.baonvezhi.change(player, 0);
                                },
                                trigger: { source: "damageSource" },
                                forced: true,
                                content() {
                                    var targets = game.filterPlayer(current => current.hasSkill("old_twxiongjun")).sortBySeat();
                                    player.line(targets, "green");
                                    game.asyncDraw(targets);
                                },
                            },
                            old_twxiongxi: {
                                audio: "twxiongxi",
                                enable: "phaseUse",
                                init(player) {
                                    lib.skill.baonvezhi.change(player, 0);
                                },
                                filterCard: () => true,
                                selectCard() {
                                    return (lib.skill.baonvezhi.baonvezhi_max || 5) - _status.event.player.countMark("baonvezhi");
                                },
                                check(card) {
                                    return 8 - get.value(card);
                                },
                                position: "he",
                                filterTarget(card, player, target) {
                                    return target != player && !player.getStorage("old_twxiongxi_mark").includes(target);
                                },
                                content() {
                                    if (!player.hasSkill("old_twxiongxi_mark")) player.addTempSkill("old_twxiongxi_mark");
                                    player.markAuto("old_twxiongxi_mark", [target]);
                                    target.damage();
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        onremove: true,
                                    },
                                },
                                ai: {
                                    combo: "old_twjuntun",
                                    expose: 0.25,
                                    order: 1,
                                    result: {
                                        player(player, target) {
                                            let num = -ui.selected.cards.length;
                                            if (player.hasSkill("twxiongjun") && !player.storage.counttrigger?.twxiongjun)
                                                num += game.countPlayer(current => {
                                                    if (current.hasSkill("twxiongjun")) return get.sgnAttitude(player, current);
                                                });
                                            return num * get.effect(player, { name: "draw" }, player, player);
                                        },
                                        target(player, target) {
                                            return get.damageEffect(target, player, target);
                                        },
                                    },
                                },
                            },
                            //侠童渊
                            old_twchuanshu: {
                                audio: "twchuanshu",
                                trigger: { player: "phaseZhunbeiBegin" },
                                // limited: true,
                                // skillAnimation: true,
                                // animationColor: "qun",
                                async cost(event, trigger, player) {
                                    event.result = await player
                                        .chooseTarget(get.prompt2("old_twchuanshu"))
                                        .set("ai", target => {
                                            if (!get.event("bool")) return 0;
                                            let val = get.attitude(_status.event.player, target);
                                            if (target.hasSkill("twchaofeng")) val += ai.guessTargetPoints(target).max;
                                            return val * get.threaten(target);
                                        })
                                        .set(
                                            "bool",
                                            (() => {
                                                const fs =
                                                    game.findPlayer(cur => {
                                                        return get.attitude(player, cur) > 2 && (cur.hasSkill("twchaofwng") || get.threaten(cur) > player.getHp());
                                                    }) || player;
                                                return (
                                                    game.countPlayer(cur => {
                                                        let eff = 0;
                                                        if (get.attitude(player, cur) < 0) eff = get.effect(cur, { name: "sha", nature: "fire", isCard: true }, player, player);
                                                        if (fs.hasSkill("twchaofeng")) eff *= 2 - 1 / ai.guessTargetPoints(fs, player).max;
                                                        return Math.max(0, eff);
                                                    }) >
                                                    10 * player.getHp()
                                                );
                                            })()
                                        )
                                        .forResult();
                                },
                                async content(event, trigger, player) {
                                    player.awakenSkill("old_twchuanshu");
                                    const target = event.targets[0];
                                    target.addMark("old_twchuanshu_mark", 1, false);
                                    target.addSkill("old_twchuanshu_effect");
                                    target.markAuto("old_twchuanshu_effect", [player]);
                                    player.addSkill("old_twchuanshu_clear");
                                    player.markAuto("old_twchuanshu_clear", [target]);
                                },
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                    },
                                    effect: {
                                        audio: "twchuanshu",
                                        trigger: {
                                            player: "compare",
                                            target: "compare",
                                        },
                                        direct: true,
                                        forced: true,
                                        charlotte: true,
                                        nopop: true,
                                        mark: true,
                                        intro: {
                                            content(storage, player) {
                                                var shisyou = player.getStorage("old_twchuanshu_effect").filter(i => i.isIn());
                                                var str = "<li>拼点牌点数+3；";
                                                if (player.hasMark("old_twchuanshu_mark")) {
                                                    str += "<li>使用的下一张【杀】对除" + get.translation(shisyou) + "外的角色造成伤害时，此伤害+" + player.countMark("old_twchuanshu_mark") + "；";
                                                    if (!shisyou.includes(player)) {
                                                        str += "<li>使用的下一张【杀】结算结束后，" + get.translation(shisyou) + "摸等同于伤害值的牌；";
                                                    }
                                                }
                                                str = str.slice(0, -1) + "。";
                                                return str;
                                            },
                                        },
                                        filter(event, player, name) {
                                            if (event.player == player && event.iwhile > 0) return false;
                                            return (player == event.player ? event.num1 : event.num2) < 13;
                                        },
                                        content() {
                                            game.log(player, "的拼点牌点数+3");
                                            if (player == trigger.player) trigger.num1 = Math.min(13, trigger.num1 + 3);
                                            else trigger.num2 = Math.min(13, trigger.num2 + 3);
                                        },
                                        group: "old_twchuanshu_damage",
                                    },
                                    damage: {
                                        charlotte: true,
                                        trigger: { player: ["useCard", "useCardAfter"], source: "damageBegin1" },
                                        filter(event, player, name) {
                                            if (name == "useCard") return event.card.name == "sha" && player.hasMark("old_twchuanshu_mark");
                                            if (name == "damageBegin1") return event.card && event.card.old_twchuanshu_mark && !player.getStorage("old_twchuanshu_effect").includes(event.player);
                                            return (
                                                event.card.old_twchuanshu_mark &&
                                                player.hasHistory("sourceDamage", function (evt) {
                                                    return evt.card == event.card;
                                                }) &&
                                                player.getStorage("old_twchuanshu_effect").filter(function (target) {
                                                    return target.isIn() && target != player;
                                                }).length
                                            );
                                        },
                                        forced: true,
                                        content() {
                                            var name = event.triggername;
                                            if (name == "useCard") {
                                                var num = player.countMark("old_twchuanshu_mark");
                                                trigger.card.old_twchuanshu_mark = num;
                                                player.removeMark("old_twchuanshu_mark", num, false);
                                            } else if (name == "damageBegin1") trigger.num++;
                                            else {
                                                var num1 = trigger.card.old_twchuanshu_mark;
                                                var num2 = 0;
                                                player.getHistory("sourceDamage", function (evt) {
                                                    if (evt.card == trigger.card) num2 += evt.num;
                                                });
                                                var targets = player.getStorage("old_twchuanshu_effect").filter(function (target) {
                                                    return target.isIn() && target != player;
                                                });
                                                if (targets.length == 1) targets[0].draw(num1 * num2);
                                                else game.asyncDraw(targets, num1 * num2);
                                            }
                                        },
                                    },
                                    clear: {
                                        charlotte: true,
                                        onremove: true,
                                        trigger: { player: "phaseBegin" },
                                        filter(event, player) {
                                            return player.getStorage("old_twchuanshu_clear").length;
                                        },
                                        forced: true,
                                        silent: true,
                                        content() {
                                            "step 0";
                                            var targets = player.getStorage("old_twchuanshu_clear");
                                            for (var target of targets) {
                                                target.unmarkAuto("old_twchuanshu_effect", [player]);
                                                if (!target.getStorage("old_twchuanshu_effect").length) target.removeSkill("old_twchuanshu_effect");
                                            }
                                            "step 1";
                                            player.removeSkill("old_twchuanshu_clear");
                                        },
                                    },
                                },
                            },
                            //侠关羽
                            old_twzhongyi: {
                                mod: {
                                    targetInRange(card) {
                                        if (card.name == "sha") return true;
                                    },
                                },
                                audio: "twzhongyi",
                                trigger: { player: "useCardAfter" },
                                filter(event, player) {
                                    if (event.card.name != "sha") return false;
                                    return player.getHistory("sourceDamage", evt => evt.card && evt.card == event.card).length;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const num = player.getHistory("sourceDamage", evt => evt.card && evt.card == trigger.card).reduce((sum, evt) => sum + evt.num, 0);
                                    // const num = game.countPlayer2(target => {
                                    // 	return target.hasHistory("damage", evt => {
                                    // 		return evt.card && evt.card == trigger.card;
                                    // 	});
                                    // });
                                    const num2 = 1 + player.getAllHistory("custom", evt => evt.old_twzhongyi).length;
                                    let choice = ["摸牌"],
                                        choiceList = ["摸" + get.cnNumber(num) + "张牌"];
                                    if (player.isDamaged()) {
                                        choice.addArray(["回血", "背水！"]);
                                        choiceList.addArray(["回复" + num + "点体力", "失去" + num2 + "点体力，依次执行以上所有项"]);
                                    }
                                    const {
                                        result: { control },
                                    } = await player
                                        .chooseControl(choice)
                                        .set("prompt", "忠义：请选择一项")
                                        .set("choiceList", choiceList)
                                        .set("ai", () => {
                                            const player = get.event("player");
                                            const num = get.event("num"),
                                                num2 = get.event("num2");
                                            if (player.isHealthy()) return "摸牌";
                                            return player.hp + player.countCards("hs", card => player.canSaveCard(card, player)) - num2 > 0 && num > num2 ? "背水！" : "回血";
                                        })
                                        .set("num", num)
                                        .set("num2", num2);
                                    if (control != "cancel2") {
                                        if (control == "背水！") {
                                            await player.loseHp(num2);
                                            player.getHistory("custom").push({ old_twzhongyi: true });
                                        }
                                        if (control != "回血") await player.draw(num);
                                        if (control != "摸牌") await player.recover(num);
                                    }
                                },
                            },
                            old_twchue: {
                                audio: "twchue",
                                trigger: { player: "useCardToPlayer" },
                                filter(event, player) {
                                    return event.card.name == "sha" && event.isFirstTarget && event.targets.length == 1 && game.hasPlayer(target => !event.targets.includes(target) && player.canUse(event.card, target));
                                },
                                prompt2: "失去1点体力，额外指定至多等同于你体力值的目标",
                                check(event, player) {
                                    return player.hp + player.countCards("hs", card => player.canSaveCard(card, player)) - 1 > 0;
                                },
                                async content(event, trigger, player) {
                                    await player.loseHp();
                                    const targetx = trigger.targets.slice(),
                                        num = player.getHp();
                                    if (!num) return;
                                    const {
                                        result: { bool, targets },
                                    } = await player
                                        .chooseTarget("额外指定至多" + get.cnNumber(num) + "名目标", [1, num], (card, player, target) => {
                                            const trigger = _status.event.getTrigger();
                                            return !trigger.targets.includes(target) && player.canUse(trigger.card, target);
                                        })
                                        .set("ai", target => {
                                            const player = get.event("player"),
                                                trigger = _status.event.getTrigger();
                                            return get.effect(target, trigger.card, player, player);
                                        });
                                    if (!bool) return;
                                    player.line(targets);
                                    trigger.targets.addArray(targets);
                                },
                                group: ["old_twchue_gain", "old_twchue_effect"],
                                marktext: "勇",
                                intro: {
                                    name: "勇",
                                    content: "mark",
                                },
                                subSkill: {
                                    gain: {
                                        audio: "twchue",
                                        trigger: { player: ["damageEnd", "loseHpEnd"] },
                                        forced: true,
                                        locked: false,
                                        async content(event, trigger, player) {
                                            await player.draw();
                                            player.addMark("old_twchue", 1);
                                        },
                                    },
                                    effect: {
                                        audio: "twchue",
                                        trigger: { global: "phaseEnd" },
                                        filter(event, player) {
                                            const card = new lib.element.VCard({ name: "sha" });
                                            return (
                                                player.hasUseTarget(card) &&
                                                /*player.getHistory('useSkill',evt=>{
                                                return evt.skill=='twchue_gain';
                                            }).length&&player.getHp()&&*/ player.countMark("twchue") >= player.getHp()
                                            );
                                        },
                                        check(event, player) {
                                            return player.hasValueTarget(new lib.element.VCard({ name: "sha" }));
                                        },
                                        prompt2(event, player) {
                                            const num = player.getHp();
                                            return "失去" + num + "个“勇”标记，视为使用一张造成的伤害+1且可以额外指定" + num + "个目标的【杀】";
                                        },
                                        async content(event, trigger, player) {
                                            const num = player.getHp();
                                            player.removeMark("old_twchue", num);
                                            const card = new lib.element.VCard({ name: "sha" });
                                            player
                                                .when("useCard2")
                                                .filter(evt => evt.getParent(2) == event)
                                                .assign({
                                                    firstDo: true,
                                                })
                                                .then(() => {
                                                    trigger.baseDamage++;
                                                    if (
                                                        !game.hasPlayer(target => {
                                                            return !trigger.targets.includes(target) && player.canUse(trigger.card, target);
                                                        })
                                                    )
                                                        return;
                                                    player
                                                        .chooseTarget("额外指定至多" + get.cnNumber(num) + "名目标", [1, num], (card, player, target) => {
                                                            const trigger = _status.event.getTrigger();
                                                            return !trigger.targets.includes(target) && player.canUse(trigger.card, target);
                                                        })
                                                        .set("ai", target => {
                                                            const player = get.event("player"),
                                                                trigger = _status.event.getTrigger();
                                                            return get.effect(target, trigger.card, player, player);
                                                        });
                                                })
                                                .then(() => {
                                                    if (result.bool) {
                                                        const targets = result.targets;
                                                        player.line(targets);
                                                        trigger.targets.addArray(targets);
                                                    }
                                                })
                                                .vars({ num: num });
                                            player.chooseUseTarget("视为使用造成的伤害+1且可以额外指定" + num + "个目标的【杀】", card, false, true);
                                        },
                                    },
                                },
                            },
                            //幻诸葛亮
                            old_twhunyou: {
                                audio: "twhunyou",
                                unique: true,
                                limited: true,
                                enable: "chooseToUse",
                                filter(event, player) {
                                    return event.type == "dying" && event.dying == player;
                                },
                                skillAnimation: true,
                                animationColor: "orange",
                                async content(event, trigger, player) {
                                    player.awakenSkill(event.name);
                                    await player.recoverTo(1);
                                    player.addTempSkill(event.name + "_buff");
                                    if (!_status.currentPhase) return;
                                    player
                                        .when({ global: "phaseAfter" })
                                        .then(() => {
                                            player.insertPhase();
                                        })
                                        .then(() => {
                                            const num = Math.min(7, player.getStorage("twbeiding").length);
                                            if (num > 0) player.draw(num);
                                        })
                                        .then(() => {
                                            player.storage.isInHuan = true;
                                            player.changeSkin({ characterName: "old_huan_zhugeliang" }, "huan_zhugeliang_shadow");
                                            player.changeSkills(get.info("old_twhunyou").derivation, ["old_twhunyou"]);
                                        });
                                },
                                derivation: ["twhuanji", "old_twchanggui"],
                                subSkill: {
                                    buff: {
                                        trigger: {
                                            player: ["damageBefore", "loseHpBefore"],
                                        },
                                        forced: true,
                                        charlotte: true,
                                        async content(event, trigger, player) {
                                            trigger.cancel();
                                            game.log(player, "防止此次了" + (trigger.name == "damage" ? "伤害" : "失去体力"));
                                        },
                                        ai: {
                                            nofire: true,
                                            nothunder: true,
                                            nodamage: true,
                                            effect: {
                                                target(card, player, target, current) {
                                                    if (get.tag(card, "damage")) return "zeroplayertarget";
                                                },
                                            },
                                        },
                                        mark: true,
                                        intro: {
                                            content: "我是无敌的",
                                        },
                                    },
                                },
                                ai: {
                                    order: 1,
                                    save: true,
                                    skillTagFilter(player, tag, target) {
                                        if (player != target || player.storage.old_twhunyou) return false;
                                    },
                                    result: {
                                        player: 1,
                                    },
                                },
                            },
                            old_twchanggui: {
                                audio: "twchanggui",
                                trigger: {
                                    player: "phaseJieshuBegin",
                                },
                                filter(event, player) {
                                    return player.isMinHp() && player.maxHp != player.getHp();
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    const num = player.maxHp - player.getHp();
                                    await player[num > 0 ? "loseMaxHp" : "gainMaxHp"](Math.abs(num));
                                    delete player.storage.isInHuan;
                                    player.changeSkin({ characterName: "old_huan_zhugeliang" }, "huan_zhugeliang");
                                    await player.changeSkills(["old_twhunyou"], get.info("old_twhunyou").derivation);
                                },
                                derivation: ["old_twhunyou"],
                            },
                            //幻曹昂
                            old_twchihui: {
                                audio: "twchihui",
                                audioname: ["huan_caoang_shadow"],
                                trigger: { global: "phaseBegin" },
                                filter(event, player) {
                                    return event.player != player && player.hasEnabledSlot();
                                },
                                async cost(event, trigger, player) {
                                    const { player: target } = trigger,
                                        equips = Array.from({ length: 5 })
                                            .map((_, i) => [i + 1, get.translation(`equip${i + 1}`)])
                                            .filter(i => player.hasEnabledSlot(`equip${i[0]}`));
                                    const {
                                        result: { bool, links },
                                    } = await player
                                        .chooseButton(2, [
                                            "炽灰：请选择你要废除的装备栏和相应操作",
                                            '<div class="text center">即将废除的装备栏</div>',
                                            [equips, "tdnodes"],
                                            `<div class="text center">对${get.translation(target)}执行的操作</div>`,
                                            [
                                                [
                                                    ["discard", `弃置其牌`],
                                                    ["equip", `置入装备牌`],
                                                ],
                                                "tdnodes",
                                            ],
                                        ])
                                        .set("filterButton", button => {
                                            const { link } = button,
                                                { player, target } = get.event();
                                            if (Boolean(ui.selected.buttons.length) == (typeof link == "number")) return false;
                                            if (ui.selected.buttons.length) {
                                                return link == "equip" || target.countDiscardableCards(player, "hej");
                                            }
                                            return true;
                                        })
                                        .set("ai", button => {
                                            const { link } = button,
                                                { player, target, list } = get.event();
                                            let att = get.attitude(player, target);
                                            if (att < 0) {
                                                att = -Math.sqrt(-att);
                                            } else {
                                                att = Math.sqrt(att);
                                            }
                                            const eff = att * lib.card.guohe.ai.result.target(player, target);
                                            if (!ui.selected.buttons.length) {
                                                const bool = player.hasSkill("old_twfuxi");
                                                const getVal = num => {
                                                    const card = player.getEquip(`equip${num}`);
                                                    if (card) {
                                                        const val = get.value(card);
                                                        if (val > 0) return 0;
                                                        return 5 - val;
                                                    }
                                                    switch (num) {
                                                        case "3":
                                                            return 4.5;
                                                        case "4":
                                                            return 4.4;
                                                        case "5":
                                                            return 4.3;
                                                        case "2":
                                                            return (3 - player.hp) * 1.5;
                                                        case "1": {
                                                            if (game.hasPlayer(current => (get.realAttitude || get.attitude)(player, current) < 0 && get.distance(player, current) > 1) && !bool) return 0;
                                                            return bool ? 4.9 : 3.2;
                                                        }
                                                    }
                                                };
                                                list.sort((a, b) => getVal(b) - getVal(a));
                                                if (link == list[0]) return 1;
                                                return 0;
                                            }
                                            if (link == "discard" && eff < 0) return 0;
                                            if ((att < 0 || target.isMaxEquip()) && link == "equip") return 0;
                                            return 1;
                                        })
                                        .set("target", target)
                                        .set(
                                            "list",
                                            equips.map(i => i[0])
                                        );
                                    event.result = {
                                        bool: bool,
                                        cost_data: links,
                                    };
                                },
                                logTarget: "player",
                                async content(event, trigger, player) {
                                    const { player: target } = trigger,
                                        { cost_data: links } = event;
                                    await player.disableEquip(`equip${links[0]}`);
                                    if (links[1] == "discard") {
                                        if (target.countDiscardableCards(player, "hej")) await player.discardPlayerCard(target, "hej", true);
                                    } else {
                                        const equip = get.cardPile2(card => get.subtype(card) == `equip${links[0]}`);
                                        if (equip) {
                                            await target.equip(equip);
                                            await game.delayx();
                                        }
                                    }
                                    await player.loseHp();
                                    const num = player.getDamagedHp();
                                    if (num) await player.draw(num);
                                },
                            },
                            old_twfuxi: {
                                audio: "twfuxi",
                                persevereSkill: true,
                                trigger: { player: ["dying", "disableEquipAfter"] },
                                filter(event, player) {
                                    return event.name == "dying" || !player.hasEnabledSlot();
                                },
                                async cost(event, trigger, player) {
                                    const {
                                        result: { bool, links },
                                    } = await player
                                        .chooseButton([
                                            get.prompt(event.name.slice(0, -5)),
                                            [
                                                [
                                                    ["phase", "当前回合结束后执行一个额外的回合"],
                                                    ["old_twchihui", `保留〖炽灰〗直到下次退幻`],
                                                    ["draw", `摸牌至体力上限`],
                                                    ["enable", `恢复所有装备栏`],
                                                ],
                                                "textbutton",
                                            ],
                                        ])
                                        .set("filterButton", button => {
                                            const { link } = button,
                                                player = get.player();
                                            if (link == "draw" && player.countCards("h") >= player.maxHp) return false;
                                            if (link == "enable" && player.hasEnabledSlot()) return false;
                                            return true;
                                        })
                                        .set("ai", button => {
                                            const { link } = button,
                                                player = get.player();
                                            const num = player.getAllHistory("useSkill", evt => evt.skill == "old_twfuxi")?.lastItem?.old_twfuxi_num;
                                            if (num == 2 && player.maxHp <= 2 && ui.selected.buttons.length) return 0;
                                            if (link == "enable") return 5;
                                            if (link == "draw") return 5 - player.countCards("h");
                                            if (link == "phase") return Math.max(4, player.countCards("h"));
                                            return 1;
                                        })
                                        .set("selectButton", [1, 2]);
                                    event.result = {
                                        bool: bool,
                                        cost_data: links,
                                    };
                                },
                                async content(event, trigger, player) {
                                    const { cost_data: choices } = event,
                                        num = choices.length,
                                        history = player.getAllHistory("useSkill", evt => evt.skill == event.name);
                                    const skills = ["old_twchihui", "old_twfuxi"];
                                    if (history.length) {
                                        history[history.length - 1][event.name + "_num"] = num;
                                    }
                                    if (choices.includes("phase")) {
                                        game.log(player, "选择了", "#y选项一");
                                        player.addTempSkill(event.name + "_mark");
                                        player.insertPhase();
                                    }
                                    if (choices.includes("old_twchihui")) {
                                        game.log(player, "选择了", "#y选项二");
                                        skills.remove("old_twchihui");
                                    }
                                    if (choices.includes("draw")) {
                                        game.log(player, "选择了", "#y选项三");
                                        await player.drawTo(Math.min(player.maxHp, 5));
                                    }
                                    if (choices.includes("enable")) {
                                        game.log(player, "选择了", "#y选项四");
                                        const list = Array.from({ length: 5 })
                                            .map((_, i) => `equip${i + 1}`)
                                            .filter(i => player.hasDisabledSlot(i));
                                        await player.enableEquip(list);
                                    }
                                    await player.recoverTo(player.maxHp);
                                    player.changeSkin({ characterName: "old_huan_caoang" }, "huan_caoang_shadow");
                                    await player.changeSkills(["old_twhuangzhu", "old_twliyuan", "twjifa"], skills);
                                },
                                derivation: ["old_twhuangzhu", "old_twliyuan", "twjifa"],
                                subSkill: {
                                    mark: {
                                        charlotte: true,
                                        mark: true,
                                        intro: {
                                            content: "本回合结束后执行一个额外回合",
                                        },
                                    },
                                },
                            },
                            old_twhuangzhu: {
                                audio: "twhuangzhu",
                                audioname: ["huan_caoang"],
                                trigger: { player: ["phaseZhunbeiBegin", "phaseUseBegin"] },
                                filter(event, player) {
                                    if (event.name == "phaseZhunbei") return player.hasDisabledSlot();
                                    return player.getStorage("old_twhuangzhu_effect").length;
                                },
                                async cost(event, trigger, player) {
                                    if (trigger.name == "phaseZhunbei") {
                                        const list = Array.from({ length: 5 })
                                            .map((_, i) => `equip${i}`)
                                            .filter(i => player.hasDisabledSlot(i))
                                            .concat(["cancel2"]);
                                        const control = await player
                                            .chooseControl(list)
                                            .set("prompt", "煌烛：选择一个已废除装备栏的类别")
                                            .set("prompt2", "从牌堆或弃牌堆中随机获得一张对应副类别的装备牌，并记录其牌名")
                                            .set("ai", () => {
                                                return get
                                                    .event()
                                                    .controls.filter(i => i !== "cancel2")
                                                    .randomGet();
                                            })
                                            .forResultControl();
                                        event.result = {
                                            bool: control != "cancel2",
                                            cost_data: control,
                                        };
                                    } else {
                                        const storag = player.getStorage("old_twhuangzhu_effect");
                                        const {
                                            result: { bool, links },
                                        } = await player.chooseButton(['###煌烛：是否选择或替换至多两个牌名？###<div class="text center">你视为拥有选择牌名的技能</div>', [storag, "vcard"]], [1, 2]).set("ai", button => get.equipValue({ name: button.link[2] }, get.player()));
                                        event.result = {
                                            bool: bool,
                                            cost_data: links,
                                        };
                                    }
                                },
                                async content(event, trigger, player) {
                                    const { cost_data } = event;
                                    if (trigger.name == "phaseZhunbei") {
                                        const equip = get.cardPile(card => get.subtype(card) == cost_data);
                                        if (equip) {
                                            await player.gain(equip, "gain2");
                                            await game.delayx();
                                            player.addSkill(event.name + "_effect");
                                            player.markAuto(event.name + "_effect", [get.name(equip)]);
                                        }
                                    } else {
                                        const equip = event.name + "_equip";
                                        const subtypes = cost_data.map(name => get.subtypes(name[2])).flat();
                                        player.unmarkAuto(
                                            equip,
                                            player.getStorage(equip).filter(name => subtypes.some(t => get.subtypes(name[2]).includes(t)))
                                        );
                                        player.addSkill(equip);
                                        player.markAuto(equip, cost_data);
                                        player.addAdditionalSkill(
                                            equip,
                                            player
                                                .getStorage(equip)
                                                .map(name => lib.card[name[2]]?.skills || [])
                                                .flat()
                                        );
                                    }
                                },
                                subSkill: {
                                    effect: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: { content: "已记录牌名：$" },
                                    },
                                    equip: {
                                        charlotte: true,
                                        mod: {
                                            globalFrom(from, to, distance) {
                                                return distance + from.getStorage("old_twhuangzhu_equip").reduce((sum, name) => sum + (lib.card[name[2]]?.distance?.globalFrom || 0), 0);
                                            },
                                            globalTo(from, to, distance) {
                                                return distance + to.getStorage("old_twhuangzhu_equip").reduce((sum, name) => sum + (lib.card[name[2]]?.distance?.globalTo || 0), 0);
                                            },
                                            attackRange(from, distance) {
                                                return distance - from.getStorage("old_twhuangzhu_equip").reduce((sum, name) => sum + (lib.card[name[2]]?.distance?.attackFrom || 0), 0);
                                            },
                                            attackTo(from, to, distance) {
                                                return distance + to.getStorage("old_twhuangzhu_equip").reduce((sum, name) => sum + (lib.card[name[2]]?.distance?.attackTo || 0), 0);
                                            },
                                        },
                                        onremove(player, skill) {
                                            player.removeAdditionalSkill(skill);
                                        },
                                        intro: {
                                            markcount: "expansion",
                                            mark(dialog, storage = []) {
                                                if (!storage.length) return "当前未视为装备任意牌";
                                                dialog.addText("当前视为装备");
                                                dialog.addSmall([storage, "vcard"]);
                                            },
                                        },
                                        trigger: { player: "enableEquipEnd" },
                                        filter(event, player) {
                                            if (!event.slots?.length) return false;
                                            return player.getStorage("old_twhuangzhu_equip").some(name => event.slots.some(t => get.subtypes(name[2]).includes(t)));
                                        },
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.unmarkAuto(
                                                event.name,
                                                player.getStorage(event.name).filter(name => trigger.slots.some(t => get.subtypes(name[2]).includes(t)))
                                            );
                                            if (!player.getStorage(event.name).length) player.removeSkill(event.name);
                                        },
                                    },
                                },
                            },
                            old_twliyuan: {
                                audio: "twliyuan",
                                audioname: ["huan_caoang"],
                                mod: {
                                    targetInRange(card) {
                                        if (card.storag?.old_twliyuan) return true;
                                    },
                                    cardUsable(card, player, num) {
                                        if (card.storag?.old_twliyuan) return Infinity;
                                    },
                                },
                                enable: ["chooseToUse", "chooseToRespond"],
                                filterCard(card, player) {
                                    return get.subtypes(card).some(i => player.hasDisabledSlot(i));
                                },
                                locked: false,
                                viewAs: {
                                    name: "sha",
                                    storage: {
                                        old_twliyuan: true,
                                    },
                                },
                                filter(event, player) {
                                    return player.countCards("hes", card => get.subtypes(card).some(i => player.hasDisabledSlot(i)));
                                },
                                position: "hes",
                                precontent() {
                                    event.getParent().addCount = false;
                                    player.addTempSkill("old_twliyuan_effect");
                                },
                                prompt: "将一张与你已废除的装备栏对应副类别的装备牌当【杀】使用或打出",
                                check(card) {
                                    const val = get.value(card);
                                    if (_status.event.name == "chooseToRespond") return 1 / Math.max(0.1, val);
                                    return 6 - val;
                                },
                                subSkill: {
                                    effect: {
                                        trigger: { player: ["useCard", "respond"] },
                                        filter: evt => evt.skill == "old_twliyuan",
                                        forced: true,
                                        popup: false,
                                        content() {
                                            player.draw(2);
                                        },
                                    },
                                },
                            },
                            twjifa: {
                                audio: 2,
                                trigger: { player: "dying" },
                                forced: true,
                                async content(event, trigger, player) {
                                    const num = player.getAllHistory("useSkill", evt => evt.skill == "old_twfuxi")?.lastItem?.old_twfuxi_num;
                                    if (num > 0) await player.loseMaxHp(num);
                                    const control = await player
                                        .chooseControl(["old_twhuangzhu", "old_twliyuan"])
                                        .set("prompt", "选择保留的技能")
                                        .set("ai", () => {
                                            return get.event().controls.randomGet();
                                        })
                                        .forResultControl();
                                    await player.recoverTo(player.maxHp);
                                    player.changeSkin({ characterName: "old_huan_caoang" }, "huan_caoang");
                                    await player.changeSkills(["old_twchihui", "old_twfuxi"], ["old_twhuangzhu", "old_twliyuan", "twjifa"].remove(control));
                                },
                            },
                            //幻魏延
                            old_twpiankuang: {
                                audio: "twpiankuang",
                                getNum: (event, player) => Math.min(3, player.getHistory("sourceDamage", evt => evt.card && evt.card.name == event.card.name && evt.card != event.card).length),
                                trigger: {
                                    source: "damageBegin1",
                                },
                                filter(event, player) {
                                    return event.card && event.getParent().type == "card" && get.info("old_twpiankuang").getNum(event, player) > 0;
                                },
                                forced: true,
                                async content(event, trigger, player) {
                                    trigger.num += get.info("old_twpiankuang").getNum(trigger, player);
                                },
                            },
                            //幻诸葛果
                            old_rexianyuan: {
                                audio: "twxianyuan",
                                trigger: { global: "phaseUseBegin" },
                                filter(event, player) {
                                    return event.player.hasMark("old_rexianyuan");
                                },
                                forced: true,
                                locked: false,
                                logTarget: "player",
                                async content(event, trigger, player) {
                                    const target = trigger.player,
                                        str = get.translation(target);
                                    const num = target.countMark("old_rexianyuan");
                                    let choice;
                                    if (!target.countCards("h")) choice = 1;
                                    else
                                        choice = await player
                                            .chooseControl()
                                            .set("choiceList", ["观看" + str + "的手牌并将其中至多" + get.cnNumber(num) + "张牌置于牌堆顶", "令" + str + "摸" + get.cnNumber(num) + "张牌"])
                                            .set("ai", () => (get.attitude(get.player(), get.event().getTrigger().player) > 0 ? 1 : 0))
                                            .forResult("index");
                                    if (typeof choice != "number") return;
                                    if (choice == 0) {
                                        const result = await player.choosePlayerCard(target, "h", "visible", [1, num], true, '###仙援###<div class="text center">将其中至多' + get.cnNumber(num) + "张牌置于牌堆顶（先选择的在上）</div>").forResult();
                                        if (result.bool && result.cards?.length) {
                                            const cards = result.cards.slice();
                                            target.$throw(cards.length, 1000);
                                            await target.lose(cards, ui.cardPile, "insert");
                                        }
                                    } else await target.draw(num);
                                    if (_status.currentPhase !== player) target.clearMark("old_rexianyuan");
                                },
                                limit: 4,
                                intro: { content: "mark" },
                                group: ["old_rexianyuan_give", "old_rexianyuan_gain"],
                                subSkill: {
                                    give: {
                                        audio: "twxianyuan",
                                        enable: "phaseUse",
                                        filter(event, player) {
                                            return player.hasMark("old_rexianyuan") && game.hasPlayer(i => lib.skill.old_rexianyuan.subSkill.give.filterTarget(null, player, i));
                                        },
                                        filterTarget(card, player, target) {
                                            return target != player && target.countMark("old_rexianyuan") < lib.skill.old_rexianyuan.limit;
                                        },
                                        prompt: "将“仙援”标记分配给其他角色",
                                        async content(event, trigger, player) {
                                            const target = event.target;
                                            const gives = Array.from({ length: player.countMark("old_rexianyuan") }).map((_, i) => get.cnNumber(i + 1) + "枚");
                                            let give;
                                            if (gives.length == 1) give = 0;
                                            else
                                                give = await player
                                                    .chooseControl(gives)
                                                    .set("ai", () => 0)
                                                    .set("prompt", "仙援：将任意枚“仙援”标记分配给" + get.translation(target))
                                                    .forResult("index");
                                            if (typeof give != "number") return;
                                            give++;
                                            player.removeMark("old_rexianyuan", give);
                                            target.addMark("old_rexianyuan", give);
                                        },
                                        ai: {
                                            order: 1,
                                            result: {
                                                player: 1,
                                                target(player, target) {
                                                    const sgn = get.sgn(get.attitude(player, target));
                                                    return sgn == 0 ? 0.5 : sgn * (2 - sgn);
                                                },
                                            },
                                        },
                                    },
                                    gain: {
                                        audio: "twxianyuan",
                                        trigger: { global: "roundStart" },
                                        filter(event, player) {
                                            return player.countMark("old_rexianyuan") < lib.skill.old_rexianyuan.limit;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            player.addMark("old_rexianyuan", Math.min(4, lib.skill.old_rexianyuan.limit - player.countMark("old_rexianyuan")));
                                        },
                                    },
                                },
                            },
                            //tw神吕蒙
                            old_twshelie: {
                                audio: "shelie",
                                inherit: "shelie",
                                prompt2: () => lib.translate.shelie_info,
                                group: "old_twshelie_jingce",
                                //什么精策技能啊喂！
                                subSkill: {
                                    round: { charlotte: true },
                                    count: {
                                        charlotte: true,
                                        onremove: true,
                                        intro: {
                                            markcount(storage) {
                                                return storage.length;
                                            },
                                            content: "本回合已使用$花色的牌",
                                        },
                                    },
                                    jingce: {
                                        audio: "shelie",
                                        trigger: { player: ["phaseJieshuBegin", "useCard1"] },
                                        filter(event, player) {
                                            if (player.hasSkill("old_twshelie_round") || player != _status.currentPhase) return false;
                                            var list = [];
                                            player.getHistory("useCard", function (evt) {
                                                if (lib.suit.includes(get.suit(evt.card)) && !list.includes(get.suit(evt.card))) list.push(get.suit(evt.card));
                                            });
                                            if (list.length) {
                                                player.addTempSkill("old_twshelie_count");
                                                player.storage.old_twshelie_count = list.sort(function (a, b) {
                                                    return lib.suit.indexOf(b) - lib.suit.indexOf(a);
                                                });
                                                player.markSkill("old_twshelie_count");
                                                player.syncStorage("old_twshelie_count");
                                            }
                                            return event.name != "useCard" && list.length >= player.hp;
                                        },
                                        forced: true,
                                        locked: false,
                                        content() {
                                            "step 0";
                                            player.addTempSkill("old_twshelie_round", "roundStart");
                                            player.chooseControl("摸牌阶段", "出牌阶段").set("prompt", "涉猎：请选择要执行的额外阶段");
                                            "step 1";
                                            const evt = trigger.getParent("phase", true, true);
                                            if (result.index == 0) {
                                                if (evt && evt.phaseList) evt.phaseList.splice(evt.num + 1, 0, "phaseDraw|old_twshelie");
                                            }
                                            if (result.index == 1) {
                                                var next = player.phaseUse();
                                                event.next.remove(next);
                                                if (evt && evt.phaseList) evt.phaseList.splice(evt.num + 1, 0, "phaseUse|old_twshelie");
                                            }
                                        },
                                    },
                                },
                            },
                            old_twgongxin: {
                                audio: "gongxin",
                                enable: "phaseUse",
                                filter(event, player) {
                                    return game.hasPlayer(function (current) {
                                        return current != player && current.countCards("h");
                                    });
                                },
                                filterTarget(card, player, target) {
                                    return target != player && target.countCards("h") > 0;
                                },
                                usable: 1,
                                content() {
                                    "step 0";
                                    event.num = target.getCards("h").reduce(function (arr, card) {
                                        return arr.add(get.suit(card, player)), arr;
                                    }, []).length;
                                    "step 1";
                                    var cards = target.getCards("h");
                                    var next = player.chooseToMove_new("攻心");
                                    next.set("list", [
                                        [get.translation(target) + "的手牌", cards],
                                        [["弃置"], ["置于牌堆顶"]],
                                    ]);
                                    next.set("filterOk", moved => {
                                        return moved[1].slice().concat(moved[2]).length == 1;
                                    });
                                    next.set("processAI", list => {
                                        let card = list[0][1].slice().sort((a, b) => {
                                            return get.value(b) - get.value(a);
                                        })[0];
                                        if (!card) return false;
                                        return [list[0][1].slice().remove(card), [card], []];
                                    });
                                    "step 2";
                                    if (result.bool) {
                                        if (result.moved[1].length) target.discard(result.moved[1]);
                                        else {
                                            player.showCards(result.moved[2], get.translation(player) + "对" + get.translation(target) + "发动了【攻心】");
                                            target.lose(result.moved[2], ui.cardPile, "visible", "insert");
                                        }
                                    }
                                    "step 3";
                                    if (
                                        event.num ==
                                        target.getCards("h").reduce(function (arr, card) {
                                            return arr.add(get.suit(card, player)), arr;
                                        }, []).length
                                    )
                                        event.finish();
                                    "step 4";
                                    var num1 = 0;
                                    for (var card of target.getCards("h")) {
                                        if (get.color(card) == "red") num1++;
                                    }
                                    var num2 = target.countCards("h") - num1;
                                    player
                                        .chooseControl(["红色", "黑色", "cancel2"])
                                        .set("prompt", "是否令" + get.translation(target) + "本回合无法使用一种颜色的牌？")
                                        .set("ai", function () {
                                            return num1 >= num2 ? "红色" : "黑色";
                                        });
                                    "step 5";
                                    if (result.control != "cancel2") {
                                        player.line(target);
                                        target.addTempSkill("old_twgongxin2");
                                        target.markAuto("old_twgongxin2", [result.control == "红色" ? "red" : "black"]);
                                        game.log(target, "本回合无法使用" + result.control + "牌");
                                        if (!event.isMine() && !event.isOnline()) game.delayx();
                                    }
                                },
                                ai: {
                                    order: 10,
                                    expose: 0.25,
                                    result: {
                                        target(player, target) {
                                            return -target.countCards("h");
                                        },
                                    },
                                },
                            },
                            old_twgongxin2: {
                                mod: {
                                    cardEnabled2(card, player) {
                                        if (player.getStorage("old_twgongxin2").contains(get.color(card))) return false;
                                    },
                                },
                                charlotte: true,
                                onremove: true,
                                intro: { content: "本回合内不能使用或打出$牌" },
                            },
                            //友徐庶
                            old_friendxiaxing: {
                                audio: "friendxiaxing",
                                trigger: {
                                    global: "phaseBefore",
                                    player: "enterGame",
                                },
                                filter(event, player) {
                                    if (event.name === "phase") return game.phaseNumber === 0;
                                    return true;
                                },
                                forced: true,
                                locked: true,
                                async content(event, trigger, player) {
                                    const card = game.createCard2("xuanjian", "spade", 9);
                                    await player.gain([card], "gain2");
                                    await player.chooseUseTarget(card, true, false);
                                },
                                group: "old_friendxiaxing_gain",
                                subSkill: {
                                    gain: {
                                        audio: "riendxiaxing",
                                        trigger: { global: ["loseEnd", "equipEnd", "addJudgeEnd", "gainEnd", "loseAsyncEnd", "addToExpansionEnd"] },
                                        filter(event, player) {
                                            if (!player.getStorage("friendqihui").length) return false;
                                            return event.getd()?.some(i => i.name == "xuanjian");
                                        },
                                        async cost(event, trigger, player) {
                                            const storage = player.getStorage("friendqihui");
                                            const gains = trigger.getd().filter(i => i.name == "xuanjian");
                                            const {
                                                result: { links, bool },
                                            } = await player.chooseButton(["###" + get.prompt("old_friendxiaxing") + '###<div class="text center">移去1枚“启诲”标记，获得' + get.translation(gains) + "</div>", [storage.map(c => [c, get.translation(c)]), "tdnodes"]]).set("ai", button => {
                                                const player = get.player();
                                                if (player.getVEquip("xuanjian")) return 0;
                                                return (
                                                    1 +
                                                    Math.random() +
                                                    player.countCards("he", card => {
                                                        return get.type2(card) === button.link && player.hasValueTarget(card);
                                                    })
                                                );
                                            });
                                            event.result = {
                                                bool: bool,
                                                cost_data: links,
                                            };
                                        },
                                        async content(event, trigger, player) {
                                            player.unmarkAuto("friendqihui", event.cost_data);
                                            await player.gain(
                                                trigger.getd().filter(i => i.name == "xuanjian"),
                                                "gain2"
                                            );
                                        },
                                    },
                                },
                            },
                        },
                        //动态翻译
                        dynamicTranslate: {
                            old_sblongdan(player) {
                                if (player.hasSkill("old_sblongdan_mark", null, null, false)) return "蓄力技（1/4）。①你可以消耗1点蓄力值，将【杀】当做【闪】或将【闪】当做【杀】使用或打出，然后摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。";
                                return "蓄力技（1/4）。①你可以消耗1点蓄力值，将【杀】当做【闪】或将【闪】当做【杀】使用或打出，然后若你以此法使用牌，你摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。";
                            },
                            old_mbzuoyou(player) {
                                const old_mbzuoyou = player.storage.old_mbzuoyou;
                                if (old_mbzuoyou) return "转换技。出牌阶段限一次，阳：你可以令一名角色摸三张牌，然后其弃置两张牌；<span class='bluetext'>阴：你可以令一名角色获得1点护甲。</span>";
                                return "转换技。出牌阶段限一次，<span class='bluetext'>阳：你可以令一名角色摸三张牌，然后其弃置两张牌；</span>阴：你可以令一名角色获得1点护甲。";
                            },
                            old_sbwansha(player) {
                                const storage = player.storage.old_sbwansha;
                                var str = "①你的回合内，不处于濒死状态的其他角色不能使用【桃】。②一名角色进入濒死状态时，你可以观看其手牌并选择其";
                                str += storage ? "区域内" : "中";
                                str += "零至";
                                str += storage ? "三" : "两";
                                str += "张牌（其他角色不可见），然后其选择一项：1.你将这些牌分配给任意名不为其的角色；2.其弃置除这些牌以外的牌。";
                                return str;
                            },
                            old_sbweimu(player) {
                                const storage = player.storage.old_sbweimu;
                                var str = "锁定技。";
                                str += storage ? "①" : "";
                                str += "当你成为黑色锦囊牌的目标时，取消之。";
                                if (storage) {
                                    str += "②每轮开始时，若你上一轮成为其他角色使用牌的目标的次数不大于2，你从弃牌堆中随机获得一张黑色锦囊牌或防具牌。";
                                }
                                return str;
                            },
                        },
                        //翻译
                        translate: {
                            oldCharacter: "怀旧武将",

                            mb_old: "手杀",
                            ol_old: "OL",
                            xin_old: "新杀",
                            tw_old: "海外",
                            other_old: "其他",

                            old_new_simayi: "旧应天神司马懿",
                            old_new_simayi_ab: "旧神司马懿",
                            old_new_simayi_prefix: "旧神",
                            old_jilin: "戢鳞",
                            old_jilin_info: "①游戏开始时，你将牌堆顶三张牌暗置于你的武将牌上，称为“志”。②当你成为其他角色使用牌的目标时，你可以明置一张暗置的“志”令此牌对你无效。③回合开始时，你可用任意张手牌替换等量暗置的“志”。",
                            old_yingyou: "英猷",
                            old_yingyou_info: "①出牌阶段开始时，你可明置一张“志”然后摸X张牌（X为明置的“志”的数量）。②当你失去与明置的“志”其中一张花色相同的牌时，你摸一张牌。",
                            old_yingtian: "应天",
                            old_yingtian_info: "觉醒技。一名角色死亡后，若场上势力数不大于2，则你获得〖鬼才〗、〖完杀〗、〖连破〗并失去〖英猷〗且你本局游戏使用牌没有距离限制。",
                            old_shen_lusu: "旧神鲁肃",
                            old_shen_lusu_prefix: "旧神",
                            old_dingzhou: "定州",
                            old_dingzhou_info: "出牌阶段限一次。你可以将X张牌交给一名场上有牌的角色，然后你获得其场上的所有牌（X为其场上的牌数）。",
                            old_tamo: "榻谟",
                            old_tamo_info: "游戏开始时，你可以重新分配除主公外所有角色的座次。",
                            old_tamo_faq: "FAQ",
                            old_tamo_faq_info: "<br><li>Q：在一号位不为主公的情况下，〖榻谟〗如何结算？</li><li>A：该角色可以正常进行座次交换。若受此技能影响导致一号位角色发生了变化，则以排列后的一号位角色为起始角色开始本局游戏。</li>",
                            old_zhimeng: "智盟",
                            old_zhimeng_info: "回合结束后，你可以选择一名其他角色。若如此做，你与其将各自所有手牌置于处理区，然后你随机获得这些牌中的一半（向上取整），其获得剩余的牌。",
                            old_mb_jushou: "旧手杀界沮授",
                            old_mb_jushou_ab: "旧界沮授",
                            old_mb_jushou_prefix: "旧界",
                            old_xinjianying: "渐营",
                            old_xinjianying_info: "①当你于出牌阶段内使用与此阶段你使用的上一张牌点数或花色相同的牌时，你可以摸一张牌。②出牌阶段限一次，你可以将一张牌当做任意基本牌使用（不计入次数限制）。若你于此阶段内使用的上一张牌有花色，则此牌的花色视为上一张牌的花色。",
                            xinshibei: "矢北",
                            xinshibei_info: "锁定技，当你受到伤害后：若此伤害是你本回合第一次受到的伤害，则你回复1点体力；否则你失去1点体力。",
                            old_mb_zhuzhi: "旧手杀界朱治",
                            old_mb_zhuzhi_ab: "旧界朱治",
                            old_mb_zhuzhi_prefix: "旧界",
                            old_sbanguo: "安国",
                            old_sbanguo_info: "①游戏开始时，你令一名其他角色获得1枚“安国”标记（有“安国”的角色手牌上限基数等于体力上限）。②出牌阶段开始时，你可以将一名有“安国”的角色的所有“安国”移动给一名本局游戏未获得过“安国”的其他角色。③当你受到伤害时，若有有“安国”的角色且伤害值不小于你的体力值且此伤害没有来源或来源没有“安国”，防止此伤害。④一名角色进入濒死状态时，若其有你因〖安国①〗获得的“安国”，你移去其该“安国”，令其将体力回复至1点。然后你选择一项：1.若你的体力值大于1，你失去体力至1点；2.若你的体力上限大于1，你将体力上限减至1。最后你令其获得X点护甲（X为你以此法失去的体力值或减少的体力上限）。",
                            old_mb_sp_zhenji: "手杀SP甄宓",
                            old_mb_sp_zhenji_ab: "旧SP甄宓",
                            old_mb_sp_zhenji_prefix: "旧SP",
                            old_mbbojian: "博鉴",
                            old_mbbojian_info: "锁定技。出牌阶段结束时，若你本阶段使用牌数与花色数与上个出牌阶段皆不同，你摸两张牌；否则你将一张弃牌堆中本阶段你因使用而失去的牌交给一名角色。",
                            old_mbjiwei: "济危",
                            old_mbjiwei_info: "锁定技。①每个其他角色的回合结束时，此回合每满足一项，你便摸一张牌：1.有至少一名角色失去过牌；2.有至少一名角色受到过伤害。②准备阶段，若你的手牌数不小于存活人数且不小于体力值，你须将手牌中数量较多颜色的牌全部分配给其他角色（若数量相同则选择一种颜色）。",
                            old_fuqian: "旧手杀傅佥",
                            old_fuqian_ab: "旧傅佥",
                            old_fuqian_prefix: "旧",
                            old_jueyong: "绝勇",
                            old_jueyong_info: "锁定技。①当你不因【绝勇】成为唯一牌的目标时，若此牌不为转化牌且对应的实体牌牌数为1且不为【桃】或【酒】，则你将此牌置于你的武将牌上，称为“绝”，且取消此牌的目标。②结束阶段开始时，若你有“绝”，且“绝”的数量不小于你已损失的体力值，则你令所有“绝”的原使用者依次对你使用所有“绝”，将无法使用的“绝”置入弃牌堆。",
                            old_poxiang: "破降",
                            old_poxiang_info: "出牌阶段限一次。你可以将一张牌交给一名其他角色并摸三张牌，移去所有“绝”并失去1点体力，然后你跳过本回合的弃牌阶段。",
                            old_mb_guozhao: "旧手杀郭照",
                            old_mb_guozhao_ab: "旧郭照",
                            old_mb_guozhao_prefix: "旧",
                            old_yichong: "易宠",
                            old_yichong_info: "①准备阶段，你可以选择一名其他角色并选择一个花色，然后你获得其所有此花色的牌，移除场上的所有“雀”标记，令其获得“雀”标记直到你的下个回合开始。②拥有“雀”标记的角色获得你最后一次发动〖易宠①〗选择的花色的牌后，你获得这些牌（你至多通过每个“雀”得到五张牌）。",
                            old_wufei: "诬诽",
                            old_wufei_info: "若场上存在拥有“雀”标记的角色A，则：①当你使用【杀】或伤害类锦囊牌指定第一个目标后，你令A成为此牌伤害来源。②当你受到伤害后，若A的体力值大于1且A的体力值大于你，则你可以对A造成1点伤害。",
                            old_mb_chengui: "旧手杀陈珪",
                            old_mb_chengui_ab: "旧陈珪",
                            old_mb_chengui_prefix: "旧",
                            old_guimou: "诡谋",
                            old_guimou_info: "锁定技。游戏开始时/回合结束时，你随机/须选择以下一项直到你的下个准备阶段：①记录场上期间角色使用牌数；②记录期间场上角色弃置牌数；③记录期间场上角色获得牌数。准备阶段，你可以选择一名场上对应记录数值最少的其他角色，观看其手牌并选择其中至多三张牌，然后你可以将其中至多两张牌交给另一名其他角色，然后弃置其余牌。",
                            old_yangfu: "旧杨阜",
                            old_yangfu_prefix: "旧",
                            oldx_jiebing: "借兵",
                            oldx_jiebing_info: "每当你受到伤害后，你可以选择一名不为伤害来源的其他角色，随机展示并获得其两张牌，若其中有装备牌，你使用之。",
                            old_hannan: "扞难",
                            old_hannan_info: "出牌阶段限一次。你可以与一名角色拼点，赢的角色对没赢的角色造成2点伤害。",
                            old_lizhaojiaobo: "旧李昭焦伯",
                            old_lizhaojiaobo_prefix: "旧",
                            old_mbzuoyou: "佐佑",
                            old_mbzuoyou_info: "转换技。出牌阶段限一次，阳：你可以令一名角色摸三张牌，然后其弃置两张手牌；阴：你可以令一名角色获得1点护甲。",
                            old_mbshishou: "侍守",
                            old_mbshishou_info: "锁定技。当你发动〖佐佑〗后，若目标角色不为你，你执行〖佐佑〗中目标角色未执行的一项。",
                            old_wangling: "旧王凌",
                            old_wangling_prefix: "旧",
                            old_sp_wangshuang: "旧手杀王双",
                            old_sp_wangshuang_ab: "旧勇王双",
                            old_sp_wangshuang_prefix: "旧勇",
                            old_shanxie: "擅械",
                            old_shanxie_info: "①出牌阶段限一次，你可选择一项：⒈从牌堆中获得一张武器牌。⒉获得一名其他角色装备区内的一张武器牌并使用，然后其将一张手牌当做【杀】对你使用。②当其他角色使用【闪】响应你使用的【杀】时，若此【闪】没有点数或点数不大于你攻击范围的二倍，则你令此【闪】无效。",
                            old_wujing: "旧吴景",
                            old_wujing_prefix: "旧",
                            old_liubing: "流兵",
                            old_liubing_info: "锁定技。①当你声明使用【杀】后，若此牌是你本回合使用的第一张有唯一对应实体牌的【杀】，则你将此牌的花色改为♦。②其他角色于其出牌阶段内使用的非转化黑色杀结算结束后，若此【杀】未造成伤害，则你获得之。",
                            old_qiaogong: "旧桥公",
                            old_qiaogong_prefix: "旧",
                            old_yizhu: "遗珠",
                            old_yizhu_info: "①结束阶段，你摸两张牌，然后将两张牌随机插入牌堆前2X张牌的位置中（X为角色数，选择牌的牌名对其他角色可见）。②当有其他角色使用“遗珠”牌指定唯一目标时，你可清除对应的“遗珠”标记并取消此目标，然后你可使用此牌。③当有“遗珠”牌进入弃牌堆后，你摸一张牌并清除对应的“遗珠”标记。",
                            old_gonghuan: "共患",
                            old_gonghuan_info: "锁定技。每回合限一次，一名其他角色受到伤害时，若其拥有“姻”标记且其体力值小于你，则你将伤害转移给自己。此伤害结算结束后，若你与其体力值相等，则你与其移去“姻”标记。",
                            old_sp_lvfan: '旧严吕范',
                            old_sp_lvfan_prefix: '旧严',
                            old_xin_zhangzhongjing: "旧张机",
                            old_xin_zhangzhongjing_prefix: "旧",
                            old_sp_zhujun: "旧手杀朱儁",
                            old_sp_zhujun_ab: "旧严朱儁",
                            old_sp_zhujun_prefix: "旧严",
                            old_yj_weiyan: "旧☆魏延",
                            old_yj_weiyan_prefix: "旧☆",
                            old_yj_zhoubuyi: "旧☆周不疑",
                            old_yj_zhoubuyi_prefix: "旧☆",
                            old_mbhuiyao: "慧夭",
                            old_mbhuiyao_info: "出牌阶段限一次。你可以受到1点无来源伤害，然后你选择一名其他角色，令其视为对另一名角色造成过1点伤害。",
                            old_mbquesong: "雀颂",
                            old_mbquesong_info: "一名角色的回合结束阶段，若你于本回合内受到过伤害，你令一名角色选择一项：1.摸X张牌并复原武将牌（X为5-其装备区牌数，且至少为1）；2.回复一点体力。",
                            old_shenpei: "旧审配",
                            old_shenpei_prefix: "旧",
                            old_mb_sp_guanqiujian: "旧玄毌丘俭",
                            old_mb_sp_guanqiujian_prefix: "旧玄",
                            old_mbcuizhen: "摧阵",
                            old_mbcuizhen_info: "①游戏开始时，你可以废除至多三名其他角色的武器栏。②当你于出牌阶段使用伤害类牌指定其他角色为目标后，若目标角色的手牌数不小于体力值，你可以废除其武器栏。③摸牌阶段，你令额定摸牌数+X（X为所有角色被废除的武器栏数之和+1，至多为4）。",
                            old_mb_wangjing: "旧王经",
                            old_mb_wangjing_prefix: "旧",
                            old_mbjiejian: "节谏",
                            old_mbjiejian_info: "准备阶段，你可将任意张手牌交给任意名其他角色，并令这些角色获得“节谏”标记。“节谏”角色成为一张非装备牌的唯一目标时，你可将此牌转移给你，然后摸一张牌。“节谏”角色的回合结束时，移去其“节谏”标记，若其体力值不小于X（X为你交给其牌时其的体力值），你摸两张牌。",
                            old_mbjiejian_tag: "已分配",
                            old_sp_jianggan: "旧蒋干",
                            old_sp_jianggan_prefix: "旧",
                            old_liwei: "旧李遗",
                            old_liwei_prefix: "旧",
                            old_jiaohua: "教化",
                            old_jiaohua_backup: "教化",
                            old_jiaohua_info: "出牌阶段限四次，你可以选择一个未被〖教化〗记录过的牌的类型，令一名角色从牌堆中获得一张此类型的牌，然后记录此类型，若基本、锦囊、装备均已被你发动〖教化〗记录，则你清空〖教化〗记录。",

                            old_sb_huangyueying: "旧谋黄月英",
                            old_sb_huangyueying_prefix: "旧谋",
                            old_sbqicai: "奇才",
                            old_sbqicai_backup: "奇才",
                            old_sbqicai_info: "①出牌阶段限一次。你可以将手牌中或弃牌堆中的一张装备牌置于一名其他角色的对应装备栏，然后其获得如下效果：当其得到普通锦囊牌后，其将此牌交给你（限三张）。②你使用锦囊牌无距离限制。",
                            old_sb_huangzhong: "旧谋黄忠",
                            old_sb_huangzhong_prefix: "旧谋",
                            old_sbliegong: "烈弓",
                            old_sbliegong_info: "①你使用【杀】可以选择你距离不大于此【杀】点数的角色为目标。②当你使用牌时，或成为其他角色使用牌的目标后，你记录此牌的花色。③当你使用【杀】指定唯一目标后，若你〖烈弓②〗的记录不为空，则你可亮出牌堆顶的X张牌（X为你〖烈弓②〗记录过的花色数-1），令此【杀】的伤害值基数+Y（Y为亮出牌中被〖烈弓②〗记录过花色的牌的数量），且目标角色不能使用〖烈弓②〗记录过花色的牌响应此【杀】。此【杀】使用结算结束后，你清除〖烈弓②〗的记录。",
                            old_sb_gongsunzan: "旧谋公孙瓒",
                            old_sb_gongsunzan_prefix: "旧谋",
                            old_sbqiaomeng: "趫猛",
                            old_sbqiaomeng_info: "当你使用【杀】造成伤害后，若你有〖义从〗，你可以选择一项：⒈弃置受伤角色区域里的一张牌并摸两张牌；⒉获得4点蓄力值。",
                            old_sb_sunquan: "旧谋孙权",
                            old_sb_sunquan_prefix: "旧谋",
                            old_sbzhiheng: "制衡",
                            old_sbzhiheng_info: "出牌阶段限一次。你可以弃置任意张牌并摸等量的牌，若你以此法弃置的牌包括你所有手牌，则你多摸X张牌（X为你的“业”数+1）。",
                            old_sbtongye: "统业",
                            old_sbtongye_info: "锁定技。结束阶段，你猜测场上装备牌数与你下一个准备阶段的场上装备牌数是否相等，并获得以下效果：你下一个准备阶段，若你猜对且“业”数小于4，你获得1枚“业”；若你猜错，你弃1枚“业”。",
                            old_sb_huanggai: "旧谋黄盖",
                            old_sb_huanggai_prefix: "旧谋",
                            old_sb_ganning: "旧谋甘宁",
                            old_sb_ganning_prefix: "旧谋",
                            old_sbqixi: "奇袭",
                            old_sbqixi_info: "你可以将一张黑色牌当作【过河拆桥】使用。你使用非转化非虚拟的【过河拆桥】可以改为：出牌阶段，对一名区域内有牌的角色使用，你弃置其区域内的所有牌。",
                            old_sbfenwei: "奋威",
                            old_sbfenwei_info: "限定技，当一名角色使用的锦囊牌指定了至少两名角色为目标时，你可以令此牌对其中任意名角色无效，然后你获得牌堆中的X张【过河拆桥】（X为你选择的角色数且X至多为4）。",
                            old_sb_xiaoqiao: "旧谋小乔",
                            old_sb_xiaoqiao_prefix: "旧谋",
                            old_sbtianxiang: "天香",
                            old_sbtianxiang_info: "①出牌阶段限三次，你可以交给一名没有“天香”标记的其他角色一张红色牌，然后令其获得此牌花色的“天香”标记。②当你受到伤害时，你可以移去一名角色的“天香”标记，若此“天香”标记为：红桃，你防止此伤害，其受到伤害来源对其造成的1点伤害（若没有伤害来源则改为无来源伤害）；方片，其交给你两张牌。③准备阶段，你移去场上所有的“天香”标记，然后摸X张牌（X为移去的“天香”标记数+3）。",
                            old_sb_daqiao: "旧谋大乔",
                            old_sb_daqiao_prefix: "旧谋",
                            old_sbguose: "国色",
                            old_sbguose_info: "出牌阶段限四次，你可以将一张♦牌当【乐不思蜀】使用或弃置场上一张【乐不思蜀】，然后你摸两张牌并弃置一张牌。",
                            old_sb_sunce: "旧谋孙策",
                            old_sb_sunce_prefix: "旧谋",
                            old_sbhunzi: "魂姿",
                            old_sbhunzi_info: "觉醒技。当你脱离濒死状态后，你减1点体力上限，获得2点护甲，摸三张牌。然后你获得〖英姿〗和〖英魂〗。",
                            old_sb_sp_zhugeliang: "旧谋卧龙·初版",
                            old_sb_sp_zhugeliang_ab: "旧谋卧龙",
                            old_sb_sp_zhugeliang_prefix: "旧谋",
                            old_sbhuoji: "火计",
                            old_sbhuoji_info: "使命技。①使命：出牌阶段限一次。你可以对一名其他角色造成1点火焰伤害，然后你对所有与其势力相同的不为其的其他角色各造成1点火焰伤害。②成功：准备阶段，若你本局游戏已对其他角色造成的火焰伤害不小于本局游戏总角色数，则你失去〖火计〗和〖看破〗，然后获得〖观星〗和〖空城〗。③失败：使命成功前进入濒死状态。",
                            old_sbkanpo: "看破",
                            old_sbkanpo_info: "①一轮游戏开始时，你清除〖看破①〗记录的牌名，然后你可以依次记录共计三个未于本次清除过的非装备牌牌名（对其他角色不可见）。②当其他角色使用你〖看破①〗记录过的牌名的牌时，你可以移去一个〖看破①〗中的此牌名的记录，令此牌无效。",
                            old_sb_zhugeliang: "旧谋诸葛亮·初版",
                            old_sb_zhugeliang_ab: "旧谋诸葛亮",
                            old_sb_zhugeliang_prefix: "旧谋",
                            old_sbguanxing: "观星",
                            old_sbguanxing_info: "①准备阶段，你将所有“星”置入弃牌堆，将牌堆顶的X张牌置于你的武将牌上，称为“星”。然后你可以将任意张“星”置于牌堆顶（X为你此次移去的“星”数+1且至多为7，若你此前未发动过〖观星①〗则X为7）。②结束阶段，若你未于本回合的准备阶段将“星”置于过牌堆顶，你可以将任意张“星”置于牌堆顶。③你可以如手牌般使用或打出“星”。",
                            old_sbkongcheng: "空城",
                            old_sbkongcheng_info: "锁定技。当你受到伤害时，若你有〖观星〗，且若你：有“星”，你判定，若结果点数不大于你的“星”数，此伤害-1；没有“星”，此伤害+1。",
                            oldx_sb_sp_zhugeliang: "旧谋卧龙",
                            oldx_sb_sp_zhugeliang_prefix: "旧谋",
                            oldx_sbhuoji: "火计",
                            oldx_sbhuoji_info: "使命技。①使命：出牌阶段限一次。你可以对一名其他角色造成1点火焰伤害，然后你对所有与其势力相同的不为其的其他角色各造成1点火焰伤害。②成功：准备阶段，若你本局游戏已造成的火焰伤害不小于本局游戏总角色数，则你失去〖火计〗和〖看破〗，然后获得〖观星〗和〖空城〗。③失败：使命成功前进入濒死状态。",
                            oldx_sbkanpo: "看破",
                            oldx_sbkanpo_info: "①一轮游戏开始时，你清除〖看破①〗记录的牌名，然后你可以依次记录任意个未于上次发动〖看破①〗记录清除过的非装备牌牌名（对其他角色不可见，每局游戏至多记录10个牌名）。②其他角色使用你〖看破①〗记录过的牌名的牌时，你可以移去一个〖看破①〗中的此牌名的记录令此牌无效，然后你摸一张牌。",
                            oldx_sb_zhugeliang: "旧谋诸葛亮",
                            oldx_sb_zhugeliang_prefix: "旧谋",
                            oldx_sbguanxing: "观星",
                            oldx_sbguanxing_info: "①准备阶段，你将所有“星”置入弃牌堆，将牌堆顶的X张牌置于你的武将牌上，称为“星”（X为7-此前发动〖观星①〗次数的两倍，且X至少为0）。然后你可以将任意张“星”置于牌堆顶。②结束阶段，若你未于本回合的准备阶段将“星”置于过牌堆顶，你可以将任意张“星”置于牌堆顶。③你可以如手牌般使用或打出“星”。",
                            oldx_sbkongcheng: "空城",
                            oldx_sbkongcheng_info: "锁定技。当你受到伤害时，若你拥有技能〖观星〗，且若你：有“星”，你判定，若结果点数不大于你的“星”数，此伤害-1；没有“星”，此伤害+1。",
                            old_sb_menghuo: "旧谋孟获",
                            old_sb_menghuo_prefix: "旧谋",
                            old_sbzaiqi: "再起",
                            old_sbzaiqi_info: "蓄力技（3/7）。①弃牌阶段结束时，你可以消耗任意点蓄力值并选择等量名角色，然后令这些角色选择一项：1.令你摸一张牌；2.弃置一张牌，然后你回复1点体力。②每回合限一次。当你造成伤害后，你获得1点蓄力值。",
                            old_sb_zhurong: "旧谋祝融",
                            old_sb_zhurong_prefix: "旧谋",
                            old_sbjuxiang: "巨象",
                            old_sbjuxiang_info: "锁定技。①【南蛮入侵】对你无效。②当其他角色使用【南蛮入侵】结算结束后，你获得此牌对应的所有实体牌。③结束阶段，若你未于本回合使用过【南蛮入侵】，你将一张游戏外的随机【南蛮入侵】（共八张）交给一名角色。",
                            old_sb_guanyu: "旧谋关羽",
                            old_sb_guanyu_prefix: "旧谋",
                            old_sbwusheng: "武圣",
                            old_sbwusheng_wusheng_backup: "武圣",
                            old_sbwusheng_info: "你可以将一张手牌当作任意【杀】使用或打出。出牌阶段开始时，你可以选择一名非主公的其他角色，本阶段对其使用【杀】无距离和次数限制，使用【杀】指定其为目标后摸一张牌，对其使用五张【杀】后不能对其使用【杀】。",
                            old_sb_zhaoyun: "旧谋赵云",
                            old_sb_zhaoyun_prefix: "旧谋",
                            old_sblongdan: "龙胆",
                            old_sblongdan_info: "蓄力技（1/4）。①你可以消耗1点蓄力值，将【杀】当做【闪】或将【闪】当做【杀】使用或打出，然后摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。",
                            old_sbjizhu: "积著",
                            old_sbjizhu_info: "准备阶段开始时，你可以和一名其他角色进行协力。其的下个结束阶段开始时，若你与其协力成功，则你修改〖龙胆〗直到你的下个结束阶段开始。",
                            old_sblongdan_shabi: "龙胆",
                            old_sblongdan_shabi_info: "蓄力技（1/4）。①你可以消耗1点蓄力值，将一张基本牌当做任意基本牌使用或打出，然后摸一张牌。②一名角色的回合结束时，你获得1点蓄力值。",
                            old_sb_fazheng: "旧谋法正",
                            old_sb_fazheng_prefix: "旧谋",
                            old_sbxuanhuo: "眩惑",
                            old_sbxuanhuo_info: "①出牌阶段限一次。你可以将一张牌交给一名没有“眩”标记的其他角色，然后令其获得“眩”标记。②当有“眩”的其他角色于摸牌阶段外得到牌后，若你以此法于其本次获得“眩”的期间内得到其的牌数小于5，你随机获得其一张手牌。",
                            old_sbenyuan: "恩怨",
                            old_sbenyuan_info: "锁定技。准备阶段，若场上存在有“眩”的角色，你移去该角色的“眩”，且你于其本次获得“眩”的期间内得到其的牌数：不小于3，你交给其两张牌；小于3，其失去1点体力，你回复1点体力。",
                            old_sb_xuhuang: "旧谋徐晃",
                            old_sb_xuhuang_prefix: "旧谋",
                            old_sbduanliang: "断粮",
                            old_sbduanliang_info: "出牌阶段限两次。你可以与一名其他角色进行谋弈。若你赢，且你选择的选项为：“围城断粮”，若其判定区没有【兵粮寸断】，你将牌堆顶牌当【兵粮寸断】对其使用，否则你获得其一张牌；“擂鼓进军”，你视为对其使用一张【决斗】。",
                            old_sb_yuanshao: "旧谋袁绍",
                            old_sb_yuanshao_prefix: "旧谋",
                            old_sbluanji: "乱击",
                            old_sbluanji_info: "①出牌阶段限一次。你可以将两张手牌当【万箭齐发】使用。②当其他角色因响应你使用的【万箭齐发】而打出【闪】时，你摸一张牌。",
                            old_sbxueyi: "血裔",
                            old_sbxueyi_info: "主公技，锁定技。①你的手牌上限+2X（X为场上其他群势力角色数）。②当你使用牌指定其他群势力角色为目标后，你摸一张牌。",
                            // old_sb_zhangjiao: "旧谋张角",
                            // old_sb_zhangjiao_prefix: "旧谋",
                            // old_sbleiji: "雷击",
                            // old_sbleiji_info: "出牌阶段，你可以选择一名其他角色并弃4枚“道兵”，对其造成1点雷电伤害。",
                            // old_sbguidao: "鬼道",
                            // old_sbguidao_info: "①游戏开始时/一名角色受到属性伤害后，你获得4/2枚“道兵”。②当你受到伤害时，你可以弃2枚“道兵”并防止此伤害。然后若当前回合角色不为你，〖鬼道①〗于你下回合开始前无效。③“道兵”上限为8。",
                            // old_sbhuangtian: "黄天",
                            // old_sbhuangtian_info: "主公技，锁定技。①回合开始时，若本回合为你的第一个回合且游戏轮数为1，且游戏内没有【太平要术】，你装备【太平要术】。②其他群势力角色造成伤害后，若你拥有〖鬼道〗，你获得2枚“道兵”（每轮你至多以此法获得4枚“道兵”）。",
                            old_sb_huaxiong: "旧谋华雄",
                            old_sb_huaxiong_prefix: "旧谋",
                            old_sb_handang: "旧谋韩当",
                            old_sb_handang_prefix: "旧谋",
                            old_sbjiefan: "解烦",
                            old_sbjiefan_info: "出牌阶段限一次。你可以令一名角色选择一项：⒈令所有攻击范围内含有其的角色依次弃置两张牌；⒉其摸等同于攻击范围内含有其的角色数+2的牌；⒊背水：此技能失效直到你杀死一名角色，然后依次执行上述所有选项。",
                            // old_sb_caopi: "旧谋曹丕",
                            // old_sb_caopi_prefix: "旧谋",
                            // old_sbxingshang: "行殇",
                            // old_sbxingshang_info: "①当一名角色受到伤害后（每回合限一次）或死亡时，你获得2个“颂”标记（你至多拥有9个“颂”标记）。②出牌阶段限两次，你可以：1.移去2个“颂”标记，令一名角色复原武将牌；2.移去2个“颂”标记，令一名角色摸X张牌（X为场上阵亡角色数，且X至少为2，至多为5）；3.移去5个“颂”标记，令一名体力上限小于10的角色回复1点体力，增加1点体力上限，随机恢复一个已废除的装备栏；4.移去5个“颂”标记，获得一名阵亡角色武将牌上的所有技能，然后你失去〖行殇〗〖放逐〗〖颂威〗。",
                            // old_sbfangzhu: "放逐",
                            // old_sbfangzhu_info: "出牌阶段限一次，你可以：1.移去1个“颂”标记，令一名其他角色于手牌中只能使用基本牌直到其回合结束；2.移去2个“颂”标记，令一名其他角色于手牌中只能使用锦囊牌直到其回合结束。3.移去3个“颂”标记，令一名其他角色于手牌中只能使用装备牌直到其回合结束；4.移去2个“颂”标记，令一名其他角色的非Charlotte技能失效直到其回合结束；5.移去2个“颂”标记，令一名其他角色不能响应除其以外的角色使用的牌直到其回合结束；6.移去3个“颂”标记，令一名其他角色将武将牌翻面；",
                            // old_sbfangzhu_info_doudizhu: "出牌阶段限一次，你可以：1.移去2个“颂”标记，令一名其他角色于手牌中只能使用锦囊牌直到其回合结束。2.移去2个“颂”标记，令一名其他角色不能响应除其以外的角色使用的牌直到其回合结束；3.移去3个“颂”标记，令一名其他角色将武将牌翻面；",
                            // old_sbsongwei: "颂威",
                            // old_sbsongwei_info: "主公技。①出牌阶段开始时，你获得Y个“颂”标记（Y为场上其他魏势力角色数的两倍）。②每局游戏限一次，出牌阶段，你可以令一名其他魏势力角色失去所有其武将牌上的技能。",
                            old_sb_jiaxu: "旧谋贾诩",
                            old_sb_jiaxu_prefix: "旧谋",
                            old_sbwansha: "完杀",
                            old_sbwansha_info: "①你的回合内，不处于濒死状态的其他角色不能使用【桃】。②一名角色进入濒死状态时，你可以观看其手牌并选择其中零至两张牌（其他人不可见），然后其选择一项：1.你将这些牌分配给任意名不为其的角色；2.其弃置除这些牌以外的牌。",
                            old_sbwansha_rewrite: "完杀·改",
                            old_sbwansha_rewrite_info: "①你的回合内，不处于濒死状态的其他角色不能使用【桃】。②一名角色进入濒死状态时，你可以观看其手牌并选择其区域内零至三张牌（其他人不可见），然后其选择一项：1.你将这些牌分配给任意名不为其的角色；2.其弃置除这些牌以外的牌。",
                            old_sbluanwu: "乱武",
                            old_sbluanwu_info: "限定技，出牌阶段，你可令所有其他角色依次选择一项：①对距离最近（或之一）的另一名其他角色使用一张【杀】；②失去1点体力。一名角色因此失去体力后，你可以修改〖完杀〗或者〖帷幕〗。",
                            old_sbweimu: "帷幕",
                            old_sbweimu_info: "锁定技。当你成为黑色锦囊牌的目标时，取消之。",
                            old_sbweimu_rewrite: "帷幕·改",
                            old_sbweimu_rewrite_info: "锁定技。①当你成为黑色锦囊牌的目标时，取消之。②每轮开始时，若你上一轮成为其他角色使用牌的目标的次数不大于2，你从弃牌堆中随机获得一张黑色锦囊牌或防具牌。",
                            old_sb_zhugejin: "旧谋诸葛瑾",
                            old_sb_zhugejin_prefix: "旧谋",
                            old_sbhuanshi: "缓释",
                            old_sbhuanshi_info: "一名角色的判定牌生效前，你可以观看牌堆顶X张牌（X为你的体力值），然后用其中一张牌或一张手牌替换之。",
                            old_sbhuanshi_tag: "牌堆顶",
                            old_sbhongyuan: "弘援",
                            old_sbhongyuan_info: "蓄力技（1/4）。你一次性获得至少两张牌时，可以消耗1点蓄力值并令至多两名角色各摸一张牌；一名其他角色一次性失去至少两张牌时，你可以消耗1点蓄力值令其摸两张牌。",
                            old_sbmingzhe: "明哲",
                            old_sbmingzhe_info: "锁定技，每轮限三次，你于回合外失去牌时，你选择一名角色：若其有蓄力技，其获得1点蓄力值；若你失去的牌中有非基本牌，其摸一张牌。",
                            old_sb_zhangliao: "旧谋张辽",
                            old_sb_zhangliao_prefix: "旧谋",
                            old_sbtuxi: "突袭",
                            old_sbtuxi_info: "你的回合限三次，当你不因此技能获得牌后，你可以将其中任意张牌置入弃牌堆，然后获得至多X名其他角色各一张手牌（X为你以此法置入弃牌堆的牌数）。",
                            old_sbdengfeng: "登锋",
                            old_sbdengfeng_info: "准备阶段，你可以选择一名其他角色并选择一项：①令其获得其装备区的至多两张牌。②你获得牌堆中的一张【杀】。③背水：你失去1点体力。",
                            old_sb_guojia: "旧谋郭嘉",
                            old_sb_guojia_prefix: "旧谋",
                            old_sbyiji: "遗计",
                            old_sbyiji_info: "当你受到伤害后，你可以摸两张牌，然后你可以将至多等量张手牌交给任意名其他角色。当你每轮首次进入濒死状态时，你可以摸两张牌，然后你可以将至多等量张牌交给任意名其他角色。",
                            old_sb_gaoshun: "旧谋高顺",
                            old_sb_gaoshun_prefix: "旧谋",
                            old_sbxianzhen: "陷阵",
                            old_sbxianzhen_info: "出牌阶段限一次。你可以选择一名其他角色，你于本阶段获得如下效果：⒈你对其使用牌无距离限制；⒉当你使用【杀】指定其为目标后，你可以与其拼点：若你赢，此【杀】无视防具且不计入次数，且若你本回合以此法对其造成的伤害小于2，你对其造成1点伤害；若其拼点牌为【杀】，则你获得之；若其拼点牌为其最后的手牌，则此【杀】对其造成伤害时，此伤害+1。",
                            old_sb_luxun: "旧谋陆逊",
                            old_sb_luxun_prefix: "旧谋",
                            old_sblianying: "连营",
                            old_sblianying_info: "其他角色的回合结束时，你可以观看牌堆顶的X张牌，然后将这些牌交给任意角色（X为你本回合失去的牌数+1，至多为5）。",
                            old_friend_xushu: "旧友徐庶",
                            old_friend_xushu_prefix: "旧友",
                            old_friendxiaxing: "侠行",
                            old_friendxiaxing_info: "游戏开始时，你获得并使用【玄剑】；当【玄剑】进入弃牌堆时，你可以移除1个“启诲”标记并获得之。",

                            oldx_clan_xuncai: "旧族荀采",
                            oldx_clan_xuncai_prefix: "旧族",
                            oldx_clanlieshi: "烈誓",
                            oldx_clanlieshi_info: "出牌阶段，你可以执行其中一项：『受到1点火焰伤害并废除判定区；弃置手牌中的所有【闪】；弃置手牌中的所有【杀】』，然后你令一名其他角色选择执行另一项（不能选择无法执行的选项）。",
                            oldx_clandianzhan: "点盏",
                            oldx_clandianzhan_info: "锁定技，当你于每轮第一次使用一种花色的牌后，你横置此牌的唯一目标并重铸手牌中所有与此牌花色相同的牌。",
                            old_clan_zhonghui: "旧族钟会",
                            old_clan_zhonghui_prefix: "旧族",
                            old_clanyuzhi: "迂志",
                            old_clanyuzhi_info: "锁定技。新的一轮开始时，你依次执行以下项：①若你上一轮使用的牌数或你上上轮因〖迂志〗摸的牌数小于你上轮因〖迂志〗摸的牌数，你失去1点体力或失去〖保族〗。②你展示一张手牌，然后摸X张牌（X为此牌牌名字数）。",
                            old_clanxieshu: "挟术",
                            old_clanxieshu_info: "当你使用牌造成伤害后，或受到来自牌造成的伤害后，你可以弃置Y张牌并摸你已损失体力值张牌（Y为此牌牌名字数）。",
                            old_clan_hanshao: "旧族韩韶",
                            old_clan_hanshao_prefix: "旧族",
                            old_fangzhen: "放赈",
                            old_fangzhen_info: "出牌阶段限一次，你可以横置一名角色，将手牌数摸至X张并交给其任意张牌，然后若本次为你第X次发动此技能，你翻面（X为其座位号）。",
                            old_liuju: "留驹",
                            old_liuju_info: "出牌阶段限一次，你可以与一名角色A拼点并使用拼点牌中的非基本牌。然后若你没赢或你与A相互之间的距离发生了变化，你复原武将牌或武将牌上的一个技能。",
                            old_clan_hanrong: "旧族韩融",
                            old_clan_hanrong_prefix: "旧族",
                            old_lianhe: "连和",
                            old_lianhe_info: "出牌阶段限一次，你可以横置两名未被横置的角色并令其同时选择一项：1，令你摸一张牌；2，令你获得其一张牌并翻面。其下个出牌阶段结束时，其重复进行上述选择，直至其本次选择的选项序号总和大于X（X为其此阶段内获得牌的总数，且至多为5）。",
                            old_huanjia: "缓颊",
                            old_huanjia_info: "出牌阶段限一次，你可以拼点，赢的男性角色下次发动“出牌阶段限一次”的技能后复原之。",
                            old_xumin: "恤民",
                            old_xumin_info: "宗族技，限定技，你可以翻面，视为对任意名手牌数小于你的角色使用一张【五谷丰登】。",
                            old_zhanghua: "旧张华",
                            old_zhanghua_prefix: "旧",
                            old_yuanji: "旧袁姬",
                            old_yuanji_prefix: "旧",
                            old_tengfanglan: "旧滕芳兰",
                            old_tengfanglan_prefix: "旧",
                            old_luochong: "落宠",
                            old_luochong_info: "准备阶段或当你受到伤害后，你可以选择一项：1、令一名角色回复1点体力；2、令一名角色失去1点体力；3、弃置至多两名角色场上各一张牌；4、摸两张牌并可以将其交给其他角色（每轮每项各限一次）。",
                            old_aichen: "哀尘",
                            old_aichen_info: "锁定技，当你进入濒死状态时，若【落宠】中剩余选项数大于1，你将体力回复至一点，执行并移去其中一项。",
                            old_dengzhong: "旧邓忠",
                            old_dengzhong_prefix: "旧",
                            old_dzkanpo: "勘破",
                            old_dzkanpo_info: "出牌阶段限X次（X为你的体力值），当你使用非装备牌指定一名角色为目标后，若该角色有手牌，你可以观看其手牌并选择一项：<br>1.弃置其一张牌，然后若弃置的牌是能造成火焰伤害的牌，你摸一张牌。<br>2.重铸其手牌中的所有【杀】和【决斗】。<br>3.若其没有【闪】，你与其互相对对方造成1点伤害。",
                            old_dzgengzhan: "更战",
                            old_dzgengzhan_info: "①每当你受到1点伤害后，你可以令一名手牌数小于体力上限的角色摸三张牌，然后其将手牌弃至其体力上限。<br>②当你进入濒死状态时，你可以令一名其他角色观看随机五张魏势力武将牌，然后该角色可以从中选择一张并替换其原武将牌（体力上限与体力值不变）。",
                            old_wangyan: "旧王衍",
                            old_wangyan_prefix: "旧",
                            old_cihuang: "雌黄",
                            old_cihuang_info: "当有牌被抵消后，若此牌的目标数为1且此牌的使用者A为当前回合角色，则你可以视为对A使用一张你本轮内未以此法使用过的任意属性的【杀】或单目标锦囊牌（无距离限制且不可被响应）。",
                            old_sanku: "三窟",
                            old_sanku_info: "锁定技，当你进入濒死状态时，你减一点体力上限并将体力回复至体力上限。",
                            old_ol_luyusheng: "旧陆郁生",
                            old_ol_luyusheng_prefix: "旧",
                            old_olcangxin: "藏心",
                            old_olcangxin_info: "锁定技。①当你受到伤害时，你观看牌堆底的三张牌并弃置其中任意张牌，若你因此弃置了红桃牌，你防止此伤害。②摸牌阶段开始时，你展示牌堆底的三张牌，然后摸X张牌(X为其中红桃牌的数量)。",
                            old_ol_hujinding: "旧胡金定",
                            old_ol_hujinding_prefix: "旧",
                            old_olchongshen: "重身",
                            old_olchongshen_info: "当你获得牌时，本轮这些牌不计入手牌上限且可以当【闪】使用。",
                            old_ol_feiyi: "旧费祎",
                            old_ol_feiyi_prefix: "旧",
                            old_hezhong: "和衷",
                            old_hezhong_info: "每回合每项限一次，当你的手牌数变为1后，你可以展示此唯一手牌A并摸一张牌，然后你选择一项：①本回合使用点数大于A的点数的普通锦囊牌额外结算一次；②本回合使用点数小于A的点数的普通锦囊牌额外结算一次。",
                            old_ol_pengyang: "旧彭羕",
                            old_ol_pengyang_prefix: "旧",
                            old_oltuishi: "侻失",
                            old_oltuishi_info: "锁定技。①你不能使用【无懈可击】。②当你使用点数为字母的牌后，你摸两张牌，且你使用的下一张牌无距离和次数限制。",
                            old_sp_sunce: "旧SP孙策",
                            old_sp_sunce_prefix: "旧SP",
                            old_ol_yufan: "旧界虞翻",
                            old_ol_yufan_prefix: "旧界",
                            old_olzongxuan: "纵玄",
                            old_olzongxuan_info: "当你或你的上家因弃置而失去牌后，你可以将位于弃牌堆的这些牌中的任意牌以任意顺序置于牌堆顶。",
                            old_olzhiyan: "直言",
                            old_olzhiyan_info: "你或你的上家的结束阶段，你可以令一名角色正面朝上摸一张牌，然后若此牌：为装备牌，则其使用此牌并回复1点体力；不为装备牌且其体力值不小于你，则其失去1点体力。",
                            old_zhugejin: "旧诸葛瑾",
                            old_zhugejin_prefix: "旧",
                            old_ruiji: "旧芮姬",
                            old_ruiji_prefix: "旧",
                            old_qiaoli: "巧力",
                            old_qiaoli_info: "出牌阶段，你可以将一张装备牌当作【决斗】使用。若此牌：为武器，此牌结算后你摸等同于其攻击范围的牌，并可以将这些牌分配给任意角色；不为武器，此【决斗】不可被响应。",
                            old_qiaoli_given: "已分配",
                            old_qingliang: "清靓",
                            old_qingliang_info: "每回合限一次，当你成为其他角色使用的基本牌或普通锦囊牌的目标时，你可以展示所有手牌，然后选择一项：1，与其各摸一张牌；2，弃置一种花色的所有手牌，令此牌对你无效。",
                            old_xurong: "旧徐荣",
                            old_xurong_prefix: "旧",
                            old_xionghuo: "凶镬",
                            old_xionghuo_info: "游戏开始时，你获得3个“暴戾”标记。出牌阶段，你可以交给一名其他角色一个“暴戾”标记。当你对有“暴戾”标记的其他角色造成伤害时，此伤害+1。有“暴戾”标记的其他角色的出牌阶段开始时，其移去所有“暴戾”标记并随机执行一项：1.受到1点火焰伤害且本回合不能对你使用【杀】；2.失去1点体力且本回合手牌上限-1；3.你随机获得其一张手牌和一张装备区里的牌。",
                            old_shajue: "杀绝",
                            old_shajue_info: "锁定技，其他角色进入濒死状态时，你获得一个“暴戾”标记。然后若其体力值小于0，你获得使其进入濒死状态的牌。",
                            old_ol_qianzhao: "旧牵招",
                            old_ol_qianzhao_prefix: "旧",
                            old_olkuansai: "款塞",
                            old_olkuansai_info: "当一张牌指定第一个目标后，若目标数大于你的体力值，你可以令其中一个目标选择一项：1.交给你一张牌；2.令你回复1点体力。",
                            old_ol_sb_dongzhuo: "旧谋董卓",
                            old_ol_sb_dongzhuo_prefix: "旧谋",
                            old_olguanbian: "观变",
                            old_olguanbian_info: "锁定技。①游戏开始时，你的手牌上限、其他角色计算与你的距离、你计算与其他角色的距离+X（X为游戏人数）。②第二轮游戏开始时，或当你发动〖凶逆〗或〖封赏〗后，你失去〖观变〗。",
                            old_olxiongni: "凶逆",
                            old_olxiongni_info: "出牌阶段开始时，你可以弃置一张牌，然后所有其他角色选择一项：1.弃置一张与此牌花色相同的牌；2.受到你的1点伤害。",
                            old_olfengshang: "封赏",
                            old_olfengshang_info: "出牌阶段限一次或当一名角色进入濒死状态时，你可以将两张本回合进入弃牌堆中的花色相同的牌分配给等量角色。若你未以此法获得牌，你视为使用一张不计入次数的【酒】。",
                            old_olzhibin: "执柄",
                            old_olzhibin_info: "主公技，锁定技。准备阶段，若其他群势力角色累计使用黑色牌的次数达到：3张，你增加1点体力上限并回复1点体力；6张，你获得〖焚城〗；9张：你获得〖崩坏〗。",
                            old_ol_nanhualaoxian: "旧南华老仙",
                            old_ol_nanhualaoxian_prefix: "旧",
                            old_olhedao: "合道",
                            old_olhedao_info: "锁定技，游戏开始时/当你首次进入濒死状态时，你至多可拥有的“天书”上限+2/+1。",
                            old_olhedao_faq: "关于天书",
                            old_olhedao_faq_info: "<br>书写“天书”时，系统先从30个“天书”时机中随机筛选出三个，角色选择时机后，系统再从30个“天书”效果中随机筛选出三个可以和选择的时机匹配的效果，然后角色获得技能为你选择的“天书”时机+“天书”效果的〖天书〗，此技能被发动前对其余玩家不可见，发动三次时失去此〖天书〗。",
                            old_olqingshu: "青书",
                            old_olqingshu_info: "锁定技，游戏开始时/准备阶段/结束阶段，你书写一册“天书”。",
                            old_olshoushu: "授术",
                            old_olshoushu_info: "出牌阶段限一次，你可以将一册未发动过的“天书”交给一名其他角色（此“天书”其仅可发动一次）。",
                            old_ol_sb_dengai: "旧谋邓艾",
                            old_ol_sb_dengai_prefix: "旧谋",
                            old_olsbjiewan: "解腕",
                            old_olsbjiewan_info: "出牌阶段限一次，你可以减1点体力上限以检索一张伤害类锦囊，然后你可令手牌中的一张伤害牌于本回合内造成的伤害+1。",
                            olsbpixian: "僻险",
                            olsbpixian_info: "锁定技，出牌阶段结束时，若你的体力值不为全场最高，你加1点体力上限或回复1点体力。",
                            old_ol_wangyi: "旧界王异",
                            old_ol_wangyi_prefix: "旧界",
                            old_olzhenlie: "贞烈",
                            old_olzhenlie_info: "当你成为其他角色使用的【杀】或非延时锦囊牌的目标后，你可以失去一点体力令此牌对你无效，然后选择一项：1，获得使用者的一张牌；2，发动一次【秘计】。",
                            // olchunlao: "醇醪",
                            // olchunlao_info: "①当你或你的上下家的【杀】因弃置进入弃牌堆后，你将位于弃牌堆的这些牌称为“醇”置于武将牌上。②一名角色处于濒死状态时，你可以将一张“醇”置入弃牌堆，然后令其视为使用一张【酒】。③当一名角色失去体力后，你可以获得至多两张“醇”。",
                            old_ol_xuelingyun: "旧薛灵芸",
                            old_ol_xuelingyun_prefix: "旧",
                            old_olsiqi: "思泣",
                            old_olsiqi_info: "你的红色牌进入弃牌堆时，将之置于牌堆底。当你受到伤害后，你可以亮出牌堆底至多五张连续的红色牌，使用其中【桃】、【无中生有】与装备牌（可指定其他角色为目标），然后你摸剩余不可使用的牌数张牌。",

                            old_re_caorui: "旧界曹叡",
                            old_re_caorui_prefix: "旧界",
                            old_re_zhangchunhua: "旧界张春华",
                            old_re_zhangchunhua_prefix: "旧界",
                            old_dc_xushu: "旧界徐庶",
                            old_dc_xushu_prefix: "旧界",
                            old_rezhuhai: "诛害",
                            old_rezhuhai_info: "其他角色的结束阶段，若其本回合造成过伤害，你可以视为对其使用一张【杀】或【过河拆桥】。",
                            old_yuechen: "旧乐綝",
                            old_yuechen_prefix: "旧",
                            old_dcporui: "破锐",
                            old_dcporui_info: "每轮限一次，其他角色的结束阶段，你可以弃置一张基本牌并选择另一名此回合内失去过牌的其他角色，你视为对该角色依次使用X+1张【杀】，然后你交给其X张手牌。（X为你的体力值，手牌不足X张则全给）",
                            old_dcgonghu: "共护",
                            old_dcgonghu_info: "锁定技，当你于回合外失去基本牌后，【破锐】最后增加描述“若其没有因此受到伤害，你回复1点体力”；当你于回合外造成或受到伤害后，你删除【破锐】中“交给”效果的描述。若以上两个效果均已触发，则你本局游戏接下来你使用红色基本牌无法响应，使用红色普通锦囊牌可以额外指定一个目标。",
                            old_ruanyu: "旧阮瑀",
                            old_ruanyu_prefix: "旧",
                            old_miaoxian: "妙弦",
                            old_miaoxian_info: "若你的手牌中仅有一张黑色牌，你可将此牌当作任意一张普通锦囊牌使用（每种牌名每回合限一次）；若你的手牌中仅有一张红色牌，你使用此牌时摸一张牌。",
                            old_bailingyun: "旧柏灵筠",
                            old_bailingyun_prefix: "旧",
                            old_dclinghui: "灵慧",
                            old_dclinghui_info: "每名角色的结束阶段，若本回合有至少两名角色受到过伤害，你可以观看的牌堆顶的三张牌：你可以使用其中一张牌，然后获得其余的牌。",
                            oldx_dclinghui: "灵慧",
                            oldx_dclinghui_info: "一名角色的结束阶段，若当前回合角色为你或本回合有角色进入过濒死状态，则你可以观看牌堆顶的三张牌并使用其中一张牌，然后获得剩余的牌。",
                            old_dcyuxin: "御心",
                            old_dcyuxin_info: "限定技，一名角色进入濒死状态时，你可以令其回复体力至1点。若以此法回复体力的是其他角色，你与其体力值互换且你摸等同于你以此法失去的体力值张牌。",
                            old_dc_liuli: "旧刘理",
                            old_dc_liuli_prefix: "旧",
                            old_dcfuli: "抚黎",
                            old_dcfuli_info: "出牌阶段，你可以展示手牌并弃置一种类别的所有手牌（每种类别每回合限一次），然后摸X张牌（X为这些牌的牌名字数和且X至多为场上手牌数最多的角色的手牌数）。若你因此弃置了伤害类卡牌，则你可以选择一名角色，令其攻击范围-1直到你的下个回合开始。",
                            old_dcdehua: "德化",
                            old_dcdehua_info: "锁定技。①一轮游戏开始时，若有你可以使用的非延时类伤害类牌的牌名，你选择其中一个并视为使用之，然后你不能从手牌中使用此牌名的牌，然后若你已选择过所有的伤害类牌牌名，你失去〖德化〗。②你的手牌上限+Y（Y为你〖德化①〗选择过的牌名数）。",
                            old_yue_miheng: "旧乐祢衡",
                            old_yue_miheng_prefix: "旧乐",
                            old_dcjigu: "激鼓",
                            old_dcjigu_info: "锁定技。①游戏开始时，你将所有手牌标记为“激鼓”。②你的“激鼓”牌不计入手牌上限。③当你造成或受到伤害后，若你的“激鼓”牌数等于你的装备区牌数，则你可以摸X张牌（X为你的空置装备栏数）。",
                            old_wu_zhugeliang: "旧武诸葛亮",
                            old_wu_zhugeliang_prefix: "旧武",
                            old_dcqingshi: "情势",
                            old_dcqingshi_info: "当你于出牌阶段使用牌时，若你手牌中有同名牌，你可以选择一项：1.令此牌对其中一个目标角色造成的伤害+1；2.令任意名其他角色各摸一张牌；3.摸X张牌，然后【情势】于本回合失效（X为你的体力值）。",
                            old_dczhizhe: "智哲",
                            old_dczhizhe_clear: "invisible",
                            old_dczhizhe_info: "限定技。出牌阶段，你可以选择一张手牌并复制之。该复制牌不计入你的手牌上限，且当你使用或打出此牌结算结束后，你获得之，然后你本回合不能再使用或打出此牌。",
                            old_wu_guanyu: "旧武关羽",
                            old_wu_guanyu_prefix: "旧武",
                            old_dcjuewu: "绝武",
                            old_dcjuewu_info: "①你可以将一张点数为2的牌当任意伤害类牌使用（包括【水淹七军】）。②当你得到其他角色区域内的牌后，你令这些牌的点数均视为2直到你失去这些牌。",
                            old_dcwuyou: "灵显",
                            old_dcwuyou_info: "其他角色的出牌阶段限一次，其可以交给你一张手牌，然后你可以声明一个非装备牌的牌名（包括【水淹七军】）并交给其一张手牌，令此牌的牌名与属性视为与你选择的相同。",
                            old_dcyixian: "义贤",
                            old_dcyixian_info: "限定技。出牌阶段，你可以获得场上和其他角色手牌中的所有武器和防具牌。然后你依次选择是否令被你以此法获得牌的角色摸X张牌或回复1点体力（X为其以此法失去的牌数）。",
                            old_wu_huangfusong: "旧武皇甫嵩",
                            old_wu_huangfusong_prefix: "旧武",
                            old_dcchaozhen: "朝镇",
                            old_dcchaozhen_info: "准备阶段或当你进入濒死状态时，你可以获得牌堆里或场上点数最小的牌，若此牌点数为A，你回复1点体力并令〖朝镇〗本回合失效。",
                            old_dclianjie: "连捷",
                            old_dclianjie_info: "你使用手牌指定目标后，若此牌点数不大于你的所有手牌，你可令一名角色将其一张点数最小的手牌置于牌堆底，然后你将手牌摸至体力上限，以此法获得的牌本回合无距离次数限制（每个点数每回合限摸一次，无点数视为0）。",
                            old_dcjiangxian: "将贤",
                            old_dcjiangxian_info: "限定技，出牌阶段，你可以获得以下效果直到本回合结束：当你使用因〖连捷〗获得的牌造成伤害时，此伤害+X（X为你本回合造成伤害的次数且至多为5）。若如此做，本回合结束后你失去〖连捷〗或〖朝镇〗。",
                            old_dc_shen_huatuo: "旧神华佗",
                            old_dc_shen_huatuo_prefix: "旧神",
                            old_jingyu: "静域",
                            old_jingyu_info: "锁定技。每个技能每回合限一次，当一名角色发动不为【静域】的技能时，你摸一张牌。",
                            old_xunyuxunyou: "旧荀彧荀攸",
                            old_xunyuxunyou_prefix: "旧",
                            old_zhinang: "智囊",
                            old_zhinang_info: "当你使用锦囊牌后，你可以获得一个技能台词包含“谋”的技能；当你使用装备牌后，你可以获得一个技能名包含“谋”的技能。",
                            old_gouzhu: "苟渚",
                            old_gouzhu_info: "你发动技能后，若此技能为：锁定技，回复1点体力；觉醒技，获得一张基本牌；限定技，对随机一名其他角色造成1点伤害；转换技，手牌上限+1；主公技，增加1点体力上限。",
                            old_zhugejing: "旧诸葛京",
                            old_zhugejing_prefix: "旧",
                            old_dcpijian: "辟剑",
                            old_dcpijian_info: "锁定技，结束阶段，若你的“研作”牌数不小于存活人数，你可以弃置这些牌，对一名角色造成2点伤害。",
                            old_xin_zhonghui: "旧界钟会",
                            old_xin_zhonghui_prefix: "旧界",
                            old_xinquanji: "权计",
                            old_xinquanji_info: "①当你受到1点伤害后，或其他角色不因你的赠予而得到你的牌后，你可以摸一张牌，然后将一张手牌置于武将牌上，称为“权”。②你的手牌上限+X（X为“权”的数量）。",
                            old_xinzili: "自立",
                            old_xinzili_info: "觉醒技。准备阶段，若你的“权”数大于2，则你回复1点体力并摸两张牌，减1点体力上限并获得〖排异〗。",
                            old_xinpaiyi: "排异",
                            old_xinpaiyi_backup: "排异",
                            old_xinpaiyi_info: "出牌阶段每项各限一次，你可移去一张“权”并选择一项：①令一名角色摸X张牌。②对至多X名角色各造成1点伤害。（X为“权”数）",
                            old_yj_majun: "旧马钧",
                            old_yj_majun_prefix: "旧",
                            old_jingyi: "精益",
                            old_jingyi_info: "锁定技。当有实体牌进入你的装备区后，你摸X张牌，然后弃置两张牌（X为你装备区内实体牌的数量）。",
                            old_star_fazheng: "旧星法正",
                            old_star_fazheng_prefix: "旧星",
                            old_staranji: "谙计",
                            old_staranji_info: "锁定技，一名角色使用牌时，若此花色的牌本轮游戏使用的最少，则你摸一张牌。",
                            old_pangfengyi: "旧庞凤衣",
                            old_pangfengyi_prefix: "旧",
                            old_dcyitong: "异瞳",
                            old_dcyitong_info: "锁定技。①游戏开始时，你记录一个花色。②每回合〖异瞳〗记录花色的牌首次进入弃牌堆后，你从牌堆或弃牌堆获得与此花色不同的牌各一张。",
                            old_dcpeiniang: "醅酿",
                            old_dcpeiniang_info: "①你可以将〖异瞳〗记录花色的牌当作【酒】使用（无任何次数限制）。②其他角色处于濒死状态时，你可以对其使用【酒】（回复效果）。③因你使用【酒】执行的体力回复效果至少令目标角色将体力值回复至1点。",
                            old_v_sunquan: "旧威孙权",
                            old_v_sunquan_prefix: "旧威",
                            old_dcwoheng: "斡衡",
                            old_dcwoheng_info: "出牌阶段或当你受到伤害后，你可令一名角色摸或弃置X张牌，选择其他角色结算后其手牌数与你不同或选择自己时，此技能失效至本回合结束(X为此技能本轮发动的次数)。",
                            old_dcjizheng: "集征",
                            old_dcjizheng_info: "威主技，其他吴势力角色出牌阶段限一次，其可交给你一张牌，则其本回合使用牌无距离限制。其他角色出牌阶段限一次，其可交给你一张牌，则其本回合使用的下张牌无距离限制。",

                            old_tw_huojun: "旧TW霍峻",
                            old_tw_huojun_ab: "旧霍峻",
                            old_tw_huojun_prefix: "旧",
                            old_twjieyu: "竭御",
                            old_twjieyu_info: "结束阶段开始时，或当你于一轮内第一次受到伤害后，你可以弃置所有手牌，然后从弃牌堆中获得不同牌名的基本牌各一张。",
                            old_tw_guohuai: "旧TW界郭淮",
                            old_tw_guohuai_ab: "旧界郭淮",
                            old_tw_guohuai_prefix: "旧界",
                            old_twjingce: "精策",
                            old_twjingce_info: "当你于出牌阶段使用第X张牌时，你可以摸X张牌（X为你的体力值）。若此阶段你此前摸过牌或本回合造成过伤害，你获得一枚“策”标记。",
                            old_yuzhang: "御嶂",
                            old_yuzhang_info: "你可以弃置一枚“策”标记，然后跳过一个阶段。当你受到伤害后，你可弃置一枚“策”标记，然后选择一项：⒈令伤害来源弃置X张牌（X为其体力值）；⒉令伤害来源本回合不能再使用或打出牌。",
                            oldx_quancong: "旧全琮",
                            oldx_quancong_prefix: "旧",
                            old_zhenshan: "振赡",
                            old_zhenshan_info: "当你需要使用或打出一张基本牌时，你可以与一名手牌数少于你的角色交换手牌，视为使用或打出此牌。",
                            old_tw_baoxin: "旧TW鲍信",
                            old_tw_baoxin_ab: "旧鲍信",
                            old_tw_baoxin_prefix: "旧",
                            old_twmutao: "募讨",
                            old_twmutao_info: "出牌阶段限一次。你可以选择一名角色，令其将手牌中所有的【杀】依次交给其下家开始除你外的每一名角色。然后其对最后一名以此法获得【杀】的角色A造成X点伤害（X为A手牌中【杀】的数量且至多为3）。",
                            old_tw_zhangmancheng: "旧TW张曼成",
                            old_tw_zhangmancheng_ab: "旧张曼成",
                            old_tw_zhangmancheng_prefix: "旧",
                            old_twbudao: "布道",
                            old_twbudao_info: "限定技。准备阶段，你可减1点体力上限，回复1点体力并从【咒护】【丰祈】【阻祸】中选择一个技能获得。然后你可以令一名其他角色也获得此技能并交给你一张牌。",
                            old_tw_guanqiujian: "旧TW毌丘俭",
                            old_tw_guanqiujian_ab: "旧毌丘俭",
                            old_tw_guanqiujian_prefix: "旧",
                            old_tw_niufudongxie: "旧牛辅董翓",
                            old_tw_niufudongxie_prefix: "旧",
                            old_twjuntun: "军屯",
                            old_twjuntun_info: "①游戏开始时或当其他角色濒死状态结算完成后，你可令一名角色获得【凶军】。②当其他角色造成伤害后，若其拥有【凶军】，你获得等同于此次伤害值的暴虐值。",
                            old_twxiongxi: "凶袭",
                            old_twxiongxi_info: "每回合每名角色限一次，出牌阶段，你可以弃置X张牌对一名其他角色造成1点伤害（X为你的暴虐值与暴虐值上限之差）。",
                            old_twxiongjun: "凶军",
                            old_twxiongjun_info: "锁定技，当你造成伤害后，所有拥有【凶军】的角色摸一张牌。",
                            old_xia_tongyuan: "旧侠童渊",
                            old_xia_tongyuan_prefix: "旧侠",
                            old_twchuanshu: "传术",
                            old_twchuanshu_info: "准备阶段，你可以选择一名角色。直到你的下回合开始，其获得以下效果：1.当其拼点牌亮出时，此牌点数+3；2.其使用的下一张【杀】对除你外的角色造成伤害时，此伤害+1；3.若其不为你，其使用的下一张【杀】结算结束后，你摸等同于其因此【杀】造成的伤害值数的牌。",
                            old_xia_guanyu: "旧侠关羽",
                            old_xia_guanyu_prefix: "旧侠",
                            old_twzhongyi: "忠义",
                            old_twzhongyi_info: "锁定技。①你使用【杀】无距离限制。②当你使用【杀】结算完毕后，你选择一项：⒈摸X张牌；⒉回复X点体力；⒊背水：失去Y点体力，依次执行以上两项（X为此牌造成的伤害值，Y为你本局游戏此前选择此项的次数+1）。",
                            old_twchue: "除恶",
                            old_twchue_info: "①当你使用【杀】指定唯一目标时，若场上存在可成为此【杀】目标的非目标角色，则你可以失去1点体力，为此牌额外指定Z个目标。②当你受到伤害或失去体力后，你摸一张牌并获得1个“勇”标记。③回合结束时，若你的“勇”标记数大于等于Z，则你可以失去Z个“勇”标记，视为使用一张伤害+1且可以额外指定Z个目标的【杀】。（Z为你的体力值）",
                            old_huan_zhugeliang: "旧幻诸葛亮",
                            old_huan_zhugeliang_prefix: "旧幻",
                            old_twhunyou: "魂游",
                            old_twhunyou_info: "限定技，当你处于濒死状态时，你可以将体力值回复至1点，若如此做，本回合当你受到伤害时或失去体力时，取消之；当前回合结束后，你入幻：摸X张牌并进行一个额外的回合（X为〖北定〗记录牌名数，且至多为7）。",
                            old_twchanggui: "怅归",
                            old_twchanggui_info: "锁定技，结束阶段，若你的体力值为全场最低且不等于体力上限，你须退幻：将体力上限调整为当前体力值。",

                            old_huan_caoang: "旧幻曹昂",
                            old_huan_caoang_prefix: "旧幻",
                            old_twchihui: "炽灰",
                            old_twchihui_info: "其他角色的回合开始时，你可废除一个装备栏并选择一项:1.弃置其区域内的一张牌；2.將牌堆中的一张与此次废除的装备栏相同副类别的装备牌置入其装备区。若如此做，你失去1点体力，然后摸X张牌（X为你已损失的体力值）。",
                            old_twfuxi: "赴曦",
                            old_twfuxi_info: "持恒技。当你进入濒死状态时或装备栏均废除后，你可选择依次执行一至两项:1.当前回合结束时，你执行一个额外的回合；2. 保留〖炽灰〗直到下次退幻；3.将手牌数摸至体力上限（至多摸至五张）；4.若你的装备栏均废除，恢复所有装备栏。然后你入幻：将体力值回复至体力上限。",
                            old_twhuangzhu: "煌烛",
                            old_twhuangzhu_info: "准备阶段，你可选择一个废除的装备栏， 从牌堆或弃牌堆中随机获得一张对应副类别的装备牌，并记录其牌名。出牌阶段开始时，你可选择或变更至多两个已记录且与已废除的装备栏相同副类别的装备牌牌名（每种副类别限一个）。你视为拥有选择的牌名的效果直到此装备栏恢复。",
                            old_twliyuan: "离渊",
                            old_twliyuan_info: "你可将一张与你已废除的装备栏对应副类别的装备牌当【杀】使用或打出（无距离和次数限制），然后你摸两张牌。",
                            twjifa: "冀筏",
                            twjifa_info: "锁定技，当你进入濒死状态时，你减X点体力上限（X为你上次发动〖赴曦〗选择的项数），保留〖煌烛〗或〖离渊〗直到下次入幻， 然后退幻：将体力值回复至体力上限。",

                            old_huan_weiyan: "旧幻魏延",
                            old_huan_weiyan_prefix: "旧幻",
                            old_twpiankuang: "偏狂",
                            old_twpiankuang_info: "锁定技，你使用的牌造成的伤害+Y（Y为你本回合使用过的且造成过伤害的相同牌名的牌的数量，且至多为3）。",
                            old_huan_zhugeguo: "旧幻诸葛果",
                            old_huan_zhugeguo_prefix: "旧幻",
                            old_rexianyuan: "仙援",
                            old_rexianyuan_info: "①一轮游戏开始时，你获得4枚“仙援”标记（一名角色至多拥有4枚“仙援”标记）。②出牌阶段，你可以将“仙援”标记分配给其他角色。③拥有“仙援”标记的角色的出牌阶段开始时，你选择一项：⒈观看其手牌，将其中至多X张牌置于牌堆顶；⒉令其摸X张牌（X为其拥有的“仙援”标记数）。然后若当前回合角色不为你，则移去其所有“仙援”标记。",
                            old_tw_shen_lvmeng: "旧TW神吕蒙",
                            old_tw_shen_lvmeng_ab: "旧神吕蒙",
                            old_tw_shen_lvmeng_prefix: "旧神",
                            old_twshelie: "涉猎",
                            old_twshelie_info: "①摸牌阶段，你可放弃摸牌并亮出牌堆顶的五张牌，然后选择获得其中每种花色的牌各一张。②每轮限一次。结束阶段，若你本回合使用的花色数不小于你的体力值，你执行一个额外的摸牌阶段或出牌阶段。",
                            old_twgongxin: "攻心",
                            old_twgongxin_info: "出牌阶段限一次。你可以观看一名其他角色的手牌，然后你可以展示其中一张牌并选择一项：1.弃置此牌；2.将此牌置于牌堆顶。若该角色手牌中的花色数因此减少，你选择一种颜色，其于本回合不能使用或打出该颜色的牌。",

                            old_gaowang: "旧高望",
                            old_gaowang_prefix: "旧",
                            old_zhangren: "旧张任",
                            old_zhangren_prefix: "旧",

                        },
                    }
                },
            },
            addFcuntion: {
                jilueSkSr(jlsgpack, loadAfter) {
                    if (lib.config['extension_极略_enable'] || window.suiSet && window.suiSet.jlsksrPackAfter) return
                    window.jlsg = {
                        debug: {
                            logCurrentRanks() {
                                var logC = function (name) {
                                    console.log(`${name} ${get.translation(name)} ${get.rank(name)}`);
                                };
                                Array.from(document.getElementsByClassName('character')).filter(
                                    c => c.link
                                ).forEach(
                                    c => logC(c.link)
                                );
                                if (!game.players || !game.players.forEach) return;
                                game.players.forEach(
                                    p => {
                                        if (p.name1) logC(p.name1);
                                        if (p.name2) logC(p.name2);
                                    }
                                )
                            },
                            debugProperty(obj, name, get = true, set = true) {
                                if (name in obj) {
                                    console.log(name, 'found in', obj);
                                    obj['__' + name + '__'] = obj[name];
                                    delete obj[name];
                                } else {
                                    console.log(name, 'not found in', obj);
                                }
                                Object.defineProperty(obj, name, {
                                    get() {
                                        debugger;
                                        return this['__' + name + '__'];
                                    },
                                    set(value) {
                                        debugger;
                                        return (this['__' + name + '__'] = value);
                                    },
                                })
                            },
                        },
                        relu(num) {
                            return num >= 0 ? num : 0;
                        },
                        get characterList() {
                            let result;
                            if (_status.characterlist) {
                                result = _status.characterlist;
                            }
                            else if (_status.connectMode) {
                                result = get.charactersOL(() => { });
                            }
                            else {
                                result = get.gainableCharacters(() => { });
                            }
                            delete this.characterList;
                            this.characterList = result;
                            return result;
                        },
                        /**
                         * 
                         * @param {Array<Number>} dist 
                         * @returns {Number}
                         */
                        distributionGet(dist) {
                            var res = Math.random();
                            let sum = dist.reduce((a, b) => a + b);
                            console.assert(sum > 0, `utils.distributionGet received param ${JSON.stringify(dist)}`);
                            dist = dist.map(v => v / sum);
                            for (let i = 0; ;) {
                                if (res < dist[i]) return i;
                                res -= dist[i];
                                ++i;
                            }
                        },
                        showRepo() {
                            var mirrorURL = lib.extensionPack["极略"] && lib.extensionPack["极略"].mirrorURL;
                            if (!mirrorURL) return;
                            this.openLink(mirrorURL);
                        },
                        openLink(url) {
                            if (window.cordova) {
                                if (cordova.InAppBrowser) {
                                    return cordova.InAppBrowser.open(url, '_system');
                                }
                                return;
                            }
                            if (window.require) {
                                return require('electron').shell.openExternal(url);
                            }
                            return window.open(url);
                        },
                        checkUpdate(refNode) {
                            if (!('noModule' in HTMLScriptElement.prototype)) {
                                alert("游戏运行时/系统webview过老无法自动更新");
                                return;
                            }
                            import('./modules/idb-keyval.js')
                            var version = lib.extensionPack['极略'].version;
                            refNode.insertAdjacentHTML('afterend',
                                `<div>当前版本${version}<br>正在获取最新版本号</div>`
                            );
                            var cNode = refNode.nextSibling;
                            var responsePromise = fetch("https://api.github.com/repos/xiaoas/jilue/releases/latest", {
                                "headers": {
                                    "accept": "application/vnd.github.v3+json",
                                    "accept-language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7",
                                    "cache-control": "no-cache",
                                    "pragma": "no-cache"
                                },
                                "method": "GET",
                            });
                            // TODO: only update to version with same major version
                            let successHandler = (response) => {
                                if (response.status >= 300) {
                                    cNode.innerHTML += ` 失败<br>${response.status} ${response.statusText}`;
                                    return Promise.reject(response);
                                } else {
                                    cNode.innerHTML += ' 成功';
                                    return response;
                                }
                            }
                            let errorHandler = (error) => {
                                cNode.innerHTML += ` 失败<br>${error}`;
                                console.log(error);
                                return Promise.reject(error);
                            };
                            responsePromise.then(successHandler, errorHandler)
                                .then(response => response.json())
                                .then(data => {
                                    var latestVersion = data.tag_name;
                                    if (latestVersion.startsWith('v')) {
                                        latestVersion = latestVersion.slice(1)
                                    }
                                    if (latestVersion > version) {
                                        refNode.innerHTML = `更新至 ${latestVersion}<br>`;
                                        window.jlsg.updateData = data;
                                        var newFunc = `jlsg.updateGuard(this)`;
                                        refNode.setAttribute("onClick", newFunc);
                                    } else {
                                        refNode.innerHTML = `当前已经是最新版<br>`;
                                    }
                                })
                        },
                        async updateGuard(refNode) {
                            if (!this.update) {
                                return;
                            }
                            if (!this.update.guard) {
                                this.update.guard = true;
                                await this.update(refNode);
                                this.update.guard = false;
                            }
                        },
                        async update(refNode) {
                            // TODO
                            var latestTag = window.jlsg.updateData.tag_name;
                            var currentTag = 'v' + lib.extensionPack['极略'].version;
                            var response = await fetch("https://api.github.com/repos/xiaoas/jilue/tags", {
                                "headers": {
                                    "accept": "application/vnd.github.v3+json",
                                    "accept-language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7",
                                },
                                "method": "GET",
                            });
                            var tags = await response.json()
                            tags = tags.map(t => t.name)
                            if (!tags.includes(currentTag)) {
                                if (tags.every(t => t > currentTag)) {
                                    refNode.insertAdjacentHTML('afterend',
                                        `<div>没有找到适用当前版本的更新讯息${currentTag}</div>`
                                    );
                                }
                                currentTag = tags.filter(t => t < currentTag).reduce((a, b) => a < b ? b : a);
                            }
                            // var compareURI = `https://api.github.com/repos/xiaoas/jilue/compare/v2.1.0208...v2.2.0631`
                            var compareURI = `https://api.github.com/repos/xiaoas/jilue/compare/${currentTag}...${latestTag}`
                            var cNode, data;
                            try {
                                refNode.insertAdjacentHTML('afterend',
                                    `<div>获取文件列表</div>`
                                ); cNode = refNode.nextSibling;
                                let response = await fetch(compareURI, {
                                    "headers": {
                                        "accept": "application/vnd.github.v3+json",
                                        "accept-language": "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7",
                                    },
                                    "method": "GET",
                                });
                                data = await response.json();
                                cNode.innerHTML += ' 成功';
                            } catch (e) {
                                console.log(e);
                                cNode.innerHTML += ' 失败';
                                return
                            }
                            var files = data.files;
                            game.saveExtensionConfig('极略', 'pendingFiles', JSON.stringify(files))
                            var idbKeyval;
                            try {
                                idbKeyval = await import('./modules/idb-keyval.js')
                            }
                            catch (e) {
                                idbKeyval = await import('https://cdn.jsdelivr.net/npm/idb-keyval@5/+esm')
                            }
                            var required = files.filter(f => ['added', 'modified'].includes(f.status))
                            var blobs = await idbKeyval.getMany(required.map(f => f.sha))
                            // var downloads = required.map((f,i) => blobs[i] || fetch(f.raw_url))
                            var myMap = new Map()
                            var waitBuffer = []
                            // for (let f of required) {
                            //   if (f.raw_url.includes("raw.githubusercontent.com")) {
                            //     f.raw_url.replace("raw.githubusercontent.com", "raw.fastgit.org")
                            //   }
                            // }
                            const maxConcurrent = 5, maxRetry = 3;
                            for (let [i, f] of required.entries()) {
                                if (!blobs[i]) {
                                    if (myMap.size < maxConcurrent) {
                                        myMap.set(fetch(f.raw_url), f)
                                    } else {
                                        waitBuffer.push(f)
                                    }
                                }
                            }
                            // required.forEach((f, i) => blobs[i] || myMap.set(fetch(f.raw_url), f))
                            refNode.insertAdjacentHTML('afterend',
                                `<div>正在下载<span>0</span>/${required.length}请耐心等待</div><br>`
                            ); cNode = refNode.nextSibling;
                            var [valNode] = cNode.getElementsByTagName('span')
                            var finishedCnt = {
                                _v: null,
                                get v() {
                                    return this._v;
                                },
                                set v(_v) {
                                    this._v = _v;
                                    valNode.innerHTML = _v.toString();
                                },
                            };
                            var downloadError = 0
                            finishedCnt.v = required.length - myMap.size - waitBuffer.length
                            while (myMap.size) {
                                let [completed] = await Promise.any(Array.from(myMap.keys()).map(p => p.then(res => [p], res => [p])))
                                let f = myMap.get(completed)
                                myMap.delete(completed)
                                try {
                                    let value = await completed;
                                    // value = await value.blob()
                                    // save as arrayBuffer
                                    value = await value.arrayBuffer()
                                    ++finishedCnt.v;
                                    idbKeyval.set(f.sha, value)
                                    console.log(`${f.filename} downloaded and stored.`)
                                } catch (e) {
                                    // console.log(f, e)
                                    f.retry = f.retry || 0;
                                    ++f.retry;
                                    console.log(`${f.filename} download No.${f.retry} failed`)
                                    if (f.retry >= maxRetry) {
                                        ++downloadError;
                                    } else {
                                        let nextURL = f.raw_url
                                        nextURL = nextURL.replace('github.com', 'hub.fastgit.org')
                                        myMap.set(fetch(nextURL), f)
                                    }
                                } finally {
                                    if (myMap.size < maxConcurrent && waitBuffer.length) {
                                        let f = waitBuffer.pop()
                                        myMap.set(fetch(f.raw_url), f)
                                    }
                                }
                            }
                            if (downloadError != 0) {
                                cNode.innerHTML += `失败${downloadError} 下次运气会更好`
                                return;
                            }
                            // actually array Buffers
                            blobs = await idbKeyval.getMany(required.map(f => f.sha))
                            if (blobs.some(b => !b)) {
                                cNode.innerHTML += ' 失败<br> Error blob not found';
                                return;
                            }
                            let blobMap = new Map(required.map((f, i) => [f.sha, blobs[i]]))
                            if (!game.download) {
                                throw "Not implemented";
                            }
                            cNode.innerHTML += ' 成功<br>请酌情等待五秒后再重启不是不可以探测安装完了但是我太懒了';
                            console.log('writing files');
                            if (lib.node && lib.node.fs) {
                                let prefix = __dirname + '/extension/极略/'
                                for (let [i, f] of files.entries()) {
                                    switch (f.status) {
                                        case 'added':
                                        case 'modified':
                                            let blob = blobMap.get(f.sha)
                                            lib.node.fs.writeFile(prefix + f.filename, Buffer.from(blob), e => e && console.log(f, e))
                                            break;
                                        case 'removed':
                                            lib.node.fs.rm(prefix + f.filename, e => e && console.log(f, e))
                                            break;
                                        case 'renamed':
                                            lib.node.fs.rename(prefix + f.previous_filename, prefix + f.filename, e => e && console.log(f, e))
                                            break;
                                        default:
                                            console.log(f)
                                            break;
                                    }
                                }
                            } else {
                                window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
                                    entry.getDirectory('extension/极略/', {}, function (dirEntry) {
                                        for (let [i, f] of files.entries()) {
                                            switch (f.status) {
                                                case 'added':
                                                case 'modified':
                                                    let blob = blobMap.get(f.sha)
                                                    dirEntry.getFile(f.filename, { create: true }, function (fileEntry) {
                                                        fileEntry.createWriter(function (fileWriter) {
                                                            fileWriter.write(blob);
                                                        });
                                                    });
                                                    break;
                                                case 'removed':
                                                    dirEntry.getFile(f.filename, function (fileEntry) {
                                                        fileEntry.remove();
                                                    });
                                                    break;
                                                case 'renamed':
                                                    dirEntry.getFile(f.previous_filename, function (fileEntry) {
                                                        fileEntry.moveTo(dirEntry, f.filename);
                                                    });
                                                    break;
                                                default:
                                                    console.log(f)
                                                    break;
                                            }
                                        }
                                    });
                                });
                            }
                            idbKeyval.clear()
                        },
                        showRepoElement(refElement) {
                            let potentialRepo = refElement.nextElementSibling;
                            if (potentialRepo && potentialRepo.id == "repo-link") {
                                potentialRepo.remove();
                            } else {
                                refElement.insertAdjacentHTML('afterend', `<a id="repo-link" onclick="lib.jlsg.showRepo()" style="cursor: pointer;text-decoration: underline;display:block">Visit Repository</a>`);
                                // refElement.nextElementSibling.scrollIntoView({
                                //   behavior: 'smooth',
                                //   block: 'nearest',
                                // });
                            }
                        },
                        getLoseHpEffect(player) {
                            var loseHpEffect = -3;
                            if (player.hp == 1) loseHpEffect *= 2.5;
                            if (player.hp == 2) loseHpEffect *= 1.8;
                            if (player.hp == 4) loseHpEffect *= 0.9;
                            if (player.hp == 5) loseHpEffect *= 0.8;
                            if (player.hp > 5) loseHpEffect *= 0.6;
                            if (player.hasSkillTag('maihp')) loseHpEffect += 3;
                            return loseHpEffect;
                        },
                        ai: {
                            skill: {
                                lose_equip: 'xiaoji|xuanfeng',
                                need_kongcheng: 'shangshix|shangshi|jlsg_ruya|jlsg_qicai|lianying|relianying|kongcheng|sijian|hengzheng',
                                rejudge: 'guicai|jlsg_guicai|guidao|jilve|nos_zhenlie|huanshi|midao',
                                save: 'jlsg_guagu|jlsg_fangxin|jlsg_renxin|jijiu|buyi|chunlao|longhun|jlsg_longhun',
                                need_card: 'jlsg_youdi|jlsg_rende|jlsg_liuyun|jlsg_yansha|jlsg_huiqu|jlsg_zhaoxiang|kanpo|guicai|jlsg_guicai|guidao|beige|xiaoguo|liuli|tianxiang|jijiu|leiji|releiji|qingjian|zhuhai|qinxue|danqi',
                                recover: 'jlsg_liuyun|jlsg_zhishi|rerende|rende|kuanggu|zaiqi|jieyin|qingnang|yinghun|hunzi|shenzhi|longhun|zishou|ganlu|xueji|shangshi|chengxiang|buqu|quji',
                                use_lion: 'longhun|duanliang|qixi|guidao|relijian|lijian|xinjujian|jujian|zhiheng|mingce|yongsi|fenxun|gongqi|yinling|jilve|qingcheng',
                                need_equip: 'shensu|mingce|jujian|jlsg_liuyun|beige|yuanhu|huyuan|gongqi|gongji|yanzheng|qingcheng|longhun|shuijian|yinbing',
                                straight_damage: 'jlsg_chouxi|jlsg_zhishi|qiangxi|duwu|danshou',
                                double_sha: 'paoxiao|fuhun|tianyi|xianzhen|zhaxiang|lihuo|jiangchi|shuangxiong|qiangwu|luanji',
                                need_maxhp: 'jlsg_ruya|yingzi|zaiqi|yinghun|hunzi|juejing|ganlu|zishou|miji|chizhong|xueji|quji|xuehen|jushou|tannang|fangzhu|shangshi|miji',
                                bad_skills: 'benghuai|jlsg_wumou|shiyong|jlsg_shiyong|yaowu|chanyuan|chouhai',
                                break_sha: 'jlsg_zhaoxiang|jlsg_yansha',
                                maixie_skill: 'guixin|yiji|fankui|jieming|xuehen|neoganglie|ganglie|vsganglie|enyuan|fangzhu|nosenyuan|langgu|quanji|zhiyu|renjie|tanlan|tongxin|huashen|duodao|chengxiang|benyu',
                            }
                        },
                        sort: {
                            hp: function (a, b) {
                                var c1 = a.hp;
                                var c2 = b.hp;
                                if (c1 == c2) {
                                    return jlsg.sort.threat(a, b);
                                }
                                return c1 > c2;
                            },
                            handcard: function (a, b) {
                                var c1 = a.num('h');
                                var c2 = b.num('h');
                                if (c1 == c2) {
                                    return jlsg.sort.defense(a, b);
                                }
                                return c1 < c2;
                            },
                            value: function (a, b) {
                                return jlsg.getValue(a) < jlsg.getValue(b);
                            },
                            chaofeng: function (a, b) {
                                return jlsg.getDefense(a) > jlsg.getDefense(b);
                            },
                            defense: function (a, b) {
                                return jlsg.getDefenseSha(a) < jlsg.getDefenseSha(b);
                            },
                            threat: function (a, b) {
                                var d1 = a.num('h');
                                for (var i = 0; i < game.players.length; i++) {
                                    if (a.canUse('sha', game.players[i]) && a != game.players[i]) {
                                        d1 = d1 + 10 / (jlsg.getDefense(game.players[i]))
                                    }
                                }
                                var d2 = b.num('h');
                                for (var i = 0; i < game.players.length; i++) {
                                    if (b.canUse('sha', game.players[i]) && b != game.players[i]) {
                                        d2 = d2 + 10 / (jlsg.getDefense(game.players[i]))
                                    }
                                }
                                return d1 > d2;
                            }
                        },
                        isKongcheng: function (player) {
                            return player.countCards('h') == 0;
                        },
                        needKongcheng: function (player, keep) {
                            if (keep) {
                                return jlsg.isKongcheng(player) && (player.hasSkill('kongcheng') || (player.hasSkill('zhiji') && !player.storage.zhiji));
                            }
                            if (!jlsg.hasLoseHandcardEffective(player) && !jlsg.isKongcheng(player)) return true;
                            if (player.hasSkill('zhiji') && !player.storage.zhiji) return true;
                            return player.hasSkills(jlsg.ai.skill.need_kongcheng);
                        },
                        hasBaguaEffect: function (player) {
                            if (player.countCards('e', 'bagua')) return true;
                            if (player.hasSkill('bazhen') && !player.get('e', '2')) return true;
                            if (player.hasSkill('linglong') && !player.get('e', '2')) return true;
                            return false;
                        },
                        hasBuquEffect: function (player) {
                            if (player.hasSkill('buqu')) {
                                if (player.storage.buqu == undefined) return true;
                                if (player.storage.buqu && player.storage.buqu.length <= 4) return true;
                                return false;
                            }
                            return false;
                        },
                        hasZhuqueEffect: function (player) {
                            var cards = player.get('h');
                            for (var i = 0; i < cards.length; i++) {
                                if (cards[i].name == 'sha' && cards[i].nature == 'fire') return true;
                                if (player.countCards('e', 'zhuque') && cards[i].name == 'sha' && !cards[i].nature) return true;
                            }
                            return false;
                        },
                        hasJiuEffect: function (player) {
                            if (player.hasSkills('jiu|boss_zuijiu|luoyi2|reluoyi2|jie|nuzhan2|anjian|jlsg_huxiao|jlsg_jiwu_buff1|jlsg_wenjiu3')) return true;
                            if (player.hasSkills('jlsg_ganglie_damage|jlsg_fenwei')) return true;
                            if (player.hasSkill('jieyuan') && player.countCards('h') >= 2)
                                if (player.hasSkill('chouhai') && jlsg.isKongcheng(player)) return true;
                            if (player.hasSkill('qingxi')) {
                                var num = 1;
                                var info = get.info(player.get('e', '1'));
                                if (info && info.distance && info.distance.attackFrom) {
                                    num -= info.distance.attackFrom;
                                }
                                return num > 1;
                            }
                            return false;
                        },
                        hasWushuangEffect: function (player) {
                            if (player.hasSkills('wushuang|jlsg_shejing')) return true;
                            return false;
                        },
                        hasZhugeEffect: function (player) {
                            if (player.countCards('e', 'zhuge')) return true;
                            if (player.hasSkills('paoxiao|tianyi2|zhanlong2|xianzhen2|jlsg_shayi')) return true;
                            return false;
                        },
                        loseCardEffect: function (player) {
                            if (jlsg.needKongcheng(player)) return 3;
                            if (jlsg.getLeastHandcardNum(player) > 0) return 1;
                            return -player.countCards('h');
                        },
                        gainCardEffect: function (player) {
                            if (jlsg.needKongcheng(target, true)) return -1;
                            if (jlsg.getOverflow(player)) return 0;
                            return 3;
                        },
                        getLeastHandcardNum: function (player) {
                            var least = 0;
                            if (player.hasSkills('lianying|relianying') && least < 1) least = 1;
                            if (player.hasSkill('jlsg_ruya') && least < player.maxHp) least = player.maxHp;
                            if (player.hasSkill('shangshix') && least < 4) least = 4;
                            var jwfy = jlsg.findPlayerBySkillName('shoucheng');
                            if (least < 1 && jwfy && jlsg.isFriend(player, jwfy)) least = 1;
                            if (player.hasSkill('shangshi') && least < Math.min(2, jlsg.getLostHp(player))) least = Math.min(2, jlsg.getLostHp(player));
                            return least;
                        },
                        hasLoseHandcardEffective: function (player) {
                            return player.countCards('h') > jlsg.getLeastHandcardNum(player);
                        },
                        isWeak: function (player) {
                            if (jlsg.hasBuquEffect(player)) return false;
                            if (player.hasSkill('longhun') && player.countCards('he') > 2) return false;
                            if (player.hasSkill('jlsg_longhun') && player.countCards('he') > 2) return false;
                            if (player.hasSkill('hunzi') && !player.storage.hunzi && player.hp > 1) return false;
                            if ((player.hp <= 2 && player.countCards('h') <= 2) || player.hp <= 1) return true;
                            return false;
                        },
                        getLostHp: function (player) {
                            return player.maxHp - player.hp;
                        },
                        getBestHp: function (player) {
                            var arr = {
                                ganlu: 1, yinghun: 2, xueji: 1,
                                baobian: Math.max(0, player.maxHp - 3),
                            };
                            if (player.hasSkill('longhun') && player.countCards('he') > 2) return 1;
                            if (player.hasSkill('hunzi') && !player.storage.hunzi) return 2;
                            for (var i in arr) {
                                if (player.hasSkill(i)) {
                                    return Math.max((player.isZhu && 3 || 2), player.maxHp - arr[i])
                                }
                            }
                            if (player.hasSkill('renjie') && player.hasSkill('sbaiyin')) return player.maxHp - 1;
                            if (player.hasSkill('quanji') && player.hasSkill('zili')) return player.maxHp - 1;
                            return player.maxHp;
                        },
                        getValue: function (player) {
                            return player.hp * 2 + player.countCards('h');
                        },
                        isGoodHp: function (player) {
                            if (player.hp > 1 || jlsg.getCardsNum('tao', player) >= 1 || jlsg.getCardsNum('jiu', player) >= 1) return true;
                            if (jlsg.hasBuquEffect(player)) return true;
                            if (player.hasSkill('niepan') && !player.storage.niepan) return true;
                            if (player.hasSkill('reniepan') && !player.storage.reniepan) return true;
                            if (player.hasSkill('jlsg_zhuizun') && !player.storage.jlsg_zhuizun) return true;
                            if (player.hasSkill('fuli') && !player.storage.fuli) return true;
                            return false;
                        },
                        isScure: function (player) {
                            if (player.hp > jlsg.getBestHp(player)) return true;
                            if (jlsg.countCanShaMe(player) <= 0) return true;
                            if (jlsg.isGoodHp(player)) return true;
                            return false;
                        },
                        needBear: function (player) {
                            return (player.hasSkill('renjie') && player.hasSkill('sbaiyin') && !player.hasSkill('jilue') && player.storage.renjie < 4) || (player.hasSkill('qinxue') && !player.storage.qinxue);
                        },
                        cardNeed: function (card, player) {
                            if (player == undefined || get.itemtype(player) != 'player') player = get.owner(card);
                            var friends = jlsg.getFriends(player).sort(jlsg.sort.hp);
                            if (!friends.length) return null;
                            if (card.name == 'tao') {
                                friends.sort(jlsg.sort.hp);
                                if (friends[0].hp < 2) return 10;
                                if (player.hp < 3 || (jlsg.getLostHp(player) > 1 && !player.hasSkills('longhun|buqu|jlsg_longhun')) || player.hasSkills('kurou|benghuai')) return 14;
                                return jlsg.getUseValue(card, player);
                            }
                            var wuguotai = jlsg.findPlayerBySkillName('buyi');
                            if (wuguotai && jlsg.isFriend(player, wuguotai) && get.type(card) != 'basic') {
                                if (player.hp < 3 || (jlsg.getLostHp(player) > 1 && !player.hasSkills('longhun|buqu|jlsg_longhun')) || player.hasSkills('kurou|benghuai')) return 13;
                            }
                            if (jlsg.isWeak(player) && card.name == 'shan' && jlsg.getCardsNum('shan', player, player) < 1) return 12;
                            return 0;
                        },
                        getOverflow: function (player, getMaxCards) {
                            var kingdom_num = 0;
                            if (player.hasSkill('yongsi') && _status.currentPhase == player && !(player.hasSkill('keji') && get.cardCount({ name: 'sha' }, player) == 0)) {
                                var list = ['wei', 'shu', 'wu', 'qun'];
                                for (var i = 0; i < game.players.length && list.length; i++) {
                                    if (list.includes(game.players[i].group)) {
                                        list.remove(game.players[i].group);
                                        kingdom_num++;
                                    }
                                }
                            }
                            var MaxCards = 0;
                            if (player.hasSkill('qiaobian')) MaxCards = Math.max(player.countCards('h') - 1, player.getHandcardLimit());
                            if (player.hasSkill('keji') && get.cardCount({ name: 'sha' }, player) == 0) MaxCards = player.countCards('h');
                            if (getMaxCards && MaxCards > 0) return MaxCards;
                            MaxCards = player.getHandcardLimit();
                            if (kingdom_num > 0) {
                                if (player.countCards('he') <= kingdom_num) MaxCards = 0;
                                else MaxCards = Math.min(player.getHandcardLimit(), player.countCards('he') - kingdom_num);
                                if (getMaxCards) return MaxCards;
                            }
                            if (getMaxCards) return player.getHandcardLimit();
                            return player.countCards('h') - MaxCards;
                        },
                        willSkipPhaseUse: function (player) {
                            var friend_wuxie = 0;
                            for (var i = 0; i < game.players.length; i++) {
                                if (jlsg.isFriend(player, game.players[i])) friend_wuxie = friend_wuxie + jlsg.getCardsNum('wuxie', game.players[i], player);
                                if (jlsg.isEnemy(player, game.players[i])) friend_wuxie = friend_wuxie - jlsg.getCardsNum('wuxie', game.players[i], player);
                            }
                            if (player.skipList.includes('phaseUse')) return true;
                            if (player.hasJudge('lebu') && !player.hasSkill('yanxiao2') && friend_wuxie <= 0) {
                                if (!player.hasSkills('zongshi|keji|guanxing|qiaobian') && player.countCards('h') >= player.hp + 1) return true;
                                return false;
                            }
                            return false;
                        },
                        willSkipPhaseDraw: function (player) {
                            var friend_wuxie = 0;
                            for (var i = 0; i < game.players.length; i++) {
                                if (jlsg.isFriend(player, game.players[i])) friend_wuxie = friend_wuxie + jlsg.getCardsNum('wuxie', game.players[i], player);
                                if (jlsg.isEnemy(player, game.players[i])) friend_wuxie = friend_wuxie - jlsg.getCardsNum('wuxie', game.players[i], player);
                            }
                            if (player.hasJudge('bingliang') && !player.hasSkill('yanxiao2') && friend_wuxie <= 0) {
                                if (!player.hasSkills('guanxing|qiaobian') && player.countCards('h') <= player.hp + 2) return true;
                                return false;
                            }
                            if (player.skipList.includes('phaseDraw')) return true;
                            return false;
                        },
                        getViewAsCard: function (card, player) {
                            var skills = player.get('s', true).concat(lib.skill.global);
                            game.expandSkills(skills);
                            var list = [];
                            for (var i = 0; i < skills.length; i++) {
                                var ifo = get.info(skills[i]);
                                if (ifo.viewAs && ifo.viewAs.name && ifo.filterCard) {
                                    var filtercard = get.filter(ifo.filterCard);
                                    var pos = jlsg.getCardPlace(card);
                                    if ((ifo.selectCard == 1 || ifo.selectCard == undefined) && filtercard(card, player) && ((ifo.position && ifo.position.indexOf(pos) == 0) || !ifo.position && pos == 'h')) {
                                        return game.createCard({ name: ifo.viewAs.name, suit: card.suit, number: card.number });
                                    }
                                }
                            }
                            return null;
                        },
                        getSkillViewCard: function (card, name, player, place) {
                            var skills = player.get('s', true).concat(lib.skill.global);
                            game.expandSkills(skills);
                            for (var i = 0; i < skills.length; i++) {
                                var ifo = get.info(skills[i]);
                                if (ifo.viewAs && ifo.viewAs.name == name) {
                                    if (ifo.filterCard) {
                                        var filtercard = get.filter(ifo.filterCard);
                                        if (filtercard(card, player) && (ifo.selectCard == 1 || ifo.selectCard == undefined)) {
                                            if (ifo.position && ifo.position.indexOf(place) == 0) return true;
                                            if (!ifo.position) return place == 'h';
                                        }
                                    }
                                }
                            }
                            return false;
                        },
                        getCardPlace: function (card) {
                            var owner = get.owner(card);
                            if (owner) {
                                if (owner.get('h').includes(card)) return 'h';
                                if (owner.get('e').includes(card)) return 'e';
                                if (owner.get('j').includes(card)) return 'j';
                                return 's';
                            }
                            return 's';
                        },
                        isCard: function (name, card, player) {
                            if (!player || !card) return false;
                            if (card.name != name) {
                                var owner = get.owner(card);
                                var place;
                                if (!owner || player != owner) {
                                    place = 'h';
                                }
                                else {
                                    place = jlsg.getCardPlace(card);
                                }
                                if (jlsg.getSkillViewCard(card, name, player, place)) return true;
                                if (player.hasSkill('wushen') && get.suit(card) == 'heart' && card.name != 'sha') return false;
                                if (player.hasSkill('jinjiu') && card.name == 'jiu') return true;
                            }
                            else {
                                if (player.hasSkill('wushen') && get.suit(card) == 'heart' && card.name == 'sha') return true;
                                if (player.hasSkill('jinjiu') && card.name == 'jiu') return true;
                                if (lib.filter.cardUsable(card, player)) return true;
                            }
                            return false;
                        },
                        getKnownCard: function (player, from, card_name, viewAs, flags) {
                            flags = flags || 'h';
                            var forbid = false;
                            if (!from && player == _status.event.player) forbid = true;
                            from = from || _status.event.player;
                            var cards = player.get(flags);
                            var know = 0;
                            for (var i = 0; i < cards.length; i++) {
                                var card = cards[i];
                                if ((!forbid && player == from)) {
                                    if ((viewAs && jlsg.isCard(card_name, card, player)) || card.name == card_name || get.suit(card) == card_name || get.color(card) == card_name) {
                                        know++;
                                    }
                                }
                            }
                            return know;
                        },
                        getDefenseSha: function (player, attacker) {
                            if (attacker == undefined || get.itemtype(attacker) != 'player') attacker = _status.event.player;
                            var defense = jlsg.getCardsNum('shan', player, attacker);
                            var knownShan = jlsg.getKnownCard(player, attacker, 'shan', true);

                            defense = defense + knownShan * 1.2;

                            if (attacker.hasSkill('liegong')) {
                                var length = player.countCards('h');
                                if (length >= attacker.hp || length <= get.attackRange(attacker)) return 0;
                            }
                            if (attacker.hasSkill('reliegong')) {
                                var num = 0;
                                if (player.countCards('h') >= attacker.num('h')) num++;
                                if (player.hp >= attacker.hp) num++;
                                if (get.attackRange(player) <= get.attackRange(attacker)) num++;
                                if (num > 0) return 0;
                            }

                            if (jlsg.hasBaguaEffect(player)) {
                                defense += 1.3;
                                if (player.hasSkill('tiandu')) defense += 0.6;
                                if (player.hasSkill('leiji')) defense += 0.4;
                                if (player.hasSkill('boss_leiji')) defense += 0.5;
                                if (player.hasSkill('releiji')) defense += 0.4;
                                if (player.hasSkill('hongyan')) defense += 0.2;
                            }

                            if (jlsg.getCardsNum('shan', player, _status.event.player) > 1) {
                                if (player.hasSkill('mingzhe')) defense += 0.2;
                                if (player.hasSkill('tuntian') && player.hasSkill('zaoxian')) defense += 1.5;
                            }

                            if (player.hasSkill('aocai') && _status.currentPhase !== player) defense += 0.5;
                            if (player.hasSkill('jlsg_zhenlie')) defense += 0.5;
                            if (player.hasSkill('jlsg_danshou') && !jlsg.isKongcheng(player) && !jlsg.isKongcheng(attacker)) defense += 0.5;

                            var jlsgsk_zhuran = jlsg.findPlayerBySkillName('jlsg_yonglie');
                            if (jlsgsk_zhuran && jlsg.isGoodHp(jlsgsk_zhuran)) {
                                if (player.inRangeOf(jlsgsk_zhuran) && jlsg.isFriend(player, jlsgsk_zhuran)) defense += 0.5;
                            }
                            var jlsgsr_zhangliao = jlsg.findPlayerBySkillName('jlsg_yansha');
                            if (jlsgsr_zhangliao && jlsgsr_zhangliao.storage.jlsg_yansha2 && jlsgsr_zhangliao.storage.jlsg_yansha2.length) {
                                if (jlsg.isFriend(player, jlsgsr_zhangliao) && get.attitude(jlsgsr_zhangliao, attacker) < 0 && attacker.num('he')) defense += 0.5;
                            }

                            if (player.hasZhuSkill('hujia')) {
                                var caocao = player;
                                var list = game.filterPlayer(function (target) {
                                    return jlsg.isFriend(target, caocao) && target.group == 'wei' && target != caocao;
                                });
                                if (list.length > 0) {
                                    var hujiaShan = 0;
                                    for (var i = 0; i < list.length; i++) {
                                        hujiaShan += jlsg.getCardsNum('shan', list[i], _status.event.player);
                                        if (jlsg.hasBaguaEffect(list[i])) hujiaShan += 0.8;
                                    }
                                    defense += hujiaShan;
                                }
                            }
                            defense = defense + Math.min(player.hp * 0.45, 10);
                            if (attacker && !attacker.hasSkill('jueqing')) {
                                if (player.hasSkillTag('maixie') && jlsg.isGoodHp(player)) defense++;

                                if (player.hasSkill('jieming')) defense += 4;
                                if (player.hasSkills('yiji|jlsg_yiji')) defense += 4;
                                if (player.hasSkill('guixin')) defense += 4;
                                if (player.hasSkill('yuce')) defense += 2;
                            }

                            if (player.hasSkills('rende|rerende') && player.hp > 2) defense++;
                            if (player.hasSkill('kuanggu') && player.hp > 1) defense += 0.2;
                            if (player.hasSkill('tianming') && player.hp > 1) defense += 0.1;
                            if (player.hasSkills('zaiqi|rezaiqi') && player.hp > 1) defense += 0.35;
                            if (player.hp > jlsg.getBestHp(player)) defense += 0.8;
                            if (player.hp <= 2) defense -= 0.4;
                            if (player.hasSkill('tianxiang')) defense += player.countCards('h') * 0.5;

                            if (player.countCards('e', 'tengjia') && jlsg.hasZhuqueEffect(attacker) && !attacker.hasSkill('unequip')) defense -= 0.6;
                            if (player.isZhu) {
                                defense -= 0.4;
                                if (jlsg.isZhuInDanger()) defense -= 0.7;
                            }
                            if (player.isTurnedOver() && !player.hasSkill('jlsg_youxia')) defense -= 0.35;

                            if (player.countCards('j', 'lebu') && !player.hasSkill('yanxiao2')) defense -= 0.15;
                            if (player.countCards('j', 'bingliang') && !player.hasSkill('yanxiao2')) defense -= 0.15;
                            if (player.countCards('j', 'caomu') && !player.hasSkill('yanxiao2')) defense -= 0.15;

                            if ((attacker.hasSkill('roulin') && player.sex == 'female') || (attacker.sex == 'female' && player.hasSkill('roulin'))) defense = defense - 2.4;

                            if (!jlsg.hasBaguaEffect(player)) {
                                if (player.hasSkill('jijiu')) defense -= 3;
                                if (player.hasSkill('dimeng')) defense -= 2.5;
                                if (player.hasSkill('guzheng') && !jlsg.getCardsNum('shan', player, attacker)) defense -= 2.5;
                                if (player.hasSkill('qiaobian')) defense -= 2.4;
                                if (player.hasSkill('jieyin')) defense -= 2.3;
                                if (player.hasSkills('lijian|jlsg_lijian')) defense -= 2.2;
                            }
                            return defense;
                        },
                        getDefense: function (player) {
                            if (player == undefined || get.itemtype(player) != 'player') {
                                return 0;
                            }
                            var current_player = _status.event.player;
                            if (!current_player) return jlsg.getValue(player);

                            var defense = jlsg.getValue(player);

                            if (player.get('e', '2')) defense += 2;
                            if (player.get('e', '3')) defense++;
                            if (player.countCards('e', 'muniu') && player.get('e', '5').cards) defense += player.get('e', '5').cards.length;

                            if (jlsg.hasBaguaEffect(player)) {
                                if (player.hasSkill('tiandu')) defense++;
                                if (player.hasSkill('leiji')) defense += 2;
                                if (player.hasSkill('boss_leiji')) defense += 2;
                                if (player.hasSkill('releiji')) defense += 2;
                                if (player.hasSkill('hongyan')) defense += 2;
                            }
                            var maixie = jlsg.ai.skill.maixie_skill.split("|");
                            for (var i = 0; i < maixie.length; i++) {
                                if (player.hasSkill(maixie[i]) && jlsg.isGoodHp(player)) defense++;
                            }

                            if (player.hasSkill('jieming')) defense += 3;
                            if (player.hasSkills('yiji|jlsg_yiji')) defense += 3;
                            if (player.hasSkill('guixin')) defense += game.players.length - 1;
                            if (player.hasSkill('yuce')) defense += 2;
                            if (player.hasSkill('chengxiang')) defense++;

                            if (player.hasZhuSkill('shichou')) {
                                var current = jlsg.findPlayerBySkillName('shichou_dying');
                                if (current) defense += current.hp;
                            }

                            if (player.hasSkill('rende') && player.countCards('h') > 1 && player.hp > 2) defense++;
                            if (player.hasSkill('rerende') && player.countCards('h') > 1 && player.hp > 2) defense++;
                            if (player.hasSkill('kuanggu') && player.hp > 1) defense += 0.5;
                            if (player.hasSkill('diykuanggu') && player.hp > 1) defense += 0.5;
                            if (player.hasSkill('zaiqi') && player.hp > 1) defense = defense + ((player.maxHp - player.hp) * 0.5);
                            if (player.hasSkill('tianming')) defense += 0.5;
                            if (player.hasSkill('keji')) defense += player.countCards('h') * 0.25;
                            if (player.hasSkill('aocai') && _status.currentPhase !== player) defense += 0.5;
                            if (player.hasSkill('tianxiang')) defense += player.countCards('h') * 0.5;

                            if (player.hp > jlsg.getBestHp(player)) defense += 0.8;
                            if (player.hp <= 2) defense = defense - 0.4;
                            if (player.hasSkill('benghuai') && player.maxHp <= 5) defense--;
                            if (player.hasSkills(jlsg.ai.skill.bad_skills)) defense--;

                            if (player.isZhu) {
                                defense = defense - 0.4;
                                if (jlsg.isZhuInDanger()) defense = defense - 0.7;
                            }

                            var invaliditySkill = ['yijue', 'boss_hujia', 'retieji', 'pozhou', 'jlsg_zhenhun'];
                            for (var i = 0; i < invaliditySkill.length; i++) {
                                if (player.disabledSkills[invaliditySkill[i]] && player.disabledSkills[invaliditySkill[i]].length > 0)
                                    defense -= 5;
                            }

                            if (player.isTurnedOver()) defense--;

                            if (player.countCards('j', 'lebu') && !player.hasSkill('yanxiao2')) defense -= 0.5;
                            if (player.countCards('j', 'bingliang') && !player.hasSkill('yanxiao2')) defense -= 0.5;
                            if (player.countCards('j', 'caomu') && !player.hasSkill('yanxiao2')) defense -= 0.5;

                            if (player.hasSkill('jijiu')) defense += 2;
                            if (player.hasSkill('qingnang')) defense += 2;
                            if (player.hasSkill('dimeng')) defense += 2.5;
                            if (player.hasSkill('guzheng')) defense += 2.5;
                            if (player.hasSkill('qiaobian')) defense += 2.4;
                            if (player.hasSkill('jieyin')) defense += 2.3;
                            if (player.hasSkills('jlsg_lijian|lijian')) defense += 2.1;
                            if (player.hasSkill('yishe')) defense += 2;
                            if (player.hasSkill('paiyi')) defense += 1.5;
                            if (player.hasSkill('yongsi')) defense += 2;

                            defense = defense + (game.players.length - (get.distance(player, _status.currentPhase, 'absolute')) % game.players.length) / 4;

                            defense = defense + player.get('s').length * 0.25;

                            return defense;
                        },
                        findCardInCardPile: function (name) {
                            var card;
                            for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
                                card = ui.cardPile.childNodes[i];
                                if (typeof name == 'string') {
                                    if (card.name == name) {
                                        return card;
                                    }
                                }
                                else if (typeof name == 'function') {
                                    if (name(card)) {
                                        return card;
                                    }
                                }
                            }
                            return null;
                        },
                        findCardInDiscardPile: function (name) {
                            var cards = [];
                            var card = false;
                            for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                                card = ui.discardPile.childNodes[i];
                                if (typeof name == 'string') {
                                    if (card.name == name) {
                                        return card;
                                    }
                                }
                                else if (typeof name == 'function') {
                                    if (name(card)) {
                                        return card;
                                    }
                                }
                                else {
                                    cards = cards.concat(card);
                                }
                            }
                            if (cards.length) return cards.randomGet();
                            return null;
                        },
                        isZhuHealthy: function () {
                            var zhu = get.zhu();
                            if (!zhu) return false;
                            var zhu_hp;
                            if (zhu.hasSkill('benghuai') && zhu.hp > 4) {
                                zhu_hp = 4;
                            }
                            else {
                                zhu_hp = zhu.hp;
                            }
                            return zhu_hp > 3 || (zhu_hp > 2 && jlsg.getDefense(zhu) > 3);
                        },
                        isZhuInDanger: function () {
                            var zhu = get.zhu();
                            if (!zhu) return false;
                            var zhu_hp;
                            if (zhu.hasSkill('benghuai') && zhu.hp > 4) {
                                zhu_hp = 4;
                            }
                            else {
                                zhu_hp = zhu.hp;
                            }
                            return zhu_hp < 3;
                        },
                        findPlayerBySkillName: function (skills) {
                            return game.findPlayer(function (player) {
                                return player.hasSkills(skills);
                            });
                        },
                        isFriend: function (other, another) {
                            return get.attitude(other, another) > 0;
                        },
                        isEnemy: function (other, another) {
                            return get.attitude(other, another) < 0;
                        },
                        getFriends: function (player) {
                            return game.filterPlayer(function (target) {
                                return jlsg.isFriend(player, target);
                            });
                        },
                        getFriendsNoself: function (player) {
                            return game.filterPlayer(function (target) {
                                return jlsg.isFriend(player, target) && player != target;
                            });
                        },
                        getEnemies: function (player) {
                            return game.filterPlayer(function (target) {
                                return jlsg.isEnemy(player, target);
                            });
                        },
                        filterFriend: function (player, func) {
                            var friends = jlsg.getFriends(player);
                            for (var i = 0; i < friends.length; i++) {
                                if (func(friends[i])) {
                                    return game.players[i];
                                }
                            }
                            return null;
                        },
                        filterFriends: function (player, func) {
                            var list = [];
                            var friends = jlsg.getFriends(player);
                            for (var i = 0; i < friends.length; i++) {
                                if (func(friends[i])) {
                                    list.push(game.players[i]);
                                }
                            }
                            return list;
                        },
                        filterEnemy: function (player, func) {
                            var enemies = jlsg.getEnemies(player);
                            for (var i = 0; i < enemies.length; i++) {
                                if (func(enemies[i])) {
                                    return game.players[i];
                                }
                            }
                            return null;
                        },
                        filterEnemies: function (player, func) {
                            var list = [];
                            var enemies = jlsg.getEnemies(player);
                            for (var i = 0; i < enemies.length; i++) {
                                if (func(enemies[i])) {
                                    list.push(game.players[i]);
                                }
                            }
                            return list;
                        },
                        countFriends: function (player) {
                            return game.countPlayer(function (target) {
                                return jlsg.isFriend(player, target) && target != player;
                            });
                        },
                        countEnemies: function (player) {
                            return game.countPlayer(function (target) {
                                return jlsg.isEnemy(player, target);
                            });
                        },
                        countNextEmenies: function (from, to) {
                            var num = 0;
                            var current = from.getNext();
                            for (var i = 0; i < 10 && current != to; i++) {
                                if (jlsg.isEnemy(to, current)) {
                                    num++;
                                }
                                current = current.getNext();
                            }
                            return num;
                        },
                        getNextEmenies: function (from, to) {
                            var list = [];
                            var current = from.getNext();
                            for (var i = 0; i < 10 && current != to; i++) {
                                if (jlsg.isEnemy(to, current)) {
                                    list.push(current);
                                }
                                current = current.getNext();
                            }
                            return list;
                        },
                        countCanShaMe: function (player) {
                            return game.countPlayer(function (target) {
                                return jlsg.isEnemy(player, target) && target.canUse('sha', player) && get.effect(target, { name: 'sha' }, player) > 0;
                            });
                        },
                        getCanShaMe: function (player) {
                            return game.filterPlayer(function (target) {
                                return jlsg.isEnemy(player, target) && target.canUse('sha', player) && get.effect(player, { name: 'sha' }, target) > 0;
                            });
                        },
                        getWillShaTarget: function (player) {
                            var target = game.filterPlayer(function (target1) {
                                return player.canUse('sha', target1) && get.effect(target1, { name: 'sha' }, player) > 0;
                            });
                            target.sort(function (a, b) {
                                return get.effect(a, { name: 'sha' }, player) < get.effect(a, { name: 'sha' }, player);
                            });
                            return target[0];
                        },
                        getCardsNum: function (class_name, player, from) {
                            if (player == undefined || get.itemtype(player) != 'player') player = _status.event.player;
                            var cards = player.get('h');
                            if (player.countCards('e', 'muniu') && player.get('e', '5').cards && player.get('e', '5').cards.length) {
                                cards = cards.concat(player.get('e', '5').cards);
                            }
                            var num = 0, shownum = 0, redtao = 0, redsha = 0, rencard = 0, blackcard = 0, blackwuxie = 0, equipwuxie = 0;
                            var equipcard = 0, heartsha = 0, hearttao = 0, spadewuxie = 0, spadejiu = 0, spadecard = 0, diamondcard = 0;
                            var clubcard = 0, shashan = 0, jiunum = 0;
                            var forbid = false;
                            if (!from && _status.event.player != player) forbid = true;
                            from = from || _status.event.player;
                            for (var i = 0; i < cards.length; i++) {
                                var card = cards[i];
                                if (!forbid && player == from) {
                                    shownum++;
                                    if (card.name == class_name) num++;
                                    if (card.name == 'jiu') jiunum++;
                                    if (get.type(card) == 'equip') equipcard++;
                                    if (card.name == 'sha' || card.name == 'shan') shashan++;
                                    if (get.color(card) == 'red') {
                                        rencard++;
                                        if (card.name != 'sha') redsha++;
                                        if (card.name != 'tao') redtao++;
                                    }
                                    if (get.color(card) == 'black') {
                                        blackcard++;
                                        if (card.name != 'wuxie') blackwuxie++;
                                    }
                                    if (get.suit(card) == 'heart') {
                                        if (card.name != 'sha') heartsha++;
                                        if (card.name != 'tao') redtao++;
                                    }
                                    if (get.suit(card) == 'spade') {
                                        if (card.name != 'wuxie') spadewuxie++;
                                        if (card.name != 'jiu') spadejiu++;
                                    }
                                    if (get.suit(card) == 'diamond' && card.name != 'sha') diamondcard++;
                                    if (get.suit(card) == 'club') clubcard++;
                                }
                            }
                            var ecards = player.get('e');
                            for (var i = 0; i < ecards.length; i++) {
                                var card = ecards[i];
                                equipcard++;
                                if (player.countCards('h') > player.hp) equipwuxie++;
                                if (get.color(card) == 'red') {
                                    redtao++; redsha++;
                                }
                                if (get.suit(card) == 'heart') hearttao++;
                                if (get.suit(card) == 'spade') spadecard++;
                                if (get.suit(card) == 'diamond') diamondcard++;
                                if (get.suit(card) == 'club') clubcard++;
                            }
                            if (class_name == 'sha') {
                                var shanum;
                                if (player.hasSkill('wusheng')) {
                                    shanum = redsha + num + (player.countCards('h') - shownum) * 0.69;
                                }
                                if (player.hasSkill('shizhi') && player.hp == 1) {
                                    shanum = shashan + (player.countCards('h') - shownum) * 0.3;
                                }
                                else if (player.hasSkill('wushen')) {
                                    shanum = heartsha + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else if (player.hasSkill('jinjiu')) {
                                    shanum = jiunum + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else if (player.hasSkills('longhun|jlsg_longhun')) {
                                    shanum = diamondcard + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else if (player.hasSkill('nos_gongji')) {
                                    shanum = equipcard + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else if (player.hasSkills('chixin')) {
                                    shanum = shashan + (player.countCards('h') - shownum) * 0.72;
                                }
                                else if (player.countCards('e', 'zhangba')) {
                                    shanum = num + (player.countCards('h') - shownum) * 0.2;
                                }
                                else {
                                    shanum = num + (player.countCards('h') - shownum) * 0.35;
                                }
                                return (jlsg.hasWushuangEffect(player) && shanum * 2) || shanum;
                            }
                            else if (class_name == 'shan') {
                                if (player.hasSkill('qingguo')) {
                                    return blackcard + num + (player.countCards('h') - shownum) * 0.8;
                                }
                                else if (player.hasSkills('longdan|chixin')) {
                                    return shashan + (player.countCards('h') - shownum) * 0.72;
                                }
                                else if (player.hasSkills('longhun|jlsg_longhun')) {
                                    return clubcard + num + (player.countCards('h') - shownum) * 0.65;
                                }
                                else if (player.hasSkill('jieyue3')) {
                                    return rencard + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else {
                                    return num + (player.countCards('h') - shownum) * 0.6;
                                }
                            }
                            else if (class_name == 'tao') {
                                if (player.hasSkill('jijiu')) {
                                    return num + redtao + (player.countCards('h') - shownum) * 0.6;
                                }
                                else if (player.hasSkills('longhun|jlsg_longhun')) {
                                    return hearttao + num + (player.countCards('h') - shownum) * 0.5;
                                }
                                else {
                                    return num;
                                }
                            }
                            else if (class_name == 'jiu') {
                                if (player.hasSkill('jiuchi')) {
                                    return num + spadejiu + (player.countCards('h') - shownum) * 0.3;
                                }
                                else if (player.hasSkill('jiushi')) {
                                    return num + 1;
                                }
                                else {
                                    return num;
                                }
                            }
                            else if (class_name == 'wuxie') {
                                if (player.hasSkill('kanpo')) {
                                    return num + blackwuxie + (player.countCards('h') - shownum) * 0.5;
                                }
                                else if (player.hasSkill('yanzheng')) {
                                    return num + equipwuxie;
                                }
                                else if (player.hasSkill('ruzong')) {
                                    return num * 3;
                                }
                                else {
                                    return num;
                                }
                            }
                            else {
                                return num;
                            }
                        },
                        getCards: function (name, player) {
                            player = player || _status.event.player;
                            return player.countCards('he', name);
                        },
                    };
                    if (!window.suiSet) {
                        window.suiSet = {}
                    }
                    lib.jlsg = window.jlsg
                    window.suiSet.jlsksrPackAfter = true
                    const addPrefix = () => {
                        lib.namePrefix.set('极略SK神', {
                            getSpan(prefix, name) {
                                return `${get.prefixSpan('极略SK', name)}${get.prefixSpan('神', name)}`;
                            }
                        });
                        lib.namePrefix.set('极略SP神', {
                            getSpan(prefix, name) {
                                return `${get.prefixSpan('极略SP', name)}${get.prefixSpan('神', name)}`;
                            }
                        });
                        lib.namePrefix.set('极略SR', {
                            getSpan: () => {
                                return `<span style="writing-mode:horizontal-tb;-webkit-writing-mode:horizontal-tb;font-family:MotoyaLMaru;transform:scaleY(0.85)" data-nature="keymm">SR</span>`;
                            }
                        });
                        lib.namePrefix.set('极略SK', {
                            getSpan: () => {
                                return `<span style="color:#fbefef;writing-mode:horizontal-tb;-webkit-writing-mode:horizontal-tb;font-family:MotoyaLMaru;transform:scaleY(0.85)" data-nature="firemm">SK</span>`;
                            }
                        });
                        lib.namePrefix.set('极略SP', {
                            getSpan: () => {
                                return `<span style="writing-mode:horizontal-tb;-webkit-writing-mode:horizontal-tb;font-family:MotoyaLMaru;transform:scaleY(0.85)">SP</span>`;
                            }
                        });
                        lib.namePrefix.set('极略★SK', {
                            getSpan(prefix, name) {
                                return `${get.prefixSpan('★SP', name)}${get.prefixSpan('极略SK', name)}`;
                            }
                        });
                    }
                    addPrefix()
                    const postProcessPack = pack => {
                        for (var i in pack.character) {
                            pack.character[i][4].push(`die:ext:极略/die/${i}.mp3`);
                            if (i in pack.translate && !i.startsWith('jlsgsy')) {
                                let name = pack.translate[i];
                                if (!((i + '_ab') in pack.translate)) {
                                    pack.translate[i + '_ab'] = '极略' + name;
                                }
                                if (name.startsWith('SK神')) {
                                    pack.translate[i + '_prefix'] = '极略SK神';
                                }
                                else if (name.startsWith('SP神')) {
                                    pack.translate[i + '_prefix'] = '极略SP神';
                                }
                                else if (name.startsWith('SK')) {
                                    pack.translate[i + '_prefix'] = '极略SK';
                                }
                                else if (name.startsWith('SR')) {
                                    pack.translate[i + '_prefix'] = '极略SR';
                                }
                                else if (name.startsWith('SP')) {
                                    // reuse the internal SP prefix
                                    pack.translate[i + '_prefix'] = '极略SP';
                                }
                                // else {
                                //   console.warn(i, name, "not prefixed!");
                                // }
                            }
                        }
                        if (lib.device || lib.node) {
                            for (var i in pack.character) {
                                pack.character[i][4].push('ext:极略/' + i + '.jpg');
                            }
                        } else {
                            for (var i in pack.character) {
                                pack.character[i][4].push('db:extension-极略:' + i + '.jpg');
                            }
                        }
                    }
                    const cardImage = jlsg_qs => {
                        const extname = '极略';
                        for (const cardName in jlsg_qs.card) {
                            var card = jlsg_qs.card[cardName];
                            if (card.fullskin) {
                                if (_status.evaluatingExtension) {
                                    card.image = `db:extension-${extname}:${cardName}.png`;
                                }
                                else {
                                    card.image = `ext:${extname}/${cardName}.png`;
                                }
                            }
                            if (card.audio === true) {
                                card.audio = `ext:${extname}`;
                            }
                            if (card.chongzhu && false) { // 七杀特殊宝物规则
                                if (!card.onEquip) {
                                    card.onEquip = function () { // remember to sync with onEquip of jlsgqs_taipingyaoshu!
                                        "step 0"
                                        var cards = player.getCards('e', { subtype: ['equip3', 'equip4'] });
                                        if (cards.length == 2) {
                                            player.chooseCard('e', '将进攻坐骑或防御坐骑置入弃牌堆', card => cards.includes(card), true);
                                        }
                                        "step 1"
                                        // 模拟替换
                                        player.lose(result.cards, false, 'visible').set('type', 'equip').set('getlx', false);
                                    };
                                }
                                if (!card.skills) {
                                    card.skills = [];
                                }
                                card.skills.push("jlsgqs_relic");
                            }
                        }

                    }
                    const hasSkills = function (skills) {
                        const skill = skills.split("|");
                        for (let i = 0; i < skill.length; i++) {
                            if (this.hasSkill(skill[i])) return true;
                        }
                        return false;
                    }
                    const packs = window.suiSet && window.suiSet.moreCharacters ? suiSet.moreCharacters.characters.jilueSkSr : jlsgpack
                    if (loadAfter) {
                        lib.element.player.hasSkills = hasSkills
                        for (const p in packs) {
                            const pack = packs[p]
                            if (pack.name === 'jlsg_qs') {
                                cardImage(pack)
                            } else {
                                postProcessPack(pack)
                            }
                            for (const key in pack) {
                                if (key in lib) {
                                    lib[key] = Object.assign(lib[key], pack[key])
                                }
                            }
                        }
                        return
                    }
                    lib.arenaReady.push(() => {
                        lib.element.player.hasSkills = hasSkills
                    });
                    for (const p in packs) {
                        const pack = packs[p]
                        game.import(pack.type, (lib, game, ui, get, ai, _status) => {
                            if (pack.type === 'card') {
                                cardImage(pack)
                            } else {
                                postProcessPack(pack)
                            }
                            delete pack.type
                            return pack
                        })
                    }
                },
                HDWJ(huanlepack, loadAfter) {
                    if (lib.config['extension_活动武将_enable'] || window.suiSet && window.suiSet.huanlePackAfter) return
                    if (!window.suiSet) {
                        window.suiSet = {}
                    }
                    window.suiSet.huanlePackAfter = true
                    const style = document.createElement('style')
                    style.innerHTML = `
                .card.minihuanhua-glow::before {
                    opacity: 0.2;
                    box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px, rgb(255, 109, 12) 0px 0px 5px, rgb(255, 0, 0) 0px 0px 10px;
                    background-color: yellow;
                    filter: blur(5px);
                }
                .card.minihuanshu-glow::before {
                    opacity: 0.2;
                    box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px, rgb(255, 109, 12) 0px 0px 5px, rgb(255, 0, 0) 0px 0px 10px;
                    background-color: rgb(0, 0, 255);
                    filter: blur(5px);
                }
            `
                    document.body.appendChild(style)
                    lib.namePrefix.set('喵', {
                        color: '#fdd559',
                        nature: 'soilmm',
                    });
                    lib.namePrefix.set('欢杀', {
                        color: '#ff6a6a',
                        nature: 'MXpink',
                        showName: '欢',
                    });
                    lib.namePrefix.set('欢杀神', {
                        getSpan: (prefix, name) => `${get.prefixSpan('欢杀')}${get.prefixSpan('神')}`,
                    });
                    lib.namePrefix.set('SP欢杀神', {
                        getSpan: (prefix, name) => `${get.prefixSpan('SP')}${get.prefixSpan('欢杀')}${get.prefixSpan('神')}`,
                    });
                    lib.namePrefix.set('欢杀谋', {
                        getSpan: (prefix, name) => `${get.prefixSpan('欢杀')}${get.prefixSpan('谋')}`,
                    });
                    const packs = window.suiSet && window.suiSet.moreCharacters ? suiSet.moreCharacters.characters.HDWJ : huanlepack
                    const prefixContent = pack => {
                        const { translate, character } = pack
                        for (const i in translate) {
                            if (translate[i]) {
                                if (translate[i].indexOf('欢杀神') == 0) lib.translate[i + '_prefix'] = '欢杀神';
                                else if (translate[i].indexOf('SP欢杀神') == 0) lib.translate[i + '_prefix'] = 'SP欢杀神';
                                else if (translate[i].indexOf('欢杀谋') == 0) lib.translate[i + '_prefix'] = '欢杀谋';
                                else if (translate[i].indexOf('欢杀') == 0) lib.translate[i + '_prefix'] = '欢杀';
                                else if (translate[i].indexOf('SP欢杀') == 0) lib.translate[i + '_prefix'] = 'SP欢杀';
                                else if (translate[i].indexOf('喵') == 0) lib.translate[i + '_prefix'] = '喵';
                            }
                        }
                        for (const i in character) {
                            if (character[i] && character[i][4]) {
                                character[i][4].push(((lib.device || lib.node) ? 'ext:' : 'db:extension-') + '活动武将/image/character/' + i + '.jpg');
                            }
                        }
                    }
                    if (loadAfter) {
                        for (const p in packs) {
                            const pack = packs[p]
                            prefixContent(pack)
                            for (const key in pack) {
                                if (key in lib) {
                                    lib[key] = Object.assign(lib[key], pack[key])
                                }
                            }
                        }
                        return
                    }
                    for (const p in packs) {
                        game.import('character', (lib, game, ui, get, ai, _status) => {
                            prefixContent(packs[p])
                            return packs[p]
                        })
                    }
                },
                DIY(diyPack, loadAfter) {
                    if (lib.config['extension_Q群DIY武将_enable'] || window.suiSet && window.suiSet.diyAfter) return
                    if (!window.suiSet) {
                        window.suiSet = {}
                    }
                    window.suiSet.diyAfter = true
                    const prefixContent = pack => { }
                    const packs = window.suiSet && window.suiSet.moreCharacters ? suiSet.moreCharacters.characters.DIY : diyPack
                    if (loadAfter) {
                        for (const p in packs) {
                            const pack = packs[p]
                            prefixContent(pack)
                            for (const key in pack) {
                                if (key in lib) {
                                    lib[key] = Object.assign(lib[key], pack[key])
                                }
                            }
                        }
                        return
                    }
                    for (const p in packs) {
                        game.import('character', (lib, game, ui, get, ai, _status) => {
                            prefixContent(packs[p])
                            const pack = packs[p]
                            for (const c in pack.character) {
                                pack.character[c].trashBin.push(((lib.device || lib.node) ? 'ext:' : 'db:extension-') + 'Q群DIY武将/image/' + c + '.jpg');
                            }
                            return packs[p]
                        })
                    }
                },
                LM(lmPack, loadAfter) {
                    if (lib.config['extension_凌梦自用_enable'] || window.suiSet && window.suiSet.lmAfter) return
                    if (!window.suiSet) {
                        window.suiSet = {}
                    }
                    window.suiSet.lmAfter = true
                    //Prefix添加
                    lib.namePrefix.set("凌", {
                        color: "#8470FF",
                        nature: "LightSlateBlue",
                        showName: "凌",
                    });
                    lib.namePrefix.set("☆神", {
                        color: "#FFD700",
                        nature: "GoldEnrod",
                        showName: "☆神",
                    });
                    lib.namePrefix.set("虎翼", {
                        color: "#FFD700",
                        nature: "GoldEnrod",
                        showName: "虎翼",
                    });
                    lib.namePrefix.set("勇", {
                        color: "#def7ca",
                        nature: "watermm",
                        showName: "勇",
                    });
                    lib.namePrefix.set("严", {
                        color: "#def7ca",
                        nature: "watermm",
                        showName: "严",
                    });
                    lib.namePrefix.set("旧界", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("界")}`,
                    });
                    lib.namePrefix.set("旧谋", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("谋")}`,
                    });
                    lib.namePrefix.set("旧勇", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("勇")}`,
                    });
                    lib.namePrefix.set("旧严", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("严")}`,
                    });
                    lib.namePrefix.set("旧玄", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("玄")}`,
                    });
                    lib.namePrefix.set("旧友", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("友")}`,
                    });
                    lib.namePrefix.set("旧☆", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("☆")}`,
                    });
                    lib.namePrefix.set("旧SP", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("SP")}`,
                    });
                    lib.namePrefix.set("旧族", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("族")}`,
                    });
                    lib.namePrefix.set("旧星", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("星")}`,
                    });
                    lib.namePrefix.set("旧乐", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("乐")}`,
                    });
                    lib.namePrefix.set("旧武", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("武")}`,
                    });
                    lib.namePrefix.set("旧威", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("威")}`,
                    });
                    lib.namePrefix.set("旧神", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("神")}`,
                    });
                    lib.namePrefix.set("旧侠", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("侠")}`,
                    });
                    lib.namePrefix.set("旧幻", {
                        getSpan: (prefix, name) => `${get.prefixSpan("旧")}${get.prefixSpan("幻")}`,
                    });
                    lib.namePrefix.set("凌界", {
                        getSpan: (prefix, name) => `${get.prefixSpan("凌")}${get.prefixSpan("界")}`,
                    });
                    lib.namePrefix.set("凌谋", {
                        getSpan: (prefix, name) => `${get.prefixSpan("凌")}${get.prefixSpan("谋")}`,
                    });
                    lib.namePrefix.set("凌神", {
                        getSpan: (prefix, name) => `${get.prefixSpan("凌")}${get.prefixSpan("神")}`,
                    });

                    const packs = window.suiSet && window.suiSet.moreCharacters ? suiSet.moreCharacters.characters.YXLM : lmPack
                    const prefixContent = pack => {
                        const { translate, character } = pack
                        for (const i in character) {
                            if (!character[i][4]) character[i][4] = []
                            character[i][4].push(((lib.device || lib.node) ? 'ext:' : 'db:extension-') + '凌梦自用/image/character/' + i + '.jpg');
                        }
                    }
                    if (loadAfter) {
                        for (const p in packs) {
                            const pack = packs[p]
                            prefixContent(pack)
                            for (const key in pack) {
                                if (key in lib) {
                                    lib[key] = Object.assign(lib[key], pack[key])
                                }
                            }
                        }
                        return
                    }
                    for (const p in packs) {
                        game.import('character', (lib, game, ui, get, ai, _status) => {
                            prefixContent(packs[p])
                            return packs[p]
                        })
                    }
                }
            },
        },
        createElement(element, option, par) {
            const node = document.createElement(element)
            for (const i in option) {
                node[i] = option[i]
            }
            if (par) {
                par.appendChild(node)
            }
            return node
        },
        connect_players() {
            const players = game.connectPlayers || game.players
            const playertrue = []
            const playersfalse = []
            players.forEach(p => {
                if (p.avatar || p.nickname) playertrue.push(p)
                else playersfalse.push(p)
            })
            return [playertrue, playersfalse]
        },
        getSelecList() {
            const list = []
            const list2 = []
            const list3 = []
            const list4 = []
            const libCharacter = {};
            lib.configOL.characterPack.forEach(p => {
                const pack = lib.characterPack[p]
                for (const j in pack) if (lib.character[j]) libCharacter[j] = pack[j];
            })
            for (const i in lib.characterReplace) {
                const ix = lib.characterReplace[i]
                for (let j = 0; j < ix.length; j++) {
                    if (!libCharacter[ix[j]] || lib.filter.characterDisabled(ix[j])) ix.splice(j--, 1);
                }
                if (ix.length) {
                    list.push(i)
                    list2.push(i)
                    list4.addArray(ix)
                    let bool = false
                    for (const j of ix) {
                        if (libCharacter[j][4] && libCharacter[j][4].includes('zhu')) {
                            bool = true; break;
                        }
                    }
                    (bool ? list2 : list3).push(i);
                }
            }
            for (const i in libCharacter) {
                if (list4.includes(i)) continue;
                if (lib.filter.characterDisabled(i, libCharacter)) continue;
                list.push(i)
                list2.push(i)
                list4.push(i)
                if (libCharacter[i][4] && libCharacter[i][4].contains('zhu')) list2.push(i)
                else list3.push(i);
            }
            return { list, list2, list3, list4, libCharacter }
        },
        getZhuList(list2) {
            const limit_zhu = lib.configOL.limit_zhu;
            if (!limit_zhu || limit_zhu == 'off') return list2.slice(0).sort(lib.sort.character);
            if (limit_zhu != 'group') {
                const num = (parseInt(limit_zhu) || 6);
                return list2.randomGets(num).sort(lib.sort.character);
            }
            const getGroup = function (name) {
                if (lib.characterReplace[name]) return lib.character[lib.characterReplace[name][0]][1];
                return lib.character[name][1];
            }
            const list2x = list2.slice(0);
            list2x.randomSort();
            for (var i = 0; i < list2x.length; i++) {
                for (var j = i + 1; j < list2x.length; j++) {
                    if (getGroup(list2x[i]) == getGroup(list2x[j])) {
                        list2x.splice(j--, 1);
                    }
                }
            }
            list2x.sort(lib.sort.character);
            return list2x;
        },
        nextSet(key, value) {
            if (key === 'createDialog') {
                const { getZhuList } = suiSet
                const { list, list2 } = _status.event
                const chooseList = (_status.event.list || _status.event.list2 || _status.characterlist || []).slice()
                const num = suiSet.getSelect(chooseList)
                value[1][0] = getZhuList(list2).concat(list.randomRemove(num))
            }
            if (arguments.length == 1 && Array.isArray(arguments[0])) {
                for (var i = 0; i < arguments[0].length; i++) {
                    if (Array.isArray(arguments[0][i])) {
                        this.set(arguments[0][i][0], arguments[0][i][1]);
                    }
                }
            } else {
                if (typeof key != 'string') {
                    console.log('warning: using non-string object as event key');
                    console.log(key, value);
                    console.log(_status.event);
                }
                this[key] = value;
                this._set.push([key, value]);
            }
            return this;
        },
        chooseButton(...args) {
            const next = game.createEvent('chooseButton');
            // let nextcreateDialog = next.next
            // Object.defineProperty(next,'createDialog',{
            //     get(){return nextcreateDialog},
            //     set(v){
            //         const chooseList = (_status.event.list||_status.event.list2||_status.characterlist||[]).slice()
            //         const {list2} = _status.event
            //         const num = suiSet.getSelect(chooseList)
            //         let zhuSelect = []
            //         if(this.player===game.zhu||next.player===game.zhu) zhuSelect = suiSet.getZhuList(list2)
            //         v[1][0] = chooseList.randomRemove(num).concat(zhuSelect)
            //         nextcreateDialog = v
            //     },
            //     configurable:true,
            // })
            if (this === game.zhu) {
                next.set = suiSet.nextSet
            }
            const selectType = {
                boolean(item) {
                    if (!next.forced) next.forced = item
                    else next.complexSelect = item
                },
                dialog(item) {
                    next.dialog = item
                    next.closeDialog = true
                },
                select(item) {
                    next.selectButton = item
                },
                number(item) {
                    next.selectButton = [item, item];
                },
                function(item) {
                    if (next.ai) next.filterButton = item
                    else next.ai = item
                },
                array(item) {
                    next.createDialog = item
                },
            }
            args.forEach(a => {
                let type = get.itemtype(a)
                const typeif = typeof a
                if (Array.isArray(a)) type = 'array'
                if (typeif === 'boolean') type = 'boolean'
                typeof selectType[type] === 'function' && selectType[type](a)
            })
            next.player = this;
            if (typeof next.forced != 'boolean') next.forced = false;
            if (next.isMine() == false && next.dialog) next.dialog.style.display = 'none';
            if (next.filterButton == undefined) next.filterButton = lib.filter.filterButton;
            if (next.selectButton == undefined) next.selectButton = [1, 1];
            if (next.ai == undefined) next.ai = function () { return 1; };
            if (next.complexSelect !== false) next.complexSelect = true;
            next.setContent('chooseButton');
            next._args = Array.from(arguments);
            next.forceDie = true;
            return next;
        },
        chooseButtonOL(list, callback, ai) {
            const chooseList = (_status.event.list || _status.event.list2 || _status.characterlist || []).slice()
            const bool = list.every(i => {
                if (typeof i[1] !== 'object') return false
                if (typeof i[1][1] !== 'object') return false
                return Object.prototype.toString.call(i[1][1][0]) === '[object Array]'
            })
            if (chooseList && chooseList.length > 0 && bool) {
                const num = suiSet.getSelect(chooseList)
                list.forEach(i => {
                    i[1][1][0] = chooseList.randomRemove(num)
                })
                const next = game.createEvent('chooseButtonOL');
                next.list = list;
                next.setContent('chooseButtonOL');
                next.ai = ai;
                next.callback = callback;
                next._args = Array.from(arguments);
                return next
            }


            const next = game.createEvent('chooseButtonOL');
            next.list = list;
            next.setContent('chooseButtonOL');
            next.ai = ai;
            next.callback = callback;
            next._args = Array.from(arguments);
            return next;
        },
        gameDraw(player, num = 4) {
            const fnum = lib.config['extension_联机修改_fun_beginDraw']
            if (typeof funm === 'function') {
                const result = num
                num = function (player) {
                    const n = result.call(this, player)
                    const more = (n - 4);
                    return more + resolveDraw
                }
            } else {
                num = parseInt(fnum)
            }
            const next = game.createEvent('gameDraw');
            next.player = player || game.me;
            next.num = num;
            const begeinDraw = lib.config['extension_联机修改_edit_selectGameDraw']
            next.setContent(begeinDraw ? 'gameSelect' : 'gameDraw');
            return next;
        },
        createCharacter(name, translate, sex, group, hp, skills, extens) {
            const copy = suiSet.copyCharacter(name)
            const character = new lib.element.Character()
        },
        copyCharacter({ character, hp, skills, name, translate }) {
            const { sex, group, trashBin } = lib.character[character]
            lib.character[name] = new lib.element.Character([sex, group, hp, skills])
            lib.character[name].maxHp = lib.character[name].hp = hp
            if (trashBin.some(t => t.includes("ext:"))) {
                lib.character[name].trashBin = trashBin
            }
            lib.character[name].trashBin.push(`character:${character}`)
            lib.character[name].trashBin.push(`die_audio:${character}`)
            lib.character[name].trashBin.remove('hiddenSkill')
            lib.translate[name] = translate
            return lib.character[name]
        },
        setPlayersSeat(first = game.zhu) {
            let seat = 1
            while (!first.next.seatNum || !first.seatNum) {
                first.seatNum = seat
                seat++
                first = first.next
            }
        },
        getCardPileSkills() {
            if (!lib.configOL) return [];
            if (!lib.configOL.cardPack) return [];
            const cards = []
            lib.configOL.cardPack.forEach(p => {
                if (Array.isArray(lib.cardPack[p])) {
                    lib.cardPack[p].forEach(c => {
                        if (!lib.configOL.bannedcards.includes(c)) {
                            cards.push(c)
                        }
                    })
                }
            })
            return cards
        },
        vcardx(item, type, position, noclick, node) {
            const card = ui.create.buttonPresets.vcard(item, type, position, noclick, node)
            if (lib.skillReplace[lib.translate[item]].length < 2) return card
            const id = lib.skillReplace[lib.translate[item]].indexOf(item)
            const intro = ui.create.div(".button.replaceButton", `切换-${id + 1}`, card);
            intro.style.zIndex = '100000000'
            intro._node = card
            intro[lib.experimental.symbol.itemType] = "button";
            card.node.replaceButton = intro
            card.refresh = function (node, item) {
                if (!_status.skillMap[item]) {
                    if (item.includes("_")) {
                        const index = item.indexOf("_")
                        item = item.slice(0, index)
                    }
                    if (!_status.skillMap[item]) return;
                }
                const character = _status.skillMap[item]
                node.setBackground(character, "character");
            }
            intro.addEventListener(lib.config.touchscreen ? "touchend" : "click", function () {
                _status.tempNoButton = true;
                const node = this._node;
                const list = lib.skillReplace[lib.translate[node.name]];
                let link = node.name;
                let index = list.indexOf(link);
                if (index == list.length - 1) index = 0;
                else index++;
                link = list[index];
                node.node.replaceButton.innerHTML = `切换-${index + 1}`
                node.name = link
                node.link = node.link.slice();
                node.link[2] = link
                node.refresh(node, link);
                setTimeout(function () {
                    delete _status.tempNoButton;
                }, 200);
            })
            return card
        },
        oldidentityList: get.identityList,
        identityList(numOfPlayers) {
            const identityFunc = suiSet.oldidentityList
            const list = identityFunc(numOfPlayers)
            if (lib.configOL.identity_neiReplaceZhong) {
                list.remove('nei')
                list.push('zhong')
            }
            return list
        },
        getInfo(skill, player) {
            if (!player) player = '目标'
            const translation = get.translation(skill)
            let translate = lib.translate[skill + "_info"]
            if (translate === translation) {
                const info = lib.skill[skill]
                if (!info) return
                const content = info.intro.content
                if (typeof content === 'string') {
                    translate = content
                } else {

                }
            }
            return translate
        },
        getSkillMapOfCharacter(characters, func) {
            // const allSkills = Object.keys(lib.skill)
            // const skillList = []
            const skillList2 = []
            const numbers = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            characters.forEach(s => {
                const theSkills = lib.character[s][3]
                theSkills.forEach(t => {
                    // const moreSkills = allSkills.filter(cs=>cs.includes(t)&&cs!==t)
                    const moreSkills = []
                    numbers.forEach(n => {
                        const skill = t + n
                        if (skill in lib.skill) {
                            moreSkills.push(t + n)
                        }
                    })
                    const info = lib.skill[t]
                    if (!info) return
                    if (info.equipSkill) return;
                    const derivation = (Array.isArray(info.derivation) ? [...theSkills, ...info.derivation] : [...theSkills, info.derivation]).filter(Boolean).addArray(moreSkills)
                    derivation.forEach(is => {
                        const groupSkill = lib.skill[is]
                        if (!groupSkill || !suiSet.getInfo(is)) return;
                        const { subSkill, global, viewAs, chooseButton, mod, charlotte, equipSkill, content, nopop, dutySkill, hiddenSkill, juexingji, zhuSkill } = groupSkill
                        if (!skillList2.includes(is) && !charlotte && !equipSkill && (subSkill || global || content || viewAs || chooseButton || mod) && !nopop && !hiddenSkill  /*!dutySkill && !juexingji && !zhuSkill*/) {
                            // skillList.push({ skill: is, name: s })
                            skillList2.push(is)
                            func(is, s)
                        }
                    })
                })
            })
            // return skillList
        },
        replacePlayer(ws, player) {
            return '这个方法已经废弃了，请使用suiSet.swapPlayer'
            if (ws instanceof lib.element.Player) {
                ws = ws.ws
            }
            //首先先给要上场的角色视角换到要下场的目标去
            ws.send((player, ws, identity) => {
                game.swapPlayer(game.me, player)
                ui.arena.classList.remove("observe")
                delete game.observe
                const chat = [...ui.system2.childNodes].some(c => c.innerHTML === '聊天')
                if (!chat) {
                    ui.create.chat()
                }
                game.onlineID = ws.id
                game.me.setIdentity(identity)
            }, player, ws, player.identity)

            //然后再把要上场的角色移除旁观
            if (lib.node.observing.includes(ws)) {
                lib.node.observing.remove(ws)
            }

            const playerws = player.ws
            const playerid = player.playerid
            //保存一下要下场的角色ws和id，待会准备换到旁观去

            if (playerws) {
                lib.node.observing.push(playerws)
                //把下场角色放到旁观去
            }
            player.ws = ws
            // 把下场角色的ws换成要上场角色的ws

            delete lib.playerOL[playerid]
            lib.playerOL[ws.id] = player
            player.nickname = ws.nickname
            player.setNickname(ws.nickname)
            //删掉旧的迎接新的


            if (lib.node.observing.length === 0) {
                if (ui.removeObserve) {
                    ui.removeObserve.remove()
                }
            }

            //应该不会那么简单，我去看看源代码
        },
        async gameSelect(event) {
            if (_status.brawl && _status.brawl.noGameDraw) {
                event.finish();
                return;
            }
            get.cards(0)//这句话只是创建牌堆而已
            const playerCards = {}
            const sliceNum = Math.floor(ui.cardPile.childNodes.length / game.players.length)
            game.players.forEach(p => {
                playerCards[p.playerid] = get.cards(sliceNum)
            })

            let numx = event.num
            if (lib.node.torespond) {
                const chooseList = game.players.map(player => {
                    const cards = playerCards[player.playerid]
                    if (typeof numx === 'function') {
                        numx = numx(player)
                    }
                    return [player, [`请选择${numx}张初始手牌`, [cards, 'card']], numx, true]
                })

                // const list = [];
                // for (let i = 0; i < game.players.length; i++) {
                //     const player = game.players[i]
                //     const skillList = playerCards[player.playerid]
                //     if(typeof numx === 'function'){
                //         numx = numx(player)
                //     }
                //     list.push([player, [`请选择${numx}张初始手牌`, [skillList, 'card']], numx, true]);
                // }

                const { result } = await game.me.chooseButtonOL(chooseList)
                for (const r in result) {
                    const player = lib.playerOL[r]
                    const cards = result[r].links
                    const playerCard = playerCards[player.playerid]
                    player.directgain(cards)
                    playerCard.forEach(card => {
                        if (!cards.includes(card)) {
                            ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                        }
                    })
                    player._start_cards = player.getCards("h");
                }
            } else {
                for await (const player of game.players) {
                    if (typeof numx === 'function') numx = numx(p)
                    const playerCard = playerCards[player.playerid]
                    const result = await player.chooseButton([`请选择起始牌${numx}张`, playerCard], numx, true);
                    const cards = result.result.links
                    player.directgain(cards)
                    playerCard.forEach(card => {
                        if (!cards.includes(card)) {
                            ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                        }
                    })
                    player._start_cards = player.getCards("h");
                }
                // event.changeCard = get.config("change_card")
                // if(event.changeCard){
                //     const bool = await game.me.chooseBool().set('prompt','是否置换手牌？<br><del>但是都自选了还置换吗</del>')
                //     if(bool.result.bool){
                //         const hs = game.me.getCards("h");
                //         game.addVideo("lose", game.me, [get.cardsInfo(hs), [], [], []]);
                //         hs.forEach(h=>h.discard(false))
                //         game.me.directgain(get.cards(hs.length));
                //     }
                // }
            }
        },
        observingId: [],
        auto(bool) {//这个auto是目标自己一个人应该收到的消息，其他人一概不管
            const fn = bool ? 'add' : 'remove'
            const replacePlayer = function (e) {
                if (!_status.auto || !game.notMe) return;
                game.swapPlayer(this || e.target.parentElement)
            }
            game.players.forEach(p => p[fn + "EventListener"](lib.config.touchscreen ? "touchend" : "click", replacePlayer))
            ui.arena.classList[fn]("observe")
            game.notMe = bool
            _status.auto = bool
            game.observe = bool
        },
        playerToobserve(player) {
            const auto = suiSet.auto
            //如果只传了一个玩家，那就是要把一个玩家放上旁观
            //但这里还要确认一下这个是不是普通玩家
            //不然传入,一些字符串或者普通对象就不太合适了
            //还有就是这个玩家不能是人机，这里用的是判断ws和主机
            if (player instanceof ClientElement) return '只传一个ws没有用'
            if (player.ws instanceof ClientElement || player === game.me) {
                const id = get.id()
                const ws = player.ws
                suiSet.observingId[ws.id] = ws
                lib.node.observing.push(ws)
                delete player.ws
                //这三步是把玩家的ws干掉
                game.broadcastAll((player, id, replaceNickname) => {
                    delete lib.playerOL[player.playerid]
                    lib.playerOL[id] = player
                    player.playerid = id
                    if (replaceNickname) {
                        player.nickname = ''
                        player.node.nameol.innerHTML = ''
                    }
                }, player, id, replaceNickname)
                if (player === game.me) {
                    auto(true)
                    return '已经将主机换至旁观'
                }

                ws.send(auto, true)
                //删掉了客机的ws就变成人机了

                if (!ui.removeObserve && lib.node.observing.length) {
                    ui.removeObserve = ui.create.system(
                        "移除旁观",
                        function () {
                            lib.configOL.observe = false;
                            if (game.onlineroom) {
                                game.send("server", "config", lib.configOL);
                            }
                            while (lib.node.observing.length) {
                                lib.node.observing.shift().ws.close();
                            }
                            this.remove();
                            delete ui.removeObserve;
                        },
                        true,
                        true
                    );
                }

                return '此客机已经变为旁观'
            }
            //否则啥也不干
            return '虽然传入了一个玩家，但这是个没有ws的人机？'
        },
        observeToPlayer(player, player2) {

            const source = player instanceof PlayerElement ? player2 : player //这就是要上位的角色，是一个ws
            const target = player2 instanceof PlayerElement ? player2 : player //这是目标，一个玩家，可能是主机

            const sourceWs = source
            const targetWs = target.ws

            suiSet.swapPlayer(target)

            target.ws = sourceWs;

            game.broadcastAll((target, targetId, sourceId) => {
                delete lib.playerOL[targetId]
                target.playerid = sourceId
                lib.playerOL[sourceId] = target
            }, target, target.playerid, source.id)

            source.send(target => {
                game.swapPlayer(game.me, target)
                game.me.setIdentity(game.me.identity)
            }, target)

            source.send(auto, true)

            if (targetWs) {
                lib.node.observing.push(targetWs)
                lib.node.observe.remove(sourceWs)
            }
        },
        noeSwapPlayer(source, target, replaceNickname) {
            const { ws: sourceWs, playerid: sourceId } = source
            const { ws: targeteWs, playerid: targetId } = target

            if (target.tempWsInfo || source.tempWsInfo) {
                source.viewNow = target.startId

                if (source.isOnline2()) {
                    source.send(game.swapPlayer, target, source)
                } else {
                    game.swapPlayer(source, target)
                }

                target.ws = target.tempWsInfo.ws
                source.ws = source.tempWsInfo.ws

                game.broadcastAll((source, target, sourceId, targetId) => {
                    delete lib.playerOL[source.playerid]
                    delete lib.playerOL[target.playerid]

                    lib.playerOL[targetId] = target
                    lib.playerOL[sourceId] = source

                    target.playerid = targetId
                    source.playerid = sourceId
                },
                    source, target,
                    source.tempWsInfo.playerid,
                    target.tempWsInfo.playerid)

                delete target.tempWsInfo
                delete source.tempWsInfo
                delete source._controlMe
                delete target._controlNow
                return '单向换位又换回来了'
            }

            const tempId = get.id()

            target.tempWsInfo = { ws: target.ws, playerid: target.playerid }
            source.tempWsInfo = { ws: source.ws, playerid: source.playerid }

            game.broadcastAll((source, target, sourceId, targetId, tempId) => {
                delete lib.playerOL[targetId]
                lib.playerOL[sourceId] = target
                lib.playerOL[tempId] = source
                source.playerid = tempId
                target.playerid = sourceId
            }, source, target, sourceId, targetId, tempId)

            if (source.isOnline2()) {
                source.send(game.swapPlayer, source, target)
                source.isOnline2 = source.isOnline = () => true
            } else {
                game.swapPlayer(source, target)
            }


            target._controlMe = source
            source._controlNow = target

            source.viewNow = target.startId

            target.ws = source.ws


            return '已经单向换位'
        },
        douleSwapPlayer(source, target, replaceNickname) {
            const { ws, playerid: sourceId, nickname: sourceNickname } = source
            const { ws: ws2, playerid: targetId, nickname: targetNickname } = target
            game.broadcastAll((target, source, sourceId, targetId, sourceNickname, targetNickname, replaceNickname) => {
                target.playerid = sourceId
                source.playerid = targetId

                lib.playerOL[sourceId] = target
                lib.playerOL[targetId] = source

                if (replaceNickname) {
                    target.nickname = sourceNickname
                    source.nickname = targetNickname
                    target.setNickname()
                    source.setNickname()
                }

            }, target, source, sourceId, targetId, sourceNickname, targetNickname, replaceNickname)


            if (target === game.me || source === game.me) {
                game.swapPlayer(source, target)
            }


            ws && ws.send(game.swapPlayer, source, target)
            ws2 && ws2.send(game.swapPlayer, source, target)

            target.ws = ws
            source.ws = ws2

            return '已经双向换位'
        },
        swapPlayer(playerAndTarget) {//ws就是WebSocket，就是一个存数据的地方
            const { player: source, player2: target, replaceNickname, unidirectional } = playerAndTarget
            const PlayerElement = lib.element.Player, ClientElement = lib.element.Client

            if (source && !source.startId) {
                source.startId = source.playerid + "-" + get.translation(source)
                source.viewNow = source.startId
            }
            if (target && !target.startId) {
                target.startId = target.playerid + "-" + get.translation(target)
                target.viewNow = target.startId
            }

            if (source && !target) return suiSet.playerToobserve(source, target)//玩家变旁观

            if (source instanceof ClientElement && target instanceof ClientElement) return '两个非玩家就不用换了'

            if (source instanceof PlayerElement && target instanceof PlayerElement) {
                if (unidirectional) return suiSet.noeSwapPlayer(source, target, replaceNickname)//单向换位（相当于控制）
                return suiSet.douleSwapPlayer(source, target, replaceNickname)//双向换位，最简单的
            }
            return suiSet.observeToPlayer(source, target)//旁观变玩家
        },
        get playerConfig() {
            const configs = Object.keys(suiSet.config).filter(s => {
                return s.startsWith('play_')
            })
            return configs
        },
        get mainConfig() {
            return Object.keys(suiSet.config).filter(s => {
                return s.startsWith('main_')
            })
        },
        get editConfig() {
            return Object.keys(suiSet.config).filter(s => {
                return s.startsWith('edit_')
            })
        },
    });


    game.gameDraw = suiSet.gameDraw
    ui.create.buttonPresets.vcardx = suiSet.vcardx
    get.identityList = suiSet.identityList
    // lib.element.player.chooseButtonOL = suiSet.chooseButtonOL
    // lib.element.player.chooseButton = suiSet.chooseButton

    lib.config.extensionsCopy = lib.config.extensions.filter(e => {
        return !suiSet.igextension.includes(e) && lib.config[`extension_${e}_enable`]
    })
    game.replaceHandcards = suiSet.replaceHandcards
    lib.element.content.replaceHandcardsOL = suiSet.replaceHandcardEvent

    const mode = ['doudizhu', 'identity', 'versus']
    mode.forEach(m => suiSet.addImport(`extension/联机修改(云笺改版)/script/mode/${m}.js`))

    game.TrueHasExtension = ext => lib.config.extensions && lib.config.extensions.includes(ext)
    game.HasExtension = ext => game.TrueHasExtension(ext) && lib.config['extension_' + ext + '_enable']
    game.phaseLoop = function (player) {
        if (!suiSet.replaceHandcardsOver) {
            game.replaceHandcards(game.players);
        }
        const next = game.createEvent("phaseLoop");
        next.player = player;
        next._isStandardLoop = true;
        next.setContent("phaseLoop");
    }
}()
